
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

080001e0 <Reset_Handler>:
                .align  2
                .thumb_func
                .global Reset_Handler
Reset_Handler:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80001e0:	b672      	cpsid	i
                ldr     r0, =__main_stack_end__
                msr     MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80001e2:	4826      	ldr	r0, [pc, #152]	; (800027c <endfiniloop+0x6>)
                msr     PSP, r0
 80001e4:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 80001e8:	4825      	ldr	r0, [pc, #148]	; (8000280 <endfiniloop+0xa>)
                movw    r1, #SCB_VTOR & 0xFFFF
 80001ea:	f64e 5108 	movw	r1, #60680	; 0xed08
                movt    r1, #SCB_VTOR >> 16
 80001ee:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 80001f2:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 80001f4:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 80001f6:	f380 8814 	msr	CONTROL, r0
                isb
 80001fa:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 80001fe:	f002 f8f7 	bl	80023f0 <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 8000202:	f001 f90d 	bl	8001420 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 8000206:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 800020a:	491e      	ldr	r1, [pc, #120]	; (8000284 <endfiniloop+0xe>)
                ldr     r2, =__main_stack_end__
 800020c:	4a1e      	ldr	r2, [pc, #120]	; (8000288 <endfiniloop+0x12>)

0800020e <msloop>:
msloop:
                cmp     r1, r2
 800020e:	4291      	cmp	r1, r2
                itt     lo
 8000210:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000212:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 8000216:	e7fa      	bcc.n	800020e <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 8000218:	491c      	ldr	r1, [pc, #112]	; (800028c <endfiniloop+0x16>)
                ldr     r2, =__process_stack_end__
 800021a:	4a18      	ldr	r2, [pc, #96]	; (800027c <endfiniloop+0x6>)

0800021c <psloop>:
psloop:
                cmp     r1, r2
 800021c:	4291      	cmp	r1, r2
                itt     lo
 800021e:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000220:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 8000224:	e7fa      	bcc.n	800021c <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 8000226:	491a      	ldr	r1, [pc, #104]	; (8000290 <endfiniloop+0x1a>)
                ldr     r2, =_data_start
 8000228:	4a1a      	ldr	r2, [pc, #104]	; (8000294 <endfiniloop+0x1e>)
                ldr     r3, =_data_end
 800022a:	4b1b      	ldr	r3, [pc, #108]	; (8000298 <endfiniloop+0x22>)

0800022c <dloop>:
dloop:
                cmp     r2, r3
 800022c:	429a      	cmp	r2, r3
                ittt    lo
 800022e:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 8000230:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 8000234:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 8000238:	e7f8      	bcc.n	800022c <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 800023a:	2000      	movs	r0, #0
                ldr     r1, =_bss_start
 800023c:	4917      	ldr	r1, [pc, #92]	; (800029c <endfiniloop+0x26>)
                ldr     r2, =_bss_end
 800023e:	4a18      	ldr	r2, [pc, #96]	; (80002a0 <endfiniloop+0x2a>)

08000240 <bloop>:
bloop:
                cmp     r1, r2
 8000240:	4291      	cmp	r1, r2
                itt     lo
 8000242:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000244:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 8000248:	e7fa      	bcc.n	8000240 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 800024a:	f002 f889 	bl	8002360 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 800024e:	f002 f8c7 	bl	80023e0 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 8000252:	4c14      	ldr	r4, [pc, #80]	; (80002a4 <endfiniloop+0x2e>)
                ldr     r5, =__init_array_end
 8000254:	4d14      	ldr	r5, [pc, #80]	; (80002a8 <endfiniloop+0x32>)

08000256 <initloop>:
initloop:
                cmp     r4, r5
 8000256:	42ac      	cmp	r4, r5
                bge     endinitloop
 8000258:	da03      	bge.n	8000262 <endinitloop>
                ldr     r1, [r4], #4
 800025a:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 800025e:	4788      	blx	r1
                b       initloop
 8000260:	e7f9      	b.n	8000256 <initloop>

08000262 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8000262:	f000 f845 	bl	80002f0 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 8000266:	4c11      	ldr	r4, [pc, #68]	; (80002ac <endfiniloop+0x36>)
                ldr     r5, =__fini_array_end
 8000268:	4d11      	ldr	r5, [pc, #68]	; (80002b0 <endfiniloop+0x3a>)

0800026a <finiloop>:
finiloop:
                cmp     r4, r5
 800026a:	42ac      	cmp	r4, r5
                bge     endfiniloop
 800026c:	da03      	bge.n	8000276 <endfiniloop>
                ldr     r1, [r4], #4
 800026e:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000272:	4788      	blx	r1
                b       finiloop
 8000274:	e7f9      	b.n	800026a <finiloop>

08000276 <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 8000276:	f002 b8ab 	b.w	80023d0 <__default_exit>
 800027a:	0000      	.short	0x0000
                ldr     r0, =__process_stack_end__
 800027c:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
 8000280:	08000000 	.word	0x08000000
                ldr     r1, =__main_stack_base__
 8000284:	20000000 	.word	0x20000000
                ldr     r2, =__main_stack_end__
 8000288:	20000400 	.word	0x20000400
                ldr     r1, =__process_stack_base__
 800028c:	20000400 	.word	0x20000400
                ldr     r1, =_textdata_start
 8000290:	080028d4 	.word	0x080028d4
                ldr     r2, =_data_start
 8000294:	20000800 	.word	0x20000800
                ldr     r3, =_data_end
 8000298:	20000850 	.word	0x20000850
                ldr     r1, =_bss_start
 800029c:	20000850 	.word	0x20000850
                ldr     r2, =_bss_end
 80002a0:	20001354 	.word	0x20001354
                ldr     r4, =__init_array_start
 80002a4:	080001e0 	.word	0x080001e0
                ldr     r5, =__init_array_end
 80002a8:	080001e0 	.word	0x080001e0
                ldr     r4, =__fini_array_start
 80002ac:	080001e0 	.word	0x080001e0
                ldr     r5, =__fini_array_end
 80002b0:	080001e0 	.word	0x080001e0

080002b4 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80002b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                vpush   {s16-s31}
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 80002b8:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80002bc:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 80002be:	469d      	mov	sp, r3
#endif

#if CORTEX_USE_FPU
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80002c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002c4 <_port_thread_start>:
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_thread_start
_port_thread_start:
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
 80002c4:	f001 fee4 	bl	8002090 <_dbg_check_unlock>
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 80002c8:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 80002ca:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80002ce:	4628      	mov	r0, r5
                blx     r4
 80002d0:	47a0      	blx	r4
#if defined(_CHIBIOS_RT_CONF_)
                movs    r0, #0              /* MSG_OK */
 80002d2:	2000      	movs	r0, #0
                bl      chThdExit
 80002d4:	f002 f814 	bl	8002300 <chThdExit>

080002d8 <_port_switch_from_isr>:
_port_switch_from_isr:
#if CH_DBG_STATISTICS
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
 80002d8:	f001 ff1a 	bl	8002110 <_dbg_check_lock>
#endif
                bl      chSchDoReschedule
 80002dc:	f001 fa78 	bl	80017d0 <chSchDoReschedule>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
 80002e0:	f001 fed6 	bl	8002090 <_dbg_check_unlock>

080002e4 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 80002e4:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 80002e6:	e7fe      	b.n	80002e6 <_port_exit_from_isr+0x2>
	...

080002f0 <main>:
void hal_lld_init(void) {

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c) and AHB2 is not
     present in STM32F410. */
  rccResetAHB1(~0);
 80002f0:	4bb1      	ldr	r3, [pc, #708]	; (80005b8 <main+0x2c8>)
  PWR->CR |= PWR_CR_DBP;
 80002f2:	4cb2      	ldr	r4, [pc, #712]	; (80005bc <main+0x2cc>)
  rccResetAHB1(~0);
 80002f4:	691a      	ldr	r2, [r3, #16]
 80002f6:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80002fa:	2200      	movs	r2, #0
};

/*
 * Application entry point.
 */
int main(void) {
 80002fc:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8000300:	6119      	str	r1, [r3, #16]
 8000302:	611a      	str	r2, [r3, #16]
#if !defined(STM32F410xx)
  rccResetAHB2(~0);
 8000304:	6958      	ldr	r0, [r3, #20]
 8000306:	6159      	str	r1, [r3, #20]
 8000308:	615a      	str	r2, [r3, #20]
#endif
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 800030a:	6a18      	ldr	r0, [r3, #32]
 800030c:	f060 5080 	orn	r0, r0, #268435456	; 0x10000000
 8000310:	6218      	str	r0, [r3, #32]
 8000312:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
 8000314:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8000316:	6259      	str	r1, [r3, #36]	; 0x24
 8000318:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 800031a:	6c19      	ldr	r1, [r3, #64]	; 0x40
 800031c:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8000320:	6419      	str	r1, [r3, #64]	; 0x40
  PWR->CR |= PWR_CR_DBP;
 8000322:	6821      	ldr	r1, [r4, #0]
 8000324:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 8000328:	6021      	str	r1, [r4, #0]
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 800032a:	6f19      	ldr	r1, [r3, #112]	; 0x70
 800032c:	f401 7140 	and.w	r1, r1, #768	; 0x300
 8000330:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8000334:	b08d      	sub	sp, #52	; 0x34
 8000336:	d003      	beq.n	8000340 <main+0x50>
    RCC->BDCR = RCC_BDCR_BDRST;
 8000338:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 800033c:	6719      	str	r1, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 800033e:	671a      	str	r2, [r3, #112]	; 0x70
  PWR->CSR &= ~PWR_CSR_BRE;
 8000340:	489e      	ldr	r0, [pc, #632]	; (80005bc <main+0x2cc>)

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000342:	499f      	ldr	r1, [pc, #636]	; (80005c0 <main+0x2d0>)
 8000344:	6842      	ldr	r2, [r0, #4]
 8000346:	4b9f      	ldr	r3, [pc, #636]	; (80005c4 <main+0x2d4>)
 8000348:	2460      	movs	r4, #96	; 0x60
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800034a:	2640      	movs	r6, #64	; 0x40
 800034c:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8000350:	6042      	str	r2, [r0, #4]
 8000352:	f44f 7580 	mov.w	r5, #256	; 0x100
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000356:	f881 4306 	strb.w	r4, [r1, #774]	; 0x306
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800035a:	f44f 7000 	mov.w	r0, #512	; 0x200
 800035e:	f8c1 6180 	str.w	r6, [r1, #384]	; 0x180
 8000362:	f44f 6280 	mov.w	r2, #1024	; 0x400
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000366:	600e      	str	r6, [r1, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000368:	2780      	movs	r7, #128	; 0x80
 800036a:	f44f 0600 	mov.w	r6, #8388608	; 0x800000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800036e:	f881 4307 	strb.w	r4, [r1, #775]	; 0x307
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000372:	f8c1 7180 	str.w	r7, [r1, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000376:	600f      	str	r7, [r1, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000378:	f881 4308 	strb.w	r4, [r1, #776]	; 0x308
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800037c:	f8c1 5180 	str.w	r5, [r1, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000380:	600d      	str	r5, [r1, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000382:	f881 4309 	strb.w	r4, [r1, #777]	; 0x309
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000386:	f8c1 0180 	str.w	r0, [r1, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800038a:	6008      	str	r0, [r1, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800038c:	f881 430a 	strb.w	r4, [r1, #778]	; 0x30a
 8000390:	1958      	adds	r0, r3, r5
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000392:	f8c1 2180 	str.w	r2, [r1, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000396:	600a      	str	r2, [r1, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000398:	f881 4317 	strb.w	r4, [r1, #791]	; 0x317

#if PAL_USE_CALLBACKS || PAL_USE_WAIT || defined(__DOXYGEN__)
  unsigned i;

  for (i = 0; i < 16; i++) {
    _pal_init_event(i);
 800039c:	2200      	movs	r2, #0
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800039e:	f8c1 6180 	str.w	r6, [r1, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80003a2:	600e      	str	r6, [r1, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80003a4:	f881 4328 	strb.w	r4, [r1, #808]	; 0x328
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80003a8:	f8c1 5184 	str.w	r5, [r1, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80003ac:	604d      	str	r5, [r1, #4]
 80003ae:	609a      	str	r2, [r3, #8]
 80003b0:	60da      	str	r2, [r3, #12]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80003b2:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80003b4:	605b      	str	r3, [r3, #4]
 80003b6:	3310      	adds	r3, #16
  for (i = 0; i < 16; i++) {
 80003b8:	4283      	cmp	r3, r0
    _pal_init_event(i);
 80003ba:	f04f 0700 	mov.w	r7, #0
  for (i = 0; i < 16; i++) {
 80003be:	d1f6      	bne.n	80003ae <main+0xbe>
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX) || defined(STM32F7XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 80003c0:	f8df e1f4 	ldr.w	lr, [pc, #500]	; 80005b8 <main+0x2c8>
  gpiop->OTYPER  = config->otyper;
 80003c4:	4b80      	ldr	r3, [pc, #512]	; (80005c8 <main+0x2d8>)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 80003c6:	f8de 2030 	ldr.w	r2, [lr, #48]	; 0x30
  gpiop->PUPDR   = config->pupdr;
 80003ca:	4d80      	ldr	r5, [pc, #512]	; (80005cc <main+0x2dc>)
  gpiop->OTYPER  = config->otyper;
 80003cc:	4980      	ldr	r1, [pc, #512]	; (80005d0 <main+0x2e0>)
  gpiop->AFRL    = config->afrl;
 80003ce:	4e81      	ldr	r6, [pc, #516]	; (80005d4 <main+0x2e4>)
  gpiop->OTYPER  = config->otyper;
 80003d0:	4c81      	ldr	r4, [pc, #516]	; (80005d8 <main+0x2e8>)
 80003d2:	4882      	ldr	r0, [pc, #520]	; (80005dc <main+0x2ec>)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 80003d4:	ea6f 2252 	mvn.w	r2, r2, lsr #9
 80003d8:	ea6f 2242 	mvn.w	r2, r2, lsl #9
 80003dc:	f8ce 2030 	str.w	r2, [lr, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
 80003e0:	f8de 2050 	ldr.w	r2, [lr, #80]	; 0x50
 80003e4:	ea6f 2252 	mvn.w	r2, r2, lsr #9
 80003e8:	ea6f 2242 	mvn.w	r2, r2, lsl #9
 80003ec:	f8ce 2050 	str.w	r2, [lr, #80]	; 0x50
  gpiop->OSPEEDR = config->ospeedr;
 80003f0:	f46f 42a8 	mvn.w	r2, #21504	; 0x5400
  gpiop->OTYPER  = config->otyper;
 80003f4:	605f      	str	r7, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80003f6:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 80003f8:	60dd      	str	r5, [r3, #12]
  gpiop->ODR     = config->odr;
 80003fa:	f64f 72ff 	movw	r2, #65535	; 0xffff
  gpiop->AFRH    = config->afrh;
 80003fe:	4d78      	ldr	r5, [pc, #480]	; (80005e0 <main+0x2f0>)
  gpiop->ODR     = config->odr;
 8000400:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8000402:	621e      	str	r6, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8000404:	625d      	str	r5, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000406:	4e77      	ldr	r6, [pc, #476]	; (80005e4 <main+0x2f4>)
 8000408:	601e      	str	r6, [r3, #0]
  gpiop->OTYPER  = config->otyper;
 800040a:	f44f 7510 	mov.w	r5, #576	; 0x240
 800040e:	604d      	str	r5, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000410:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  gpiop->PUPDR   = config->pupdr;
 8000414:	4e74      	ldr	r6, [pc, #464]	; (80005e8 <main+0x2f8>)
  gpiop->OSPEEDR = config->ospeedr;
 8000416:	608b      	str	r3, [r1, #8]
  gpiop->AFRL    = config->afrl;
 8000418:	f04f 6580 	mov.w	r5, #67108864	; 0x4000000
  gpiop->PUPDR   = config->pupdr;
 800041c:	60ce      	str	r6, [r1, #12]
  gpiop->ODR     = config->odr;
 800041e:	614a      	str	r2, [r1, #20]
  gpiop->AFRL    = config->afrl;
 8000420:	620d      	str	r5, [r1, #32]
  gpiop->MODER   = config->moder;
 8000422:	4d72      	ldr	r5, [pc, #456]	; (80005ec <main+0x2fc>)
  gpiop->AFRH    = config->afrh;
 8000424:	2640      	movs	r6, #64	; 0x40
 8000426:	624e      	str	r6, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000428:	600d      	str	r5, [r1, #0]
  gpiop->PUPDR   = config->pupdr;
 800042a:	f105 45aa 	add.w	r5, r5, #1426063360	; 0x55000000
 800042e:	f5a5 0543 	sub.w	r5, r5, #12779520	; 0xc30000
 8000432:	f6a5 352c 	subw	r5, r5, #2860	; 0xb2c
  gpiop->OTYPER  = config->otyper;
 8000436:	6067      	str	r7, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000438:	60a3      	str	r3, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 800043a:	60e5      	str	r5, [r4, #12]
  gpiop->AFRL    = config->afrl;
 800043c:	f04f 45c0 	mov.w	r5, #1610612736	; 0x60000000
  gpiop->ODR     = config->odr;
 8000440:	6162      	str	r2, [r4, #20]
  gpiop->AFRL    = config->afrl;
 8000442:	6225      	str	r5, [r4, #32]
  gpiop->AFRH    = config->afrh;
 8000444:	4d6a      	ldr	r5, [pc, #424]	; (80005f0 <main+0x300>)
 8000446:	6265      	str	r5, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000448:	4d6a      	ldr	r5, [pc, #424]	; (80005f4 <main+0x304>)
 800044a:	6025      	str	r5, [r4, #0]
  gpiop->PUPDR   = config->pupdr;
 800044c:	4c6a      	ldr	r4, [pc, #424]	; (80005f8 <main+0x308>)
  gpiop->OTYPER  = config->otyper;
 800044e:	6047      	str	r7, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000450:	6083      	str	r3, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
 8000452:	60c4      	str	r4, [r0, #12]
  gpiop->ODR     = config->odr;
 8000454:	f640 74ff 	movw	r4, #4095	; 0xfff
 8000458:	6144      	str	r4, [r0, #20]
  gpiop->MODER   = config->moder;
 800045a:	4c68      	ldr	r4, [pc, #416]	; (80005fc <main+0x30c>)
  gpiop->OTYPER  = config->otyper;
 800045c:	4d68      	ldr	r5, [pc, #416]	; (8000600 <main+0x310>)
  gpiop->AFRL    = config->afrl;
 800045e:	6207      	str	r7, [r0, #32]
  gpiop->AFRH    = config->afrh;
 8000460:	6247      	str	r7, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000462:	6004      	str	r4, [r0, #0]
  gpiop->OTYPER  = config->otyper;
 8000464:	f8c1 7c04 	str.w	r7, [r1, #3076]	; 0xc04
 8000468:	4c66      	ldr	r4, [pc, #408]	; (8000604 <main+0x314>)
  gpiop->OSPEEDR = config->ospeedr;
 800046a:	f8c1 3c08 	str.w	r3, [r1, #3080]	; 0xc08
  gpiop->OTYPER  = config->otyper;
 800046e:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
  gpiop->PUPDR   = config->pupdr;
 8000472:	f8c1 7c0c 	str.w	r7, [r1, #3084]	; 0xc0c
  gpiop->ODR     = config->odr;
 8000476:	f8c1 2c14 	str.w	r2, [r1, #3092]	; 0xc14
  gpiop->AFRL    = config->afrl;
 800047a:	f8c1 7c20 	str.w	r7, [r1, #3104]	; 0xc20
  gpiop->AFRH    = config->afrh;
 800047e:	f8c1 7c24 	str.w	r7, [r1, #3108]	; 0xc24
  gpiop->MODER   = config->moder;
 8000482:	f8c1 6c00 	str.w	r6, [r1, #3072]	; 0xc00
  gpiop->OTYPER  = config->otyper;
 8000486:	f501 51e0 	add.w	r1, r1, #7168	; 0x1c00
 800048a:	606f      	str	r7, [r5, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800048c:	60ab      	str	r3, [r5, #8]
  gpiop->PUPDR   = config->pupdr;
 800048e:	60ef      	str	r7, [r5, #12]
  gpiop->ODR     = config->odr;
 8000490:	616a      	str	r2, [r5, #20]
  gpiop->AFRL    = config->afrl;
 8000492:	622f      	str	r7, [r5, #32]
  gpiop->AFRH    = config->afrh;
 8000494:	626f      	str	r7, [r5, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000496:	602f      	str	r7, [r5, #0]
  gpiop->OTYPER  = config->otyper;
 8000498:	6067      	str	r7, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800049a:	60a3      	str	r3, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 800049c:	60e7      	str	r7, [r4, #12]
  gpiop->ODR     = config->odr;
 800049e:	6162      	str	r2, [r4, #20]
  gpiop->AFRL    = config->afrl;
 80004a0:	6227      	str	r7, [r4, #32]
  gpiop->AFRH    = config->afrh;
 80004a2:	6267      	str	r7, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80004a4:	6027      	str	r7, [r4, #0]
  gpiop->OTYPER  = config->otyper;
 80004a6:	6047      	str	r7, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80004a8:	6083      	str	r3, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
 80004aa:	60c7      	str	r7, [r0, #12]
  gpiop->ODR     = config->odr;
 80004ac:	6142      	str	r2, [r0, #20]
  gpiop->AFRL    = config->afrl;
 80004ae:	6207      	str	r7, [r0, #32]
  gpiop->AFRH    = config->afrh;
 80004b0:	6247      	str	r7, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80004b2:	6007      	str	r7, [r0, #0]
  gpiop->OTYPER  = config->otyper;
 80004b4:	604f      	str	r7, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80004b6:	608b      	str	r3, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 80004b8:	60cf      	str	r7, [r1, #12]
  gpiop->ODR     = config->odr;
 80004ba:	614a      	str	r2, [r1, #20]
  gpiop->AFRL    = config->afrl;
 80004bc:	620f      	str	r7, [r1, #32]
  gpiop->AFRH    = config->afrh;
 80004be:	624f      	str	r7, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80004c0:	600f      	str	r7, [r1, #0]

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80004c2:	f8de 2040 	ldr.w	r2, [lr, #64]	; 0x40
 *
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {

  pwmp->state    = PWM_STOP;
 80004c6:	4d50      	ldr	r5, [pc, #320]	; (8000608 <main+0x318>)
 *
 * @init
 */
void icuObjectInit(ICUDriver *icup) {

  icup->state  = ICU_STOP;
 80004c8:	4e50      	ldr	r6, [pc, #320]	; (800060c <main+0x31c>)

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80004ca:	4951      	ldr	r1, [pc, #324]	; (8000610 <main+0x320>)
  icup->config = NULL;
 80004cc:	6077      	str	r7, [r6, #4]
  icup->state  = ICU_STOP;
 80004ce:	2001      	movs	r0, #1
  ST_ENABLE_CLOCK();
 80004d0:	4302      	orrs	r2, r0
 80004d2:	7030      	strb	r0, [r6, #0]
 80004d4:	7028      	strb	r0, [r5, #0]
 80004d6:	f8ce 2040 	str.w	r2, [lr, #64]	; 0x40
  ST_ENABLE_STOP();
 80004da:	688a      	ldr	r2, [r1, #8]
  pwmp->config   = NULL;
 80004dc:	606f      	str	r7, [r5, #4]
#endif

#if STM32_ICU_USE_TIM3
  /* Driver initialization.*/
  icuObjectInit(&ICUD3);
  ICUD3.tim = STM32_TIM3;
 80004de:	f5ae 3e0d 	sub.w	lr, lr, #144384	; 0x23400
 80004e2:	f8c6 e00c 	str.w	lr, [r6, #12]
void pwm_lld_init(void) {

#if STM32_PWM_USE_TIM1
  /* Driver initialization.*/
  pwmObjectInit(&PWMD1);
  PWMD1.channels = STM32_TIM1_CHANNELS;
 80004e6:	f04f 0e04 	mov.w	lr, #4
 80004ea:	f885 e010 	strb.w	lr, [r5, #16]
 80004ee:	4302      	orrs	r2, r0
  PWMD1.tim = STM32_TIM1;
 80004f0:	f8df e12c 	ldr.w	lr, [pc, #300]	; 8000620 <main+0x330>
  pwmp->enabled  = 0;
 80004f4:	60ef      	str	r7, [r5, #12]
 80004f6:	f8c5 e018 	str.w	lr, [r5, #24]
 80004fa:	608a      	str	r2, [r1, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80004fc:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  tqp->next = (thread_t *)tqp;
 8000500:	4c44      	ldr	r4, [pc, #272]	; (8000614 <main+0x324>)
 8000502:	f242 01cf 	movw	r1, #8399	; 0x20cf
 8000506:	6291      	str	r1, [r2, #40]	; 0x28
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000508:	492d      	ldr	r1, [pc, #180]	; (80005c0 <main+0x2d0>)
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 800050a:	62d3      	str	r3, [r2, #44]	; 0x2c
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.delta = (sysinterval_t)-1;
 800050c:	6263      	str	r3, [r4, #36]	; 0x24
  STM32_ST_TIM->CCMR1  = 0;
 800050e:	6197      	str	r7, [r2, #24]
 8000510:	2380      	movs	r3, #128	; 0x80
  tqp->prev = (thread_t *)tqp;
 8000512:	6064      	str	r4, [r4, #4]
  STM32_ST_TIM->CCR[0] = 0;
 8000514:	6357      	str	r7, [r2, #52]	; 0x34
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
 8000516:	60a7      	str	r7, [r4, #8]
  STM32_ST_TIM->DIER   = 0;
 8000518:	60d7      	str	r7, [r2, #12]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.newer = (thread_t *)&ch.rlist;
 800051a:	6124      	str	r4, [r4, #16]
  STM32_ST_TIM->CR2    = 0;
 800051c:	6057      	str	r7, [r2, #4]
  ch.rlist.older = (thread_t *)&ch.rlist;
 800051e:	6164      	str	r4, [r4, #20]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8000520:	6150      	str	r0, [r2, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8000522:	6010      	str	r0, [r2, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000524:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8000528:	f104 001c 	add.w	r0, r4, #28
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800052c:	f881 331c 	strb.w	r3, [r1, #796]	; 0x31c
 8000530:	61e0      	str	r0, [r4, #28]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000532:	f8c1 2180 	str.w	r2, [r1, #384]	; 0x180
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8000536:	6220      	str	r0, [r4, #32]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000538:	600a      	str	r2, [r1, #0]
 * @note    Internal use only.
 */
void _trace_init(void) {
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)~CH_DBG_TRACE_MASK;
 800053a:	f64f 70f0 	movw	r0, #65520	; 0xfff0
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
 800053e:	f104 0240 	add.w	r2, r4, #64	; 0x40
  tqp->next = (thread_t *)tqp;
 8000542:	6024      	str	r4, [r4, #0]
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 8000544:	62a7      	str	r7, [r4, #40]	; 0x28
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
 8000546:	8763      	strh	r3, [r4, #58]	; 0x3a
  ch.dbg.trace_buffer.suspended = (uint16_t)~CH_DBG_TRACE_MASK;
 8000548:	8720      	strh	r0, [r4, #56]	; 0x38
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
 800054a:	63e2      	str	r2, [r4, #60]	; 0x3c
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
 800054c:	3701      	adds	r7, #1
 800054e:	eb04 1307 	add.w	r3, r4, r7, lsl #4
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8000552:	2f80      	cmp	r7, #128	; 0x80
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8000554:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
 8000558:	492e      	ldr	r1, [pc, #184]	; (8000614 <main+0x324>)
 800055a:	f36f 0202 	bfc	r2, #0, #3
 800055e:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8000562:	d1f3      	bne.n	800054c <main+0x25c>
  _scheduler_init();
  _vt_init();
  _trace_init();

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  ch.dbg.isr_cnt  = (cnt_t)0;
 8000564:	f04f 0800 	mov.w	r8, #0
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 8000568:	f04f 3eff 	mov.w	lr, #4294967295	; 0xffffffff
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 800056c:	2200      	movs	r2, #0
 800056e:	2300      	movs	r3, #0
  chTMStartMeasurementX(&tm);
 8000570:	a806      	add	r0, sp, #24
 8000572:	f8c1 8030 	str.w	r8, [r1, #48]	; 0x30
  ch.dbg.lock_cnt = (cnt_t)0;
 8000576:	f8c1 8034 	str.w	r8, [r1, #52]	; 0x34
  ch.tm.offset = (rtcnt_t)0;
 800057a:	f8c1 8884 	str.w	r8, [r1, #2180]	; 0x884
  tmp->cumulative = (rttime_t)0;
 800057e:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
  ch.tm.offset = (rtcnt_t)0;
 8000582:	9101      	str	r1, [sp, #4]
  tmp->best       = (rtcnt_t)-1;
 8000584:	f8cd e018 	str.w	lr, [sp, #24]
  tmp->worst      = (rtcnt_t)0;
 8000588:	f8cd 801c 	str.w	r8, [sp, #28]
  tmp->last       = (rtcnt_t)0;
 800058c:	f8cd 8020 	str.w	r8, [sp, #32]
  tmp->n          = (ucnt_t)0;
 8000590:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
  chTMStartMeasurementX(&tm);
 8000594:	f001 ff34 	bl	8002400 <chTMStartMeasurementX.constprop.32>
  chTMStopMeasurementX(&tm);
 8000598:	a806      	add	r0, sp, #24
 800059a:	f001 f829 	bl	80015f0 <chTMStopMeasurementX>
 800059e:	4b1e      	ldr	r3, [pc, #120]	; (8000618 <main+0x328>)
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 80005a0:	9901      	ldr	r1, [sp, #4]
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
 80005a2:	4a1e      	ldr	r2, [pc, #120]	; (800061c <main+0x32c>)
 80005a4:	f8df c07c 	ldr.w	ip, [pc, #124]	; 8000624 <main+0x334>
 80005a8:	f8c2 c000 	str.w	ip, [r2]
  tp->prio      = prio;
 80005ac:	f8c1 7848 	str.w	r7, [r1, #2120]	; 0x848
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void dyn_list_init(dyn_list_t *dlp) {

  dlp->next = (dyn_element_t *)dlp;
 80005b0:	f103 0c24 	add.w	ip, r3, #36	; 0x24
 80005b4:	e038      	b.n	8000628 <main+0x338>
 80005b6:	bf00      	nop
 80005b8:	40023800 	.word	0x40023800
 80005bc:	40007000 	.word	0x40007000
 80005c0:	e000e100 	.word	0xe000e100
 80005c4:	20001100 	.word	0x20001100
 80005c8:	40020000 	.word	0x40020000
 80005cc:	40010054 	.word	0x40010054
 80005d0:	40020400 	.word	0x40020400
 80005d4:	55560000 	.word	0x55560000
 80005d8:	40020800 	.word	0x40020800
 80005dc:	40020c00 	.word	0x40020c00
 80005e0:	000aaa00 	.word	0x000aaa00
 80005e4:	2aa0aa00 	.word	0x2aa0aa00
 80005e8:	55514515 	.word	0x55514515
 80005ec:	00082080 	.word	0x00082080
 80005f0:	00060600 	.word	0x00060600
 80005f4:	02208001 	.word	0x02208001
 80005f8:	00555055 	.word	0x00555055
 80005fc:	55000100 	.word	0x55000100
 8000600:	40021400 	.word	0x40021400
 8000604:	40021800 	.word	0x40021800
 8000608:	20001338 	.word	0x20001338
 800060c:	20001200 	.word	0x20001200
 8000610:	e0042000 	.word	0xe0042000
 8000614:	20000878 	.word	0x20000878
 8000618:	20001218 	.word	0x20001218
 800061c:	20000850 	.word	0x20000850
 8000620:	40010000 	.word	0x40010000
 8000624:	08002131 	.word	0x08002131
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8000628:	f8c1 787c 	str.w	r7, [r1, #2172]	; 0x87c
 800062c:	f102 0710 	add.w	r7, r2, #16
  H_NEXT(&default_heap.header) = NULL;
 8000630:	f8c2 8008 	str.w	r8, [r2, #8]
  H_PAGES(&default_heap.header) = 0;
 8000634:	f8c2 800c 	str.w	r8, [r2, #12]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 8000638:	f8c2 8018 	str.w	r8, [r2, #24]
 800063c:	6117      	str	r7, [r2, #16]
  tqp->prev = (thread_t *)tqp;
 800063e:	6157      	str	r7, [r2, #20]
 8000640:	f8c3 c024 	str.w	ip, [r3, #36]	; 0x24
 8000644:	f103 0228 	add.w	r2, r3, #40	; 0x28
 8000648:	f103 0c40 	add.w	ip, r3, #64	; 0x40
                             unsigned align, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
  mp->object_size = size;
 800064c:	f04f 0914 	mov.w	r9, #20
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000650:	489e      	ldr	r0, [pc, #632]	; (80008cc <main+0x5dc>)
 8000652:	f8c3 8008 	str.w	r8, [r3, #8]
  mp->next = NULL;
 8000656:	f8c3 8014 	str.w	r8, [r3, #20]
 800065a:	f8c3 802c 	str.w	r8, [r3, #44]	; 0x2c
  mp->object_size = size;
 800065e:	f8c3 9018 	str.w	r9, [r3, #24]
 8000662:	629a      	str	r2, [r3, #40]	; 0x28
 8000664:	f8c3 c040 	str.w	ip, [r3, #64]	; 0x40
  mp->align = align;
 8000668:	2204      	movs	r2, #4
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.nextmem = __heap_base__;
 800066a:	f8df e298 	ldr.w	lr, [pc, #664]	; 8000904 <main+0x614>
  tp->flags     = CH_FLAG_MODE_STATIC;
 800066e:	f881 8861 	strb.w	r8, [r1, #2145]	; 0x861
  tp->mtxlist   = NULL;
 8000672:	f8c1 8878 	str.w	r8, [r1, #2168]	; 0x878
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8000676:	f8c1 8874 	str.w	r8, [r1, #2164]	; 0x874
  mp->object_size = size;
 800067a:	271c      	movs	r7, #28
 800067c:	f103 083c 	add.w	r8, r3, #60	; 0x3c
  ch_memcore.endmem  = __heap_end__;
 8000680:	f8df c284 	ldr.w	ip, [pc, #644]	; 8000908 <main+0x618>
  ch_memcore.nextmem = __heap_base__;
 8000684:	f8df 9284 	ldr.w	r9, [pc, #644]	; 800090c <main+0x61c>
 8000688:	631f      	str	r7, [r3, #48]	; 0x30
 800068a:	f8c3 803c 	str.w	r8, [r3, #60]	; 0x3c
  mp->provider = provider;
 800068e:	4f90      	ldr	r7, [pc, #576]	; (80008d0 <main+0x5e0>)
  mp->align = align;
 8000690:	61da      	str	r2, [r3, #28]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8000692:	f04f 0801 	mov.w	r8, #1
 8000696:	635a      	str	r2, [r3, #52]	; 0x34
 8000698:	f103 0a10 	add.w	sl, r3, #16
  ch.tm.offset = tm.last;
 800069c:	9a08      	ldr	r2, [sp, #32]
  mp->provider = provider;
 800069e:	621f      	str	r7, [r3, #32]
 80006a0:	639f      	str	r7, [r3, #56]	; 0x38
  ch_memcore.endmem  = __heap_end__;
 80006a2:	e88e 1200 	stmia.w	lr, {r9, ip}
  tqp->next = (thread_t *)tqp;
 80006a6:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80006a8:	605b      	str	r3, [r3, #4]
 80006aa:	f8c3 a010 	str.w	sl, [r3, #16]
 80006ae:	f8c1 2884 	str.w	r2, [r1, #2180]	; 0x884
  tp->name      = name;
 80006b2:	4b88      	ldr	r3, [pc, #544]	; (80008d4 <main+0x5e4>)
  tp->refs      = (trefs_t)1;
 80006b4:	f881 8862 	strb.w	r8, [r1, #2146]	; 0x862
 80006b8:	68c7      	ldr	r7, [r0, #12]
  tp->name      = name;
 80006ba:	f8c1 3858 	str.w	r3, [r1, #2136]	; 0x858
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80006be:	f64f 02ff 	movw	r2, #63743	; 0xf8ff
  reg_value  =  (reg_value                                   |
 80006c2:	4b85      	ldr	r3, [pc, #532]	; (80008d8 <main+0x5e8>)
  REG_INSERT(tp);
 80006c4:	f8d1 e014 	ldr.w	lr, [r1, #20]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80006c8:	f8df c244 	ldr.w	ip, [pc, #580]	; 8000910 <main+0x620>
 80006cc:	f8c1 e854 	str.w	lr, [r1, #2132]	; 0x854
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80006d0:	403a      	ands	r2, r7
  reg_value  =  (reg_value                                   |
 80006d2:	4313      	orrs	r3, r2
 80006d4:	f501 6704 	add.w	r7, r1, #2112	; 0x840
 80006d8:	f8c1 1850 	str.w	r1, [r1, #2128]	; 0x850
 80006dc:	f8ce 7010 	str.w	r7, [lr, #16]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 80006e0:	60c3      	str	r3, [r0, #12]
 80006e2:	f8dc 300c 	ldr.w	r3, [ip, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80006e6:	f8df e22c 	ldr.w	lr, [pc, #556]	; 8000914 <main+0x624>
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 80006ea:	f881 8860 	strb.w	r8, [r1, #2144]	; 0x860
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80006ee:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80006f2:	f8cc 300c 	str.w	r3, [ip, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80006f6:	f8de 3000 	ldr.w	r3, [lr]
 80006fa:	614f      	str	r7, [r1, #20]
 80006fc:	ea43 0308 	orr.w	r3, r3, r8
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 8000700:	618f      	str	r7, [r1, #24]
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000702:	f04f 0810 	mov.w	r8, #16
 8000706:	f8ce 3000 	str.w	r3, [lr]
 800070a:	2720      	movs	r7, #32
  tlp->next = (thread_t *)tlp;
 800070c:	f601 0e68 	addw	lr, r1, #2152	; 0x868
 8000710:	f880 801f 	strb.w	r8, [r0, #31]
  tqp->next = (thread_t *)tqp;
 8000714:	f601 036c 	addw	r3, r1, #2156	; 0x86c
  tlp->next = (thread_t *)tlp;
 8000718:	f8c1 e868 	str.w	lr, [r1, #2152]	; 0x868
 800071c:	f880 7022 	strb.w	r7, [r0, #34]	; 0x22
  tqp->next = (thread_t *)tqp;
 8000720:	f8c1 386c 	str.w	r3, [r1, #2156]	; 0x86c
  tqp->prev = (thread_t *)tqp;
 8000724:	f8c1 3870 	str.w	r3, [r1, #2160]	; 0x870
 *
 * @notapi
 */
void _dbg_check_enable(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8000728:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    currp->wabase = &__main_thread_stack_base__;
 800072a:	4a6c      	ldr	r2, [pc, #432]	; (80008dc <main+0x5ec>)
 800072c:	f8c1 285c 	str.w	r2, [r1, #2140]	; 0x85c
 8000730:	b90b      	cbnz	r3, 8000736 <main+0x446>
 8000732:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 8000734:	b113      	cbz	r3, 800073c <main+0x44c>
    chSysHalt("SV#3");
 8000736:	486a      	ldr	r0, [pc, #424]	; (80008e0 <main+0x5f0>)
 8000738:	f000 ff9a 	bl	8001670 <chSysHalt>
 800073c:	9101      	str	r1, [sp, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__((always_inline)) __STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800073e:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
 8000742:	b662      	cpsie	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000744:	f387 8811 	msr	BASEPRI, r7
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8000748:	f001 fce2 	bl	8002110 <_dbg_check_lock>
 */
thread_t *chRegFirstThread(void) {
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.newer;
 800074c:	9901      	ldr	r1, [sp, #4]
 800074e:	690f      	ldr	r7, [r1, #16]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 8000750:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8000754:	3301      	adds	r3, #1
 8000756:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800075a:	f001 fc99 	bl	8002090 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800075e:	9901      	ldr	r1, [sp, #4]
 8000760:	680b      	ldr	r3, [r1, #0]
 8000762:	428b      	cmp	r3, r1
 8000764:	d004      	beq.n	8000770 <main+0x480>
 8000766:	698a      	ldr	r2, [r1, #24]
 8000768:	689b      	ldr	r3, [r3, #8]
 800076a:	6892      	ldr	r2, [r2, #8]
 800076c:	429a      	cmp	r2, r3
 800076e:	d34e      	bcc.n	800080e <main+0x51e>
 8000770:	2300      	movs	r3, #0
 8000772:	f383 8811 	msr	BASEPRI, r3
 8000776:	f8df 91a0 	ldr.w	r9, [pc, #416]	; 8000918 <main+0x628>
  chSysLock();
  ntp = tp->newer;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
  /*lint -restore*/
    ntp = NULL;
 800077a:	9301      	str	r3, [sp, #4]
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 800077c:	69fb      	ldr	r3, [r7, #28]
 800077e:	4a59      	ldr	r2, [pc, #356]	; (80008e4 <main+0x5f4>)
 8000780:	4293      	cmp	r3, r2
 8000782:	f000 8095 	beq.w	80008b0 <main+0x5c0>
 8000786:	2320      	movs	r3, #32
 8000788:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800078c:	f001 fcc0 	bl	8002110 <_dbg_check_lock>
  ntp = tp->newer;
 8000790:	693b      	ldr	r3, [r7, #16]
 8000792:	9302      	str	r3, [sp, #8]
  if (ntp == (thread_t *)&ch.rlist) {
 8000794:	42a3      	cmp	r3, r4
 8000796:	f000 8096 	beq.w	80008c6 <main+0x5d6>
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 800079a:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800079e:	2bff      	cmp	r3, #255	; 0xff
 80007a0:	d03e      	beq.n	8000820 <main+0x530>
    ntp->refs++;
 80007a2:	9a02      	ldr	r2, [sp, #8]
 80007a4:	3301      	adds	r3, #1
 80007a6:	f882 3022 	strb.w	r3, [r2, #34]	; 0x22
  _dbg_check_unlock();
 80007aa:	f001 fc71 	bl	8002090 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80007ae:	6823      	ldr	r3, [r4, #0]
 80007b0:	42a3      	cmp	r3, r4
 80007b2:	d005      	beq.n	80007c0 <main+0x4d0>
 80007b4:	f8d9 2018 	ldr.w	r2, [r9, #24]
 80007b8:	689b      	ldr	r3, [r3, #8]
 80007ba:	6892      	ldr	r2, [r2, #8]
 80007bc:	429a      	cmp	r2, r3
 80007be:	d326      	bcc.n	800080e <main+0x51e>
 80007c0:	9b01      	ldr	r3, [sp, #4]
 80007c2:	f383 8811 	msr	BASEPRI, r3
 80007c6:	2320      	movs	r3, #32
 80007c8:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80007cc:	f001 fca0 	bl	8002110 <_dbg_check_lock>
 * @api
 */
void chThdRelease(thread_t *tp) {

  chSysLock();
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 80007d0:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 80007d4:	b30b      	cbz	r3, 800081a <main+0x52a>
  tp->refs--;
 80007d6:	3b01      	subs	r3, #1
 80007d8:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 80007dc:	6a3b      	ldr	r3, [r7, #32]
 80007de:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 80007e2:	2b0f      	cmp	r3, #15
 80007e4:	d01f      	beq.n	8000826 <main+0x536>
  _dbg_check_unlock();
 80007e6:	f001 fc53 	bl	8002090 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80007ea:	6823      	ldr	r3, [r4, #0]
 80007ec:	42a3      	cmp	r3, r4
 80007ee:	d005      	beq.n	80007fc <main+0x50c>
 80007f0:	f8d9 2018 	ldr.w	r2, [r9, #24]
 80007f4:	689b      	ldr	r3, [r3, #8]
 80007f6:	6892      	ldr	r2, [r2, #8]
 80007f8:	429a      	cmp	r2, r3
 80007fa:	d30b      	bcc.n	8000814 <main+0x524>
 80007fc:	9b01      	ldr	r3, [sp, #4]
 80007fe:	f383 8811 	msr	BASEPRI, r3
      return ctp;
    }
    ctp = chRegNextThread(ctp);
  } while (ctp != NULL);
 8000802:	9b02      	ldr	r3, [sp, #8]
 8000804:	2b00      	cmp	r3, #0
 8000806:	f000 8089 	beq.w	800091c <main+0x62c>
 800080a:	9f02      	ldr	r7, [sp, #8]
 800080c:	e7b6      	b.n	800077c <main+0x48c>
 800080e:	4836      	ldr	r0, [pc, #216]	; (80008e8 <main+0x5f8>)
 8000810:	f000 ff2e 	bl	8001670 <chSysHalt>
 8000814:	4835      	ldr	r0, [pc, #212]	; (80008ec <main+0x5fc>)
 8000816:	f000 ff2b 	bl	8001670 <chSysHalt>
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 800081a:	4835      	ldr	r0, [pc, #212]	; (80008f0 <main+0x600>)
 800081c:	f000 ff28 	bl	8001670 <chSysHalt>
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 8000820:	4834      	ldr	r0, [pc, #208]	; (80008f4 <main+0x604>)
 8000822:	f000 ff25 	bl	8001670 <chSysHalt>
    REG_REMOVE(tp);
 8000826:	697b      	ldr	r3, [r7, #20]
 8000828:	693a      	ldr	r2, [r7, #16]
 800082a:	611a      	str	r2, [r3, #16]
 800082c:	693a      	ldr	r2, [r7, #16]
 800082e:	6153      	str	r3, [r2, #20]
  _dbg_check_unlock();
 8000830:	f001 fc2e 	bl	8002090 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8000834:	6823      	ldr	r3, [r4, #0]
 8000836:	42a3      	cmp	r3, r4
 8000838:	d005      	beq.n	8000846 <main+0x556>
 800083a:	f8d9 2018 	ldr.w	r2, [r9, #24]
 800083e:	689b      	ldr	r3, [r3, #8]
 8000840:	6892      	ldr	r2, [r2, #8]
 8000842:	429a      	cmp	r2, r3
 8000844:	d3e6      	bcc.n	8000814 <main+0x524>
 8000846:	9b01      	ldr	r3, [sp, #4]
 8000848:	f383 8811 	msr	BASEPRI, r3
    chSysUnlock();

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 800084c:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8000850:	f003 0303 	and.w	r3, r3, #3
 8000854:	2b01      	cmp	r3, #1
 8000856:	d02e      	beq.n	80008b6 <main+0x5c6>
 8000858:	2b02      	cmp	r3, #2
 800085a:	d1d2      	bne.n	8000802 <main+0x512>
      chHeapFree(chThdGetWorkingAreaX(tp));
      break;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 800085c:	f8d7 8040 	ldr.w	r8, [r7, #64]	; 0x40
 8000860:	69ff      	ldr	r7, [r7, #28]
 8000862:	2320      	movs	r3, #32
 8000864:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8000868:	f001 fc52 	bl	8002110 <_dbg_check_lock>
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
  struct pool_header *php = objp;

  chDbgCheckClassI();
 800086c:	f000 ff70 	bl	8001750 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) && (objp != NULL));
 8000870:	f1b8 0f00 	cmp.w	r8, #0
 8000874:	f000 80de 	beq.w	8000a34 <main+0x744>
 8000878:	2f00      	cmp	r7, #0
 800087a:	f000 80db 	beq.w	8000a34 <main+0x744>

  chDbgAssert(((size_t)objp & MEM_ALIGN_MASK(mp->align)) == 0U,
 800087e:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8000882:	3b01      	subs	r3, #1
 8000884:	421f      	tst	r7, r3
 8000886:	f040 80d5 	bne.w	8000a34 <main+0x744>
              "unaligned object");

  php->next = mp->next;
 800088a:	f8d8 3000 	ldr.w	r3, [r8]
 800088e:	603b      	str	r3, [r7, #0]
  mp->next = php;
 8000890:	f8c8 7000 	str.w	r7, [r8]
  _dbg_check_unlock();
 8000894:	f001 fbfc 	bl	8002090 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8000898:	6823      	ldr	r3, [r4, #0]
 800089a:	42a3      	cmp	r3, r4
 800089c:	d0ae      	beq.n	80007fc <main+0x50c>
 800089e:	f8d9 2018 	ldr.w	r2, [r9, #24]
 80008a2:	689b      	ldr	r3, [r3, #8]
 80008a4:	6892      	ldr	r2, [r2, #8]
 80008a6:	429a      	cmp	r2, r3
 80008a8:	d2a8      	bcs.n	80007fc <main+0x50c>
 80008aa:	4813      	ldr	r0, [pc, #76]	; (80008f8 <main+0x608>)
 80008ac:	f000 fee0 	bl	8001670 <chSysHalt>
  chDbgAssert(chRegFindThreadByWorkingArea(tdp->wbase) == NULL,
 80008b0:	4812      	ldr	r0, [pc, #72]	; (80008fc <main+0x60c>)
 80008b2:	f000 fedd 	bl	8001670 <chSysHalt>
 80008b6:	69ff      	ldr	r7, [r7, #28]
 */
void chHeapFree(void *p) {
  heap_header_t *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
 80008b8:	b117      	cbz	r7, 80008c0 <main+0x5d0>
 80008ba:	077a      	lsls	r2, r7, #29
 80008bc:	f000 80bd 	beq.w	8000a3a <main+0x74a>
 80008c0:	480f      	ldr	r0, [pc, #60]	; (8000900 <main+0x610>)
 80008c2:	f000 fed5 	bl	8001670 <chSysHalt>
    ntp = NULL;
 80008c6:	2300      	movs	r3, #0
 80008c8:	9302      	str	r3, [sp, #8]
 80008ca:	e76e      	b.n	80007aa <main+0x4ba>
 80008cc:	e000ed00 	.word	0xe000ed00
 80008d0:	080017c1 	.word	0x080017c1
 80008d4:	080025b0 	.word	0x080025b0
 80008d8:	05fa0300 	.word	0x05fa0300
 80008dc:	20000400 	.word	0x20000400
 80008e0:	080025c8 	.word	0x080025c8
 80008e4:	20001260 	.word	0x20001260
 80008e8:	08002528 	.word	0x08002528
 80008ec:	08002670 	.word	0x08002670
 80008f0:	08002594 	.word	0x08002594
 80008f4:	08002554 	.word	0x08002554
 80008f8:	08002688 	.word	0x08002688
 80008fc:	08002588 	.word	0x08002588
 8000900:	08002570 	.word	0x08002570
 8000904:	20000870 	.word	0x20000870
 8000908:	20020000 	.word	0x20020000
 800090c:	20001358 	.word	0x20001358
 8000910:	e000edf0 	.word	0xe000edf0
 8000914:	e0001000 	.word	0xe0001000
 8000918:	20000878 	.word	0x20000878
    *startp++ = v;
 800091c:	2255      	movs	r2, #85	; 0x55
 800091e:	49b8      	ldr	r1, [pc, #736]	; (8000c00 <main+0x910>)
 8000920:	54ca      	strb	r2, [r1, r3]
 8000922:	3301      	adds	r3, #1
  while (startp < endp) {
 8000924:	2bd8      	cmp	r3, #216	; 0xd8
    *startp++ = v;
 8000926:	460f      	mov	r7, r1
  while (startp < endp) {
 8000928:	d1f9      	bne.n	800091e <main+0x62e>
 800092a:	2320      	movs	r3, #32
 800092c:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8000930:	f001 fbee 	bl	8002110 <_dbg_check_lock>
  chDbgCheckClassI();
 8000934:	f000 ff0c 	bl	8001750 <chDbgCheckClassI>
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000938:	4ab2      	ldr	r2, [pc, #712]	; (8000c04 <main+0x914>)
 800093a:	66fa      	str	r2, [r7, #108]	; 0x6c
 800093c:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8000940:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
  tp->name      = name;
 8000944:	4ab0      	ldr	r2, [pc, #704]	; (8000c08 <main+0x918>)
  REG_INSERT(tp);
 8000946:	6961      	ldr	r1, [r4, #20]
  tp->name      = name;
 8000948:	f8c7 20a8 	str.w	r2, [r7, #168]	; 0xa8
  tp->state     = CH_STATE_WTSTART;
 800094c:	2302      	movs	r3, #2
  tp->prio      = prio;
 800094e:	2201      	movs	r2, #1
  tp->state     = CH_STATE_WTSTART;
 8000950:	f887 30b0 	strb.w	r3, [r7, #176]	; 0xb0
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000954:	2300      	movs	r3, #0
 8000956:	48ad      	ldr	r0, [pc, #692]	; (8000c0c <main+0x91c>)
 8000958:	673b      	str	r3, [r7, #112]	; 0x70
  tp->flags     = CH_FLAG_MODE_STATIC;
 800095a:	f887 30b1 	strb.w	r3, [r7, #177]	; 0xb1
  tp->mtxlist   = NULL;
 800095e:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
  tp->epending  = (eventmask_t)0;
 8000962:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
  tp->prio      = prio;
 8000966:	f8c7 2098 	str.w	r2, [r7, #152]	; 0x98
  tqp->next = (thread_t *)tqp;
 800096a:	f107 03bc 	add.w	r3, r7, #188	; 0xbc
  tp->realprio  = prio;
 800096e:	f8c7 20cc 	str.w	r2, [r7, #204]	; 0xcc
  tp->refs      = (trefs_t)1;
 8000972:	f887 20b2 	strb.w	r2, [r7, #178]	; 0xb2
  REG_INSERT(tp);
 8000976:	f107 0890 	add.w	r8, r7, #144	; 0x90
  tlp->next = (thread_t *)tlp;
 800097a:	f107 02b8 	add.w	r2, r7, #184	; 0xb8
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800097e:	f8c7 008c 	str.w	r0, [r7, #140]	; 0x8c
  tp->wabase = tdp->wbase;
 8000982:	f8c7 70ac 	str.w	r7, [r7, #172]	; 0xac
  REG_INSERT(tp);
 8000986:	f8c7 40a0 	str.w	r4, [r7, #160]	; 0xa0
 800098a:	f8c7 10a4 	str.w	r1, [r7, #164]	; 0xa4
 800098e:	f8c1 8010 	str.w	r8, [r1, #16]
  tqp->next = (thread_t *)tqp;
 8000992:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
  tqp->prev = (thread_t *)tqp;
 8000996:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
  tlp->next = (thread_t *)tlp;
 800099a:	f8c7 20b8 	str.w	r2, [r7, #184]	; 0xb8
 800099e:	f8c4 8014 	str.w	r8, [r4, #20]
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  thread_t *otp = currp;

  chDbgCheckClassS();
 80009a2:	f000 fe95 	bl	80016d0 <chDbgCheckClassS>

  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80009a6:	6823      	ldr	r3, [r4, #0]
  thread_t *otp = currp;
 80009a8:	69a0      	ldr	r0, [r4, #24]
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80009aa:	42a3      	cmp	r3, r4
 80009ac:	d004      	beq.n	80009b8 <main+0x6c8>
 80009ae:	689b      	ldr	r3, [r3, #8]
 80009b0:	6882      	ldr	r2, [r0, #8]
 80009b2:	429a      	cmp	r2, r3
 80009b4:	f0c0 826f 	bcc.w	8000e96 <main+0xba6>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 80009b8:	4a91      	ldr	r2, [pc, #580]	; (8000c00 <main+0x910>)
 80009ba:	2300      	movs	r3, #0
 80009bc:	f8c2 30b4 	str.w	r3, [r2, #180]	; 0xb4

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 80009c0:	6883      	ldr	r3, [r0, #8]
  ntp->u.rdymsg = msg;
 80009c2:	4691      	mov	r9, r2
  if (ntp->prio <= otp->prio) {
 80009c4:	2b00      	cmp	r3, #0
 80009c6:	f040 8261 	bne.w	8000e8c <main+0xb9c>
    (void) chSchReadyI(ntp);
  }
  else {
    otp = chSchReadyI(otp);
 80009ca:	f000 ff41 	bl	8001850 <chSchReadyI>
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 80009ce:	8f23      	ldrh	r3, [r4, #56]	; 0x38
    if (otp->prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
 80009d0:	f8c4 8018 	str.w	r8, [r4, #24]
    ntp->state = CH_STATE_CURRENT;
 80009d4:	2201      	movs	r2, #1
 80009d6:	07db      	lsls	r3, r3, #31
    otp = chSchReadyI(otp);
 80009d8:	4607      	mov	r7, r0
    ntp->state = CH_STATE_CURRENT;
 80009da:	f889 20b0 	strb.w	r2, [r9, #176]	; 0xb0
 80009de:	d401      	bmi.n	80009e4 <main+0x6f4>
 80009e0:	f000 fe2e 	bl	8001640 <_trace_switch.part.0>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80009e4:	f3ef 8309 	mrs	r3, PSP

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 80009e8:	69fa      	ldr	r2, [r7, #28]
 80009ea:	3b24      	subs	r3, #36	; 0x24
 80009ec:	429a      	cmp	r2, r3
 80009ee:	f200 818e 	bhi.w	8000d0e <main+0xa1e>
 80009f2:	4639      	mov	r1, r7
 80009f4:	4886      	ldr	r0, [pc, #536]	; (8000c10 <main+0x920>)
 80009f6:	f7ff fc5d 	bl	80002b4 <_port_switch>
  _dbg_check_unlock();
 80009fa:	f001 fb49 	bl	8002090 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80009fe:	6823      	ldr	r3, [r4, #0]
 8000a00:	4a84      	ldr	r2, [pc, #528]	; (8000c14 <main+0x924>)
 8000a02:	42a3      	cmp	r3, r4
 8000a04:	d005      	beq.n	8000a12 <main+0x722>
 8000a06:	6992      	ldr	r2, [r2, #24]
 8000a08:	689b      	ldr	r3, [r3, #8]
 8000a0a:	6892      	ldr	r2, [r2, #8]
 8000a0c:	429a      	cmp	r2, r3
 8000a0e:	f4ff af01 	bcc.w	8000814 <main+0x524>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000a12:	2400      	movs	r4, #0
 8000a14:	f384 8811 	msr	BASEPRI, r4
 8000a18:	2320      	movs	r3, #32
 8000a1a:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8000a1e:	f001 fb77 	bl	8002110 <_dbg_check_lock>
void pwmStart(PWMDriver *pwmp, const PWMConfig *config) {

  osalDbgCheck((pwmp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
 8000a22:	782b      	ldrb	r3, [r5, #0]
 8000a24:	4a7c      	ldr	r2, [pc, #496]	; (8000c18 <main+0x928>)
 8000a26:	1e59      	subs	r1, r3, #1
 8000a28:	2901      	cmp	r1, #1
 8000a2a:	f240 8173 	bls.w	8000d14 <main+0xa24>
 8000a2e:	487b      	ldr	r0, [pc, #492]	; (8000c1c <main+0x92c>)
 8000a30:	f000 fe1e 	bl	8001670 <chSysHalt>
  chDbgCheck((mp != NULL) && (objp != NULL));
 8000a34:	487a      	ldr	r0, [pc, #488]	; (8000c20 <main+0x930>)
 8000a36:	f000 fe1b 	bl	8001670 <chSysHalt>
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8000a3a:	f857 3c04 	ldr.w	r3, [r7, #-4]
  heapp = H_HEAP(hp);
 8000a3e:	f857 8c08 	ldr.w	r8, [r7, #-8]
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8000a42:	3307      	adds	r3, #7
 8000a44:	08db      	lsrs	r3, r3, #3
 8000a46:	f847 3c04 	str.w	r3, [r7, #-4]
  hp = (heap_header_t *)p - 1U;
 8000a4a:	f1a7 0108 	sub.w	r1, r7, #8
  qp = &heapp->header;
 8000a4e:	f108 0308 	add.w	r3, r8, #8
 8000a52:	9303      	str	r3, [sp, #12]
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8000a54:	f108 0a10 	add.w	sl, r8, #16
  hp = (heap_header_t *)p - 1U;
 8000a58:	9104      	str	r1, [sp, #16]
 8000a5a:	2320      	movs	r3, #32
 8000a5c:	f383 8811 	msr	BASEPRI, r3
 8000a60:	f001 fb56 	bl	8002110 <_dbg_check_lock>
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;

  chDbgCheckClassS();
 8000a64:	f000 fe34 	bl	80016d0 <chDbgCheckClassS>
  thread_t *ctp = currp;
 8000a68:	f8d4 b018 	ldr.w	fp, [r4, #24]
  chDbgCheck(mp != NULL);
 8000a6c:	9904      	ldr	r1, [sp, #16]
 8000a6e:	f1ba 0f00 	cmp.w	sl, #0
 8000a72:	d03e      	beq.n	8000af2 <main+0x802>

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8000a74:	f8d8 0018 	ldr.w	r0, [r8, #24]
 8000a78:	2800      	cmp	r0, #0
 8000a7a:	d03d      	beq.n	8000af8 <main+0x808>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 8000a7c:	f8db 2008 	ldr.w	r2, [fp, #8]
 8000a80:	6883      	ldr	r3, [r0, #8]
 8000a82:	9204      	str	r2, [sp, #16]
 8000a84:	429a      	cmp	r2, r3
 8000a86:	d917      	bls.n	8000ab8 <main+0x7c8>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8000a88:	f890 3020 	ldrb.w	r3, [r0, #32]
        tp->prio = ctp->prio;
 8000a8c:	9a04      	ldr	r2, [sp, #16]
 8000a8e:	6082      	str	r2, [r0, #8]
        switch (tp->state) {
 8000a90:	2b06      	cmp	r3, #6
 8000a92:	f000 811b 	beq.w	8000ccc <main+0x9dc>
 8000a96:	2b07      	cmp	r3, #7
 8000a98:	4694      	mov	ip, r2
 8000a9a:	f000 8102 	beq.w	8000ca2 <main+0x9b2>
 8000a9e:	b95b      	cbnz	r3, 8000ab8 <main+0x7c8>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8000aa0:	6843      	ldr	r3, [r0, #4]
 8000aa2:	9104      	str	r1, [sp, #16]
          break;
#endif
        case CH_STATE_READY:
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
 8000aa4:	2201      	movs	r2, #1
 8000aa6:	f880 2020 	strb.w	r2, [r0, #32]
 8000aaa:	6802      	ldr	r2, [r0, #0]
 8000aac:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8000aae:	6802      	ldr	r2, [r0, #0]
 8000ab0:	6053      	str	r3, [r2, #4]
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 8000ab2:	f000 fecd 	bl	8001850 <chSchReadyI>
 8000ab6:	9904      	ldr	r1, [sp, #16]
  thread_t *cp = (thread_t *)tqp;
 8000ab8:	4652      	mov	r2, sl
 8000aba:	e004      	b.n	8000ac6 <main+0x7d6>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8000abc:	6890      	ldr	r0, [r2, #8]
 8000abe:	f8db 3008 	ldr.w	r3, [fp, #8]
 8000ac2:	4298      	cmp	r0, r3
 8000ac4:	d302      	bcc.n	8000acc <main+0x7dc>
    cp = cp->queue.next;
 8000ac6:	6812      	ldr	r2, [r2, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8000ac8:	4592      	cmp	sl, r2
 8000aca:	d1f7      	bne.n	8000abc <main+0x7cc>
  tp->queue.prev             = cp->queue.prev;
 8000acc:	6853      	ldr	r3, [r2, #4]
 8000ace:	9104      	str	r1, [sp, #16]
 8000ad0:	e88b 000c 	stmia.w	fp, {r2, r3}
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 8000ad4:	2006      	movs	r0, #6
  tp->queue.prev->queue.next = tp;
 8000ad6:	f8c3 b000 	str.w	fp, [r3]
  cp->queue.prev             = tp;
 8000ada:	f8c2 b004 	str.w	fp, [r2, #4]
      ctp->u.wtmtxp = mp;
 8000ade:	f8cb a024 	str.w	sl, [fp, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 8000ae2:	f000 fe05 	bl	80016f0 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == ctp, "not owner");
 8000ae6:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8000aea:	9904      	ldr	r1, [sp, #16]
 8000aec:	459b      	cmp	fp, r3
 8000aee:	f000 80d2 	beq.w	8000c96 <main+0x9a6>
  chDbgCheck(mp != NULL);
 8000af2:	484c      	ldr	r0, [pc, #304]	; (8000c24 <main+0x934>)
 8000af4:	f000 fdbc 	bl	8001670 <chSysHalt>

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
    mp->next = ctp->mtxlist;
 8000af8:	f8db 3038 	ldr.w	r3, [fp, #56]	; 0x38
 8000afc:	f8c8 301c 	str.w	r3, [r8, #28]
    mp->owner = ctp;
 8000b00:	f8c8 b018 	str.w	fp, [r8, #24]
    ctp->mtxlist = mp;
 8000b04:	f8cb a038 	str.w	sl, [fp, #56]	; 0x38
 8000b08:	9104      	str	r1, [sp, #16]
  _dbg_check_unlock();
 8000b0a:	f001 fac1 	bl	8002090 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8000b0e:	6822      	ldr	r2, [r4, #0]
 8000b10:	9904      	ldr	r1, [sp, #16]
 8000b12:	42a2      	cmp	r2, r4
 8000b14:	d006      	beq.n	8000b24 <main+0x834>
 8000b16:	f8d9 3018 	ldr.w	r3, [r9, #24]
 8000b1a:	6892      	ldr	r2, [r2, #8]
 8000b1c:	689b      	ldr	r3, [r3, #8]
 8000b1e:	4293      	cmp	r3, r2
 8000b20:	f0c0 80b6 	bcc.w	8000c90 <main+0x9a0>
 8000b24:	9b01      	ldr	r3, [sp, #4]
 8000b26:	f383 8811 	msr	BASEPRI, r3
  qp = &heapp->header;
 8000b2a:	9a03      	ldr	r2, [sp, #12]

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 8000b2c:	4291      	cmp	r1, r2
 8000b2e:	d306      	bcc.n	8000b3e <main+0x84e>
 8000b30:	6853      	ldr	r3, [r2, #4]
 8000b32:	3301      	adds	r3, #1
 8000b34:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8000b38:	4299      	cmp	r1, r3
 8000b3a:	f4ff aec1 	bcc.w	80008c0 <main+0x5d0>

    if (((qp == &heapp->header) || (hp > qp)) &&
 8000b3e:	9b03      	ldr	r3, [sp, #12]
 8000b40:	4293      	cmp	r3, r2
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8000b42:	6813      	ldr	r3, [r2, #0]
    if (((qp == &heapp->header) || (hp > qp)) &&
 8000b44:	d001      	beq.n	8000b4a <main+0x85a>
 8000b46:	4291      	cmp	r1, r2
 8000b48:	d902      	bls.n	8000b50 <main+0x860>
 8000b4a:	b11b      	cbz	r3, 8000b54 <main+0x864>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8000b4c:	4299      	cmp	r1, r3
 8000b4e:	d301      	bcc.n	8000b54 <main+0x864>
        H_PAGES(qp) += H_PAGES(hp) + 1U;
        H_NEXT(qp) = H_NEXT(hp);
      }
      break;
    }
    qp = H_NEXT(qp);
 8000b50:	461a      	mov	r2, r3
 8000b52:	e7eb      	b.n	8000b2c <main+0x83c>
      H_NEXT(hp) = H_NEXT(qp);
 8000b54:	f847 3c08 	str.w	r3, [r7, #-8]
      H_NEXT(qp) = hp;
 8000b58:	6011      	str	r1, [r2, #0]
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8000b5a:	e917 4008 	ldmdb	r7, {r3, lr}
 8000b5e:	f10e 0001 	add.w	r0, lr, #1
 8000b62:	eb01 0cc0 	add.w	ip, r1, r0, lsl #3
 8000b66:	459c      	cmp	ip, r3
 8000b68:	d109      	bne.n	8000b7e <main+0x88e>
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8000b6a:	f8dc 3004 	ldr.w	r3, [ip, #4]
 8000b6e:	4473      	add	r3, lr
 8000b70:	3301      	adds	r3, #1
 8000b72:	f847 3c04 	str.w	r3, [r7, #-4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 8000b76:	f851 3030 	ldr.w	r3, [r1, r0, lsl #3]
 8000b7a:	f847 3c08 	str.w	r3, [r7, #-8]
      if ((H_LIMIT(qp) == hp)) {
 8000b7e:	6853      	ldr	r3, [r2, #4]
 8000b80:	1c58      	adds	r0, r3, #1
 8000b82:	eb02 00c0 	add.w	r0, r2, r0, lsl #3
 8000b86:	4281      	cmp	r1, r0
 8000b88:	d00d      	beq.n	8000ba6 <main+0x8b6>
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
 8000b8a:	69a7      	ldr	r7, [r4, #24]
 8000b8c:	2320      	movs	r3, #32
 8000b8e:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8000b92:	f001 fabd 	bl	8002110 <_dbg_check_lock>

  chDbgCheck(mp != NULL);

  chSysLock();

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 8000b96:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8000b98:	b113      	cbz	r3, 8000ba0 <main+0x8b0>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
 8000b9a:	689a      	ldr	r2, [r3, #8]
 8000b9c:	4297      	cmp	r7, r2
 8000b9e:	d00c      	beq.n	8000bba <main+0x8ca>
  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 8000ba0:	4821      	ldr	r0, [pc, #132]	; (8000c28 <main+0x938>)
 8000ba2:	f000 fd65 	bl	8001670 <chSysHalt>
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8000ba6:	f857 1c04 	ldr.w	r1, [r7, #-4]
 8000baa:	440b      	add	r3, r1
 8000bac:	3301      	adds	r3, #1
 8000bae:	6053      	str	r3, [r2, #4]
        H_NEXT(qp) = H_NEXT(hp);
 8000bb0:	f857 3c08 	ldr.w	r3, [r7, #-8]
 8000bb4:	6013      	str	r3, [r2, #0]
  thread_t *ctp = currp;
 8000bb6:	69a7      	ldr	r7, [r4, #24]
 8000bb8:	e7e8      	b.n	8000b8c <main+0x89c>
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
#endif

    chDbgAssert(ctp->mtxlist == mp, "not next in list");
 8000bba:	459a      	cmp	sl, r3
 8000bbc:	d1f0      	bne.n	8000ba0 <main+0x8b0>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 8000bbe:	f8d8 301c 	ldr.w	r3, [r8, #28]
 8000bc2:	63bb      	str	r3, [r7, #56]	; 0x38
 8000bc4:	9304      	str	r3, [sp, #16]
 * @deprecated
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {

  chDbgCheckClassS();
 8000bc6:	f000 fd83 	bl	80016d0 <chDbgCheckClassS>
  return (bool)(tqp->next != (const thread_t *)tqp);
 8000bca:	f8d8 b010 	ldr.w	fp, [r8, #16]

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8000bce:	45da      	cmp	sl, fp
 8000bd0:	f000 8099 	beq.w	8000d06 <main+0xa16>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 8000bd4:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8000bd6:	9b04      	ldr	r3, [sp, #16]
 8000bd8:	f8cd a00c 	str.w	sl, [sp, #12]
 8000bdc:	f8cd b010 	str.w	fp, [sp, #16]
 8000be0:	46ba      	mov	sl, r7
 8000be2:	46c3      	mov	fp, r8
 8000be4:	461f      	mov	r7, r3
 8000be6:	4690      	mov	r8, r2
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 8000be8:	b307      	cbz	r7, 8000c2c <main+0x93c>
 8000bea:	f000 fd71 	bl	80016d0 <chDbgCheckClassS>
 8000bee:	683b      	ldr	r3, [r7, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8000bf0:	429f      	cmp	r7, r3
 8000bf2:	d003      	beq.n	8000bfc <main+0x90c>
            (lmp->queue.next->prio > newprio)) {
 8000bf4:	689b      	ldr	r3, [r3, #8]
 8000bf6:	4598      	cmp	r8, r3
 8000bf8:	bf38      	it	cc
 8000bfa:	4698      	movcc	r8, r3
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
 8000bfc:	68ff      	ldr	r7, [r7, #12]
 8000bfe:	e7f3      	b.n	8000be8 <main+0x8f8>
 8000c00:	20001260 	.word	0x20001260
 8000c04:	08001401 	.word	0x08001401
 8000c08:	080025d0 	.word	0x080025d0
 8000c0c:	080002c5 	.word	0x080002c5
 8000c10:	200012f0 	.word	0x200012f0
 8000c14:	20000878 	.word	0x20000878
 8000c18:	20001338 	.word	0x20001338
 8000c1c:	080025a4 	.word	0x080025a4
 8000c20:	08002564 	.word	0x08002564
 8000c24:	0800250c 	.word	0x0800250c
 8000c28:	0800257c 	.word	0x0800257c
 8000c2c:	4642      	mov	r2, r8
 8000c2e:	46d8      	mov	r8, fp
 8000c30:	f8dd b010 	ldr.w	fp, [sp, #16]
 8000c34:	4657      	mov	r7, sl
  tqp->next             = tp->queue.next;
 8000c36:	f8db 3000 	ldr.w	r3, [fp]
 8000c3a:	f8dd a00c 	ldr.w	sl, [sp, #12]
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 8000c3e:	60ba      	str	r2, [r7, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 8000c40:	f8db 2038 	ldr.w	r2, [fp, #56]	; 0x38
 8000c44:	f8c8 3010 	str.w	r3, [r8, #16]

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8000c48:	4658      	mov	r0, fp
  tqp->next->queue.prev = (thread_t *)tqp;
 8000c4a:	f8c3 a004 	str.w	sl, [r3, #4]
      mp->next = tp->mtxlist;
 8000c4e:	f8c8 201c 	str.w	r2, [r8, #28]
      mp->owner = tp;
 8000c52:	f8c8 b018 	str.w	fp, [r8, #24]
      tp->mtxlist = mp;
 8000c56:	f8cb a038 	str.w	sl, [fp, #56]	; 0x38
      (void) chSchReadyI(tp);
 8000c5a:	f000 fdf9 	bl	8001850 <chSchReadyI>
 *
 * @sclass
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();
 8000c5e:	f000 fd37 	bl	80016d0 <chDbgCheckClassS>
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();
 8000c62:	f000 fd75 	bl	8001750 <chDbgCheckClassI>

  return firstprio(&ch.rlist.queue) > currp->prio;
 8000c66:	6822      	ldr	r2, [r4, #0]
 8000c68:	69a3      	ldr	r3, [r4, #24]

  if (chSchIsRescRequiredI()) {
 8000c6a:	6892      	ldr	r2, [r2, #8]
 8000c6c:	689b      	ldr	r3, [r3, #8]
 8000c6e:	429a      	cmp	r2, r3
 8000c70:	d901      	bls.n	8000c76 <main+0x986>
    chSchDoRescheduleAhead();
 8000c72:	f000 fdad 	bl	80017d0 <chSchDoReschedule>
  _dbg_check_unlock();
 8000c76:	f001 fa0b 	bl	8002090 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8000c7a:	6823      	ldr	r3, [r4, #0]
 8000c7c:	42a3      	cmp	r3, r4
 8000c7e:	f43f adbd 	beq.w	80007fc <main+0x50c>
 8000c82:	f8d9 2018 	ldr.w	r2, [r9, #24]
 8000c86:	689b      	ldr	r3, [r3, #8]
 8000c88:	6892      	ldr	r2, [r2, #8]
 8000c8a:	429a      	cmp	r2, r3
 8000c8c:	f4bf adb6 	bcs.w	80007fc <main+0x50c>
 8000c90:	48ab      	ldr	r0, [pc, #684]	; (8000f40 <main+0xc50>)
 8000c92:	f000 fced 	bl	8001670 <chSysHalt>
      chDbgAssert(ctp->mtxlist == mp, "not owned");
 8000c96:	f8db 3038 	ldr.w	r3, [fp, #56]	; 0x38
 8000c9a:	459a      	cmp	sl, r3
 8000c9c:	f47f af29 	bne.w	8000af2 <main+0x802>
 8000ca0:	e732      	b.n	8000b08 <main+0x818>
  tp->queue.prev->queue.next = tp->queue.next;
 8000ca2:	6842      	ldr	r2, [r0, #4]
 8000ca4:	6803      	ldr	r3, [r0, #0]
 8000ca6:	6013      	str	r3, [r2, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8000ca8:	6803      	ldr	r3, [r0, #0]
 8000caa:	605a      	str	r2, [r3, #4]
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8000cac:	6a43      	ldr	r3, [r0, #36]	; 0x24
  thread_t *cp = (thread_t *)tqp;
 8000cae:	461a      	mov	r2, r3
 8000cb0:	469e      	mov	lr, r3
 8000cb2:	e002      	b.n	8000cba <main+0x9ca>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8000cb4:	6893      	ldr	r3, [r2, #8]
 8000cb6:	459c      	cmp	ip, r3
 8000cb8:	d802      	bhi.n	8000cc0 <main+0x9d0>
    cp = cp->queue.next;
 8000cba:	6812      	ldr	r2, [r2, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8000cbc:	4596      	cmp	lr, r2
 8000cbe:	d1f9      	bne.n	8000cb4 <main+0x9c4>
  tp->queue.prev             = cp->queue.prev;
 8000cc0:	6853      	ldr	r3, [r2, #4]
 8000cc2:	e880 000c 	stmia.w	r0, {r2, r3}
  tp->queue.prev->queue.next = tp;
 8000cc6:	6018      	str	r0, [r3, #0]
  cp->queue.prev             = tp;
 8000cc8:	6050      	str	r0, [r2, #4]
 8000cca:	e6f5      	b.n	8000ab8 <main+0x7c8>
  tp->queue.prev->queue.next = tp->queue.next;
 8000ccc:	e890 000c 	ldmia.w	r0, {r2, r3}
 8000cd0:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8000cd2:	6802      	ldr	r2, [r0, #0]
  thread_t *cp = (thread_t *)tqp;
 8000cd4:	9105      	str	r1, [sp, #20]
  tp->queue.next->queue.prev = tp->queue.prev;
 8000cd6:	6053      	str	r3, [r2, #4]
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8000cd8:	f8d0 c024 	ldr.w	ip, [r0, #36]	; 0x24
  thread_t *cp = (thread_t *)tqp;
 8000cdc:	4663      	mov	r3, ip
 8000cde:	e003      	b.n	8000ce8 <main+0x9f8>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8000ce0:	689a      	ldr	r2, [r3, #8]
 8000ce2:	9904      	ldr	r1, [sp, #16]
 8000ce4:	4291      	cmp	r1, r2
 8000ce6:	d802      	bhi.n	8000cee <main+0x9fe>
    cp = cp->queue.next;
 8000ce8:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8000cea:	459c      	cmp	ip, r3
 8000cec:	d1f8      	bne.n	8000ce0 <main+0x9f0>
 8000cee:	469e      	mov	lr, r3
  tp->queue.prev             = cp->queue.prev;
 8000cf0:	685b      	ldr	r3, [r3, #4]
 8000cf2:	6043      	str	r3, [r0, #4]
  tp->queue.next             = cp;
 8000cf4:	f8c0 e000 	str.w	lr, [r0]
 8000cf8:	9905      	ldr	r1, [sp, #20]
  tp->queue.prev->queue.next = tp;
 8000cfa:	6018      	str	r0, [r3, #0]
  cp->queue.prev             = tp;
 8000cfc:	f8ce 0004 	str.w	r0, [lr, #4]
          tp = tp->u.wtmtxp->owner;
 8000d00:	f8dc 0008 	ldr.w	r0, [ip, #8]
 8000d04:	e6ba      	b.n	8000a7c <main+0x78c>
      chSchRescheduleS();
    }
    else {
      mp->owner = NULL;
 8000d06:	9b01      	ldr	r3, [sp, #4]
 8000d08:	f8c8 3018 	str.w	r3, [r8, #24]
 8000d0c:	e7b3      	b.n	8000c76 <main+0x986>
    chSysSwitch(ntp, otp);
 8000d0e:	488d      	ldr	r0, [pc, #564]	; (8000f44 <main+0xc54>)
 8000d10:	f000 fcae 	bl	8001670 <chSysHalt>
                "invalid state");
  pwmp->config = config;
 8000d14:	488c      	ldr	r0, [pc, #560]	; (8000f48 <main+0xc58>)
 8000d16:	6050      	str	r0, [r2, #4]
  pwmp->period = config->period;
 8000d18:	6841      	ldr	r1, [r0, #4]
 8000d1a:	6091      	str	r1, [r2, #8]
 */
void pwm_lld_start(PWMDriver *pwmp) {
  uint32_t psc;
  uint32_t ccer;

  if (pwmp->state == PWM_STOP) {
 8000d1c:	2b01      	cmp	r3, #1
 8000d1e:	d018      	beq.n	8000d52 <main+0xa62>
                       STM32_TIM_CCMR3_OC6M(6) | STM32_TIM_CCMR3_OC6PE;
#endif
  }
  else {
    /* Driver re-configuration scenario, it must be stopped first.*/
    pwmp->tim->CR1    = 0;                  /* Timer disabled.              */
 8000d20:	6993      	ldr	r3, [r2, #24]
 8000d22:	601c      	str	r4, [r3, #0]
    pwmp->tim->CCR[0] = 0;                  /* Comparator 1 disabled.       */
 8000d24:	635c      	str	r4, [r3, #52]	; 0x34
    pwmp->tim->CCR[1] = 0;                  /* Comparator 2 disabled.       */
 8000d26:	639c      	str	r4, [r3, #56]	; 0x38
    pwmp->tim->CCR[2] = 0;                  /* Comparator 3 disabled.       */
 8000d28:	63dc      	str	r4, [r3, #60]	; 0x3c
    pwmp->tim->CCR[3] = 0;                  /* Comparator 4 disabled.       */
 8000d2a:	641c      	str	r4, [r3, #64]	; 0x40
    if (pwmp->channels > 4) {
      pwmp->tim->CCXR[0] = 0;               /* Comparator 5 disabled.       */
      pwmp->tim->CCXR[1] = 0;               /* Comparator 6 disabled.       */
    }
#endif
    pwmp->tim->CNT  = 0;                    /* Counter reset to zero.       */
 8000d2c:	625c      	str	r4, [r3, #36]	; 0x24
  }

  /* Timer configuration.*/
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
 8000d2e:	6969      	ldr	r1, [r5, #20]
 8000d30:	f8d0 e000 	ldr.w	lr, [r0]
 8000d34:	fbb1 f3fe 	udiv	r3, r1, lr
 8000d38:	1e5c      	subs	r4, r3, #1
  osalDbgAssert((psc <= 0xFFFF) &&
 8000d3a:	f5b4 3f80 	cmp.w	r4, #65536	; 0x10000
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
 8000d3e:	4a83      	ldr	r2, [pc, #524]	; (8000f4c <main+0xc5c>)
 8000d40:	4f81      	ldr	r7, [pc, #516]	; (8000f48 <main+0xc58>)
  osalDbgAssert((psc <= 0xFFFF) &&
 8000d42:	d203      	bcs.n	8000d4c <main+0xa5c>
 8000d44:	fb03 f30e 	mul.w	r3, r3, lr
 8000d48:	4299      	cmp	r1, r3
 8000d4a:	d027      	beq.n	8000d9c <main+0xaac>
 8000d4c:	4880      	ldr	r0, [pc, #512]	; (8000f50 <main+0xc60>)
 8000d4e:	f000 fc8f 	bl	8001670 <chSysHalt>
      rccEnableTIM1(FALSE);
 8000d52:	4980      	ldr	r1, [pc, #512]	; (8000f54 <main+0xc64>)
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000d54:	4b80      	ldr	r3, [pc, #512]	; (8000f58 <main+0xc68>)
 8000d56:	6c4f      	ldr	r7, [r1, #68]	; 0x44
    pwmp->tim->CCMR1 = STM32_TIM_CCMR1_OC1M(6) | STM32_TIM_CCMR1_OC1PE |
 8000d58:	f8d2 e018 	ldr.w	lr, [r2, #24]
      rccEnableTIM1(FALSE);
 8000d5c:	f047 0701 	orr.w	r7, r7, #1
 8000d60:	644f      	str	r7, [r1, #68]	; 0x44
      rccResetTIM1();
 8000d62:	6a4f      	ldr	r7, [r1, #36]	; 0x24
 8000d64:	f047 0701 	orr.w	r7, r7, #1
 8000d68:	624f      	str	r7, [r1, #36]	; 0x24
 8000d6a:	624c      	str	r4, [r1, #36]	; 0x24
 8000d6c:	2170      	movs	r1, #112	; 0x70
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000d6e:	f04f 7400 	mov.w	r4, #33554432	; 0x2000000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000d72:	f883 1319 	strb.w	r1, [r3, #793]	; 0x319
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000d76:	f8c3 4180 	str.w	r4, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000d7a:	601c      	str	r4, [r3, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000d7c:	f04f 6400 	mov.w	r4, #134217728	; 0x8000000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000d80:	f883 131b 	strb.w	r1, [r3, #795]	; 0x31b
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000d84:	f8c3 4180 	str.w	r4, [r3, #384]	; 0x180
    pwmp->tim->CCMR1 = STM32_TIM_CCMR1_OC1M(6) | STM32_TIM_CCMR1_OC1PE |
 8000d88:	f646 0168 	movw	r1, #26728	; 0x6868
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000d8c:	601c      	str	r4, [r3, #0]
      pwmp->clock = STM32_TIMCLK2;
 8000d8e:	4b73      	ldr	r3, [pc, #460]	; (8000f5c <main+0xc6c>)
    pwmp->tim->CCMR1 = STM32_TIM_CCMR1_OC1M(6) | STM32_TIM_CCMR1_OC1PE |
 8000d90:	f8ce 1018 	str.w	r1, [lr, #24]
      pwmp->clock = STM32_TIMCLK2;
 8000d94:	6153      	str	r3, [r2, #20]
    pwmp->tim->CCMR2 = STM32_TIM_CCMR2_OC3M(6) | STM32_TIM_CCMR2_OC3PE |
 8000d96:	f8ce 101c 	str.w	r1, [lr, #28]
 8000d9a:	e7c8      	b.n	8000d2e <main+0xa3e>
  pwmp->tim->ARR  = pwmp->period - 1;
  pwmp->tim->CR2  = pwmp->config->cr2;

  /* Output enables and polarities setup.*/
  ccer = 0;
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 8000d9c:	68fb      	ldr	r3, [r7, #12]
  pwmp->tim->ARR  = pwmp->period - 1;
 8000d9e:	6891      	ldr	r1, [r2, #8]
  pwmp->tim->PSC  = psc;
 8000da0:	6992      	ldr	r2, [r2, #24]
  pwmp->tim->CR2  = pwmp->config->cr2;
 8000da2:	6aff      	ldr	r7, [r7, #44]	; 0x2c
  pwmp->tim->PSC  = psc;
 8000da4:	6294      	str	r4, [r2, #40]	; 0x28
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 8000da6:	f003 030f 	and.w	r3, r3, #15
  pwmp->tim->ARR  = pwmp->period - 1;
 8000daa:	3901      	subs	r1, #1
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 8000dac:	2b01      	cmp	r3, #1
  pwmp->tim->ARR  = pwmp->period - 1;
 8000dae:	62d1      	str	r1, [r2, #44]	; 0x2c
  pwmp->tim->CR2  = pwmp->config->cr2;
 8000db0:	6057      	str	r7, [r2, #4]
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 8000db2:	d043      	beq.n	8000e3c <main+0xb4c>
 8000db4:	2b02      	cmp	r3, #2
 8000db6:	d143      	bne.n	8000e40 <main+0xb50>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC1P;
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC1E;
 8000db8:	f043 0301 	orr.w	r3, r3, #1
  default:
    ;
  }
  switch (pwmp->config->channels[1].mode & PWM_OUTPUT_MASK) {
 8000dbc:	6941      	ldr	r1, [r0, #20]
 8000dbe:	f001 010f 	and.w	r1, r1, #15
 8000dc2:	2901      	cmp	r1, #1
 8000dc4:	d003      	beq.n	8000dce <main+0xade>
 8000dc6:	2902      	cmp	r1, #2
 8000dc8:	d103      	bne.n	8000dd2 <main+0xae2>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC2P;
 8000dca:	f043 0320 	orr.w	r3, r3, #32
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC2E;
 8000dce:	f043 0310 	orr.w	r3, r3, #16
  default:
    ;
  }
  switch (pwmp->config->channels[2].mode & PWM_OUTPUT_MASK) {
 8000dd2:	69c1      	ldr	r1, [r0, #28]
 8000dd4:	f001 010f 	and.w	r1, r1, #15
 8000dd8:	2901      	cmp	r1, #1
 8000dda:	d003      	beq.n	8000de4 <main+0xaf4>
 8000ddc:	2902      	cmp	r1, #2
 8000dde:	d103      	bne.n	8000de8 <main+0xaf8>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC3P;
 8000de0:	f443 7300 	orr.w	r3, r3, #512	; 0x200
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC3E;
 8000de4:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  default:
    ;
  }
  switch (pwmp->config->channels[3].mode & PWM_OUTPUT_MASK) {
 8000de8:	6a41      	ldr	r1, [r0, #36]	; 0x24
 8000dea:	f001 010f 	and.w	r1, r1, #15
 8000dee:	2901      	cmp	r1, #1
 8000df0:	d003      	beq.n	8000dfa <main+0xb0a>
 8000df2:	2902      	cmp	r1, #2
 8000df4:	d103      	bne.n	8000dfe <main+0xb0e>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC4P;
 8000df6:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC4E;
 8000dfa:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
#endif /* STM32_PWM_USE_ADVANCED*/

  pwmp->tim->CCER  = ccer;
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 8000dfe:	6b01      	ldr	r1, [r0, #48]	; 0x30
  pwmp->tim->CCER  = ccer;
 8000e00:	6213      	str	r3, [r2, #32]
#else
  pwmp->tim->BDTR  = STM32_TIM_BDTR_MOE;
#endif
#endif
  /* Timer configured and started.*/
  pwmp->tim->CR1   = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS |
 8000e02:	2085      	movs	r0, #133	; 0x85
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 8000e04:	f021 03ff 	bic.w	r3, r1, #255	; 0xff
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
 8000e08:	2701      	movs	r7, #1
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
 8000e0a:	2100      	movs	r1, #0
  pwmp->tim->BDTR  = STM32_TIM_BDTR_MOE;
 8000e0c:	f44f 4400 	mov.w	r4, #32768	; 0x8000
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
 8000e10:	6157      	str	r7, [r2, #20]
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
 8000e12:	6111      	str	r1, [r2, #16]
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 8000e14:	60d3      	str	r3, [r2, #12]
  pwmp->tim->BDTR  = STM32_TIM_BDTR_MOE;
 8000e16:	6454      	str	r4, [r2, #68]	; 0x44
  pwm_lld_start(pwmp);
  pwmp->enabled = 0;
  pwmp->state = PWM_READY;
 8000e18:	2302      	movs	r3, #2
  pwmp->tim->CR1   = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS |
 8000e1a:	6010      	str	r0, [r2, #0]
  pwmp->enabled = 0;
 8000e1c:	4c4b      	ldr	r4, [pc, #300]	; (8000f4c <main+0xc5c>)
  pwmp->state = PWM_READY;
 8000e1e:	702b      	strb	r3, [r5, #0]
  pwmp->enabled = 0;
 8000e20:	60e9      	str	r1, [r5, #12]
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
 8000e22:	f001 f945 	bl	80020b0 <chSysUnlock.lto_priv.38>
 8000e26:	2320      	movs	r3, #32
 8000e28:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8000e2c:	f001 f970 	bl	8002110 <_dbg_check_lock>

  osalDbgCheck(pwmp != NULL);

  osalSysLock();

  osalDbgAssert(pwmp->state == PWM_READY, "not ready");
 8000e30:	782b      	ldrb	r3, [r5, #0]
 8000e32:	2b02      	cmp	r3, #2
 8000e34:	d006      	beq.n	8000e44 <main+0xb54>
 8000e36:	484a      	ldr	r0, [pc, #296]	; (8000f60 <main+0xc70>)
 8000e38:	f000 fc1a 	bl	8001670 <chSysHalt>
  ccer = 0;
 8000e3c:	2300      	movs	r3, #0
 8000e3e:	e7bb      	b.n	8000db8 <main+0xac8>
 8000e40:	2300      	movs	r3, #0
 8000e42:	e7bb      	b.n	8000dbc <main+0xacc>
  osalDbgAssert(pwmp->config->callback != NULL, "undefined periodic callback");
 8000e44:	6863      	ldr	r3, [r4, #4]
 8000e46:	689b      	ldr	r3, [r3, #8]
 8000e48:	2b00      	cmp	r3, #0
 8000e4a:	d0f4      	beq.n	8000e36 <main+0xb46>
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_enable_periodic_notification(PWMDriver *pwmp) {
  uint32_t dier = pwmp->tim->DIER;
 8000e4c:	69a3      	ldr	r3, [r4, #24]
 8000e4e:	68da      	ldr	r2, [r3, #12]

  /* If the IRQ is not already enabled care must be taken to clear it,
     it is probably already pending because the timer is running.*/
  if ((dier & STM32_TIM_DIER_UIE) == 0) {
 8000e50:	07d4      	lsls	r4, r2, #31
 8000e52:	d406      	bmi.n	8000e62 <main+0xb72>
    pwmp->tim->DIER = dier | STM32_TIM_DIER_UIE;
 8000e54:	f042 0201 	orr.w	r2, r2, #1
 8000e58:	60da      	str	r2, [r3, #12]
    pwmp->tim->SR &= STM32_TIM_SR_UIF;
 8000e5a:	691a      	ldr	r2, [r3, #16]
 8000e5c:	f002 0201 	and.w	r2, r2, #1
 8000e60:	611a      	str	r2, [r3, #16]
 8000e62:	f001 f925 	bl	80020b0 <chSysUnlock.lto_priv.38>
   * GPIOC6 is the ICU input.
   * The two pins have to be externally connected together.
   */
  pwmStart(&PWMD1, &pwmcfg);
  pwmEnablePeriodicNotification(&PWMD1);
  palSetPadMode(GPIOA, 8, PAL_MODE_ALTERNATE(1));
 8000e66:	2282      	movs	r2, #130	; 0x82
 8000e68:	f44f 7180 	mov.w	r1, #256	; 0x100
 8000e6c:	483d      	ldr	r0, [pc, #244]	; (8000f64 <main+0xc74>)
 8000e6e:	f000 fb57 	bl	8001520 <_pal_lld_setgroupmode>
 8000e72:	2320      	movs	r3, #32
 8000e74:	f383 8811 	msr	BASEPRI, r3
 8000e78:	f001 f94a 	bl	8002110 <_dbg_check_lock>
void icuStart(ICUDriver *icup, const ICUConfig *config) {

  osalDbgCheck((icup != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((icup->state == ICU_STOP) || (icup->state == ICU_READY),
 8000e7c:	7833      	ldrb	r3, [r6, #0]
 8000e7e:	493a      	ldr	r1, [pc, #232]	; (8000f68 <main+0xc78>)
 8000e80:	1e5a      	subs	r2, r3, #1
 8000e82:	2a01      	cmp	r2, #1
 8000e84:	d90a      	bls.n	8000e9c <main+0xbac>
 8000e86:	4839      	ldr	r0, [pc, #228]	; (8000f6c <main+0xc7c>)
 8000e88:	f000 fbf2 	bl	8001670 <chSysHalt>
    (void) chSchReadyI(ntp);
 8000e8c:	f102 0090 	add.w	r0, r2, #144	; 0x90
 8000e90:	f000 fcde 	bl	8001850 <chSchReadyI>
 8000e94:	e5b1      	b.n	80009fa <main+0x70a>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8000e96:	4836      	ldr	r0, [pc, #216]	; (8000f70 <main+0xc80>)
 8000e98:	f000 fbea 	bl	8001670 <chSysHalt>
                "invalid state");
  icup->config = config;
 8000e9c:	4a35      	ldr	r2, [pc, #212]	; (8000f74 <main+0xc84>)
 8000e9e:	604a      	str	r2, [r1, #4]
 * @notapi
 */
void icu_lld_start(ICUDriver *icup) {
  uint32_t psc;

  osalDbgAssert((icup->config->channel == ICU_CHANNEL_1) ||
 8000ea0:	7d10      	ldrb	r0, [r2, #20]
 8000ea2:	2801      	cmp	r0, #1
 8000ea4:	d902      	bls.n	8000eac <main+0xbbc>
 8000ea6:	4834      	ldr	r0, [pc, #208]	; (8000f78 <main+0xc88>)
 8000ea8:	f000 fbe2 	bl	8001670 <chSysHalt>
                (icup->config->channel == ICU_CHANNEL_2),
                "invalid input");

  if (icup->state == ICU_STOP) {
 8000eac:	2b01      	cmp	r3, #1
 8000eae:	d069      	beq.n	8000f84 <main+0xc94>
    }
#endif
  }
  else {
    /* Driver re-configuration scenario, it must be stopped first.*/
    icup->tim->CR1    = 0;                  /* Timer disabled.              */
 8000eb0:	68cb      	ldr	r3, [r1, #12]
 8000eb2:	2100      	movs	r1, #0
 8000eb4:	6019      	str	r1, [r3, #0]
    icup->tim->CCR[0] = 0;                  /* Comparator 1 disabled.       */
 8000eb6:	6359      	str	r1, [r3, #52]	; 0x34
    icup->tim->CCR[1] = 0;                  /* Comparator 2 disabled.       */
 8000eb8:	6399      	str	r1, [r3, #56]	; 0x38
    icup->tim->CNT    = 0;                  /* Counter reset to zero.       */
 8000eba:	6259      	str	r1, [r3, #36]	; 0x24
  }

  /* Timer configuration.*/
  icup->tim->SR   = 0;                      /* Clear eventual pending IRQs. */
  icup->tim->DIER = icup->config->dier &    /* DMA-related DIER settings.   */
 8000ebc:	6991      	ldr	r1, [r2, #24]
  icup->tim->SR   = 0;                      /* Clear eventual pending IRQs. */
 8000ebe:	68f3      	ldr	r3, [r6, #12]
                    ~STM32_TIM_DIER_IRQ_MASK;
  psc = (icup->clock / icup->config->frequency) - 1;
 8000ec0:	6857      	ldr	r7, [r2, #4]
 8000ec2:	68b4      	ldr	r4, [r6, #8]
 8000ec4:	fbb4 f2f7 	udiv	r2, r4, r7
 8000ec8:	1e50      	subs	r0, r2, #1
  icup->tim->DIER = icup->config->dier &    /* DMA-related DIER settings.   */
 8000eca:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
  icup->tim->SR   = 0;                      /* Clear eventual pending IRQs. */
 8000ece:	f04f 0e00 	mov.w	lr, #0
  osalDbgAssert((psc <= 0xFFFF) &&
 8000ed2:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
  icup->tim->SR   = 0;                      /* Clear eventual pending IRQs. */
 8000ed6:	f8c3 e010 	str.w	lr, [r3, #16]
  icup->tim->DIER = icup->config->dier &    /* DMA-related DIER settings.   */
 8000eda:	60d9      	str	r1, [r3, #12]
 8000edc:	4925      	ldr	r1, [pc, #148]	; (8000f74 <main+0xc84>)
  osalDbgAssert((psc <= 0xFFFF) &&
 8000ede:	d2e2      	bcs.n	8000ea6 <main+0xbb6>
 8000ee0:	fb02 f207 	mul.w	r2, r2, r7
 8000ee4:	4294      	cmp	r4, r2
 8000ee6:	d1de      	bne.n	8000ea6 <main+0xbb6>
                ((psc + 1) * icup->config->frequency) == icup->clock,
                "invalid frequency");
  icup->tim->PSC  = psc;
  icup->tim->ARR  = 0xFFFF;

  if (icup->config->channel == ICU_CHANNEL_1) {
 8000ee8:	7d0a      	ldrb	r2, [r1, #20]
  icup->tim->PSC  = psc;
 8000eea:	6298      	str	r0, [r3, #40]	; 0x28
  icup->tim->ARR  = 0xFFFF;
 8000eec:	f64f 70ff 	movw	r0, #65535	; 0xffff
 8000ef0:	62d8      	str	r0, [r3, #44]	; 0x2c
  if (icup->config->channel == ICU_CHANNEL_1) {
 8000ef2:	2a00      	cmp	r2, #0
 8000ef4:	d178      	bne.n	8000fe8 <main+0xcf8>
    icup->tim->SMCR  = STM32_TIM_SMCR_TS(5) | STM32_TIM_SMCR_SMS(4);

    /* The CCER settings depend on the selected trigger mode.
       ICU_INPUT_ACTIVE_HIGH: Active on rising edge, idle on falling edge.
       ICU_INPUT_ACTIVE_LOW:  Active on falling edge, idle on rising edge.*/
    if (icup->config->mode == ICU_INPUT_ACTIVE_HIGH)
 8000ef6:	780a      	ldrb	r2, [r1, #0]
    icup->tim->CCMR1 = STM32_TIM_CCMR1_CC1S(1) | STM32_TIM_CCMR1_CC2S(2);
 8000ef8:	f240 2001 	movw	r0, #513	; 0x201
    icup->tim->SMCR  = STM32_TIM_SMCR_TS(5) | STM32_TIM_SMCR_SMS(4);
 8000efc:	2154      	movs	r1, #84	; 0x54
    icup->tim->CCMR1 = STM32_TIM_CCMR1_CC1S(1) | STM32_TIM_CCMR1_CC2S(2);
 8000efe:	6198      	str	r0, [r3, #24]
    icup->tim->SMCR  = STM32_TIM_SMCR_TS(5) | STM32_TIM_SMCR_SMS(4);
 8000f00:	6099      	str	r1, [r3, #8]
    if (icup->config->mode == ICU_INPUT_ACTIVE_HIGH)
 8000f02:	2a00      	cmp	r2, #0
 8000f04:	d16d      	bne.n	8000fe2 <main+0xcf2>
      icup->tim->CCER = STM32_TIM_CCER_CC1E |
 8000f06:	2231      	movs	r2, #49	; 0x31
 8000f08:	621a      	str	r2, [r3, #32]
      icup->tim->CCER = STM32_TIM_CCER_CC1E | STM32_TIM_CCER_CC1P |
                        STM32_TIM_CCER_CC2E;

    /* Direct pointers to the capture registers in order to make reading
       data faster from within callbacks.*/
    icup->wccrp = &icup->tim->CCR[1];
 8000f0a:	f103 0238 	add.w	r2, r3, #56	; 0x38
    icup->pccrp = &icup->tim->CCR[0];
 8000f0e:	3334      	adds	r3, #52	; 0x34
    icup->wccrp = &icup->tim->CCR[1];
 8000f10:	6132      	str	r2, [r6, #16]
    icup->pccrp = &icup->tim->CCR[0];
 8000f12:	6173      	str	r3, [r6, #20]
  icu_lld_start(icup);
  icup->state = ICU_READY;
 8000f14:	2302      	movs	r3, #2
 8000f16:	7033      	strb	r3, [r6, #0]
 8000f18:	f001 f8e2 	bl	80020e0 <chSysUnlock.lto_priv.49>
  icuStart(&ICUD3, &icucfg);
  palSetPadMode(GPIOC, 6, PAL_MODE_ALTERNATE(2));
 8000f1c:	f44f 7281 	mov.w	r2, #258	; 0x102
 8000f20:	2140      	movs	r1, #64	; 0x40
 8000f22:	4816      	ldr	r0, [pc, #88]	; (8000f7c <main+0xc8c>)
 8000f24:	4c10      	ldr	r4, [pc, #64]	; (8000f68 <main+0xc78>)
 8000f26:	f000 fafb 	bl	8001520 <_pal_lld_setgroupmode>
 8000f2a:	2720      	movs	r7, #32
 8000f2c:	f387 8811 	msr	BASEPRI, r7
 8000f30:	f001 f8ee 	bl	8002110 <_dbg_check_lock>
void icuStartCapture(ICUDriver *icup) {

  osalDbgCheck(icup != NULL);

  osalSysLock();
  osalDbgAssert(icup->state == ICU_READY, "invalid state");
 8000f34:	7833      	ldrb	r3, [r6, #0]
 8000f36:	2b02      	cmp	r3, #2
 8000f38:	d03b      	beq.n	8000fb2 <main+0xcc2>
 8000f3a:	4811      	ldr	r0, [pc, #68]	; (8000f80 <main+0xc90>)
 8000f3c:	f000 fb98 	bl	8001670 <chSysHalt>
 8000f40:	0800267c 	.word	0x0800267c
 8000f44:	080025d8 	.word	0x080025d8
 8000f48:	20000800 	.word	0x20000800
 8000f4c:	20001338 	.word	0x20001338
 8000f50:	080025f4 	.word	0x080025f4
 8000f54:	40023800 	.word	0x40023800
 8000f58:	e000e100 	.word	0xe000e100
 8000f5c:	0a037a00 	.word	0x0a037a00
 8000f60:	08002650 	.word	0x08002650
 8000f64:	40020000 	.word	0x40020000
 8000f68:	20001200 	.word	0x20001200
 8000f6c:	080025e8 	.word	0x080025e8
 8000f70:	08002518 	.word	0x08002518
 8000f74:	20000834 	.word	0x20000834
 8000f78:	08002604 	.word	0x08002604
 8000f7c:	40020800 	.word	0x40020800
 8000f80:	08002694 	.word	0x08002694
      rccEnableTIM3(FALSE);
 8000f84:	4ba8      	ldr	r3, [pc, #672]	; (8001228 <main+0xf38>)
     icup->clock = STM32_TIMCLK1;
 8000f86:	4fa9      	ldr	r7, [pc, #676]	; (800122c <main+0xf3c>)
      rccEnableTIM3(FALSE);
 8000f88:	6c1c      	ldr	r4, [r3, #64]	; 0x40
     icup->clock = STM32_TIMCLK1;
 8000f8a:	608f      	str	r7, [r1, #8]
      rccEnableTIM3(FALSE);
 8000f8c:	f044 0102 	orr.w	r1, r4, #2
 8000f90:	6419      	str	r1, [r3, #64]	; 0x40
      rccResetTIM3();
 8000f92:	6a19      	ldr	r1, [r3, #32]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000f94:	48a6      	ldr	r0, [pc, #664]	; (8001230 <main+0xf40>)
 8000f96:	f041 0102 	orr.w	r1, r1, #2
 8000f9a:	6219      	str	r1, [r3, #32]
 8000f9c:	2700      	movs	r7, #0
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000f9e:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000fa2:	2470      	movs	r4, #112	; 0x70
 8000fa4:	621f      	str	r7, [r3, #32]
 8000fa6:	f880 431d 	strb.w	r4, [r0, #797]	; 0x31d
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000faa:	f8c0 1180 	str.w	r1, [r0, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000fae:	6001      	str	r1, [r0, #0]
 8000fb0:	e784      	b.n	8000ebc <main+0xbcc>
 * @notapi
 */
void icu_lld_start_capture(ICUDriver *icup) {

  /* Triggering an UG and clearing the IRQ status.*/
  icup->tim->EGR |= STM32_TIM_EGR_UG;
 8000fb2:	68e3      	ldr	r3, [r4, #12]
 8000fb4:	695a      	ldr	r2, [r3, #20]
  icup->tim->SR = 0;
 8000fb6:	2000      	movs	r0, #0

  /* Timer is started.*/
  icup->tim->CR1 = STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
 8000fb8:	2105      	movs	r1, #5
  icup->tim->EGR |= STM32_TIM_EGR_UG;
 8000fba:	f042 0201 	orr.w	r2, r2, #1
 8000fbe:	615a      	str	r2, [r3, #20]
  icup->tim->SR = 0;
 8000fc0:	6118      	str	r0, [r3, #16]
  icuStartCaptureI(icup);
 8000fc2:	2203      	movs	r2, #3
  icup->tim->CR1 = STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
 8000fc4:	6019      	str	r1, [r3, #0]
 8000fc6:	7022      	strb	r2, [r4, #0]
 8000fc8:	f001 f88a 	bl	80020e0 <chSysUnlock.lto_priv.49>
 8000fcc:	f387 8811 	msr	BASEPRI, r7
 8000fd0:	f001 f89e 	bl	8002110 <_dbg_check_lock>
void icuEnableNotifications(ICUDriver *icup) {

  osalDbgCheck(icup != NULL);

  osalSysLock();
  osalDbgAssert((icup->state == ICU_WAITING) || (icup->state == ICU_ACTIVE),
 8000fd4:	7823      	ldrb	r3, [r4, #0]
 8000fd6:	3b03      	subs	r3, #3
 8000fd8:	2b01      	cmp	r3, #1
 8000fda:	d915      	bls.n	8001008 <main+0xd18>
 8000fdc:	4895      	ldr	r0, [pc, #596]	; (8001234 <main+0xf44>)
 8000fde:	f000 fb47 	bl	8001670 <chSysHalt>
      icup->tim->CCER = STM32_TIM_CCER_CC1E | STM32_TIM_CCER_CC1P |
 8000fe2:	2213      	movs	r2, #19
 8000fe4:	621a      	str	r2, [r3, #32]
 8000fe6:	e790      	b.n	8000f0a <main+0xc1a>
    if (icup->config->mode == ICU_INPUT_ACTIVE_HIGH)
 8000fe8:	780a      	ldrb	r2, [r1, #0]
    icup->tim->CCMR1 = STM32_TIM_CCMR1_CC1S(2) | STM32_TIM_CCMR1_CC2S(1);
 8000fea:	f44f 7081 	mov.w	r0, #258	; 0x102
    icup->tim->SMCR  = STM32_TIM_SMCR_TS(6) | STM32_TIM_SMCR_SMS(4);
 8000fee:	2164      	movs	r1, #100	; 0x64
    icup->tim->CCMR1 = STM32_TIM_CCMR1_CC1S(2) | STM32_TIM_CCMR1_CC2S(1);
 8000ff0:	6198      	str	r0, [r3, #24]
    icup->tim->SMCR  = STM32_TIM_SMCR_TS(6) | STM32_TIM_SMCR_SMS(4);
 8000ff2:	6099      	str	r1, [r3, #8]
    if (icup->config->mode == ICU_INPUT_ACTIVE_HIGH)
 8000ff4:	2a00      	cmp	r2, #0
 8000ff6:	d137      	bne.n	8001068 <main+0xd78>
      icup->tim->CCER = STM32_TIM_CCER_CC1E | STM32_TIM_CCER_CC1P |
 8000ff8:	2213      	movs	r2, #19
 8000ffa:	621a      	str	r2, [r3, #32]
    icup->wccrp = &icup->tim->CCR[0];
 8000ffc:	f103 0234 	add.w	r2, r3, #52	; 0x34
    icup->pccrp = &icup->tim->CCR[1];
 8001000:	3338      	adds	r3, #56	; 0x38
    icup->wccrp = &icup->tim->CCR[0];
 8001002:	6132      	str	r2, [r6, #16]
    icup->pccrp = &icup->tim->CCR[1];
 8001004:	6173      	str	r3, [r6, #20]
 8001006:	e785      	b.n	8000f14 <main+0xc24>
 * @param[in] icup      pointer to the @p ICUDriver object
 *
 * @notapi
 */
void icu_lld_enable_notifications(ICUDriver *icup) {
  uint32_t dier = icup->tim->DIER;
 8001008:	68e0      	ldr	r0, [r4, #12]
 800100a:	68c2      	ldr	r2, [r0, #12]

  /* If interrupts were already enabled then the operation is skipped.
     This is done in order to avoid clearing the SR and risk losing
     pending interrupts.*/
  if ((dier & STM32_TIM_DIER_IRQ_MASK) == 0) {
 800100c:	f012 03ff 	ands.w	r3, r2, #255	; 0xff
 8001010:	d10e      	bne.n	8001030 <main+0xd40>
    /* Previously triggered IRQs are ignored, status cleared.*/
    icup->tim->SR = 0;

    if (icup->config->channel == ICU_CHANNEL_1) {
 8001012:	6861      	ldr	r1, [r4, #4]
    icup->tim->SR = 0;
 8001014:	6103      	str	r3, [r0, #16]
    if (icup->config->channel == ICU_CHANNEL_1) {
 8001016:	7d0b      	ldrb	r3, [r1, #20]
      /* Enabling periodic callback on CC1.*/
      dier |= STM32_TIM_DIER_CC1IE;

      /* Optionally enabling width callback on CC2.*/
      if (icup->config->width_cb != NULL)
 8001018:	688c      	ldr	r4, [r1, #8]
    if (icup->config->channel == ICU_CHANNEL_1) {
 800101a:	bb03      	cbnz	r3, 800105e <main+0xd6e>
      dier |= STM32_TIM_DIER_CC1IE;
 800101c:	f042 0302 	orr.w	r3, r2, #2
      if (icup->config->width_cb != NULL)
 8001020:	b10c      	cbz	r4, 8001026 <main+0xd36>
      /* Enabling periodic callback on CC2.*/
      dier |= STM32_TIM_DIER_CC2IE;

      /* Optionally enabling width callback on CC1.*/
      if (icup->config->width_cb != NULL)
        dier |= STM32_TIM_DIER_CC1IE;
 8001022:	f042 0306 	orr.w	r3, r2, #6
    }

    /* If an overflow callback is defined then also the overflow callback
       is enabled.*/
    if (icup->config->overflow_cb != NULL)
 8001026:	690a      	ldr	r2, [r1, #16]
 8001028:	b10a      	cbz	r2, 800102e <main+0xd3e>
      dier |= STM32_TIM_DIER_UIE;
 800102a:	f043 0301 	orr.w	r3, r3, #1

    /* One single atomic write.*/
    icup->tim->DIER = dier;
 800102e:	60c3      	str	r3, [r0, #12]
 8001030:	f001 f856 	bl	80020e0 <chSysUnlock.lto_priv.49>
  icuStartCapture(&ICUD3);
  icuEnableNotifications(&ICUD3);
  chThdSleepMilliseconds(2000);
 8001034:	f644 6020 	movw	r0, #20000	; 0x4e20
 8001038:	f001 f8a2 	bl	8002180 <chThdSleep>

  /*
   * Starts the PWM channel 0 using 75% duty cycle.
   */
  pwmEnableChannel(&PWMD1, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD1, 7500));
 800103c:	68aa      	ldr	r2, [r5, #8]
 800103e:	4c7e      	ldr	r4, [pc, #504]	; (8001238 <main+0xf48>)
 8001040:	f641 534c 	movw	r3, #7500	; 0x1d4c
 8001044:	fb03 f302 	mul.w	r3, r3, r2
 8001048:	f242 7010 	movw	r0, #10000	; 0x2710
 800104c:	fbb3 f0f0 	udiv	r0, r3, r0
 8001050:	f001 fa3e 	bl	80024d0 <pwmEnableChannel.constprop.8>
 *
 * @api
 */
void pwmEnableChannelNotification(PWMDriver *pwmp, pwmchannel_t channel) {

  osalDbgCheck((pwmp != NULL) && (channel < pwmp->channels));
 8001054:	7c2b      	ldrb	r3, [r5, #16]
 8001056:	b953      	cbnz	r3, 800106e <main+0xd7e>
 8001058:	4878      	ldr	r0, [pc, #480]	; (800123c <main+0xf4c>)
 800105a:	f000 fb09 	bl	8001670 <chSysHalt>
      dier |= STM32_TIM_DIER_CC2IE;
 800105e:	f042 0304 	orr.w	r3, r2, #4
      if (icup->config->width_cb != NULL)
 8001062:	2c00      	cmp	r4, #0
 8001064:	d1dd      	bne.n	8001022 <main+0xd32>
 8001066:	e7de      	b.n	8001026 <main+0xd36>
      icup->tim->CCER = STM32_TIM_CCER_CC1E |
 8001068:	2231      	movs	r2, #49	; 0x31
 800106a:	621a      	str	r2, [r3, #32]
 800106c:	e7c6      	b.n	8000ffc <main+0xd0c>
 800106e:	2320      	movs	r3, #32
 8001070:	f383 8811 	msr	BASEPRI, r3
 8001074:	f001 f84c 	bl	8002110 <_dbg_check_lock>

  osalSysLock();

  osalDbgAssert(pwmp->state == PWM_READY, "not ready");
 8001078:	7823      	ldrb	r3, [r4, #0]
 800107a:	2b02      	cmp	r3, #2
 800107c:	d1ec      	bne.n	8001058 <main+0xd68>
  osalDbgAssert((pwmp->enabled & ((pwmchnmsk_t)1U << (pwmchnmsk_t)channel)) != 0U,
 800107e:	68e3      	ldr	r3, [r4, #12]
 8001080:	07d8      	lsls	r0, r3, #31
 8001082:	d5e9      	bpl.n	8001058 <main+0xd68>
                "channel not enabled");
  osalDbgAssert(pwmp->config->channels[channel].callback != NULL,
 8001084:	6863      	ldr	r3, [r4, #4]
 8001086:	691b      	ldr	r3, [r3, #16]
 8001088:	2b00      	cmp	r3, #0
 800108a:	d0e5      	beq.n	8001058 <main+0xd68>
 *
 * @notapi
 */
void pwm_lld_enable_channel_notification(PWMDriver *pwmp,
                                         pwmchannel_t channel) {
  uint32_t dier = pwmp->tim->DIER;
 800108c:	69a2      	ldr	r2, [r4, #24]
 800108e:	68d3      	ldr	r3, [r2, #12]
  osalDbgAssert(channel < 4, "callback not supported");
#endif

  /* If the IRQ is not already enabled care must be taken to clear it,
     it is probably already pending because the timer is running.*/
  if ((dier & (2 << channel)) == 0) {
 8001090:	0799      	lsls	r1, r3, #30
 8001092:	d405      	bmi.n	80010a0 <main+0xdb0>
    pwmp->tim->DIER = dier | (2 << channel);
 8001094:	f043 0302 	orr.w	r3, r3, #2
    pwmp->tim->SR   = ~(2 << channel);
 8001098:	f06f 0102 	mvn.w	r1, #2
    pwmp->tim->DIER = dier | (2 << channel);
 800109c:	60d3      	str	r3, [r2, #12]
    pwmp->tim->SR   = ~(2 << channel);
 800109e:	6111      	str	r1, [r2, #16]
 80010a0:	f001 f806 	bl	80020b0 <chSysUnlock.lto_priv.38>
  pwmEnableChannelNotification(&PWMD1, 0);
  chThdSleepMilliseconds(5000);
 80010a4:	f24c 3050 	movw	r0, #50000	; 0xc350
 80010a8:	f001 f86a 	bl	8002180 <chThdSleep>

  /*
   * Changes the PWM channel 0 to 50% duty cycle.
   */
  pwmEnableChannel(&PWMD1, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD1, 5000));
 80010ac:	68ab      	ldr	r3, [r5, #8]
 80010ae:	4c62      	ldr	r4, [pc, #392]	; (8001238 <main+0xf48>)
 80010b0:	f241 3788 	movw	r7, #5000	; 0x1388
 80010b4:	fb07 f003 	mul.w	r0, r7, r3
 80010b8:	f242 7810 	movw	r8, #10000	; 0x2710
 80010bc:	fbb0 f0f8 	udiv	r0, r0, r8
 80010c0:	f001 fa06 	bl	80024d0 <pwmEnableChannel.constprop.8>
  chThdSleepMilliseconds(5000);
 80010c4:	f24c 3050 	movw	r0, #50000	; 0xc350
 80010c8:	f001 f85a 	bl	8002180 <chThdSleep>

  /*
   * Changes the PWM channel 0 to 25% duty cycle.
   */
  pwmEnableChannel(&PWMD1, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD1, 2500));
 80010cc:	68a8      	ldr	r0, [r5, #8]
 80010ce:	f640 13c4 	movw	r3, #2500	; 0x9c4
 80010d2:	fb03 f000 	mul.w	r0, r3, r0
 80010d6:	fbb0 f0f8 	udiv	r0, r0, r8
 80010da:	f001 f9f9 	bl	80024d0 <pwmEnableChannel.constprop.8>
  chThdSleepMilliseconds(5000);
 80010de:	f24c 3050 	movw	r0, #50000	; 0xc350
 80010e2:	f001 f84d 	bl	8002180 <chThdSleep>
 80010e6:	f04f 0820 	mov.w	r8, #32
 80010ea:	f388 8811 	msr	BASEPRI, r8
 80010ee:	f001 f80f 	bl	8002110 <_dbg_check_lock>
  osalDbgAssert(pwmp->state == PWM_READY, "invalid state");
 80010f2:	782b      	ldrb	r3, [r5, #0]
 80010f4:	2b02      	cmp	r3, #2
 80010f6:	d002      	beq.n	80010fe <main+0xe0e>
 80010f8:	4851      	ldr	r0, [pc, #324]	; (8001240 <main+0xf50>)
 80010fa:	f000 fab9 	bl	8001670 <chSysHalt>
  pwmChangePeriodI(pwmp, period);
 80010fe:	69a3      	ldr	r3, [r4, #24]
 8001100:	60a7      	str	r7, [r4, #8]
 8001102:	f241 3287 	movw	r2, #4999	; 0x1387
 8001106:	62da      	str	r2, [r3, #44]	; 0x2c
 8001108:	f000 ffd2 	bl	80020b0 <chSysUnlock.lto_priv.38>
  /*
   * Changes PWM period to half second the duty cycle becomes 50%
   * implicitly.
   */
  pwmChangePeriod(&PWMD1, 5000);
  chThdSleepMilliseconds(5000);
 800110c:	f24c 3050 	movw	r0, #50000	; 0xc350
 8001110:	f001 f836 	bl	8002180 <chThdSleep>
  osalDbgCheck((pwmp != NULL) && (channel < pwmp->channels));
 8001114:	7c23      	ldrb	r3, [r4, #16]
 8001116:	b913      	cbnz	r3, 800111e <main+0xe2e>
 8001118:	484a      	ldr	r0, [pc, #296]	; (8001244 <main+0xf54>)
 800111a:	f000 faa9 	bl	8001670 <chSysHalt>
 800111e:	f388 8811 	msr	BASEPRI, r8
 8001122:	f000 fff5 	bl	8002110 <_dbg_check_lock>
  osalDbgAssert(pwmp->state == PWM_READY, "not ready");
 8001126:	7823      	ldrb	r3, [r4, #0]
 8001128:	2b02      	cmp	r3, #2
 800112a:	d1f5      	bne.n	8001118 <main+0xe28>
  pwmp->tim->CCR[channel] = 0;
 800112c:	69a3      	ldr	r3, [r4, #24]
  pwmDisableChannelI(pwmp, channel);
 800112e:	68e1      	ldr	r1, [r4, #12]
 8001130:	2700      	movs	r7, #0
 8001132:	635f      	str	r7, [r3, #52]	; 0x34
  pwmp->tim->DIER &= ~(2 << channel);
 8001134:	68da      	ldr	r2, [r3, #12]
 8001136:	f021 0101 	bic.w	r1, r1, #1
 800113a:	f022 0202 	bic.w	r2, r2, #2
 800113e:	60e1      	str	r1, [r4, #12]
 8001140:	60da      	str	r2, [r3, #12]
 8001142:	f000 ffb5 	bl	80020b0 <chSysUnlock.lto_priv.38>
 8001146:	f388 8811 	msr	BASEPRI, r8
 800114a:	f000 ffe1 	bl	8002110 <_dbg_check_lock>
  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
 800114e:	7823      	ldrb	r3, [r4, #0]
 8001150:	1e5a      	subs	r2, r3, #1
 8001152:	2a01      	cmp	r2, #1
 8001154:	d902      	bls.n	800115c <main+0xe6c>
 8001156:	483c      	ldr	r0, [pc, #240]	; (8001248 <main+0xf58>)
 8001158:	f000 fa8a 	bl	8001670 <chSysHalt>
  if (pwmp->state == PWM_READY) {
 800115c:	2b02      	cmp	r3, #2
 800115e:	d116      	bne.n	800118e <main+0xe9e>
    pwmp->tim->CR1  = 0;                    /* Timer disabled.              */
 8001160:	69a2      	ldr	r2, [r4, #24]
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8001162:	4b33      	ldr	r3, [pc, #204]	; (8001230 <main+0xf40>)
      rccDisableTIM1(FALSE);
 8001164:	4930      	ldr	r1, [pc, #192]	; (8001228 <main+0xf38>)
    pwmp->tim->CR1  = 0;                    /* Timer disabled.              */
 8001166:	6017      	str	r7, [r2, #0]
 8001168:	f04f 7400 	mov.w	r4, #33554432	; 0x2000000
 800116c:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
    pwmp->tim->DIER = 0;                    /* All IRQs disabled.           */
 8001170:	60d7      	str	r7, [r2, #12]
    pwmp->tim->SR   = 0;                    /* Clear eventual pending IRQs. */
 8001172:	6117      	str	r7, [r2, #16]
    pwmp->tim->BDTR  = 0;
 8001174:	6457      	str	r7, [r2, #68]	; 0x44
 8001176:	f8c3 4080 	str.w	r4, [r3, #128]	; 0x80
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 800117a:	f883 7319 	strb.w	r7, [r3, #793]	; 0x319
  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 800117e:	f8c3 0080 	str.w	r0, [r3, #128]	; 0x80
  NVIC->IP[n] = 0U;
 8001182:	f883 731b 	strb.w	r7, [r3, #795]	; 0x31b
      rccDisableTIM1(FALSE);
 8001186:	6c4b      	ldr	r3, [r1, #68]	; 0x44
 8001188:	f023 0301 	bic.w	r3, r3, #1
 800118c:	644b      	str	r3, [r1, #68]	; 0x44
  pwmp->enabled = 0;
 800118e:	2400      	movs	r4, #0
  pwmp->state   = PWM_STOP;
 8001190:	2301      	movs	r3, #1
  pwmp->enabled = 0;
 8001192:	60ec      	str	r4, [r5, #12]
  pwmp->config  = NULL;
 8001194:	606c      	str	r4, [r5, #4]
  pwmp->state   = PWM_STOP;
 8001196:	702b      	strb	r3, [r5, #0]
 8001198:	2720      	movs	r7, #32
 800119a:	f000 ff89 	bl	80020b0 <chSysUnlock.lto_priv.38>
 800119e:	f387 8811 	msr	BASEPRI, r7
 80011a2:	f000 ffb5 	bl	8002110 <_dbg_check_lock>
  osalDbgAssert((icup->state == ICU_READY) || (icup->state == ICU_WAITING) ||
 80011a6:	7833      	ldrb	r3, [r6, #0]
 80011a8:	4d28      	ldr	r5, [pc, #160]	; (800124c <main+0xf5c>)
 80011aa:	3b02      	subs	r3, #2
 80011ac:	2b02      	cmp	r3, #2
 80011ae:	d814      	bhi.n	80011da <main+0xeea>
  icup->tim->CR1   = 0;
 80011b0:	68eb      	ldr	r3, [r5, #12]
 80011b2:	601c      	str	r4, [r3, #0]
  icup->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
 80011b4:	68da      	ldr	r2, [r3, #12]
 80011b6:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 80011ba:	60da      	str	r2, [r3, #12]
  icuStopCaptureI(icup);
 80011bc:	2302      	movs	r3, #2
 80011be:	702b      	strb	r3, [r5, #0]
 80011c0:	f000 ff8e 	bl	80020e0 <chSysUnlock.lto_priv.49>
 80011c4:	f387 8811 	msr	BASEPRI, r7
 80011c8:	f000 ffa2 	bl	8002110 <_dbg_check_lock>
  osalDbgAssert((icup->state == ICU_STOP) || (icup->state == ICU_READY),
 80011cc:	782b      	ldrb	r3, [r5, #0]
 80011ce:	1e5a      	subs	r2, r3, #1
 80011d0:	2a01      	cmp	r2, #1
 80011d2:	d905      	bls.n	80011e0 <main+0xef0>
 80011d4:	481e      	ldr	r0, [pc, #120]	; (8001250 <main+0xf60>)
 80011d6:	f000 fa4b 	bl	8001670 <chSysHalt>
  osalDbgAssert((icup->state == ICU_READY) || (icup->state == ICU_WAITING) ||
 80011da:	481e      	ldr	r0, [pc, #120]	; (8001254 <main+0xf64>)
 80011dc:	f000 fa48 	bl	8001670 <chSysHalt>
  if (icup->state == ICU_READY) {
 80011e0:	2b02      	cmp	r3, #2
 80011e2:	d10f      	bne.n	8001204 <main+0xf14>
    icup->tim->CR1  = 0;                    /* Timer disabled.              */
 80011e4:	68eb      	ldr	r3, [r5, #12]
  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 80011e6:	4912      	ldr	r1, [pc, #72]	; (8001230 <main+0xf40>)
      rccDisableTIM3(FALSE);
 80011e8:	4a0f      	ldr	r2, [pc, #60]	; (8001228 <main+0xf38>)
    icup->tim->CR1  = 0;                    /* Timer disabled.              */
 80011ea:	601c      	str	r4, [r3, #0]
 80011ec:	f04f 5000 	mov.w	r0, #536870912	; 0x20000000
    icup->tim->DIER = 0;                    /* All IRQs disabled.           */
 80011f0:	60dc      	str	r4, [r3, #12]
    icup->tim->SR   = 0;                    /* Clear eventual pending IRQs. */
 80011f2:	611c      	str	r4, [r3, #16]
 80011f4:	f8c1 0080 	str.w	r0, [r1, #128]	; 0x80
  NVIC->IP[n] = 0U;
 80011f8:	f881 431d 	strb.w	r4, [r1, #797]	; 0x31d
      rccDisableTIM3(FALSE);
 80011fc:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80011fe:	f023 0302 	bic.w	r3, r3, #2
 8001202:	6413      	str	r3, [r2, #64]	; 0x40
  icup->config = NULL;
 8001204:	2200      	movs	r2, #0
  icup->state  = ICU_STOP;
 8001206:	2301      	movs	r3, #1
  icup->config = NULL;
 8001208:	6072      	str	r2, [r6, #4]
  icup->state  = ICU_STOP;
 800120a:	7033      	strb	r3, [r6, #0]
 800120c:	f000 ff68 	bl	80020e0 <chSysUnlock.lto_priv.49>
   */
  pwmDisableChannel(&PWMD1, 0);
  pwmStop(&PWMD1);
  icuStopCapture(&ICUD3);
  icuStop(&ICUD3);
  palClearPad(GPIOD, GPIOD_LED4);
 8001210:	4b11      	ldr	r3, [pc, #68]	; (8001258 <main+0xf68>)
 8001212:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  palClearPad(GPIOD, GPIOD_LED5);
 8001216:	f44f 4280 	mov.w	r2, #16384	; 0x4000
  palClearPad(GPIOD, GPIOD_LED4);
 800121a:	8359      	strh	r1, [r3, #26]
  palClearPad(GPIOD, GPIOD_LED5);
 800121c:	835a      	strh	r2, [r3, #26]

  /*
   * Normal main() thread activity, in this demo it does nothing.
   */
  while (true) {
    chThdSleepMilliseconds(500);
 800121e:	f241 3088 	movw	r0, #5000	; 0x1388
 8001222:	f000 ffad 	bl	8002180 <chThdSleep>
 8001226:	e7fa      	b.n	800121e <main+0xf2e>
 8001228:	40023800 	.word	0x40023800
 800122c:	0501bd00 	.word	0x0501bd00
 8001230:	e000e100 	.word	0xe000e100
 8001234:	08002638 	.word	0x08002638
 8001238:	20001338 	.word	0x20001338
 800123c:	08002534 	.word	0x08002534
 8001240:	080026a4 	.word	0x080026a4
 8001244:	08002624 	.word	0x08002624
 8001248:	080026b4 	.word	0x080026b4
 800124c:	20001200 	.word	0x20001200
 8001250:	080026bc 	.word	0x080026bc
 8001254:	08002614 	.word	0x08002614
 8001258:	40020c00 	.word	0x40020c00
 800125c:	00000000 	.word	0x00000000

08001260 <icuperiodcb.lto_priv.57>:
  palClearPad(GPIOD, GPIOD_LED4);
 8001260:	4b03      	ldr	r3, [pc, #12]	; (8001270 <icuperiodcb.lto_priv.57+0x10>)
 8001262:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8001266:	835a      	strh	r2, [r3, #26]
  last_period = icuGetPeriodX(icup);
 8001268:	6943      	ldr	r3, [r0, #20]
 800126a:	681b      	ldr	r3, [r3, #0]
 800126c:	4770      	bx	lr
 800126e:	bf00      	nop
 8001270:	40020c00 	.word	0x40020c00
	...

08001280 <icuwidthcb.lto_priv.56>:
  palSetPad(GPIOD, GPIOD_LED4);
 8001280:	4b03      	ldr	r3, [pc, #12]	; (8001290 <icuwidthcb.lto_priv.56+0x10>)
 8001282:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8001286:	831a      	strh	r2, [r3, #24]
  last_width = icuGetWidthX(icup);
 8001288:	6903      	ldr	r3, [r0, #16]
 800128a:	681b      	ldr	r3, [r3, #0]
 800128c:	4770      	bx	lr
 800128e:	bf00      	nop
 8001290:	40020c00 	.word	0x40020c00
	...

080012a0 <pwmc1cb.lto_priv.55>:
  palSetPad(GPIOD, GPIOD_LED5);
 80012a0:	4b02      	ldr	r3, [pc, #8]	; (80012ac <pwmc1cb.lto_priv.55+0xc>)
 80012a2:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 80012a6:	831a      	strh	r2, [r3, #24]
 80012a8:	4770      	bx	lr
 80012aa:	bf00      	nop
 80012ac:	40020c00 	.word	0x40020c00

080012b0 <pwmpcb.lto_priv.54>:
  palClearPad(GPIOD, GPIOD_LED5);
 80012b0:	4b02      	ldr	r3, [pc, #8]	; (80012bc <pwmpcb.lto_priv.54+0xc>)
 80012b2:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 80012b6:	835a      	strh	r2, [r3, #26]
 80012b8:	4770      	bx	lr
 80012ba:	bf00      	nop
 80012bc:	40020c00 	.word	0x40020c00

080012c0 <_port_irq_epilogue>:
 80012c0:	2320      	movs	r3, #32
 80012c2:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 80012c6:	4b0f      	ldr	r3, [pc, #60]	; (8001304 <_port_irq_epilogue+0x44>)
 80012c8:	685b      	ldr	r3, [r3, #4]
 80012ca:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 80012ce:	d102      	bne.n	80012d6 <_port_irq_epilogue+0x16>
 80012d0:	f383 8811 	msr	BASEPRI, r3
 80012d4:	4770      	bx	lr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80012d6:	f3ef 8309 	mrs	r3, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 80012da:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 80012de:	f843 2c04 	str.w	r2, [r3, #-4]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 80012e2:	f1a3 0220 	sub.w	r2, r3, #32
 80012e6:	f382 8809 	msr	PSP, r2
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 80012ea:	4a07      	ldr	r2, [pc, #28]	; (8001308 <_port_irq_epilogue+0x48>)
 80012ec:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->prio;
 80012ee:	6992      	ldr	r2, [r2, #24]
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 80012f0:	6889      	ldr	r1, [r1, #8]
 80012f2:	6892      	ldr	r2, [r2, #8]
 80012f4:	4291      	cmp	r1, r2
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80012f6:	bf8c      	ite	hi
 80012f8:	4a04      	ldrhi	r2, [pc, #16]	; (800130c <_port_irq_epilogue+0x4c>)
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 80012fa:	4a05      	ldrls	r2, [pc, #20]	; (8001310 <_port_irq_epilogue+0x50>)
 80012fc:	f843 2c08 	str.w	r2, [r3, #-8]
 8001300:	4770      	bx	lr
 8001302:	bf00      	nop
 8001304:	e000ed00 	.word	0xe000ed00
 8001308:	20000878 	.word	0x20000878
 800130c:	080002d9 	.word	0x080002d9
 8001310:	080002e4 	.word	0x080002e4
	...

08001320 <SVC_Handler>:
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8001320:	f3ef 8309 	mrs	r3, PSP
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8001324:	3320      	adds	r3, #32
 8001326:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800132a:	2300      	movs	r3, #0
 800132c:	f383 8811 	msr	BASEPRI, r3
 8001330:	4770      	bx	lr
 8001332:	bf00      	nop
	...

08001340 <trace_next>:
static NOINLINE void trace_next(void) {
 8001340:	b410      	push	{r4}
  ch.dbg.trace_buffer.ptr->time    = chVTGetSystemTimeX();
 8001342:	4a0b      	ldr	r2, [pc, #44]	; (8001370 <trace_next+0x30>)
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8001344:	480b      	ldr	r0, [pc, #44]	; (8001374 <trace_next+0x34>)
 8001346:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8001348:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
  ch.dbg.trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 800134c:	6819      	ldr	r1, [r3, #0]
 800134e:	6a64      	ldr	r4, [r4, #36]	; 0x24
  ch.dbg.trace_buffer.ptr->time    = chVTGetSystemTimeX();
 8001350:	605c      	str	r4, [r3, #4]
 8001352:	6840      	ldr	r0, [r0, #4]
  ch.dbg.trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 8001354:	f360 211f 	bfi	r1, r0, #8, #24
 8001358:	f843 1b10 	str.w	r1, [r3], #16
  if (++ch.dbg.trace_buffer.ptr >=
 800135c:	f502 6104 	add.w	r1, r2, #2112	; 0x840
 8001360:	428b      	cmp	r3, r1
    ch.dbg.trace_buffer.ptr = &ch.dbg.trace_buffer.buffer[0];
 8001362:	bf28      	it	cs
 8001364:	f102 0340 	addcs.w	r3, r2, #64	; 0x40
 8001368:	63d3      	str	r3, [r2, #60]	; 0x3c
}
 800136a:	bc10      	pop	{r4}
 800136c:	4770      	bx	lr
 800136e:	bf00      	nop
 8001370:	20000878 	.word	0x20000878
 8001374:	e0001000 	.word	0xe0001000
	...

08001380 <_trace_isr_leave>:
 *
 * @notapi
 */
void _trace_isr_leave(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8001380:	4b0b      	ldr	r3, [pc, #44]	; (80013b0 <_trace_isr_leave+0x30>)
void _trace_isr_leave(const char *isr) {
 8001382:	b510      	push	{r4, lr}
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8001384:	8f1c      	ldrh	r4, [r3, #56]	; 0x38
 8001386:	f004 0402 	and.w	r4, r4, #2
 800138a:	b2a4      	uxth	r4, r4
 800138c:	b97c      	cbnz	r4, 80013ae <_trace_isr_leave+0x2e>
 800138e:	2220      	movs	r2, #32
 8001390:	f382 8811 	msr	BASEPRI, r2
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8001394:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8001396:	7813      	ldrb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = 0U;
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8001398:	6090      	str	r0, [r2, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800139a:	2103      	movs	r1, #3
 800139c:	f361 0302 	bfi	r3, r1, #0, #3
    ch.dbg.trace_buffer.ptr->state       = 0U;
 80013a0:	f364 03c7 	bfi	r3, r4, #3, #5
 80013a4:	7013      	strb	r3, [r2, #0]
    trace_next();
 80013a6:	f7ff ffcb 	bl	8001340 <trace_next>
 80013aa:	f384 8811 	msr	BASEPRI, r4
 80013ae:	bd10      	pop	{r4, pc}
 80013b0:	20000878 	.word	0x20000878
	...

080013c0 <_trace_isr_enter>:
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80013c0:	4b0b      	ldr	r3, [pc, #44]	; (80013f0 <_trace_isr_enter+0x30>)
void _trace_isr_enter(const char *isr) {
 80013c2:	b510      	push	{r4, lr}
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80013c4:	8f1c      	ldrh	r4, [r3, #56]	; 0x38
 80013c6:	f004 0402 	and.w	r4, r4, #2
 80013ca:	b2a4      	uxth	r4, r4
 80013cc:	b97c      	cbnz	r4, 80013ee <_trace_isr_enter+0x2e>
 80013ce:	2220      	movs	r2, #32
 80013d0:	f382 8811 	msr	BASEPRI, r2
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80013d4:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 80013d6:	7813      	ldrb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 80013d8:	6090      	str	r0, [r2, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80013da:	2102      	movs	r1, #2
 80013dc:	f361 0302 	bfi	r3, r1, #0, #3
    ch.dbg.trace_buffer.ptr->state       = 0U;
 80013e0:	f364 03c7 	bfi	r3, r4, #3, #5
 80013e4:	7013      	strb	r3, [r2, #0]
    trace_next();
 80013e6:	f7ff ffab 	bl	8001340 <trace_next>
 80013ea:	f384 8811 	msr	BASEPRI, r4
 80013ee:	bd10      	pop	{r4, pc}
 80013f0:	20000878 	.word	0x20000878
	...

08001400 <_idle_thread.lto_priv.58>:
static void _idle_thread(void *p) {
 8001400:	e7fe      	b.n	8001400 <_idle_thread.lto_priv.58>
 8001402:	bf00      	nop
	...

08001410 <BusFault_Handler>:
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
__attribute__((weak))
void _unhandled_exception(void) {
 8001410:	e7fe      	b.n	8001410 <BusFault_Handler>
 8001412:	bf00      	nop
	...

08001420 <__early_init>:
#if !STM32_NO_INIT
  /* PWR clock enable.*/
#if defined(HAL_USE_RTC) && defined(RCC_APB1ENR_RTCAPBEN)
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCAPBEN;
#else
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8001420:	4934      	ldr	r1, [pc, #208]	; (80014f4 <__early_init+0xd4>)
#endif

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8001422:	4b35      	ldr	r3, [pc, #212]	; (80014f8 <__early_init+0xd8>)
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8001424:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
  PWR->CR = STM32_VOS;
 8001428:	f44f 4240 	mov.w	r2, #49152	; 0xc000
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 800142c:	6408      	str	r0, [r1, #64]	; 0x40
  PWR->CR = STM32_VOS;
 800142e:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8001430:	680b      	ldr	r3, [r1, #0]
 8001432:	f043 0301 	orr.w	r3, r3, #1
 8001436:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8001438:	680a      	ldr	r2, [r1, #0]
 800143a:	4b2e      	ldr	r3, [pc, #184]	; (80014f4 <__early_init+0xd4>)
 800143c:	0790      	lsls	r0, r2, #30
 800143e:	d5fb      	bpl.n	8001438 <__early_init+0x18>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8001440:	689a      	ldr	r2, [r3, #8]
 8001442:	f022 0203 	bic.w	r2, r2, #3
 8001446:	609a      	str	r2, [r3, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8001448:	689a      	ldr	r2, [r3, #8]
 800144a:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800144c:	4619      	mov	r1, r3
 800144e:	688b      	ldr	r3, [r1, #8]
 8001450:	4a28      	ldr	r2, [pc, #160]	; (80014f4 <__early_init+0xd4>)
 8001452:	f013 030c 	ands.w	r3, r3, #12
 8001456:	d1fa      	bne.n	800144e <__early_init+0x2e>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8001458:	6811      	ldr	r1, [r2, #0]
 800145a:	f001 01f9 	and.w	r1, r1, #249	; 0xf9
 800145e:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8001460:	6093      	str	r3, [r2, #8]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 8001462:	6813      	ldr	r3, [r2, #0]
 8001464:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001468:	6013      	str	r3, [r2, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 800146a:	6811      	ldr	r1, [r2, #0]
 800146c:	4b21      	ldr	r3, [pc, #132]	; (80014f4 <__early_init+0xd4>)
 800146e:	0389      	lsls	r1, r1, #14
 8001470:	d5fb      	bpl.n	800146a <__early_init+0x4a>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8001472:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8001474:	f042 0201 	orr.w	r2, r2, #1
 8001478:	675a      	str	r2, [r3, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800147a:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 800147c:	491d      	ldr	r1, [pc, #116]	; (80014f4 <__early_init+0xd4>)
 800147e:	0790      	lsls	r0, r2, #30
 8001480:	d5fb      	bpl.n	800147a <__early_init+0x5a>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 8001482:	4b1e      	ldr	r3, [pc, #120]	; (80014fc <__early_init+0xdc>)
 8001484:	604b      	str	r3, [r1, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8001486:	680b      	ldr	r3, [r1, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8001488:	4a1b      	ldr	r2, [pc, #108]	; (80014f8 <__early_init+0xd8>)
  RCC->CR |= RCC_CR_PLLON;
 800148a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800148e:	600b      	str	r3, [r1, #0]
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8001490:	6853      	ldr	r3, [r2, #4]
 8001492:	0459      	lsls	r1, r3, #17
 8001494:	d5fc      	bpl.n	8001490 <__early_init+0x70>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8001496:	4917      	ldr	r1, [pc, #92]	; (80014f4 <__early_init+0xd4>)
 8001498:	680b      	ldr	r3, [r1, #0]
 800149a:	4a16      	ldr	r2, [pc, #88]	; (80014f4 <__early_init+0xd4>)
 800149c:	019b      	lsls	r3, r3, #6
 800149e:	d5fb      	bpl.n	8001498 <__early_init+0x78>

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 80014a0:	4b17      	ldr	r3, [pc, #92]	; (8001500 <__early_init+0xe0>)
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 80014a2:	4918      	ldr	r1, [pc, #96]	; (8001504 <__early_init+0xe4>)
 80014a4:	6091      	str	r1, [r2, #8]
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 80014a6:	681a      	ldr	r2, [r3, #0]
 80014a8:	4b17      	ldr	r3, [pc, #92]	; (8001508 <__early_init+0xe8>)
 80014aa:	429a      	cmp	r2, r3
 80014ac:	d017      	beq.n	80014de <__early_init+0xbe>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 80014ae:	4b17      	ldr	r3, [pc, #92]	; (800150c <__early_init+0xec>)
 80014b0:	f240 7205 	movw	r2, #1797	; 0x705
 80014b4:	601a      	str	r2, [r3, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 80014b6:	4a0f      	ldr	r2, [pc, #60]	; (80014f4 <__early_init+0xd4>)
 80014b8:	6893      	ldr	r3, [r2, #8]
 80014ba:	f043 0302 	orr.w	r3, r3, #2
 80014be:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80014c0:	6893      	ldr	r3, [r2, #8]
 80014c2:	490c      	ldr	r1, [pc, #48]	; (80014f4 <__early_init+0xd4>)
 80014c4:	f003 030c 	and.w	r3, r3, #12
 80014c8:	2b08      	cmp	r3, #8
 80014ca:	d1f9      	bne.n	80014c0 <__early_init+0xa0>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 80014cc:	6c4b      	ldr	r3, [r1, #68]	; 0x44
 80014ce:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80014d2:	644b      	str	r3, [r1, #68]	; 0x44
 80014d4:	6e4b      	ldr	r3, [r1, #100]	; 0x64
 80014d6:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80014da:	664b      	str	r3, [r1, #100]	; 0x64
 80014dc:	4770      	bx	lr
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 80014de:	4a0c      	ldr	r2, [pc, #48]	; (8001510 <__early_init+0xf0>)
 80014e0:	4b0c      	ldr	r3, [pc, #48]	; (8001514 <__early_init+0xf4>)
 80014e2:	6812      	ldr	r2, [r2, #0]
 80014e4:	429a      	cmp	r2, r3
 80014e6:	d1e2      	bne.n	80014ae <__early_init+0x8e>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
 80014e8:	4b08      	ldr	r3, [pc, #32]	; (800150c <__early_init+0xec>)
 80014ea:	f240 1205 	movw	r2, #261	; 0x105
 80014ee:	601a      	str	r2, [r3, #0]
 80014f0:	e7e1      	b.n	80014b6 <__early_init+0x96>
 80014f2:	bf00      	nop
 80014f4:	40023800 	.word	0x40023800
 80014f8:	40007000 	.word	0x40007000
 80014fc:	07405408 	.word	0x07405408
 8001500:	e0042000 	.word	0xe0042000
 8001504:	38889400 	.word	0x38889400
 8001508:	20006411 	.word	0x20006411
 800150c:	40023c00 	.word	0x40023c00
 8001510:	e000ed00 	.word	0xe000ed00
 8001514:	410fc241 	.word	0x410fc241
	...

08001520 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8001520:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8001524:	f002 0a03 	and.w	sl, r2, #3
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8001528:	f3c2 0880 	ubfx	r8, r2, #2, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 800152c:	f3c2 0cc1 	ubfx	ip, r2, #3, #2
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 8001530:	f3c2 1e41 	ubfx	lr, r2, #5, #2
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8001534:	46d1      	mov	r9, sl
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 8001536:	f3c2 12c3 	ubfx	r2, r2, #7, #4
  uint32_t bit     = 0;
 800153a:	2700      	movs	r7, #0
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 800153c:	f04f 0b0f 	mov.w	fp, #15
 8001540:	e00f      	b.n	8001562 <_pal_lld_setgroupmode+0x42>
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8001542:	6a04      	ldr	r4, [r0, #32]
 8001544:	ea24 0303 	bic.w	r3, r4, r3
 8001548:	431d      	orrs	r5, r3
 800154a:	6205      	str	r5, [r0, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
    if (!mask)
 800154c:	0849      	lsrs	r1, r1, #1
 800154e:	d039      	beq.n	80015c4 <_pal_lld_setgroupmode+0xa4>
      return;
    otyper <<= 1;
 8001550:	ea4f 0848 	mov.w	r8, r8, lsl #1
    ospeedr <<= 2;
 8001554:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
    pupdr <<= 2;
 8001558:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
    moder <<= 2;
 800155c:	ea4f 0989 	mov.w	r9, r9, lsl #2
    bit++;
 8001560:	3701      	adds	r7, #1
    if ((mask & 1) != 0) {
 8001562:	07cb      	lsls	r3, r1, #31
 8001564:	d5f2      	bpl.n	800154c <_pal_lld_setgroupmode+0x2c>
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8001566:	6843      	ldr	r3, [r0, #4]
 8001568:	2401      	movs	r4, #1
 800156a:	40bc      	lsls	r4, r7
 800156c:	ea23 0304 	bic.w	r3, r3, r4
 8001570:	ea43 0308 	orr.w	r3, r3, r8
 8001574:	6043      	str	r3, [r0, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8001576:	2503      	movs	r5, #3
 8001578:	007c      	lsls	r4, r7, #1
 800157a:	6883      	ldr	r3, [r0, #8]
 800157c:	fa05 f404 	lsl.w	r4, r5, r4
 8001580:	43e4      	mvns	r4, r4
 8001582:	4023      	ands	r3, r4
 8001584:	ea43 030c 	orr.w	r3, r3, ip
 8001588:	6083      	str	r3, [r0, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 800158a:	68c5      	ldr	r5, [r0, #12]
      altrmask = altr << ((bit & 7) * 4);
 800158c:	f007 0307 	and.w	r3, r7, #7
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8001590:	4025      	ands	r5, r4
 8001592:	ea45 050e 	orr.w	r5, r5, lr
      altrmask = altr << ((bit & 7) * 4);
 8001596:	009b      	lsls	r3, r3, #2
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 8001598:	f1ba 0f02 	cmp.w	sl, #2
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 800159c:	60c5      	str	r5, [r0, #12]
      altrmask = altr << ((bit & 7) * 4);
 800159e:	fa02 f503 	lsl.w	r5, r2, r3
      m4 = 15 << ((bit & 7) * 4);
 80015a2:	fa0b f303 	lsl.w	r3, fp, r3
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 80015a6:	d00f      	beq.n	80015c8 <_pal_lld_setgroupmode+0xa8>
        port->MODER   = (port->MODER & ~m2) | moder;
 80015a8:	6806      	ldr	r6, [r0, #0]
 80015aa:	4034      	ands	r4, r6
 80015ac:	ea44 0409 	orr.w	r4, r4, r9
        if (bit < 8)
 80015b0:	2f07      	cmp	r7, #7
        port->MODER   = (port->MODER & ~m2) | moder;
 80015b2:	6004      	str	r4, [r0, #0]
        if (bit < 8)
 80015b4:	d9c5      	bls.n	8001542 <_pal_lld_setgroupmode+0x22>
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80015b6:	6a44      	ldr	r4, [r0, #36]	; 0x24
 80015b8:	ea24 0303 	bic.w	r3, r4, r3
 80015bc:	431d      	orrs	r5, r3
    if (!mask)
 80015be:	0849      	lsrs	r1, r1, #1
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80015c0:	6245      	str	r5, [r0, #36]	; 0x24
    if (!mask)
 80015c2:	d1c5      	bne.n	8001550 <_pal_lld_setgroupmode+0x30>
 80015c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (bit < 8)
 80015c8:	2f07      	cmp	r7, #7
 80015ca:	d80a      	bhi.n	80015e2 <_pal_lld_setgroupmode+0xc2>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 80015cc:	6a06      	ldr	r6, [r0, #32]
 80015ce:	ea26 0303 	bic.w	r3, r6, r3
 80015d2:	431d      	orrs	r5, r3
 80015d4:	6205      	str	r5, [r0, #32]
        port->MODER   = (port->MODER & ~m2) | moder;
 80015d6:	6803      	ldr	r3, [r0, #0]
 80015d8:	401c      	ands	r4, r3
 80015da:	ea44 0409 	orr.w	r4, r4, r9
 80015de:	6004      	str	r4, [r0, #0]
 80015e0:	e7b4      	b.n	800154c <_pal_lld_setgroupmode+0x2c>
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80015e2:	6a46      	ldr	r6, [r0, #36]	; 0x24
 80015e4:	ea26 0303 	bic.w	r3, r6, r3
 80015e8:	431d      	orrs	r5, r3
 80015ea:	6245      	str	r5, [r0, #36]	; 0x24
 80015ec:	e7f3      	b.n	80015d6 <_pal_lld_setgroupmode+0xb6>
 80015ee:	bf00      	nop

080015f0 <chTMStopMeasurementX>:
 80015f0:	4b0f      	ldr	r3, [pc, #60]	; (8001630 <chTMStopMeasurementX+0x40>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 80015f2:	4910      	ldr	r1, [pc, #64]	; (8001634 <chTMStopMeasurementX+0x44>)
 80015f4:	685a      	ldr	r2, [r3, #4]
  tmp->last = (now - tmp->last) - offset;
 80015f6:	6883      	ldr	r3, [r0, #8]
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 80015f8:	b4f0      	push	{r4, r5, r6, r7}
  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 80015fa:	f8d1 7884 	ldr.w	r7, [r1, #2180]	; 0x884
  if (tmp->last > tmp->worst) {
 80015fe:	6841      	ldr	r1, [r0, #4]
  tmp->n++;
 8001600:	68c6      	ldr	r6, [r0, #12]
  tmp->cumulative += (rttime_t)tmp->last;
 8001602:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
  tmp->last = (now - tmp->last) - offset;
 8001606:	1ad3      	subs	r3, r2, r3
 8001608:	1bdb      	subs	r3, r3, r7
  tmp->cumulative += (rttime_t)tmp->last;
 800160a:	18e4      	adds	r4, r4, r3
  if (tmp->last < tmp->best) {
 800160c:	6802      	ldr	r2, [r0, #0]
  tmp->last = (now - tmp->last) - offset;
 800160e:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8001610:	f145 0500 	adc.w	r5, r5, #0
  if (tmp->last > tmp->worst) {
 8001614:	428b      	cmp	r3, r1
  tmp->n++;
 8001616:	f106 0601 	add.w	r6, r6, #1
    tmp->worst = tmp->last;
 800161a:	bf88      	it	hi
 800161c:	6043      	strhi	r3, [r0, #4]
  if (tmp->last < tmp->best) {
 800161e:	4293      	cmp	r3, r2
  tmp->n++;
 8001620:	60c6      	str	r6, [r0, #12]
  tmp->cumulative += (rttime_t)tmp->last;
 8001622:	e9c0 4504 	strd	r4, r5, [r0, #16]
    tmp->best = tmp->last;
 8001626:	bf38      	it	cc
 8001628:	6003      	strcc	r3, [r0, #0]
}
 800162a:	bcf0      	pop	{r4, r5, r6, r7}
 800162c:	4770      	bx	lr
 800162e:	bf00      	nop
 8001630:	e0001000 	.word	0xe0001000
 8001634:	20000878 	.word	0x20000878
	...

08001640 <_trace_switch.part.0>:
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8001640:	4909      	ldr	r1, [pc, #36]	; (8001668 <_trace_switch.part.0+0x28>)
 8001642:	6bca      	ldr	r2, [r1, #60]	; 0x3c
 8001644:	7813      	ldrb	r3, [r2, #0]
void _trace_switch(thread_t *ntp, thread_t *otp) {
 8001646:	b410      	push	{r4}
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8001648:	2401      	movs	r4, #1
 800164a:	f364 0302 	bfi	r3, r4, #0, #3
 800164e:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8001650:	f890 4020 	ldrb.w	r4, [r0, #32]
 8001654:	f364 03c7 	bfi	r3, r4, #3, #5
 8001658:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 800165a:	698b      	ldr	r3, [r1, #24]
 800165c:	6093      	str	r3, [r2, #8]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 800165e:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001660:	60d3      	str	r3, [r2, #12]
}
 8001662:	bc10      	pop	{r4}
    trace_next();
 8001664:	f7ff be6c 	b.w	8001340 <trace_next>
 8001668:	20000878 	.word	0x20000878
 800166c:	00000000 	.word	0x00000000

08001670 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 8001670:	b508      	push	{r3, lr}
 8001672:	4605      	mov	r5, r0
  __ASM volatile ("cpsid i" : : : "memory");
 8001674:	b672      	cpsid	i
 *
 * @notapi
 */
void _trace_halt(const char *reason) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
 8001676:	4c0a      	ldr	r4, [pc, #40]	; (80016a0 <chSysHalt+0x30>)
 8001678:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 800167a:	f003 0304 	and.w	r3, r3, #4
 800167e:	b29b      	uxth	r3, r3
 8001680:	b10b      	cbz	r3, 8001686 <chSysHalt+0x16>

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8001682:	62e5      	str	r5, [r4, #44]	; 0x2c
 8001684:	e7fe      	b.n	8001684 <chSysHalt+0x14>
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 8001686:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8001688:	780a      	ldrb	r2, [r1, #0]
    ch.dbg.trace_buffer.ptr->state         = 0;
    ch.dbg.trace_buffer.ptr->u.halt.reason = reason;
 800168a:	6088      	str	r0, [r1, #8]
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 800168c:	2004      	movs	r0, #4
 800168e:	f360 0202 	bfi	r2, r0, #0, #3
    ch.dbg.trace_buffer.ptr->state         = 0;
 8001692:	f363 02c7 	bfi	r2, r3, #3, #5
 8001696:	700a      	strb	r2, [r1, #0]
    trace_next();
 8001698:	f7ff fe52 	bl	8001340 <trace_next>
 800169c:	e7f1      	b.n	8001682 <chSysHalt+0x12>
 800169e:	bf00      	nop
 80016a0:	20000878 	.word	0x20000878
	...

080016b0 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 80016b0:	b508      	push	{r3, lr}
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 80016b2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80016b6:	68da      	ldr	r2, [r3, #12]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 80016b8:	0792      	lsls	r2, r2, #30
 80016ba:	d501      	bpl.n	80016c0 <stSetAlarm+0x10>
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80016bc:	6358      	str	r0, [r3, #52]	; 0x34
 80016be:	bd08      	pop	{r3, pc}
 80016c0:	4801      	ldr	r0, [pc, #4]	; (80016c8 <stSetAlarm+0x18>)
 80016c2:	f7ff ffd5 	bl	8001670 <chSysHalt>
 80016c6:	bf00      	nop
 80016c8:	080027dc 	.word	0x080027dc
 80016cc:	00000000 	.word	0x00000000

080016d0 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 80016d0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80016d2:	4b05      	ldr	r3, [pc, #20]	; (80016e8 <chDbgCheckClassS+0x18>)
 80016d4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80016d6:	b91a      	cbnz	r2, 80016e0 <chDbgCheckClassS+0x10>
 80016d8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80016da:	2b00      	cmp	r3, #0
 80016dc:	dd00      	ble.n	80016e0 <chDbgCheckClassS+0x10>
 80016de:	bd08      	pop	{r3, pc}
    chSysHalt("SV#11");
 80016e0:	4802      	ldr	r0, [pc, #8]	; (80016ec <chDbgCheckClassS+0x1c>)
 80016e2:	f7ff ffc5 	bl	8001670 <chSysHalt>
 80016e6:	bf00      	nop
 80016e8:	20000878 	.word	0x20000878
 80016ec:	0800286c 	.word	0x0800286c

080016f0 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
 80016f0:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
 80016f2:	4c12      	ldr	r4, [pc, #72]	; (800173c <chSchGoSleepS+0x4c>)
 80016f4:	69a5      	ldr	r5, [r4, #24]
void chSchGoSleepS(tstate_t newstate) {
 80016f6:	4606      	mov	r6, r0
  chDbgCheckClassS();
 80016f8:	f7ff ffea 	bl	80016d0 <chDbgCheckClassS>
  thread_t *tp = tqp->next;
 80016fc:	6823      	ldr	r3, [r4, #0]
  otp->state = newstate;
 80016fe:	f885 6020 	strb.w	r6, [r5, #32]
  tqp->next             = tp->queue.next;
 8001702:	681a      	ldr	r2, [r3, #0]
 8001704:	6022      	str	r2, [r4, #0]
  currp->state = CH_STATE_CURRENT;
 8001706:	2101      	movs	r1, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 8001708:	6054      	str	r4, [r2, #4]
 800170a:	f883 1020 	strb.w	r1, [r3, #32]
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 800170e:	8f22      	ldrh	r2, [r4, #56]	; 0x38
  currp = queue_fifo_remove(&ch.rlist.queue);
 8001710:	61a3      	str	r3, [r4, #24]
 8001712:	07d3      	lsls	r3, r2, #31
 8001714:	d402      	bmi.n	800171c <chSchGoSleepS+0x2c>
 8001716:	4628      	mov	r0, r5
 8001718:	f7ff ff92 	bl	8001640 <_trace_switch.part.0>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 800171c:	f3ef 8309 	mrs	r3, PSP
  chSysSwitch(currp, otp);
 8001720:	69ea      	ldr	r2, [r5, #28]
 8001722:	3b24      	subs	r3, #36	; 0x24
 8001724:	429a      	cmp	r2, r3
 8001726:	d805      	bhi.n	8001734 <chSchGoSleepS+0x44>
 8001728:	4629      	mov	r1, r5
 800172a:	69a0      	ldr	r0, [r4, #24]
}
 800172c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  chSysSwitch(currp, otp);
 8001730:	f7fe bdc0 	b.w	80002b4 <_port_switch>
 8001734:	4802      	ldr	r0, [pc, #8]	; (8001740 <chSchGoSleepS+0x50>)
 8001736:	f7ff ff9b 	bl	8001670 <chSysHalt>
 800173a:	bf00      	nop
 800173c:	20000878 	.word	0x20000878
 8001740:	080025d8 	.word	0x080025d8
	...

08001750 <chDbgCheckClassI>:
void chDbgCheckClassI(void) {
 8001750:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8001752:	4b05      	ldr	r3, [pc, #20]	; (8001768 <chDbgCheckClassI+0x18>)
 8001754:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001756:	2a00      	cmp	r2, #0
 8001758:	db03      	blt.n	8001762 <chDbgCheckClassI+0x12>
 800175a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800175c:	2b00      	cmp	r3, #0
 800175e:	dd00      	ble.n	8001762 <chDbgCheckClassI+0x12>
 8001760:	bd08      	pop	{r3, pc}
    chSysHalt("SV#10");
 8001762:	4802      	ldr	r0, [pc, #8]	; (800176c <chDbgCheckClassI+0x1c>)
 8001764:	f7ff ff84 	bl	8001670 <chSysHalt>
 8001768:	20000878 	.word	0x20000878
 800176c:	08002874 	.word	0x08002874

08001770 <chCoreAllocAlignedWithOffsetI>:
 *
 * @iclass
 */
void *chCoreAllocAlignedWithOffsetI(size_t size,
                                    unsigned align,
                                    size_t offset) {
 8001770:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001772:	460c      	mov	r4, r1
 8001774:	4606      	mov	r6, r0
 8001776:	4615      	mov	r5, r2
  uint8_t *p, *next;

  chDbgCheckClassI();
 8001778:	f7ff ffea 	bl	8001750 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 800177c:	b1b4      	cbz	r4, 80017ac <chCoreAllocAlignedWithOffsetI+0x3c>
 800177e:	1e60      	subs	r0, r4, #1
 8001780:	ea10 0704 	ands.w	r7, r0, r4
 8001784:	d112      	bne.n	80017ac <chCoreAllocAlignedWithOffsetI+0x3c>

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8001786:	4a0c      	ldr	r2, [pc, #48]	; (80017b8 <chCoreAllocAlignedWithOffsetI+0x48>)
  next = p + size;

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 8001788:	e892 000a 	ldmia.w	r2, {r1, r3}
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 800178c:	440d      	add	r5, r1
 800178e:	4425      	add	r5, r4
  size = MEM_ALIGN_NEXT(size, align);
 8001790:	3e01      	subs	r6, #1
 8001792:	4426      	add	r6, r4
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8001794:	3d01      	subs	r5, #1
  size = MEM_ALIGN_NEXT(size, align);
 8001796:	4264      	negs	r4, r4
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8001798:	ea05 0004 	and.w	r0, r5, r4
  next = p + size;
 800179c:	4034      	ands	r4, r6
 800179e:	4404      	add	r4, r0
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 80017a0:	429c      	cmp	r4, r3
 80017a2:	d806      	bhi.n	80017b2 <chCoreAllocAlignedWithOffsetI+0x42>
 80017a4:	42a1      	cmp	r1, r4
 80017a6:	d804      	bhi.n	80017b2 <chCoreAllocAlignedWithOffsetI+0x42>
    return NULL;
  }

  ch_memcore.nextmem = next;
 80017a8:	6014      	str	r4, [r2, #0]
 80017aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 80017ac:	4803      	ldr	r0, [pc, #12]	; (80017bc <chCoreAllocAlignedWithOffsetI+0x4c>)
 80017ae:	f7ff ff5f 	bl	8001670 <chSysHalt>
    return NULL;
 80017b2:	4638      	mov	r0, r7

  return p;
}
 80017b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80017b6:	bf00      	nop
 80017b8:	20000870 	.word	0x20000870
 80017bc:	08002708 	.word	0x08002708

080017c0 <chCoreAllocAlignedI.lto_priv.53>:
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
 80017c0:	2200      	movs	r2, #0
 80017c2:	f7ff bfd5 	b.w	8001770 <chCoreAllocAlignedWithOffsetI>
 80017c6:	bf00      	nop
	...

080017d0 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 80017d0:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
 80017d2:	4d1c      	ldr	r5, [pc, #112]	; (8001844 <chSchDoReschedule+0x74>)
  thread_t *tp = tqp->next;
 80017d4:	682b      	ldr	r3, [r5, #0]
 80017d6:	69ae      	ldr	r6, [r5, #24]
  tqp->next             = tp->queue.next;
 80017d8:	681c      	ldr	r4, [r3, #0]
 80017da:	602c      	str	r4, [r5, #0]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 80017dc:	2201      	movs	r2, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 80017de:	6065      	str	r5, [r4, #4]
 80017e0:	f883 2020 	strb.w	r2, [r3, #32]
  currp = queue_fifo_remove(&ch.rlist.queue);
 80017e4:	61ab      	str	r3, [r5, #24]
  chDbgCheckClassI();
 80017e6:	f7ff ffb3 	bl	8001750 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 80017ea:	b326      	cbz	r6, 8001836 <chSchDoReschedule+0x66>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 80017ec:	f896 3020 	ldrb.w	r3, [r6, #32]
 80017f0:	b30b      	cbz	r3, 8001836 <chSchDoReschedule+0x66>
 80017f2:	2b0f      	cmp	r3, #15
 80017f4:	d01f      	beq.n	8001836 <chSchDoReschedule+0x66>
  tp->state = CH_STATE_READY;
 80017f6:	2300      	movs	r3, #0
 80017f8:	68b2      	ldr	r2, [r6, #8]
 80017fa:	f886 3020 	strb.w	r3, [r6, #32]
 80017fe:	e000      	b.n	8001802 <chSchDoReschedule+0x32>
 8001800:	6824      	ldr	r4, [r4, #0]
  } while (cp->prio > tp->prio);
 8001802:	68a3      	ldr	r3, [r4, #8]
 8001804:	4293      	cmp	r3, r2
 8001806:	d8fb      	bhi.n	8001800 <chSchDoReschedule+0x30>
  tp->queue.prev             = cp->queue.prev;
 8001808:	6863      	ldr	r3, [r4, #4]
 800180a:	8f2a      	ldrh	r2, [r5, #56]	; 0x38
 800180c:	6073      	str	r3, [r6, #4]
  tp->queue.next             = cp;
 800180e:	6034      	str	r4, [r6, #0]
  tp->queue.prev->queue.next = tp;
 8001810:	601e      	str	r6, [r3, #0]
 8001812:	07d3      	lsls	r3, r2, #31
  cp->queue.prev             = tp;
 8001814:	6066      	str	r6, [r4, #4]
 8001816:	d402      	bmi.n	800181e <chSchDoReschedule+0x4e>
 8001818:	4630      	mov	r0, r6
 800181a:	f7ff ff11 	bl	8001640 <_trace_switch.part.0>
 800181e:	f3ef 8309 	mrs	r3, PSP

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8001822:	69f2      	ldr	r2, [r6, #28]
 8001824:	3b24      	subs	r3, #36	; 0x24
 8001826:	429a      	cmp	r2, r3
 8001828:	d808      	bhi.n	800183c <chSchDoReschedule+0x6c>
 800182a:	4631      	mov	r1, r6
 800182c:	69a8      	ldr	r0, [r5, #24]
}
 800182e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  chSysSwitch(currp, otp);
 8001832:	f7fe bd3f 	b.w	80002b4 <_port_switch>
  chDbgCheck(tp != NULL);
 8001836:	4804      	ldr	r0, [pc, #16]	; (8001848 <chSchDoReschedule+0x78>)
 8001838:	f7ff ff1a 	bl	8001670 <chSysHalt>
  chSysSwitch(currp, otp);
 800183c:	4803      	ldr	r0, [pc, #12]	; (800184c <chSchDoReschedule+0x7c>)
 800183e:	f7ff ff17 	bl	8001670 <chSysHalt>
 8001842:	bf00      	nop
 8001844:	20000878 	.word	0x20000878
 8001848:	080026f4 	.word	0x080026f4
 800184c:	080025d8 	.word	0x080025d8

08001850 <chSchReadyI>:
thread_t *chSchReadyI(thread_t *tp) {
 8001850:	b510      	push	{r4, lr}
 8001852:	4604      	mov	r4, r0
  chDbgCheckClassI();
 8001854:	f7ff ff7c 	bl	8001750 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8001858:	b1a4      	cbz	r4, 8001884 <chSchReadyI+0x34>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 800185a:	f894 3020 	ldrb.w	r3, [r4, #32]
 800185e:	b18b      	cbz	r3, 8001884 <chSchReadyI+0x34>
 8001860:	2b0f      	cmp	r3, #15
 8001862:	d00f      	beq.n	8001884 <chSchReadyI+0x34>
  tp->state = CH_STATE_READY;
 8001864:	2200      	movs	r2, #0
 8001866:	68a1      	ldr	r1, [r4, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8001868:	4b08      	ldr	r3, [pc, #32]	; (800188c <chSchReadyI+0x3c>)
  tp->state = CH_STATE_READY;
 800186a:	f884 2020 	strb.w	r2, [r4, #32]
    cp = cp->queue.next;
 800186e:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8001870:	689a      	ldr	r2, [r3, #8]
 8001872:	428a      	cmp	r2, r1
 8001874:	d2fb      	bcs.n	800186e <chSchReadyI+0x1e>
  tp->queue.prev             = cp->queue.prev;
 8001876:	685a      	ldr	r2, [r3, #4]
 8001878:	6062      	str	r2, [r4, #4]
  tp->queue.next             = cp;
 800187a:	6023      	str	r3, [r4, #0]
}
 800187c:	4620      	mov	r0, r4
  tp->queue.prev->queue.next = tp;
 800187e:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8001880:	605c      	str	r4, [r3, #4]
}
 8001882:	bd10      	pop	{r4, pc}
  chDbgCheck(tp != NULL);
 8001884:	4802      	ldr	r0, [pc, #8]	; (8001890 <chSchReadyI+0x40>)
 8001886:	f7ff fef3 	bl	8001670 <chSysHalt>
 800188a:	bf00      	nop
 800188c:	20000878 	.word	0x20000878
 8001890:	080026e8 	.word	0x080026e8
	...

080018a0 <_dbg_check_leave_isr>:
void _dbg_check_leave_isr(void) {
 80018a0:	b508      	push	{r3, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80018a2:	2320      	movs	r3, #32
 80018a4:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80018a8:	4a06      	ldr	r2, [pc, #24]	; (80018c4 <_dbg_check_leave_isr+0x24>)
 80018aa:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80018ac:	2b00      	cmp	r3, #0
 80018ae:	dd01      	ble.n	80018b4 <_dbg_check_leave_isr+0x14>
 80018b0:	6b51      	ldr	r1, [r2, #52]	; 0x34
 80018b2:	b111      	cbz	r1, 80018ba <_dbg_check_leave_isr+0x1a>
    chSysHalt("SV#9");
 80018b4:	4804      	ldr	r0, [pc, #16]	; (80018c8 <_dbg_check_leave_isr+0x28>)
 80018b6:	f7ff fedb 	bl	8001670 <chSysHalt>
  ch.dbg.isr_cnt--;
 80018ba:	3b01      	subs	r3, #1
 80018bc:	6313      	str	r3, [r2, #48]	; 0x30
 80018be:	f381 8811 	msr	BASEPRI, r1
 80018c2:	bd08      	pop	{r3, pc}
 80018c4:	20000878 	.word	0x20000878
 80018c8:	0800287c 	.word	0x0800287c
 80018cc:	00000000 	.word	0x00000000

080018d0 <_dbg_check_enter_isr>:
void _dbg_check_enter_isr(void) {
 80018d0:	b508      	push	{r3, lr}
 80018d2:	2320      	movs	r3, #32
 80018d4:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80018d8:	4a06      	ldr	r2, [pc, #24]	; (80018f4 <_dbg_check_enter_isr+0x24>)
 80018da:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80018dc:	2b00      	cmp	r3, #0
 80018de:	db01      	blt.n	80018e4 <_dbg_check_enter_isr+0x14>
 80018e0:	6b51      	ldr	r1, [r2, #52]	; 0x34
 80018e2:	b111      	cbz	r1, 80018ea <_dbg_check_enter_isr+0x1a>
    chSysHalt("SV#8");
 80018e4:	4804      	ldr	r0, [pc, #16]	; (80018f8 <_dbg_check_enter_isr+0x28>)
 80018e6:	f7ff fec3 	bl	8001670 <chSysHalt>
  ch.dbg.isr_cnt++;
 80018ea:	3301      	adds	r3, #1
 80018ec:	6313      	str	r3, [r2, #48]	; 0x30
 80018ee:	f381 8811 	msr	BASEPRI, r1
 80018f2:	bd08      	pop	{r3, pc}
 80018f4:	20000878 	.word	0x20000878
 80018f8:	08002884 	.word	0x08002884
 80018fc:	00000000 	.word	0x00000000

08001900 <VectorAC>:
OSAL_IRQ_HANDLER(STM32_TIM1_CC_HANDLER) {
 8001900:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8001902:	4c08      	ldr	r4, [pc, #32]	; (8001924 <VectorAC+0x24>)
 8001904:	4620      	mov	r0, r4
 8001906:	f7ff fd5b 	bl	80013c0 <_trace_isr_enter>
 800190a:	f7ff ffe1 	bl	80018d0 <_dbg_check_enter_isr>
  pwm_lld_serve_interrupt(&PWMD1);
 800190e:	f000 fda7 	bl	8002460 <pwm_lld_serve_interrupt.constprop.0>
  OSAL_IRQ_EPILOGUE();
 8001912:	f7ff ffc5 	bl	80018a0 <_dbg_check_leave_isr>
 8001916:	4620      	mov	r0, r4
 8001918:	f7ff fd32 	bl	8001380 <_trace_isr_leave>
}
 800191c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8001920:	f7ff bcce 	b.w	80012c0 <_port_irq_epilogue>
 8001924:	08002734 	.word	0x08002734
	...

08001930 <VectorA4>:
OSAL_IRQ_HANDLER(STM32_TIM1_UP_HANDLER) {
 8001930:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8001932:	4c08      	ldr	r4, [pc, #32]	; (8001954 <VectorA4+0x24>)
 8001934:	4620      	mov	r0, r4
 8001936:	f7ff fd43 	bl	80013c0 <_trace_isr_enter>
 800193a:	f7ff ffc9 	bl	80018d0 <_dbg_check_enter_isr>
  pwm_lld_serve_interrupt(&PWMD1);
 800193e:	f000 fd8f 	bl	8002460 <pwm_lld_serve_interrupt.constprop.0>
  OSAL_IRQ_EPILOGUE();
 8001942:	f7ff ffad 	bl	80018a0 <_dbg_check_leave_isr>
 8001946:	4620      	mov	r0, r4
 8001948:	f7ff fd1a 	bl	8001380 <_trace_isr_leave>
}
 800194c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8001950:	f7ff bcb6 	b.w	80012c0 <_port_irq_epilogue>
 8001954:	080026c4 	.word	0x080026c4
	...

08001960 <VectorB4>:
OSAL_IRQ_HANDLER(STM32_TIM3_HANDLER) {
 8001960:	b538      	push	{r3, r4, r5, lr}
 * @notapi
 */
void icu_lld_serve_interrupt(ICUDriver *icup) {
  uint32_t sr;

  sr  = icup->tim->SR;
 8001962:	4d2a      	ldr	r5, [pc, #168]	; (8001a0c <VectorB4+0xac>)
  OSAL_IRQ_PROLOGUE();
 8001964:	482a      	ldr	r0, [pc, #168]	; (8001a10 <VectorB4+0xb0>)
 8001966:	f7ff fd2b 	bl	80013c0 <_trace_isr_enter>
 800196a:	f7ff ffb1 	bl	80018d0 <_dbg_check_enter_isr>
  sr  = icup->tim->SR;
 800196e:	68eb      	ldr	r3, [r5, #12]
  sr &= icup->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  icup->tim->SR = ~sr;
  if (icup->config->channel == ICU_CHANNEL_1) {
 8001970:	6869      	ldr	r1, [r5, #4]
  sr  = icup->tim->SR;
 8001972:	691c      	ldr	r4, [r3, #16]
  sr &= icup->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 8001974:	68da      	ldr	r2, [r3, #12]
  if (icup->config->channel == ICU_CHANNEL_1) {
 8001976:	7d08      	ldrb	r0, [r1, #20]
 8001978:	4014      	ands	r4, r2
  icup->tim->SR = ~sr;
 800197a:	b2e2      	uxtb	r2, r4
 800197c:	43d2      	mvns	r2, r2
 800197e:	611a      	str	r2, [r3, #16]
  if (icup->config->channel == ICU_CHANNEL_1) {
 8001980:	b9b8      	cbnz	r0, 80019b2 <VectorB4+0x52>
    if ((sr & STM32_TIM_SR_CC2IF) != 0)
 8001982:	0760      	lsls	r0, r4, #29
 8001984:	d534      	bpl.n	80019f0 <VectorB4+0x90>
      _icu_isr_invoke_width_cb(icup);
 8001986:	782b      	ldrb	r3, [r5, #0]
 8001988:	2b04      	cmp	r3, #4
 800198a:	d02d      	beq.n	80019e8 <VectorB4+0x88>
    if ((sr & STM32_TIM_SR_CC1IF) != 0)
 800198c:	07a1      	lsls	r1, r4, #30
 800198e:	d417      	bmi.n	80019c0 <VectorB4+0x60>
    if ((sr & STM32_TIM_SR_CC1IF) != 0)
      _icu_isr_invoke_width_cb(icup);
    if ((sr & STM32_TIM_SR_CC2IF) != 0)
      _icu_isr_invoke_period_cb(icup);
  }
  if ((sr & STM32_TIM_SR_UIF) != 0)
 8001990:	07e4      	lsls	r4, r4, #31
 8001992:	d505      	bpl.n	80019a0 <VectorB4+0x40>
    _icu_isr_invoke_overflow_cb(icup);
 8001994:	686b      	ldr	r3, [r5, #4]
 8001996:	481d      	ldr	r0, [pc, #116]	; (8001a0c <VectorB4+0xac>)
 8001998:	691b      	ldr	r3, [r3, #16]
 800199a:	4798      	blx	r3
 800199c:	2303      	movs	r3, #3
 800199e:	702b      	strb	r3, [r5, #0]
  OSAL_IRQ_EPILOGUE();
 80019a0:	f7ff ff7e 	bl	80018a0 <_dbg_check_leave_isr>
 80019a4:	481a      	ldr	r0, [pc, #104]	; (8001a10 <VectorB4+0xb0>)
 80019a6:	f7ff fceb 	bl	8001380 <_trace_isr_leave>
}
 80019aa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80019ae:	f7ff bc87 	b.w	80012c0 <_port_irq_epilogue>
    if ((sr & STM32_TIM_SR_CC1IF) != 0)
 80019b2:	07a2      	lsls	r2, r4, #30
 80019b4:	d50b      	bpl.n	80019ce <VectorB4+0x6e>
      _icu_isr_invoke_width_cb(icup);
 80019b6:	782b      	ldrb	r3, [r5, #0]
 80019b8:	2b04      	cmp	r3, #4
 80019ba:	d004      	beq.n	80019c6 <VectorB4+0x66>
    if ((sr & STM32_TIM_SR_CC2IF) != 0)
 80019bc:	0763      	lsls	r3, r4, #29
 80019be:	d5e7      	bpl.n	8001990 <VectorB4+0x30>
      _icu_isr_invoke_period_cb(icup);
 80019c0:	2304      	movs	r3, #4
 80019c2:	702b      	strb	r3, [r5, #0]
 80019c4:	e7e4      	b.n	8001990 <VectorB4+0x30>
      _icu_isr_invoke_width_cb(icup);
 80019c6:	688b      	ldr	r3, [r1, #8]
 80019c8:	b1e3      	cbz	r3, 8001a04 <VectorB4+0xa4>
 80019ca:	4628      	mov	r0, r5
 80019cc:	4798      	blx	r3
    if ((sr & STM32_TIM_SR_CC2IF) != 0)
 80019ce:	0763      	lsls	r3, r4, #29
 80019d0:	d5de      	bpl.n	8001990 <VectorB4+0x30>
      _icu_isr_invoke_period_cb(icup);
 80019d2:	782b      	ldrb	r3, [r5, #0]
 80019d4:	4a0d      	ldr	r2, [pc, #52]	; (8001a0c <VectorB4+0xac>)
 80019d6:	2b04      	cmp	r3, #4
 80019d8:	d1f2      	bne.n	80019c0 <VectorB4+0x60>
 80019da:	6851      	ldr	r1, [r2, #4]
 80019dc:	68cb      	ldr	r3, [r1, #12]
 80019de:	2b00      	cmp	r3, #0
 80019e0:	d0ee      	beq.n	80019c0 <VectorB4+0x60>
 80019e2:	480a      	ldr	r0, [pc, #40]	; (8001a0c <VectorB4+0xac>)
 80019e4:	4798      	blx	r3
 80019e6:	e7eb      	b.n	80019c0 <VectorB4+0x60>
      _icu_isr_invoke_width_cb(icup);
 80019e8:	688b      	ldr	r3, [r1, #8]
 80019ea:	b143      	cbz	r3, 80019fe <VectorB4+0x9e>
 80019ec:	4628      	mov	r0, r5
 80019ee:	4798      	blx	r3
    if ((sr & STM32_TIM_SR_CC1IF) != 0)
 80019f0:	07a1      	lsls	r1, r4, #30
 80019f2:	d5cd      	bpl.n	8001990 <VectorB4+0x30>
      _icu_isr_invoke_period_cb(icup);
 80019f4:	782b      	ldrb	r3, [r5, #0]
 80019f6:	4a05      	ldr	r2, [pc, #20]	; (8001a0c <VectorB4+0xac>)
 80019f8:	2b04      	cmp	r3, #4
 80019fa:	d1e1      	bne.n	80019c0 <VectorB4+0x60>
 80019fc:	e7ed      	b.n	80019da <VectorB4+0x7a>
    if ((sr & STM32_TIM_SR_CC1IF) != 0)
 80019fe:	07a0      	lsls	r0, r4, #30
 8001a00:	d4ec      	bmi.n	80019dc <VectorB4+0x7c>
 8001a02:	e7c5      	b.n	8001990 <VectorB4+0x30>
    if ((sr & STM32_TIM_SR_CC2IF) != 0)
 8001a04:	0762      	lsls	r2, r4, #29
 8001a06:	d4e9      	bmi.n	80019dc <VectorB4+0x7c>
 8001a08:	e7c2      	b.n	8001990 <VectorB4+0x30>
 8001a0a:	bf00      	nop
 8001a0c:	20001200 	.word	0x20001200
 8001a10:	080026dc 	.word	0x080026dc
	...

08001a20 <_dbg_check_unlock_from_isr>:
void _dbg_check_unlock_from_isr(void) {
 8001a20:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8001a22:	4b06      	ldr	r3, [pc, #24]	; (8001a3c <_dbg_check_unlock_from_isr+0x1c>)
 8001a24:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001a26:	2a00      	cmp	r2, #0
 8001a28:	dd05      	ble.n	8001a36 <_dbg_check_unlock_from_isr+0x16>
 8001a2a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001a2c:	2a00      	cmp	r2, #0
 8001a2e:	dd02      	ble.n	8001a36 <_dbg_check_unlock_from_isr+0x16>
  _dbg_leave_lock();
 8001a30:	2200      	movs	r2, #0
 8001a32:	635a      	str	r2, [r3, #52]	; 0x34
 8001a34:	bd08      	pop	{r3, pc}
    chSysHalt("SV#7");
 8001a36:	4802      	ldr	r0, [pc, #8]	; (8001a40 <_dbg_check_unlock_from_isr+0x20>)
 8001a38:	f7ff fe1a 	bl	8001670 <chSysHalt>
 8001a3c:	20000878 	.word	0x20000878
 8001a40:	0800288c 	.word	0x0800288c
	...

08001a50 <_dbg_check_lock_from_isr>:
void _dbg_check_lock_from_isr(void) {
 8001a50:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8001a52:	4b06      	ldr	r3, [pc, #24]	; (8001a6c <_dbg_check_lock_from_isr+0x1c>)
 8001a54:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001a56:	2a00      	cmp	r2, #0
 8001a58:	dd01      	ble.n	8001a5e <_dbg_check_lock_from_isr+0xe>
 8001a5a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001a5c:	b112      	cbz	r2, 8001a64 <_dbg_check_lock_from_isr+0x14>
    chSysHalt("SV#6");
 8001a5e:	4804      	ldr	r0, [pc, #16]	; (8001a70 <_dbg_check_lock_from_isr+0x20>)
 8001a60:	f7ff fe06 	bl	8001670 <chSysHalt>
  _dbg_enter_lock();
 8001a64:	2201      	movs	r2, #1
 8001a66:	635a      	str	r2, [r3, #52]	; 0x34
 8001a68:	bd08      	pop	{r3, pc}
 8001a6a:	bf00      	nop
 8001a6c:	20000878 	.word	0x20000878
 8001a70:	08002894 	.word	0x08002894
	...

08001a80 <VectorB0>:
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8001a80:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8001a84:	f04f 4880 	mov.w	r8, #1073741824	; 0x40000000
  OSAL_IRQ_PROLOGUE();
 8001a88:	4838      	ldr	r0, [pc, #224]	; (8001b6c <VectorB0+0xec>)
 8001a8a:	f7ff fc99 	bl	80013c0 <_trace_isr_enter>
 8001a8e:	f7ff ff1f 	bl	80018d0 <_dbg_check_enter_isr>
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8001a92:	f8d8 3010 	ldr.w	r3, [r8, #16]
 8001a96:	079b      	lsls	r3, r3, #30
 8001a98:	d408      	bmi.n	8001aac <VectorB0+0x2c>
  OSAL_IRQ_EPILOGUE();
 8001a9a:	f7ff ff01 	bl	80018a0 <_dbg_check_leave_isr>
 8001a9e:	4833      	ldr	r0, [pc, #204]	; (8001b6c <VectorB0+0xec>)
 8001aa0:	f7ff fc6e 	bl	8001380 <_trace_isr_leave>
}
 8001aa4:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  OSAL_IRQ_EPILOGUE();
 8001aa8:	f7ff bc0a 	b.w	80012c0 <_port_irq_epilogue>
    STM32_ST_TIM->SR = 0U;
 8001aac:	2300      	movs	r3, #0
 8001aae:	f8c8 3010 	str.w	r3, [r8, #16]
 8001ab2:	2320      	movs	r3, #32
 8001ab4:	f383 8811 	msr	BASEPRI, r3
  virtual_timer_t *vtp;
  systime_t now;
  sysinterval_t delta, nowdelta;

  /* Looping through timers.*/
  vtp = ch.vtlist.next;
 8001ab8:	f8df 90b4 	ldr.w	r9, [pc, #180]	; 8001b70 <VectorB0+0xf0>
 8001abc:	46ca      	mov	sl, r9
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8001abe:	f7ff ffc7 	bl	8001a50 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {

  chDbgCheckClassI();
 8001ac2:	f7ff fe45 	bl	8001750 <chDbgCheckClassI>
  chDbgCheckClassI();
 8001ac6:	f7ff fe43 	bl	8001750 <chDbgCheckClassI>
  vtp = ch.vtlist.next;
 8001aca:	f85a 4f1c 	ldr.w	r4, [sl, #28]!
 8001ace:	68a3      	ldr	r3, [r4, #8]
  while (true) {

    /* Getting the system time as reference.*/
    now = chVTGetSystemTimeX();
    nowdelta = chTimeDiffX(ch.vtlist.lasttime, now);
 8001ad0:	464f      	mov	r7, r9
  return (systime_t)STM32_ST_TIM->CNT;
 8001ad2:	f8d8 1024 	ldr.w	r1, [r8, #36]	; 0x24
 8001ad6:	f8d9 2028 	ldr.w	r2, [r9, #40]	; 0x28
 8001ada:	4825      	ldr	r0, [pc, #148]	; (8001b70 <VectorB0+0xf0>)
 *
 * @xclass
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  return (sysinterval_t)((systime_t)(end - start));
 8001adc:	1a8d      	subs	r5, r1, r2

    /* The list scan is limited by the timers header having
       "ch.vtlist.vt_delta == (sysinterval_t)-1" which is
       greater than all deltas.*/
    if (nowdelta < vtp->delta) {
 8001ade:	429d      	cmp	r5, r3
 8001ae0:	d322      	bcc.n	8001b28 <VectorB0+0xa8>
      nowdelta -= vtp->delta;

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
      ch.vtlist.next = vtp->next;
      fn = vtp->func;
      vtp->func = NULL;
 8001ae2:	2600      	movs	r6, #0
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8001ae4:	6821      	ldr	r1, [r4, #0]
      fn = vtp->func;
 8001ae6:	f8d4 b00c 	ldr.w	fp, [r4, #12]
      ch.vtlist.lasttime += vtp->delta;
 8001aea:	441a      	add	r2, r3

      /* if the list becomes empty then the timer is stopped.*/
      if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8001aec:	4551      	cmp	r1, sl
      ch.vtlist.lasttime += vtp->delta;
 8001aee:	f8c9 2028 	str.w	r2, [r9, #40]	; 0x28
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8001af2:	f8c1 a004 	str.w	sl, [r1, #4]
      ch.vtlist.next = vtp->next;
 8001af6:	f8c9 101c 	str.w	r1, [r9, #28]
      vtp->func = NULL;
 8001afa:	60e6      	str	r6, [r4, #12]
  STM32_ST_TIM->DIER = 0;
 8001afc:	bf08      	it	eq
 8001afe:	f8c8 600c 	streq.w	r6, [r8, #12]
      nowdelta -= vtp->delta;
 8001b02:	1aed      	subs	r5, r5, r3
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8001b04:	f7ff ff8c 	bl	8001a20 <_dbg_check_unlock_from_isr>
 8001b08:	f386 8811 	msr	BASEPRI, r6
        port_timer_stop_alarm();
      }

      /* The callback is invoked outside the kernel critical zone.*/
      chSysUnlockFromISR();
      fn(vtp->par);
 8001b0c:	6920      	ldr	r0, [r4, #16]
 8001b0e:	47d8      	blx	fp
 8001b10:	2320      	movs	r3, #32
 8001b12:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8001b16:	f7ff ff9b 	bl	8001a50 <_dbg_check_lock_from_isr>
      chSysLockFromISR();

      /* Next element in the list.*/
      vtp = ch.vtlist.next;
 8001b1a:	f8d9 401c 	ldr.w	r4, [r9, #28]
    }
    while (vtp->delta <= nowdelta);
 8001b1e:	68a3      	ldr	r3, [r4, #8]
 8001b20:	429d      	cmp	r5, r3
 8001b22:	d3d6      	bcc.n	8001ad2 <VectorB0+0x52>
 8001b24:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8001b26:	e7dd      	b.n	8001ae4 <VectorB0+0x64>
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8001b28:	69c3      	ldr	r3, [r0, #28]
 8001b2a:	4553      	cmp	r3, sl
 8001b2c:	d014      	beq.n	8001b58 <VectorB0+0xd8>
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  ch.vtlist.lasttime += nowdelta;
  ch.vtlist.next->delta -= nowdelta;
 8001b2e:	689a      	ldr	r2, [r3, #8]
  ch.vtlist.lasttime += nowdelta;
 8001b30:	6281      	str	r1, [r0, #40]	; 0x28
  ch.vtlist.next->delta -= nowdelta;
 8001b32:	1b55      	subs	r5, r2, r5
 8001b34:	609d      	str	r5, [r3, #8]

  /* Recalculating the next alarm time.*/
  delta = chTimeDiffX(now, chTimeAddX(ch.vtlist.lasttime, vtp->delta));
 8001b36:	68a3      	ldr	r3, [r4, #8]
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
    delta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8001b38:	2b01      	cmp	r3, #1
 8001b3a:	bf98      	it	ls
 8001b3c:	2302      	movls	r3, #2
  return systime + (systime_t)interval;
 8001b3e:	18cc      	adds	r4, r1, r3
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 8001b40:	4620      	mov	r0, r4
 8001b42:	f7ff fdb5 	bl	80016b0 <stSetAlarm>
  return (systime_t)STM32_ST_TIM->CNT;
 8001b46:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    delta = (sysinterval_t)TIME_MAX_SYSTIME;
  }
#endif
  port_timer_set_alarm(chTimeAddX(now, delta));

  chDbgAssert(chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX()) <=
 8001b4a:	f8d9 1028 	ldr.w	r1, [r9, #40]	; 0x28
 8001b4e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001b50:	1a63      	subs	r3, r4, r1
 8001b52:	1a52      	subs	r2, r2, r1
 8001b54:	429a      	cmp	r2, r3
 8001b56:	d805      	bhi.n	8001b64 <VectorB0+0xe4>
  _dbg_check_unlock_from_isr();
 8001b58:	f7ff ff62 	bl	8001a20 <_dbg_check_unlock_from_isr>
 8001b5c:	2300      	movs	r3, #0
 8001b5e:	f383 8811 	msr	BASEPRI, r3
 8001b62:	e79a      	b.n	8001a9a <VectorB0+0x1a>
 8001b64:	4803      	ldr	r0, [pc, #12]	; (8001b74 <VectorB0+0xf4>)
 8001b66:	f7ff fd83 	bl	8001670 <chSysHalt>
 8001b6a:	bf00      	nop
 8001b6c:	08002800 	.word	0x08002800
 8001b70:	20000878 	.word	0x20000878
 8001b74:	0800283c 	.word	0x0800283c
	...

08001b80 <VectorE0>:
/**
 * @brief   EXTI[10]...EXTI[15] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(VectorE0) {
 8001b80:	b510      	push	{r4, lr}
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();
 8001b82:	484c      	ldr	r0, [pc, #304]	; (8001cb4 <VectorE0+0x134>)
 8001b84:	f7ff fc1c 	bl	80013c0 <_trace_isr_enter>
 8001b88:	f7ff fea2 	bl	80018d0 <_dbg_check_enter_isr>

  pr = EXTI->PR;
 8001b8c:	4b4a      	ldr	r3, [pc, #296]	; (8001cb8 <VectorE0+0x138>)
 8001b8e:	695c      	ldr	r4, [r3, #20]
  pr &= EXTI->IMR & ((1U << 10) | (1U << 11) | (1U << 12) | (1U << 13) |
 8001b90:	681a      	ldr	r2, [r3, #0]
 8001b92:	4014      	ands	r4, r2
 8001b94:	f404 427c 	and.w	r2, r4, #64512	; 0xfc00
                     (1U << 14) | (1U << 15));
  EXTI->PR = pr;
 8001b98:	615a      	str	r2, [r3, #20]

  exti_serve_irq(pr, 10);
 8001b9a:	0562      	lsls	r2, r4, #21
 8001b9c:	d513      	bpl.n	8001bc6 <VectorE0+0x46>
 8001b9e:	4a47      	ldr	r2, [pc, #284]	; (8001cbc <VectorE0+0x13c>)
 8001ba0:	f8d2 30a8 	ldr.w	r3, [r2, #168]	; 0xa8
 8001ba4:	b113      	cbz	r3, 8001bac <VectorE0+0x2c>
 8001ba6:	f8d2 00ac 	ldr.w	r0, [r2, #172]	; 0xac
 8001baa:	4798      	blx	r3
 8001bac:	2320      	movs	r3, #32
 8001bae:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8001bb2:	f7ff ff4d 	bl	8001a50 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 8001bb6:	4842      	ldr	r0, [pc, #264]	; (8001cc0 <VectorE0+0x140>)
 8001bb8:	f000 fc2a 	bl	8002410 <chThdDequeueAllI.constprop.28>
  _dbg_check_unlock_from_isr();
 8001bbc:	f7ff ff30 	bl	8001a20 <_dbg_check_unlock_from_isr>
 8001bc0:	2300      	movs	r3, #0
 8001bc2:	f383 8811 	msr	BASEPRI, r3
  exti_serve_irq(pr, 11);
 8001bc6:	0523      	lsls	r3, r4, #20
 8001bc8:	d513      	bpl.n	8001bf2 <VectorE0+0x72>
 8001bca:	4a3c      	ldr	r2, [pc, #240]	; (8001cbc <VectorE0+0x13c>)
 8001bcc:	f8d2 30b8 	ldr.w	r3, [r2, #184]	; 0xb8
 8001bd0:	b113      	cbz	r3, 8001bd8 <VectorE0+0x58>
 8001bd2:	f8d2 00bc 	ldr.w	r0, [r2, #188]	; 0xbc
 8001bd6:	4798      	blx	r3
 8001bd8:	2320      	movs	r3, #32
 8001bda:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8001bde:	f7ff ff37 	bl	8001a50 <_dbg_check_lock_from_isr>
 8001be2:	4838      	ldr	r0, [pc, #224]	; (8001cc4 <VectorE0+0x144>)
 8001be4:	f000 fc14 	bl	8002410 <chThdDequeueAllI.constprop.28>
  _dbg_check_unlock_from_isr();
 8001be8:	f7ff ff1a 	bl	8001a20 <_dbg_check_unlock_from_isr>
 8001bec:	2300      	movs	r3, #0
 8001bee:	f383 8811 	msr	BASEPRI, r3
  exti_serve_irq(pr, 12);
 8001bf2:	04e0      	lsls	r0, r4, #19
 8001bf4:	d513      	bpl.n	8001c1e <VectorE0+0x9e>
 8001bf6:	4a31      	ldr	r2, [pc, #196]	; (8001cbc <VectorE0+0x13c>)
 8001bf8:	f8d2 30c8 	ldr.w	r3, [r2, #200]	; 0xc8
 8001bfc:	b113      	cbz	r3, 8001c04 <VectorE0+0x84>
 8001bfe:	f8d2 00cc 	ldr.w	r0, [r2, #204]	; 0xcc
 8001c02:	4798      	blx	r3
 8001c04:	2320      	movs	r3, #32
 8001c06:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8001c0a:	f7ff ff21 	bl	8001a50 <_dbg_check_lock_from_isr>
 8001c0e:	482e      	ldr	r0, [pc, #184]	; (8001cc8 <VectorE0+0x148>)
 8001c10:	f000 fbfe 	bl	8002410 <chThdDequeueAllI.constprop.28>
  _dbg_check_unlock_from_isr();
 8001c14:	f7ff ff04 	bl	8001a20 <_dbg_check_unlock_from_isr>
 8001c18:	2300      	movs	r3, #0
 8001c1a:	f383 8811 	msr	BASEPRI, r3
  exti_serve_irq(pr, 13);
 8001c1e:	04a1      	lsls	r1, r4, #18
 8001c20:	d513      	bpl.n	8001c4a <VectorE0+0xca>
 8001c22:	4a26      	ldr	r2, [pc, #152]	; (8001cbc <VectorE0+0x13c>)
 8001c24:	f8d2 30d8 	ldr.w	r3, [r2, #216]	; 0xd8
 8001c28:	b113      	cbz	r3, 8001c30 <VectorE0+0xb0>
 8001c2a:	f8d2 00dc 	ldr.w	r0, [r2, #220]	; 0xdc
 8001c2e:	4798      	blx	r3
 8001c30:	2320      	movs	r3, #32
 8001c32:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8001c36:	f7ff ff0b 	bl	8001a50 <_dbg_check_lock_from_isr>
 8001c3a:	4824      	ldr	r0, [pc, #144]	; (8001ccc <VectorE0+0x14c>)
 8001c3c:	f000 fbe8 	bl	8002410 <chThdDequeueAllI.constprop.28>
  _dbg_check_unlock_from_isr();
 8001c40:	f7ff feee 	bl	8001a20 <_dbg_check_unlock_from_isr>
 8001c44:	2300      	movs	r3, #0
 8001c46:	f383 8811 	msr	BASEPRI, r3
  exti_serve_irq(pr, 14);
 8001c4a:	0462      	lsls	r2, r4, #17
 8001c4c:	d513      	bpl.n	8001c76 <VectorE0+0xf6>
 8001c4e:	4a1b      	ldr	r2, [pc, #108]	; (8001cbc <VectorE0+0x13c>)
 8001c50:	f8d2 30e8 	ldr.w	r3, [r2, #232]	; 0xe8
 8001c54:	b113      	cbz	r3, 8001c5c <VectorE0+0xdc>
 8001c56:	f8d2 00ec 	ldr.w	r0, [r2, #236]	; 0xec
 8001c5a:	4798      	blx	r3
 8001c5c:	2320      	movs	r3, #32
 8001c5e:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8001c62:	f7ff fef5 	bl	8001a50 <_dbg_check_lock_from_isr>
 8001c66:	481a      	ldr	r0, [pc, #104]	; (8001cd0 <VectorE0+0x150>)
 8001c68:	f000 fbd2 	bl	8002410 <chThdDequeueAllI.constprop.28>
  _dbg_check_unlock_from_isr();
 8001c6c:	f7ff fed8 	bl	8001a20 <_dbg_check_unlock_from_isr>
 8001c70:	2300      	movs	r3, #0
 8001c72:	f383 8811 	msr	BASEPRI, r3
  exti_serve_irq(pr, 15);
 8001c76:	0423      	lsls	r3, r4, #16
 8001c78:	d513      	bpl.n	8001ca2 <VectorE0+0x122>
 8001c7a:	4a10      	ldr	r2, [pc, #64]	; (8001cbc <VectorE0+0x13c>)
 8001c7c:	f8d2 30f8 	ldr.w	r3, [r2, #248]	; 0xf8
 8001c80:	b113      	cbz	r3, 8001c88 <VectorE0+0x108>
 8001c82:	f8d2 00fc 	ldr.w	r0, [r2, #252]	; 0xfc
 8001c86:	4798      	blx	r3
 8001c88:	2320      	movs	r3, #32
 8001c8a:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8001c8e:	f7ff fedf 	bl	8001a50 <_dbg_check_lock_from_isr>
 8001c92:	4810      	ldr	r0, [pc, #64]	; (8001cd4 <VectorE0+0x154>)
 8001c94:	f000 fbbc 	bl	8002410 <chThdDequeueAllI.constprop.28>
  _dbg_check_unlock_from_isr();
 8001c98:	f7ff fec2 	bl	8001a20 <_dbg_check_unlock_from_isr>
 8001c9c:	2300      	movs	r3, #0
 8001c9e:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
 8001ca2:	f7ff fdfd 	bl	80018a0 <_dbg_check_leave_isr>
 8001ca6:	4803      	ldr	r0, [pc, #12]	; (8001cb4 <VectorE0+0x134>)
 8001ca8:	f7ff fb6a 	bl	8001380 <_trace_isr_leave>
}
 8001cac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8001cb0:	f7ff bb06 	b.w	80012c0 <_port_irq_epilogue>
 8001cb4:	08002830 	.word	0x08002830
 8001cb8:	40013c00 	.word	0x40013c00
 8001cbc:	20001100 	.word	0x20001100
 8001cc0:	200011a0 	.word	0x200011a0
 8001cc4:	200011b0 	.word	0x200011b0
 8001cc8:	200011c0 	.word	0x200011c0
 8001ccc:	200011d0 	.word	0x200011d0
 8001cd0:	200011e0 	.word	0x200011e0
 8001cd4:	200011f0 	.word	0x200011f0
	...

08001ce0 <Vector9C>:
OSAL_IRQ_HANDLER(Vector9C) {
 8001ce0:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8001ce2:	483e      	ldr	r0, [pc, #248]	; (8001ddc <Vector9C+0xfc>)
 8001ce4:	f7ff fb6c 	bl	80013c0 <_trace_isr_enter>
 8001ce8:	f7ff fdf2 	bl	80018d0 <_dbg_check_enter_isr>
  pr = EXTI->PR;
 8001cec:	4b3c      	ldr	r3, [pc, #240]	; (8001de0 <Vector9C+0x100>)
 8001cee:	695c      	ldr	r4, [r3, #20]
  pr &= EXTI->IMR & ((1U << 5) | (1U << 6) | (1U << 7) | (1U << 8) |
 8001cf0:	681a      	ldr	r2, [r3, #0]
 8001cf2:	4014      	ands	r4, r2
 8001cf4:	f404 7278 	and.w	r2, r4, #992	; 0x3e0
  EXTI->PR = pr;
 8001cf8:	615a      	str	r2, [r3, #20]
  exti_serve_irq(pr, 5);
 8001cfa:	06a3      	lsls	r3, r4, #26
 8001cfc:	d511      	bpl.n	8001d22 <Vector9C+0x42>
 8001cfe:	4a39      	ldr	r2, [pc, #228]	; (8001de4 <Vector9C+0x104>)
 8001d00:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8001d02:	b10b      	cbz	r3, 8001d08 <Vector9C+0x28>
 8001d04:	6dd0      	ldr	r0, [r2, #92]	; 0x5c
 8001d06:	4798      	blx	r3
 8001d08:	2320      	movs	r3, #32
 8001d0a:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8001d0e:	f7ff fe9f 	bl	8001a50 <_dbg_check_lock_from_isr>
 8001d12:	4835      	ldr	r0, [pc, #212]	; (8001de8 <Vector9C+0x108>)
 8001d14:	f000 fb7c 	bl	8002410 <chThdDequeueAllI.constprop.28>
  _dbg_check_unlock_from_isr();
 8001d18:	f7ff fe82 	bl	8001a20 <_dbg_check_unlock_from_isr>
 8001d1c:	2300      	movs	r3, #0
 8001d1e:	f383 8811 	msr	BASEPRI, r3
  exti_serve_irq(pr, 6);
 8001d22:	0660      	lsls	r0, r4, #25
 8001d24:	d511      	bpl.n	8001d4a <Vector9C+0x6a>
 8001d26:	4a2f      	ldr	r2, [pc, #188]	; (8001de4 <Vector9C+0x104>)
 8001d28:	6e93      	ldr	r3, [r2, #104]	; 0x68
 8001d2a:	b10b      	cbz	r3, 8001d30 <Vector9C+0x50>
 8001d2c:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 8001d2e:	4798      	blx	r3
 8001d30:	2320      	movs	r3, #32
 8001d32:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8001d36:	f7ff fe8b 	bl	8001a50 <_dbg_check_lock_from_isr>
 8001d3a:	482c      	ldr	r0, [pc, #176]	; (8001dec <Vector9C+0x10c>)
 8001d3c:	f000 fb68 	bl	8002410 <chThdDequeueAllI.constprop.28>
  _dbg_check_unlock_from_isr();
 8001d40:	f7ff fe6e 	bl	8001a20 <_dbg_check_unlock_from_isr>
 8001d44:	2300      	movs	r3, #0
 8001d46:	f383 8811 	msr	BASEPRI, r3
  exti_serve_irq(pr, 7);
 8001d4a:	0621      	lsls	r1, r4, #24
 8001d4c:	d511      	bpl.n	8001d72 <Vector9C+0x92>
 8001d4e:	4a25      	ldr	r2, [pc, #148]	; (8001de4 <Vector9C+0x104>)
 8001d50:	6f93      	ldr	r3, [r2, #120]	; 0x78
 8001d52:	b10b      	cbz	r3, 8001d58 <Vector9C+0x78>
 8001d54:	6fd0      	ldr	r0, [r2, #124]	; 0x7c
 8001d56:	4798      	blx	r3
 8001d58:	2320      	movs	r3, #32
 8001d5a:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8001d5e:	f7ff fe77 	bl	8001a50 <_dbg_check_lock_from_isr>
 8001d62:	4823      	ldr	r0, [pc, #140]	; (8001df0 <Vector9C+0x110>)
 8001d64:	f000 fb54 	bl	8002410 <chThdDequeueAllI.constprop.28>
  _dbg_check_unlock_from_isr();
 8001d68:	f7ff fe5a 	bl	8001a20 <_dbg_check_unlock_from_isr>
 8001d6c:	2300      	movs	r3, #0
 8001d6e:	f383 8811 	msr	BASEPRI, r3
  exti_serve_irq(pr, 8);
 8001d72:	05e2      	lsls	r2, r4, #23
 8001d74:	d513      	bpl.n	8001d9e <Vector9C+0xbe>
 8001d76:	4a1b      	ldr	r2, [pc, #108]	; (8001de4 <Vector9C+0x104>)
 8001d78:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8001d7c:	b113      	cbz	r3, 8001d84 <Vector9C+0xa4>
 8001d7e:	f8d2 008c 	ldr.w	r0, [r2, #140]	; 0x8c
 8001d82:	4798      	blx	r3
 8001d84:	2320      	movs	r3, #32
 8001d86:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8001d8a:	f7ff fe61 	bl	8001a50 <_dbg_check_lock_from_isr>
 8001d8e:	4819      	ldr	r0, [pc, #100]	; (8001df4 <Vector9C+0x114>)
 8001d90:	f000 fb3e 	bl	8002410 <chThdDequeueAllI.constprop.28>
  _dbg_check_unlock_from_isr();
 8001d94:	f7ff fe44 	bl	8001a20 <_dbg_check_unlock_from_isr>
 8001d98:	2300      	movs	r3, #0
 8001d9a:	f383 8811 	msr	BASEPRI, r3
  exti_serve_irq(pr, 9);
 8001d9e:	05a3      	lsls	r3, r4, #22
 8001da0:	d513      	bpl.n	8001dca <Vector9C+0xea>
 8001da2:	4a10      	ldr	r2, [pc, #64]	; (8001de4 <Vector9C+0x104>)
 8001da4:	f8d2 3098 	ldr.w	r3, [r2, #152]	; 0x98
 8001da8:	b113      	cbz	r3, 8001db0 <Vector9C+0xd0>
 8001daa:	f8d2 009c 	ldr.w	r0, [r2, #156]	; 0x9c
 8001dae:	4798      	blx	r3
 8001db0:	2320      	movs	r3, #32
 8001db2:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8001db6:	f7ff fe4b 	bl	8001a50 <_dbg_check_lock_from_isr>
 8001dba:	480f      	ldr	r0, [pc, #60]	; (8001df8 <Vector9C+0x118>)
 8001dbc:	f000 fb28 	bl	8002410 <chThdDequeueAllI.constprop.28>
  _dbg_check_unlock_from_isr();
 8001dc0:	f7ff fe2e 	bl	8001a20 <_dbg_check_unlock_from_isr>
 8001dc4:	2300      	movs	r3, #0
 8001dc6:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_EPILOGUE();
 8001dca:	f7ff fd69 	bl	80018a0 <_dbg_check_leave_isr>
 8001dce:	4803      	ldr	r0, [pc, #12]	; (8001ddc <Vector9C+0xfc>)
 8001dd0:	f7ff fad6 	bl	8001380 <_trace_isr_leave>
}
 8001dd4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8001dd8:	f7ff ba72 	b.w	80012c0 <_port_irq_epilogue>
 8001ddc:	08002824 	.word	0x08002824
 8001de0:	40013c00 	.word	0x40013c00
 8001de4:	20001100 	.word	0x20001100
 8001de8:	20001150 	.word	0x20001150
 8001dec:	20001160 	.word	0x20001160
 8001df0:	20001170 	.word	0x20001170
 8001df4:	20001180 	.word	0x20001180
 8001df8:	20001190 	.word	0x20001190
 8001dfc:	00000000 	.word	0x00000000

08001e00 <Vector68>:
OSAL_IRQ_HANDLER(Vector68) {
 8001e00:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
 8001e02:	4814      	ldr	r0, [pc, #80]	; (8001e54 <Vector68+0x54>)
 8001e04:	f7ff fadc 	bl	80013c0 <_trace_isr_enter>
 8001e08:	f7ff fd62 	bl	80018d0 <_dbg_check_enter_isr>
  pr = EXTI->PR;
 8001e0c:	4a12      	ldr	r2, [pc, #72]	; (8001e58 <Vector68+0x58>)
 8001e0e:	6951      	ldr	r1, [r2, #20]
  pr &= EXTI->IMR & (1U << 4);
 8001e10:	6813      	ldr	r3, [r2, #0]
 8001e12:	400b      	ands	r3, r1
 8001e14:	f003 0310 	and.w	r3, r3, #16
  EXTI->PR = pr;
 8001e18:	6153      	str	r3, [r2, #20]
  exti_serve_irq(pr, 4);
 8001e1a:	b18b      	cbz	r3, 8001e40 <Vector68+0x40>
 8001e1c:	4a0f      	ldr	r2, [pc, #60]	; (8001e5c <Vector68+0x5c>)
 8001e1e:	6c93      	ldr	r3, [r2, #72]	; 0x48
 8001e20:	b10b      	cbz	r3, 8001e26 <Vector68+0x26>
 8001e22:	6cd0      	ldr	r0, [r2, #76]	; 0x4c
 8001e24:	4798      	blx	r3
 8001e26:	2320      	movs	r3, #32
 8001e28:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8001e2c:	f7ff fe10 	bl	8001a50 <_dbg_check_lock_from_isr>
 8001e30:	480b      	ldr	r0, [pc, #44]	; (8001e60 <Vector68+0x60>)
 8001e32:	f000 faed 	bl	8002410 <chThdDequeueAllI.constprop.28>
  _dbg_check_unlock_from_isr();
 8001e36:	f7ff fdf3 	bl	8001a20 <_dbg_check_unlock_from_isr>
 8001e3a:	2300      	movs	r3, #0
 8001e3c:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_EPILOGUE();
 8001e40:	f7ff fd2e 	bl	80018a0 <_dbg_check_leave_isr>
 8001e44:	4803      	ldr	r0, [pc, #12]	; (8001e54 <Vector68+0x54>)
 8001e46:	f7ff fa9b 	bl	8001380 <_trace_isr_leave>
}
 8001e4a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8001e4e:	f7ff ba37 	b.w	80012c0 <_port_irq_epilogue>
 8001e52:	bf00      	nop
 8001e54:	08002818 	.word	0x08002818
 8001e58:	40013c00 	.word	0x40013c00
 8001e5c:	20001100 	.word	0x20001100
 8001e60:	20001140 	.word	0x20001140
	...

08001e70 <Vector64>:
OSAL_IRQ_HANDLER(Vector64) {
 8001e70:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
 8001e72:	4814      	ldr	r0, [pc, #80]	; (8001ec4 <Vector64+0x54>)
 8001e74:	f7ff faa4 	bl	80013c0 <_trace_isr_enter>
 8001e78:	f7ff fd2a 	bl	80018d0 <_dbg_check_enter_isr>
  pr = EXTI->PR;
 8001e7c:	4a12      	ldr	r2, [pc, #72]	; (8001ec8 <Vector64+0x58>)
 8001e7e:	6951      	ldr	r1, [r2, #20]
  pr &= EXTI->IMR & (1U << 3);
 8001e80:	6813      	ldr	r3, [r2, #0]
 8001e82:	400b      	ands	r3, r1
 8001e84:	f003 0308 	and.w	r3, r3, #8
  EXTI->PR = pr;
 8001e88:	6153      	str	r3, [r2, #20]
  exti_serve_irq(pr, 3);
 8001e8a:	b18b      	cbz	r3, 8001eb0 <Vector64+0x40>
 8001e8c:	4a0f      	ldr	r2, [pc, #60]	; (8001ecc <Vector64+0x5c>)
 8001e8e:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8001e90:	b10b      	cbz	r3, 8001e96 <Vector64+0x26>
 8001e92:	6bd0      	ldr	r0, [r2, #60]	; 0x3c
 8001e94:	4798      	blx	r3
 8001e96:	2320      	movs	r3, #32
 8001e98:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8001e9c:	f7ff fdd8 	bl	8001a50 <_dbg_check_lock_from_isr>
 8001ea0:	480b      	ldr	r0, [pc, #44]	; (8001ed0 <Vector64+0x60>)
 8001ea2:	f000 fab5 	bl	8002410 <chThdDequeueAllI.constprop.28>
  _dbg_check_unlock_from_isr();
 8001ea6:	f7ff fdbb 	bl	8001a20 <_dbg_check_unlock_from_isr>
 8001eaa:	2300      	movs	r3, #0
 8001eac:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_EPILOGUE();
 8001eb0:	f7ff fcf6 	bl	80018a0 <_dbg_check_leave_isr>
 8001eb4:	4803      	ldr	r0, [pc, #12]	; (8001ec4 <Vector64+0x54>)
 8001eb6:	f7ff fa63 	bl	8001380 <_trace_isr_leave>
}
 8001eba:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8001ebe:	f7ff b9ff 	b.w	80012c0 <_port_irq_epilogue>
 8001ec2:	bf00      	nop
 8001ec4:	080027f4 	.word	0x080027f4
 8001ec8:	40013c00 	.word	0x40013c00
 8001ecc:	20001100 	.word	0x20001100
 8001ed0:	20001130 	.word	0x20001130
	...

08001ee0 <Vector60>:
OSAL_IRQ_HANDLER(Vector60) {
 8001ee0:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
 8001ee2:	4814      	ldr	r0, [pc, #80]	; (8001f34 <Vector60+0x54>)
 8001ee4:	f7ff fa6c 	bl	80013c0 <_trace_isr_enter>
 8001ee8:	f7ff fcf2 	bl	80018d0 <_dbg_check_enter_isr>
  pr = EXTI->PR;
 8001eec:	4a12      	ldr	r2, [pc, #72]	; (8001f38 <Vector60+0x58>)
 8001eee:	6951      	ldr	r1, [r2, #20]
  pr &= EXTI->IMR & (1U << 2);
 8001ef0:	6813      	ldr	r3, [r2, #0]
 8001ef2:	400b      	ands	r3, r1
 8001ef4:	f003 0304 	and.w	r3, r3, #4
  EXTI->PR = pr;
 8001ef8:	6153      	str	r3, [r2, #20]
  exti_serve_irq(pr, 2);
 8001efa:	b18b      	cbz	r3, 8001f20 <Vector60+0x40>
 8001efc:	4a0f      	ldr	r2, [pc, #60]	; (8001f3c <Vector60+0x5c>)
 8001efe:	6a93      	ldr	r3, [r2, #40]	; 0x28
 8001f00:	b10b      	cbz	r3, 8001f06 <Vector60+0x26>
 8001f02:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 8001f04:	4798      	blx	r3
 8001f06:	2320      	movs	r3, #32
 8001f08:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8001f0c:	f7ff fda0 	bl	8001a50 <_dbg_check_lock_from_isr>
 8001f10:	480b      	ldr	r0, [pc, #44]	; (8001f40 <Vector60+0x60>)
 8001f12:	f000 fa7d 	bl	8002410 <chThdDequeueAllI.constprop.28>
  _dbg_check_unlock_from_isr();
 8001f16:	f7ff fd83 	bl	8001a20 <_dbg_check_unlock_from_isr>
 8001f1a:	2300      	movs	r3, #0
 8001f1c:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_EPILOGUE();
 8001f20:	f7ff fcbe 	bl	80018a0 <_dbg_check_leave_isr>
 8001f24:	4803      	ldr	r0, [pc, #12]	; (8001f34 <Vector60+0x54>)
 8001f26:	f7ff fa2b 	bl	8001380 <_trace_isr_leave>
}
 8001f2a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8001f2e:	f7ff b9c7 	b.w	80012c0 <_port_irq_epilogue>
 8001f32:	bf00      	nop
 8001f34:	080027e8 	.word	0x080027e8
 8001f38:	40013c00 	.word	0x40013c00
 8001f3c:	20001100 	.word	0x20001100
 8001f40:	20001120 	.word	0x20001120
	...

08001f50 <Vector5C>:
OSAL_IRQ_HANDLER(Vector5C) {
 8001f50:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
 8001f52:	4814      	ldr	r0, [pc, #80]	; (8001fa4 <Vector5C+0x54>)
 8001f54:	f7ff fa34 	bl	80013c0 <_trace_isr_enter>
 8001f58:	f7ff fcba 	bl	80018d0 <_dbg_check_enter_isr>
  pr = EXTI->PR;
 8001f5c:	4a12      	ldr	r2, [pc, #72]	; (8001fa8 <Vector5C+0x58>)
 8001f5e:	6951      	ldr	r1, [r2, #20]
  pr &= EXTI->IMR & (1U << 1);
 8001f60:	6813      	ldr	r3, [r2, #0]
 8001f62:	400b      	ands	r3, r1
 8001f64:	f003 0302 	and.w	r3, r3, #2
  EXTI->PR = pr;
 8001f68:	6153      	str	r3, [r2, #20]
  exti_serve_irq(pr, 1);
 8001f6a:	b18b      	cbz	r3, 8001f90 <Vector5C+0x40>
 8001f6c:	4a0f      	ldr	r2, [pc, #60]	; (8001fac <Vector5C+0x5c>)
 8001f6e:	6993      	ldr	r3, [r2, #24]
 8001f70:	b10b      	cbz	r3, 8001f76 <Vector5C+0x26>
 8001f72:	69d0      	ldr	r0, [r2, #28]
 8001f74:	4798      	blx	r3
 8001f76:	2320      	movs	r3, #32
 8001f78:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8001f7c:	f7ff fd68 	bl	8001a50 <_dbg_check_lock_from_isr>
 8001f80:	480b      	ldr	r0, [pc, #44]	; (8001fb0 <Vector5C+0x60>)
 8001f82:	f000 fa45 	bl	8002410 <chThdDequeueAllI.constprop.28>
  _dbg_check_unlock_from_isr();
 8001f86:	f7ff fd4b 	bl	8001a20 <_dbg_check_unlock_from_isr>
 8001f8a:	2300      	movs	r3, #0
 8001f8c:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_EPILOGUE();
 8001f90:	f7ff fc86 	bl	80018a0 <_dbg_check_leave_isr>
 8001f94:	4803      	ldr	r0, [pc, #12]	; (8001fa4 <Vector5C+0x54>)
 8001f96:	f7ff f9f3 	bl	8001380 <_trace_isr_leave>
}
 8001f9a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8001f9e:	f7ff b98f 	b.w	80012c0 <_port_irq_epilogue>
 8001fa2:	bf00      	nop
 8001fa4:	08002740 	.word	0x08002740
 8001fa8:	40013c00 	.word	0x40013c00
 8001fac:	20001100 	.word	0x20001100
 8001fb0:	20001110 	.word	0x20001110
	...

08001fc0 <Vector58>:
OSAL_IRQ_HANDLER(Vector58) {
 8001fc0:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
 8001fc2:	4814      	ldr	r0, [pc, #80]	; (8002014 <Vector58+0x54>)
 8001fc4:	f7ff f9fc 	bl	80013c0 <_trace_isr_enter>
 8001fc8:	f7ff fc82 	bl	80018d0 <_dbg_check_enter_isr>
  pr = EXTI->PR;
 8001fcc:	4a12      	ldr	r2, [pc, #72]	; (8002018 <Vector58+0x58>)
 8001fce:	6951      	ldr	r1, [r2, #20]
  pr &= EXTI->IMR & (1U << 0);
 8001fd0:	6813      	ldr	r3, [r2, #0]
 8001fd2:	400b      	ands	r3, r1
 8001fd4:	f003 0301 	and.w	r3, r3, #1
  EXTI->PR = pr;
 8001fd8:	6153      	str	r3, [r2, #20]
  exti_serve_irq(pr, 0);
 8001fda:	b18b      	cbz	r3, 8002000 <Vector58+0x40>
 8001fdc:	4a0f      	ldr	r2, [pc, #60]	; (800201c <Vector58+0x5c>)
 8001fde:	6893      	ldr	r3, [r2, #8]
 8001fe0:	b10b      	cbz	r3, 8001fe6 <Vector58+0x26>
 8001fe2:	68d0      	ldr	r0, [r2, #12]
 8001fe4:	4798      	blx	r3
 8001fe6:	2320      	movs	r3, #32
 8001fe8:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8001fec:	f7ff fd30 	bl	8001a50 <_dbg_check_lock_from_isr>
 8001ff0:	480a      	ldr	r0, [pc, #40]	; (800201c <Vector58+0x5c>)
 8001ff2:	f000 fa0d 	bl	8002410 <chThdDequeueAllI.constprop.28>
  _dbg_check_unlock_from_isr();
 8001ff6:	f7ff fd13 	bl	8001a20 <_dbg_check_unlock_from_isr>
 8001ffa:	2300      	movs	r3, #0
 8001ffc:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_EPILOGUE();
 8002000:	f7ff fc4e 	bl	80018a0 <_dbg_check_leave_isr>
 8002004:	4803      	ldr	r0, [pc, #12]	; (8002014 <Vector58+0x54>)
 8002006:	f7ff f9bb 	bl	8001380 <_trace_isr_leave>
}
 800200a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 800200e:	f7ff b957 	b.w	80012c0 <_port_irq_epilogue>
 8002012:	bf00      	nop
 8002014:	080026d0 	.word	0x080026d0
 8002018:	40013c00 	.word	0x40013c00
 800201c:	20001100 	.word	0x20001100

08002020 <wakeup>:
static void wakeup(void *p) {
 8002020:	b538      	push	{r3, r4, r5, lr}
 8002022:	4604      	mov	r4, r0
 8002024:	2320      	movs	r3, #32
 8002026:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 800202a:	f7ff fd11 	bl	8001a50 <_dbg_check_lock_from_isr>
  switch (tp->state) {
 800202e:	f894 3020 	ldrb.w	r3, [r4, #32]
 8002032:	2b07      	cmp	r3, #7
 8002034:	d810      	bhi.n	8002058 <wakeup+0x38>
 8002036:	e8df f003 	tbb	[pc, r3]
 800203a:	0f15      	.short	0x0f15
 800203c:	040a1b0f 	.word	0x040a1b0f
 8002040:	0a0f      	.short	0x0a0f
    chSemFastSignalI(tp->u.wtsemp);
 8002042:	6a65      	ldr	r5, [r4, #36]	; 0x24
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();
 8002044:	f7ff fb84 	bl	8001750 <chDbgCheckClassI>

  sp->cnt++;
 8002048:	68ab      	ldr	r3, [r5, #8]
 800204a:	3301      	adds	r3, #1
 800204c:	60ab      	str	r3, [r5, #8]
  tp->queue.prev->queue.next = tp->queue.next;
 800204e:	e894 000c 	ldmia.w	r4, {r2, r3}
 8002052:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8002054:	6822      	ldr	r2, [r4, #0]
 8002056:	6053      	str	r3, [r2, #4]
  tp->u.rdymsg = MSG_TIMEOUT;
 8002058:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800205c:	6263      	str	r3, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
 800205e:	4620      	mov	r0, r4
 8002060:	f7ff fbf6 	bl	8001850 <chSchReadyI>
  _dbg_check_unlock_from_isr();
 8002064:	f7ff fcdc 	bl	8001a20 <_dbg_check_unlock_from_isr>
 8002068:	2300      	movs	r3, #0
 800206a:	f383 8811 	msr	BASEPRI, r3
 800206e:	bd38      	pop	{r3, r4, r5, pc}
    *tp->u.wttrp = NULL;
 8002070:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8002072:	2200      	movs	r2, #0
 8002074:	601a      	str	r2, [r3, #0]
  tp->u.rdymsg = MSG_TIMEOUT;
 8002076:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800207a:	6263      	str	r3, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
 800207c:	4620      	mov	r0, r4
 800207e:	f7ff fbe7 	bl	8001850 <chSchReadyI>
 8002082:	e7ef      	b.n	8002064 <wakeup+0x44>
	...

08002090 <_dbg_check_unlock>:
void _dbg_check_unlock(void) {
 8002090:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002092:	4b05      	ldr	r3, [pc, #20]	; (80020a8 <_dbg_check_unlock+0x18>)
 8002094:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002096:	b922      	cbnz	r2, 80020a2 <_dbg_check_unlock+0x12>
 8002098:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800209a:	2900      	cmp	r1, #0
 800209c:	dd01      	ble.n	80020a2 <_dbg_check_unlock+0x12>
  _dbg_leave_lock();
 800209e:	635a      	str	r2, [r3, #52]	; 0x34
 80020a0:	bd08      	pop	{r3, pc}
    chSysHalt("SV#5");
 80020a2:	4802      	ldr	r0, [pc, #8]	; (80020ac <_dbg_check_unlock+0x1c>)
 80020a4:	f7ff fae4 	bl	8001670 <chSysHalt>
 80020a8:	20000878 	.word	0x20000878
 80020ac:	0800289c 	.word	0x0800289c

080020b0 <chSysUnlock.lto_priv.38>:
static inline void chSysUnlock(void) {
 80020b0:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 80020b2:	f7ff ffed 	bl	8002090 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80020b6:	4b08      	ldr	r3, [pc, #32]	; (80020d8 <chSysUnlock.lto_priv.38+0x28>)
 80020b8:	681a      	ldr	r2, [r3, #0]
 80020ba:	429a      	cmp	r2, r3
 80020bc:	d004      	beq.n	80020c8 <chSysUnlock.lto_priv.38+0x18>
 80020be:	6999      	ldr	r1, [r3, #24]
 80020c0:	6893      	ldr	r3, [r2, #8]
 80020c2:	688a      	ldr	r2, [r1, #8]
 80020c4:	429a      	cmp	r2, r3
 80020c6:	d303      	bcc.n	80020d0 <chSysUnlock.lto_priv.38+0x20>
 80020c8:	2300      	movs	r3, #0
 80020ca:	f383 8811 	msr	BASEPRI, r3
 80020ce:	bd08      	pop	{r3, pc}
 80020d0:	4802      	ldr	r0, [pc, #8]	; (80020dc <chSysUnlock.lto_priv.38+0x2c>)
 80020d2:	f7ff facd 	bl	8001670 <chSysHalt>
 80020d6:	bf00      	nop
 80020d8:	20000878 	.word	0x20000878
 80020dc:	08002860 	.word	0x08002860

080020e0 <chSysUnlock.lto_priv.49>:
static inline void chSysUnlock(void) {
 80020e0:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 80020e2:	f7ff ffd5 	bl	8002090 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80020e6:	4b08      	ldr	r3, [pc, #32]	; (8002108 <chSysUnlock.lto_priv.49+0x28>)
 80020e8:	681a      	ldr	r2, [r3, #0]
 80020ea:	429a      	cmp	r2, r3
 80020ec:	d004      	beq.n	80020f8 <chSysUnlock.lto_priv.49+0x18>
 80020ee:	6999      	ldr	r1, [r3, #24]
 80020f0:	6893      	ldr	r3, [r2, #8]
 80020f2:	688a      	ldr	r2, [r1, #8]
 80020f4:	429a      	cmp	r2, r3
 80020f6:	d303      	bcc.n	8002100 <chSysUnlock.lto_priv.49+0x20>
 80020f8:	2300      	movs	r3, #0
 80020fa:	f383 8811 	msr	BASEPRI, r3
 80020fe:	bd08      	pop	{r3, pc}
 8002100:	4802      	ldr	r0, [pc, #8]	; (800210c <chSysUnlock.lto_priv.49+0x2c>)
 8002102:	f7ff fab5 	bl	8001670 <chSysHalt>
 8002106:	bf00      	nop
 8002108:	20000878 	.word	0x20000878
 800210c:	08002854 	.word	0x08002854

08002110 <_dbg_check_lock>:
void _dbg_check_lock(void) {
 8002110:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002112:	4b05      	ldr	r3, [pc, #20]	; (8002128 <_dbg_check_lock+0x18>)
 8002114:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002116:	b90a      	cbnz	r2, 800211c <_dbg_check_lock+0xc>
 8002118:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800211a:	b112      	cbz	r2, 8002122 <_dbg_check_lock+0x12>
    chSysHalt("SV#4");
 800211c:	4803      	ldr	r0, [pc, #12]	; (800212c <_dbg_check_lock+0x1c>)
 800211e:	f7ff faa7 	bl	8001670 <chSysHalt>
  _dbg_enter_lock();
 8002122:	2201      	movs	r2, #1
 8002124:	635a      	str	r2, [r3, #52]	; 0x34
 8002126:	bd08      	pop	{r3, pc}
 8002128:	20000878 	.word	0x20000878
 800212c:	080028a4 	.word	0x080028a4

08002130 <chCoreAllocAlignedWithOffset>:
 *
 * @api
 */
void *chCoreAllocAlignedWithOffset(size_t size,
                                   unsigned align,
                                   size_t offset) {
 8002130:	b570      	push	{r4, r5, r6, lr}
 8002132:	2320      	movs	r3, #32
 8002134:	4604      	mov	r4, r0
 8002136:	460d      	mov	r5, r1
 8002138:	4616      	mov	r6, r2
 800213a:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800213e:	f7ff ffe7 	bl	8002110 <_dbg_check_lock>
  void *p;

  chSysLock();
  p = chCoreAllocAlignedWithOffsetI(size, align, offset);
 8002142:	4632      	mov	r2, r6
 8002144:	4629      	mov	r1, r5
 8002146:	4620      	mov	r0, r4
 8002148:	f7ff fb12 	bl	8001770 <chCoreAllocAlignedWithOffsetI>
 800214c:	4604      	mov	r4, r0
  _dbg_check_unlock();
 800214e:	f7ff ff9f 	bl	8002090 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002152:	4b08      	ldr	r3, [pc, #32]	; (8002174 <chCoreAllocAlignedWithOffset+0x44>)
 8002154:	681a      	ldr	r2, [r3, #0]
 8002156:	429a      	cmp	r2, r3
 8002158:	d004      	beq.n	8002164 <chCoreAllocAlignedWithOffset+0x34>
 800215a:	6999      	ldr	r1, [r3, #24]
 800215c:	6893      	ldr	r3, [r2, #8]
 800215e:	688a      	ldr	r2, [r1, #8]
 8002160:	429a      	cmp	r2, r3
 8002162:	d304      	bcc.n	800216e <chCoreAllocAlignedWithOffset+0x3e>
 8002164:	2300      	movs	r3, #0
 8002166:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return p;
}
 800216a:	4620      	mov	r0, r4
 800216c:	bd70      	pop	{r4, r5, r6, pc}
 800216e:	4802      	ldr	r0, [pc, #8]	; (8002178 <chCoreAllocAlignedWithOffset+0x48>)
 8002170:	f7ff fa7e 	bl	8001670 <chSysHalt>
 8002174:	20000878 	.word	0x20000878
 8002178:	08002848 	.word	0x08002848
 800217c:	00000000 	.word	0x00000000

08002180 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(sysinterval_t time) {
 8002180:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8002184:	2320      	movs	r3, #32
 8002186:	b087      	sub	sp, #28
 8002188:	4605      	mov	r5, r0
 800218a:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800218e:	f7ff ffbf 	bl	8002110 <_dbg_check_lock>
 *
 * @sclass
 */
static inline void chThdSleepS(sysinterval_t ticks) {

  chDbgCheck(ticks != TIME_IMMEDIATE);
 8002192:	2d00      	cmp	r5, #0
 8002194:	d04f      	beq.n	8002236 <chThdSleep+0xb6>
  chDbgCheckClassS();
 8002196:	f7ff fa9b 	bl	80016d0 <chDbgCheckClassS>
  if (TIME_INFINITE != timeout) {
 800219a:	1c6b      	adds	r3, r5, #1
 800219c:	d04e      	beq.n	800223c <chThdSleep+0xbc>
    chVTDoSetI(&vt, timeout, wakeup, currp);
 800219e:	4f52      	ldr	r7, [pc, #328]	; (80022e8 <chThdSleep+0x168>)
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80021a0:	46b8      	mov	r8, r7
  chDbgCheckClassI();
 80021a2:	f7ff fad5 	bl	8001750 <chDbgCheckClassI>
 80021a6:	69bb      	ldr	r3, [r7, #24]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80021a8:	f858 6f1c 	ldr.w	r6, [r8, #28]!
  vtp->par = par;
 80021ac:	9305      	str	r3, [sp, #20]
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 80021ae:	2d01      	cmp	r5, #1
 80021b0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  vtp->func = vtfunc;
 80021b4:	4a4d      	ldr	r2, [pc, #308]	; (80022ec <chThdSleep+0x16c>)
 80021b6:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 80021b8:	9204      	str	r2, [sp, #16]
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 80021ba:	bf08      	it	eq
 80021bc:	2502      	moveq	r5, #2
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80021be:	4546      	cmp	r6, r8
 80021c0:	d076      	beq.n	80022b0 <chThdSleep+0x130>
    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
 80021c2:	6ab8      	ldr	r0, [r7, #40]	; 0x28

    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 80021c4:	68b3      	ldr	r3, [r6, #8]
  return (sysinterval_t)((systime_t)(end - start));
 80021c6:	1a24      	subs	r4, r4, r0
    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 80021c8:	192c      	adds	r4, r5, r4
 80021ca:	d34c      	bcc.n	8002266 <chThdSleep+0xe6>
      p = p->next;
 80021cc:	6836      	ldr	r6, [r6, #0]
      delta -= p->delta;
 80021ce:	1ae4      	subs	r4, r4, r3
 80021d0:	68b3      	ldr	r3, [r6, #8]
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 80021d2:	429c      	cmp	r4, r3
 80021d4:	d904      	bls.n	80021e0 <chThdSleep+0x60>
    delta -= p->delta;
    p = p->next;
 80021d6:	6836      	ldr	r6, [r6, #0]
    delta -= p->delta;
 80021d8:	1ae4      	subs	r4, r4, r3
  while (p->delta < delta) {
 80021da:	68b3      	ldr	r3, [r6, #8]
 80021dc:	42a3      	cmp	r3, r4
 80021de:	d3fa      	bcc.n	80021d6 <chThdSleep+0x56>
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 80021e0:	6873      	ldr	r3, [r6, #4]
 80021e2:	9302      	str	r3, [sp, #8]
  vtp->prev->next = vtp;
 80021e4:	f10d 0904 	add.w	r9, sp, #4
  vtp->next = p;
 80021e8:	9601      	str	r6, [sp, #4]
  vtp->prev->next = vtp;
 80021ea:	f8c3 9000 	str.w	r9, [r3]
  p->prev = vtp;
 80021ee:	f8c6 9004 	str.w	r9, [r6, #4]
  vtp->delta = delta
 80021f2:	9403      	str	r4, [sp, #12]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 80021f4:	68b0      	ldr	r0, [r6, #8]
  ch.vtlist.delta = (sysinterval_t)-1;
 80021f6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  p->delta -= delta;
 80021fa:	1b00      	subs	r0, r0, r4
 80021fc:	60b0      	str	r0, [r6, #8]
  ch.vtlist.delta = (sysinterval_t)-1;
 80021fe:	627b      	str	r3, [r7, #36]	; 0x24
    chSchGoSleepS(newstate);
 8002200:	2008      	movs	r0, #8
 8002202:	f7ff fa75 	bl	80016f0 <chSchGoSleepS>
  chDbgCheckClassI();
 8002206:	f7ff faa3 	bl	8001750 <chDbgCheckClassI>
    if (chVTIsArmedI(&vt)) {
 800220a:	9b04      	ldr	r3, [sp, #16]
 800220c:	b1d3      	cbz	r3, 8002244 <chThdSleep+0xc4>
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
 800220e:	f7ff fa9f 	bl	8001750 <chDbgCheckClassI>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8002212:	69fb      	ldr	r3, [r7, #28]
 8002214:	4a34      	ldr	r2, [pc, #208]	; (80022e8 <chThdSleep+0x168>)
 8002216:	454b      	cmp	r3, r9
 8002218:	d02f      	beq.n	800227a <chThdSleep+0xfa>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 800221a:	9a02      	ldr	r2, [sp, #8]
 800221c:	9b01      	ldr	r3, [sp, #4]
 800221e:	6013      	str	r3, [r2, #0]
    vtp->next->prev = vtp->prev;
 8002220:	9b01      	ldr	r3, [sp, #4]
    vtp->func = NULL;
 8002222:	2100      	movs	r1, #0

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8002224:	4543      	cmp	r3, r8
    vtp->next->prev = vtp->prev;
 8002226:	605a      	str	r2, [r3, #4]
    vtp->func = NULL;
 8002228:	9104      	str	r1, [sp, #16]
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 800222a:	d00b      	beq.n	8002244 <chThdSleep+0xc4>
      vtp->next->delta += vtp->delta;
 800222c:	6899      	ldr	r1, [r3, #8]
 800222e:	9a03      	ldr	r2, [sp, #12]
 8002230:	440a      	add	r2, r1
 8002232:	609a      	str	r2, [r3, #8]
 8002234:	e006      	b.n	8002244 <chThdSleep+0xc4>
 8002236:	482e      	ldr	r0, [pc, #184]	; (80022f0 <chThdSleep+0x170>)
 8002238:	f7ff fa1a 	bl	8001670 <chSysHalt>
    chSchGoSleepS(newstate);
 800223c:	2008      	movs	r0, #8
 800223e:	f7ff fa57 	bl	80016f0 <chSchGoSleepS>
 8002242:	4f29      	ldr	r7, [pc, #164]	; (80022e8 <chThdSleep+0x168>)
  _dbg_check_unlock();
 8002244:	f7ff ff24 	bl	8002090 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002248:	683b      	ldr	r3, [r7, #0]
 800224a:	4a27      	ldr	r2, [pc, #156]	; (80022e8 <chThdSleep+0x168>)
 800224c:	42bb      	cmp	r3, r7
 800224e:	d004      	beq.n	800225a <chThdSleep+0xda>
 8002250:	6992      	ldr	r2, [r2, #24]
 8002252:	689b      	ldr	r3, [r3, #8]
 8002254:	6892      	ldr	r2, [r2, #8]
 8002256:	429a      	cmp	r2, r3
 8002258:	d30c      	bcc.n	8002274 <chThdSleep+0xf4>
 800225a:	2300      	movs	r3, #0
 800225c:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chThdSleepS(time);
  chSysUnlock();
}
 8002260:	b007      	add	sp, #28
 8002262:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    else if (delta < p->delta) {
 8002266:	429c      	cmp	r4, r3
 8002268:	d2b3      	bcs.n	80021d2 <chThdSleep+0x52>
 800226a:	4420      	add	r0, r4
 800226c:	f7ff fa20 	bl	80016b0 <stSetAlarm>
 8002270:	68b3      	ldr	r3, [r6, #8]
 8002272:	e7ae      	b.n	80021d2 <chThdSleep+0x52>
 8002274:	481f      	ldr	r0, [pc, #124]	; (80022f4 <chThdSleep+0x174>)
 8002276:	f7ff f9fb 	bl	8001670 <chSysHalt>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 800227a:	9b01      	ldr	r3, [sp, #4]
 800227c:	61d3      	str	r3, [r2, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
  vtp->func = NULL;
 800227e:	2100      	movs	r1, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8002280:	4543      	cmp	r3, r8
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8002282:	f8c3 8004 	str.w	r8, [r3, #4]
  vtp->func = NULL;
 8002286:	9104      	str	r1, [sp, #16]
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8002288:	d029      	beq.n	80022de <chThdSleep+0x15e>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 800228a:	689c      	ldr	r4, [r3, #8]
 800228c:	9903      	ldr	r1, [sp, #12]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
 800228e:	6a90      	ldr	r0, [r2, #40]	; 0x28
  ch.vtlist.next->delta += vtp->delta;
 8002290:	1862      	adds	r2, r4, r1
 8002292:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 8002296:	609a      	str	r2, [r3, #8]
 8002298:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 800229a:	1a1b      	subs	r3, r3, r0

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 800229c:	429a      	cmp	r2, r3
 800229e:	d9d1      	bls.n	8002244 <chThdSleep+0xc4>
  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 80022a0:	1ad1      	subs	r1, r2, r3
 80022a2:	2901      	cmp	r1, #1
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 80022a4:	bf98      	it	ls
 80022a6:	1c9a      	addls	r2, r3, #2
 80022a8:	4410      	add	r0, r2
 80022aa:	f7ff fa01 	bl	80016b0 <stSetAlarm>
 80022ae:	e7c9      	b.n	8002244 <chThdSleep+0xc4>
      ch.vtlist.lasttime = now;
 80022b0:	62bc      	str	r4, [r7, #40]	; 0x28
      vtp->delta = delay;
 80022b2:	9503      	str	r5, [sp, #12]
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 80022b4:	68da      	ldr	r2, [r3, #12]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 80022b6:	9601      	str	r6, [sp, #4]
      ch.vtlist.next = vtp;
 80022b8:	f10d 0904 	add.w	r9, sp, #4
  osalDbgAssert(stIsAlarmActive() == false, "already active");
 80022bc:	f012 0202 	ands.w	r2, r2, #2
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 80022c0:	9602      	str	r6, [sp, #8]
      ch.vtlist.next = vtp;
 80022c2:	f8c7 901c 	str.w	r9, [r7, #28]
      ch.vtlist.prev = vtp;
 80022c6:	f8c7 9020 	str.w	r9, [r7, #32]
 80022ca:	d105      	bne.n	80022d8 <chThdSleep+0x158>
  return systime + (systime_t)interval;
 80022cc:	442c      	add	r4, r5
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80022ce:	2102      	movs	r1, #2
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80022d0:	635c      	str	r4, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 80022d2:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80022d4:	60d9      	str	r1, [r3, #12]
 80022d6:	e793      	b.n	8002200 <chThdSleep+0x80>
 80022d8:	4807      	ldr	r0, [pc, #28]	; (80022f8 <chThdSleep+0x178>)
 80022da:	f7ff f9c9 	bl	8001670 <chSysHalt>
  STM32_ST_TIM->DIER = 0;
 80022de:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80022e2:	60d9      	str	r1, [r3, #12]
 80022e4:	e7ae      	b.n	8002244 <chThdSleep+0xc4>
 80022e6:	bf00      	nop
 80022e8:	20000878 	.word	0x20000878
 80022ec:	08002021 	.word	0x08002021
 80022f0:	08002728 	.word	0x08002728
 80022f4:	08002670 	.word	0x08002670
 80022f8:	0800274c 	.word	0x0800274c
 80022fc:	00000000 	.word	0x00000000

08002300 <chThdExit>:
void chThdExit(msg_t msg) {
 8002300:	b508      	push	{r3, lr}
 8002302:	4605      	mov	r5, r0
 8002304:	2320      	movs	r3, #32
 8002306:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800230a:	f7ff ff01 	bl	8002110 <_dbg_check_lock>
  thread_t *tp = currp;
 800230e:	4b10      	ldr	r3, [pc, #64]	; (8002350 <chThdExit+0x50>)
 8002310:	699c      	ldr	r4, [r3, #24]
  return (bool)(tlp->next != (thread_t *)tlp);
 8002312:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  tp->u.exitcode = msg;
 8002314:	6265      	str	r5, [r4, #36]	; 0x24
  while (list_notempty(&tp->waiting)) {
 8002316:	f104 0528 	add.w	r5, r4, #40	; 0x28
 800231a:	4285      	cmp	r5, r0
 800231c:	d006      	beq.n	800232c <chThdExit+0x2c>
  tlp->next = tp->queue.next;
 800231e:	6803      	ldr	r3, [r0, #0]
 8002320:	62a3      	str	r3, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
 8002322:	f7ff fa95 	bl	8001850 <chSchReadyI>
  return (bool)(tlp->next != (thread_t *)tlp);
 8002326:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  while (list_notempty(&tp->waiting)) {
 8002328:	42a8      	cmp	r0, r5
 800232a:	d1f8      	bne.n	800231e <chThdExit+0x1e>
  if ((tp->refs == (trefs_t)0) &&
 800232c:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 8002330:	b943      	cbnz	r3, 8002344 <chThdExit+0x44>
 8002332:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 8002336:	079b      	lsls	r3, r3, #30
 8002338:	d104      	bne.n	8002344 <chThdExit+0x44>
    REG_REMOVE(tp);
 800233a:	6963      	ldr	r3, [r4, #20]
 800233c:	6922      	ldr	r2, [r4, #16]
 800233e:	611a      	str	r2, [r3, #16]
 8002340:	6922      	ldr	r2, [r4, #16]
 8002342:	6153      	str	r3, [r2, #20]
  chSchGoSleepS(CH_STATE_FINAL);
 8002344:	200f      	movs	r0, #15
 8002346:	f7ff f9d3 	bl	80016f0 <chSchGoSleepS>
  chDbgAssert(false, "zombies apocalypse");
 800234a:	4802      	ldr	r0, [pc, #8]	; (8002354 <chThdExit+0x54>)
 800234c:	f7ff f990 	bl	8001670 <chSysHalt>
 8002350:	20000878 	.word	0x20000878
 8002354:	0800280c 	.word	0x0800280c
	...

08002360 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8002360:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002362:	4f13      	ldr	r7, [pc, #76]	; (80023b0 <__init_ram_areas+0x50>)
 8002364:	4d13      	ldr	r5, [pc, #76]	; (80023b4 <__init_ram_areas+0x54>)
 8002366:	4c14      	ldr	r4, [pc, #80]	; (80023b8 <__init_ram_areas+0x58>)
 8002368:	4b14      	ldr	r3, [pc, #80]	; (80023bc <__init_ram_areas+0x5c>)
 800236a:	4915      	ldr	r1, [pc, #84]	; (80023c0 <__init_ram_areas+0x60>)
 800236c:	f107 0e70 	add.w	lr, r7, #112	; 0x70
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8002370:	2600      	movs	r6, #0
    while (p < rap->clear_area) {
 8002372:	429c      	cmp	r4, r3
 8002374:	d911      	bls.n	800239a <__init_ram_areas+0x3a>
 8002376:	3904      	subs	r1, #4
 8002378:	461a      	mov	r2, r3
      *p = *tp;
 800237a:	f851 0f04 	ldr.w	r0, [r1, #4]!
 800237e:	f842 0b04 	str.w	r0, [r2], #4
    while (p < rap->clear_area) {
 8002382:	4294      	cmp	r4, r2
 8002384:	d8f9      	bhi.n	800237a <__init_ram_areas+0x1a>
 8002386:	43da      	mvns	r2, r3
 8002388:	4414      	add	r4, r2
 800238a:	f024 0403 	bic.w	r4, r4, #3
 800238e:	3404      	adds	r4, #4
 8002390:	4423      	add	r3, r4
    while (p < rap->no_init_area) {
 8002392:	429d      	cmp	r5, r3
 8002394:	d903      	bls.n	800239e <__init_ram_areas+0x3e>
      *p = 0;
 8002396:	f843 6b04 	str.w	r6, [r3], #4
    while (p < rap->no_init_area) {
 800239a:	429d      	cmp	r5, r3
 800239c:	d8fb      	bhi.n	8002396 <__init_ram_areas+0x36>
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 800239e:	4577      	cmp	r7, lr
 80023a0:	d005      	beq.n	80023ae <__init_ram_areas+0x4e>
 80023a2:	6939      	ldr	r1, [r7, #16]
 80023a4:	697b      	ldr	r3, [r7, #20]
 80023a6:	69bc      	ldr	r4, [r7, #24]
 80023a8:	69fd      	ldr	r5, [r7, #28]
 80023aa:	3710      	adds	r7, #16
 80023ac:	e7e1      	b.n	8002372 <__init_ram_areas+0x12>
 80023ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80023b0:	0800275c 	.word	0x0800275c
 80023b4:	20001354 	.word	0x20001354
 80023b8:	20001354 	.word	0x20001354
 80023bc:	20001354 	.word	0x20001354
 80023c0:	08002924 	.word	0x08002924
	...

080023d0 <__default_exit>:
void __default_exit(void) {
 80023d0:	e7fe      	b.n	80023d0 <__default_exit>
 80023d2:	bf00      	nop
	...

080023e0 <__late_init>:
 80023e0:	4770      	bx	lr
 80023e2:	bf00      	nop
	...

080023f0 <__core_init>:
void __core_init(void) {
 80023f0:	4770      	bx	lr
 80023f2:	bf00      	nop
	...

08002400 <chTMStartMeasurementX.constprop.32>:
 8002400:	4b01      	ldr	r3, [pc, #4]	; (8002408 <chTMStartMeasurementX.constprop.32+0x8>)
 8002402:	685b      	ldr	r3, [r3, #4]
  tmp->last = chSysGetRealtimeCounterX();
 8002404:	6083      	str	r3, [r0, #8]
 8002406:	4770      	bx	lr
 8002408:	e0001000 	.word	0xe0001000
 800240c:	00000000 	.word	0x00000000

08002410 <chThdDequeueAllI.constprop.28>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8002410:	b538      	push	{r3, r4, r5, lr}
  return (bool)(tqp->next != (const thread_t *)tqp);
 8002412:	6803      	ldr	r3, [r0, #0]

  while (queue_notempty(tqp)) {
 8002414:	4298      	cmp	r0, r3
 8002416:	d00a      	beq.n	800242e <chThdDequeueAllI.constprop.28+0x1e>
  tqp->next             = tp->queue.next;
 8002418:	681a      	ldr	r2, [r3, #0]
 800241a:	6002      	str	r2, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800241c:	6050      	str	r0, [r2, #4]

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 800241e:	f893 2020 	ldrb.w	r2, [r3, #32]
 8002422:	2a04      	cmp	r2, #4
 8002424:	4604      	mov	r4, r0
 8002426:	d003      	beq.n	8002430 <chThdDequeueAllI.constprop.28+0x20>
 8002428:	4809      	ldr	r0, [pc, #36]	; (8002450 <chThdDequeueAllI.constprop.28+0x40>)
 800242a:	f7ff f921 	bl	8001670 <chSysHalt>
 800242e:	bd38      	pop	{r3, r4, r5, pc}

  tp->u.rdymsg = msg;
 8002430:	2500      	movs	r5, #0
 8002432:	625d      	str	r5, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 8002434:	4618      	mov	r0, r3
 8002436:	f7ff fa0b 	bl	8001850 <chSchReadyI>
  return (bool)(tqp->next != (const thread_t *)tqp);
 800243a:	6823      	ldr	r3, [r4, #0]
 800243c:	429c      	cmp	r4, r3
 800243e:	d0f6      	beq.n	800242e <chThdDequeueAllI.constprop.28+0x1e>
  tqp->next             = tp->queue.next;
 8002440:	681a      	ldr	r2, [r3, #0]
 8002442:	6022      	str	r2, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8002444:	6054      	str	r4, [r2, #4]
  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 8002446:	f893 2020 	ldrb.w	r2, [r3, #32]
 800244a:	2a04      	cmp	r2, #4
 800244c:	d1ec      	bne.n	8002428 <chThdDequeueAllI.constprop.28+0x18>
 800244e:	e7f0      	b.n	8002432 <chThdDequeueAllI.constprop.28+0x22>
 8002450:	080028c0 	.word	0x080028c0
	...

08002460 <pwm_lld_serve_interrupt.constprop.0>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
 8002460:	b570      	push	{r4, r5, r6, lr}
  uint32_t sr;

  sr  = pwmp->tim->SR;
 8002462:	4d17      	ldr	r5, [pc, #92]	; (80024c0 <pwm_lld_serve_interrupt.constprop.0+0x60>)
 8002464:	69ab      	ldr	r3, [r5, #24]
 8002466:	691c      	ldr	r4, [r3, #16]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 8002468:	68da      	ldr	r2, [r3, #12]
 800246a:	4014      	ands	r4, r2
  pwmp->tim->SR = ~sr;
 800246c:	b2e2      	uxtb	r2, r4
 800246e:	43d2      	mvns	r2, r2
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8002470:	07a6      	lsls	r6, r4, #30
  pwmp->tim->SR = ~sr;
 8002472:	611a      	str	r2, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8002474:	d504      	bpl.n	8002480 <pwm_lld_serve_interrupt.constprop.0+0x20>
      (pwmp->config->channels[0].callback != NULL))
 8002476:	686b      	ldr	r3, [r5, #4]
 8002478:	691b      	ldr	r3, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 800247a:	b10b      	cbz	r3, 8002480 <pwm_lld_serve_interrupt.constprop.0+0x20>
    pwmp->config->channels[0].callback(pwmp);
 800247c:	4628      	mov	r0, r5
 800247e:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8002480:	0760      	lsls	r0, r4, #29
 8002482:	d504      	bpl.n	800248e <pwm_lld_serve_interrupt.constprop.0+0x2e>
      (pwmp->config->channels[1].callback != NULL))
 8002484:	686b      	ldr	r3, [r5, #4]
 8002486:	699b      	ldr	r3, [r3, #24]
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8002488:	b10b      	cbz	r3, 800248e <pwm_lld_serve_interrupt.constprop.0+0x2e>
    pwmp->config->channels[1].callback(pwmp);
 800248a:	480d      	ldr	r0, [pc, #52]	; (80024c0 <pwm_lld_serve_interrupt.constprop.0+0x60>)
 800248c:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 800248e:	0721      	lsls	r1, r4, #28
 8002490:	d504      	bpl.n	800249c <pwm_lld_serve_interrupt.constprop.0+0x3c>
      (pwmp->config->channels[2].callback != NULL))
 8002492:	686b      	ldr	r3, [r5, #4]
 8002494:	6a1b      	ldr	r3, [r3, #32]
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8002496:	b10b      	cbz	r3, 800249c <pwm_lld_serve_interrupt.constprop.0+0x3c>
    pwmp->config->channels[2].callback(pwmp);
 8002498:	4809      	ldr	r0, [pc, #36]	; (80024c0 <pwm_lld_serve_interrupt.constprop.0+0x60>)
 800249a:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 800249c:	06e2      	lsls	r2, r4, #27
 800249e:	d504      	bpl.n	80024aa <pwm_lld_serve_interrupt.constprop.0+0x4a>
      (pwmp->config->channels[3].callback != NULL))
 80024a0:	686b      	ldr	r3, [r5, #4]
 80024a2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 80024a4:	b10b      	cbz	r3, 80024aa <pwm_lld_serve_interrupt.constprop.0+0x4a>
    pwmp->config->channels[3].callback(pwmp);
 80024a6:	4806      	ldr	r0, [pc, #24]	; (80024c0 <pwm_lld_serve_interrupt.constprop.0+0x60>)
 80024a8:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
 80024aa:	07e3      	lsls	r3, r4, #31
 80024ac:	d506      	bpl.n	80024bc <pwm_lld_serve_interrupt.constprop.0+0x5c>
 80024ae:	686b      	ldr	r3, [r5, #4]
 80024b0:	689b      	ldr	r3, [r3, #8]
 80024b2:	b11b      	cbz	r3, 80024bc <pwm_lld_serve_interrupt.constprop.0+0x5c>
    pwmp->config->callback(pwmp);
 80024b4:	4802      	ldr	r0, [pc, #8]	; (80024c0 <pwm_lld_serve_interrupt.constprop.0+0x60>)
}
 80024b6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    pwmp->config->callback(pwmp);
 80024ba:	4718      	bx	r3
 80024bc:	bd70      	pop	{r4, r5, r6, pc}
 80024be:	bf00      	nop
 80024c0:	20001338 	.word	0x20001338
	...

080024d0 <pwmEnableChannel.constprop.8>:
void pwmEnableChannel(PWMDriver *pwmp,
 80024d0:	b538      	push	{r3, r4, r5, lr}
  osalDbgCheck((pwmp != NULL) && (channel < pwmp->channels));
 80024d2:	4c0c      	ldr	r4, [pc, #48]	; (8002504 <pwmEnableChannel.constprop.8+0x34>)
 80024d4:	7c23      	ldrb	r3, [r4, #16]
 80024d6:	b143      	cbz	r3, 80024ea <pwmEnableChannel.constprop.8+0x1a>
 80024d8:	4605      	mov	r5, r0
 80024da:	2320      	movs	r3, #32
 80024dc:	f383 8811 	msr	BASEPRI, r3
 80024e0:	f7ff fe16 	bl	8002110 <_dbg_check_lock>
  osalDbgAssert(pwmp->state == PWM_READY, "not ready");
 80024e4:	7823      	ldrb	r3, [r4, #0]
 80024e6:	2b02      	cmp	r3, #2
 80024e8:	d002      	beq.n	80024f0 <pwmEnableChannel.constprop.8+0x20>
  osalDbgCheck((pwmp != NULL) && (channel < pwmp->channels));
 80024ea:	4807      	ldr	r0, [pc, #28]	; (8002508 <pwmEnableChannel.constprop.8+0x38>)
 80024ec:	f7ff f8c0 	bl	8001670 <chSysHalt>
  pwmEnableChannelI(pwmp, channel, width);
 80024f0:	68e3      	ldr	r3, [r4, #12]
  pwmp->tim->CCR[channel] = width;
 80024f2:	69a2      	ldr	r2, [r4, #24]
 80024f4:	f043 0301 	orr.w	r3, r3, #1
 80024f8:	6355      	str	r5, [r2, #52]	; 0x34
 80024fa:	60e3      	str	r3, [r4, #12]
}
 80024fc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSysUnlock();
 8002500:	f7ff bdd6 	b.w	80020b0 <chSysUnlock.lto_priv.38>
 8002504:	20001338 	.word	0x20001338
 8002508:	080028ac 	.word	0x080028ac
