
build/acs_f0_pwm-icu.elf:     file format elf32-littlearm


Disassembly of section .text:

080000c0 <Reset_Handler>:
 80000c0:	b672      	cpsid	i
 80000c2:	4824      	ldr	r0, [pc, #144]	; (8000154 <endfiniloop+0x6>)
 80000c4:	f380 8808 	msr	MSP, r0
 80000c8:	4823      	ldr	r0, [pc, #140]	; (8000158 <endfiniloop+0xa>)
 80000ca:	f380 8809 	msr	PSP, r0
 80000ce:	2002      	movs	r0, #2
 80000d0:	f380 8814 	msr	CONTROL, r0
 80000d4:	f3bf 8f6f 	isb	sy
 80000d8:	f002 fb92 	bl	8002800 <__core_init>
 80000dc:	f000 fb28 	bl	8000730 <__early_init>
 80000e0:	481e      	ldr	r0, [pc, #120]	; (800015c <endfiniloop+0xe>)
 80000e2:	491f      	ldr	r1, [pc, #124]	; (8000160 <endfiniloop+0x12>)
 80000e4:	4a1b      	ldr	r2, [pc, #108]	; (8000154 <endfiniloop+0x6>)

080000e6 <msloop>:
 80000e6:	4291      	cmp	r1, r2
 80000e8:	da02      	bge.n	80000f0 <endmsloop>
 80000ea:	6008      	str	r0, [r1, #0]
 80000ec:	3104      	adds	r1, #4
 80000ee:	e7fa      	b.n	80000e6 <msloop>

080000f0 <endmsloop>:
 80000f0:	491c      	ldr	r1, [pc, #112]	; (8000164 <endfiniloop+0x16>)
 80000f2:	4a19      	ldr	r2, [pc, #100]	; (8000158 <endfiniloop+0xa>)

080000f4 <psloop>:
 80000f4:	4291      	cmp	r1, r2
 80000f6:	da02      	bge.n	80000fe <endpsloop>
 80000f8:	6008      	str	r0, [r1, #0]
 80000fa:	3104      	adds	r1, #4
 80000fc:	e7fa      	b.n	80000f4 <psloop>

080000fe <endpsloop>:
 80000fe:	491a      	ldr	r1, [pc, #104]	; (8000168 <endfiniloop+0x1a>)
 8000100:	4a1a      	ldr	r2, [pc, #104]	; (800016c <endfiniloop+0x1e>)
 8000102:	4b1b      	ldr	r3, [pc, #108]	; (8000170 <endfiniloop+0x22>)

08000104 <dloop>:
 8000104:	429a      	cmp	r2, r3
 8000106:	da04      	bge.n	8000112 <enddloop>
 8000108:	6808      	ldr	r0, [r1, #0]
 800010a:	6010      	str	r0, [r2, #0]
 800010c:	3104      	adds	r1, #4
 800010e:	3204      	adds	r2, #4
 8000110:	e7f8      	b.n	8000104 <dloop>

08000112 <enddloop>:
 8000112:	2000      	movs	r0, #0
 8000114:	4917      	ldr	r1, [pc, #92]	; (8000174 <endfiniloop+0x26>)
 8000116:	4a18      	ldr	r2, [pc, #96]	; (8000178 <endfiniloop+0x2a>)

08000118 <bloop>:
 8000118:	4291      	cmp	r1, r2
 800011a:	da02      	bge.n	8000122 <endbloop>
 800011c:	6008      	str	r0, [r1, #0]
 800011e:	3104      	adds	r1, #4
 8000120:	e7fa      	b.n	8000118 <bloop>

08000122 <endbloop>:
 8000122:	f002 fb85 	bl	8002830 <__init_ram_areas>
 8000126:	f002 fb73 	bl	8002810 <__late_init>
 800012a:	4c14      	ldr	r4, [pc, #80]	; (800017c <endfiniloop+0x2e>)
 800012c:	4d14      	ldr	r5, [pc, #80]	; (8000180 <endfiniloop+0x32>)

0800012e <initloop>:
 800012e:	42ac      	cmp	r4, r5
 8000130:	da03      	bge.n	800013a <endinitloop>
 8000132:	6821      	ldr	r1, [r4, #0]
 8000134:	4788      	blx	r1
 8000136:	3404      	adds	r4, #4
 8000138:	e7f9      	b.n	800012e <initloop>

0800013a <endinitloop>:
 800013a:	f000 fb61 	bl	8000800 <main>
 800013e:	4c11      	ldr	r4, [pc, #68]	; (8000184 <endfiniloop+0x36>)
 8000140:	4d11      	ldr	r5, [pc, #68]	; (8000188 <endfiniloop+0x3a>)

08000142 <finiloop>:
 8000142:	42ac      	cmp	r4, r5
 8000144:	da03      	bge.n	800014e <endfiniloop>
 8000146:	6821      	ldr	r1, [r4, #0]
 8000148:	4788      	blx	r1
 800014a:	3404      	adds	r4, #4
 800014c:	e7f9      	b.n	8000142 <finiloop>

0800014e <endfiniloop>:
 800014e:	490f      	ldr	r1, [pc, #60]	; (800018c <endfiniloop+0x3e>)
 8000150:	4708      	bx	r1
 8000152:	0000      	.short	0x0000
 8000154:	20000200 	.word	0x20000200
 8000158:	20000400 	.word	0x20000400
 800015c:	55555555 	.word	0x55555555
 8000160:	20000000 	.word	0x20000000
 8000164:	20000200 	.word	0x20000200
 8000168:	08003f1c 	.word	0x08003f1c
 800016c:	20000400 	.word	0x20000400
 8000170:	20000450 	.word	0x20000450
 8000174:	20000450 	.word	0x20000450
 8000178:	20000e14 	.word	0x20000e14
 800017c:	080000c0 	.word	0x080000c0
 8000180:	080000c0 	.word	0x080000c0
 8000184:	080000c0 	.word	0x080000c0
 8000188:	080000c0 	.word	0x080000c0
 800018c:	08002821 	.word	0x08002821

08000190 <_port_switch>:
 8000190:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000192:	4644      	mov	r4, r8
 8000194:	464d      	mov	r5, r9
 8000196:	4656      	mov	r6, sl
 8000198:	465f      	mov	r7, fp
 800019a:	b4f0      	push	{r4, r5, r6, r7}
 800019c:	466b      	mov	r3, sp
 800019e:	60cb      	str	r3, [r1, #12]
 80001a0:	68c3      	ldr	r3, [r0, #12]
 80001a2:	469d      	mov	sp, r3
 80001a4:	bcf0      	pop	{r4, r5, r6, r7}
 80001a6:	46a0      	mov	r8, r4
 80001a8:	46a9      	mov	r9, r5
 80001aa:	46b2      	mov	sl, r6
 80001ac:	46bb      	mov	fp, r7
 80001ae:	bdf0      	pop	{r4, r5, r6, r7, pc}

080001b0 <_port_thread_start>:
 80001b0:	f002 fd9e 	bl	8002cf0 <_dbg_check_unlock>
 80001b4:	b662      	cpsie	i
 80001b6:	1c28      	adds	r0, r5, #0
 80001b8:	47a0      	blx	r4
 80001ba:	2000      	movs	r0, #0
 80001bc:	f002 f960 	bl	8002480 <chThdExit>

080001c0 <_port_switch_from_isr>:
 80001c0:	f002 fd7e 	bl	8002cc0 <_dbg_check_lock>
 80001c4:	f003 fbac 	bl	8003920 <chSchDoReschedule>
 80001c8:	f002 fd92 	bl	8002cf0 <_dbg_check_unlock>

080001cc <_port_exit_from_isr>:
 80001cc:	4a01      	ldr	r2, [pc, #4]	; (80001d4 <_port_exit_from_isr+0x8>)
 80001ce:	4b02      	ldr	r3, [pc, #8]	; (80001d8 <_port_exit_from_isr+0xc>)
 80001d0:	6013      	str	r3, [r2, #0]
 80001d2:	e7fe      	b.n	80001d2 <_port_exit_from_isr+0x6>
 80001d4:	e000ed04 	.word	0xe000ed04
 80001d8:	80000000 	.word	0x80000000

080001dc <__aeabi_uidiv>:
 80001dc:	2200      	movs	r2, #0
 80001de:	0843      	lsrs	r3, r0, #1
 80001e0:	428b      	cmp	r3, r1
 80001e2:	d374      	bcc.n	80002ce <__aeabi_uidiv+0xf2>
 80001e4:	0903      	lsrs	r3, r0, #4
 80001e6:	428b      	cmp	r3, r1
 80001e8:	d35f      	bcc.n	80002aa <__aeabi_uidiv+0xce>
 80001ea:	0a03      	lsrs	r3, r0, #8
 80001ec:	428b      	cmp	r3, r1
 80001ee:	d344      	bcc.n	800027a <__aeabi_uidiv+0x9e>
 80001f0:	0b03      	lsrs	r3, r0, #12
 80001f2:	428b      	cmp	r3, r1
 80001f4:	d328      	bcc.n	8000248 <__aeabi_uidiv+0x6c>
 80001f6:	0c03      	lsrs	r3, r0, #16
 80001f8:	428b      	cmp	r3, r1
 80001fa:	d30d      	bcc.n	8000218 <__aeabi_uidiv+0x3c>
 80001fc:	22ff      	movs	r2, #255	; 0xff
 80001fe:	0209      	lsls	r1, r1, #8
 8000200:	ba12      	rev	r2, r2
 8000202:	0c03      	lsrs	r3, r0, #16
 8000204:	428b      	cmp	r3, r1
 8000206:	d302      	bcc.n	800020e <__aeabi_uidiv+0x32>
 8000208:	1212      	asrs	r2, r2, #8
 800020a:	0209      	lsls	r1, r1, #8
 800020c:	d065      	beq.n	80002da <__aeabi_uidiv+0xfe>
 800020e:	0b03      	lsrs	r3, r0, #12
 8000210:	428b      	cmp	r3, r1
 8000212:	d319      	bcc.n	8000248 <__aeabi_uidiv+0x6c>
 8000214:	e000      	b.n	8000218 <__aeabi_uidiv+0x3c>
 8000216:	0a09      	lsrs	r1, r1, #8
 8000218:	0bc3      	lsrs	r3, r0, #15
 800021a:	428b      	cmp	r3, r1
 800021c:	d301      	bcc.n	8000222 <__aeabi_uidiv+0x46>
 800021e:	03cb      	lsls	r3, r1, #15
 8000220:	1ac0      	subs	r0, r0, r3
 8000222:	4152      	adcs	r2, r2
 8000224:	0b83      	lsrs	r3, r0, #14
 8000226:	428b      	cmp	r3, r1
 8000228:	d301      	bcc.n	800022e <__aeabi_uidiv+0x52>
 800022a:	038b      	lsls	r3, r1, #14
 800022c:	1ac0      	subs	r0, r0, r3
 800022e:	4152      	adcs	r2, r2
 8000230:	0b43      	lsrs	r3, r0, #13
 8000232:	428b      	cmp	r3, r1
 8000234:	d301      	bcc.n	800023a <__aeabi_uidiv+0x5e>
 8000236:	034b      	lsls	r3, r1, #13
 8000238:	1ac0      	subs	r0, r0, r3
 800023a:	4152      	adcs	r2, r2
 800023c:	0b03      	lsrs	r3, r0, #12
 800023e:	428b      	cmp	r3, r1
 8000240:	d301      	bcc.n	8000246 <__aeabi_uidiv+0x6a>
 8000242:	030b      	lsls	r3, r1, #12
 8000244:	1ac0      	subs	r0, r0, r3
 8000246:	4152      	adcs	r2, r2
 8000248:	0ac3      	lsrs	r3, r0, #11
 800024a:	428b      	cmp	r3, r1
 800024c:	d301      	bcc.n	8000252 <__aeabi_uidiv+0x76>
 800024e:	02cb      	lsls	r3, r1, #11
 8000250:	1ac0      	subs	r0, r0, r3
 8000252:	4152      	adcs	r2, r2
 8000254:	0a83      	lsrs	r3, r0, #10
 8000256:	428b      	cmp	r3, r1
 8000258:	d301      	bcc.n	800025e <__aeabi_uidiv+0x82>
 800025a:	028b      	lsls	r3, r1, #10
 800025c:	1ac0      	subs	r0, r0, r3
 800025e:	4152      	adcs	r2, r2
 8000260:	0a43      	lsrs	r3, r0, #9
 8000262:	428b      	cmp	r3, r1
 8000264:	d301      	bcc.n	800026a <__aeabi_uidiv+0x8e>
 8000266:	024b      	lsls	r3, r1, #9
 8000268:	1ac0      	subs	r0, r0, r3
 800026a:	4152      	adcs	r2, r2
 800026c:	0a03      	lsrs	r3, r0, #8
 800026e:	428b      	cmp	r3, r1
 8000270:	d301      	bcc.n	8000276 <__aeabi_uidiv+0x9a>
 8000272:	020b      	lsls	r3, r1, #8
 8000274:	1ac0      	subs	r0, r0, r3
 8000276:	4152      	adcs	r2, r2
 8000278:	d2cd      	bcs.n	8000216 <__aeabi_uidiv+0x3a>
 800027a:	09c3      	lsrs	r3, r0, #7
 800027c:	428b      	cmp	r3, r1
 800027e:	d301      	bcc.n	8000284 <__aeabi_uidiv+0xa8>
 8000280:	01cb      	lsls	r3, r1, #7
 8000282:	1ac0      	subs	r0, r0, r3
 8000284:	4152      	adcs	r2, r2
 8000286:	0983      	lsrs	r3, r0, #6
 8000288:	428b      	cmp	r3, r1
 800028a:	d301      	bcc.n	8000290 <__aeabi_uidiv+0xb4>
 800028c:	018b      	lsls	r3, r1, #6
 800028e:	1ac0      	subs	r0, r0, r3
 8000290:	4152      	adcs	r2, r2
 8000292:	0943      	lsrs	r3, r0, #5
 8000294:	428b      	cmp	r3, r1
 8000296:	d301      	bcc.n	800029c <__aeabi_uidiv+0xc0>
 8000298:	014b      	lsls	r3, r1, #5
 800029a:	1ac0      	subs	r0, r0, r3
 800029c:	4152      	adcs	r2, r2
 800029e:	0903      	lsrs	r3, r0, #4
 80002a0:	428b      	cmp	r3, r1
 80002a2:	d301      	bcc.n	80002a8 <__aeabi_uidiv+0xcc>
 80002a4:	010b      	lsls	r3, r1, #4
 80002a6:	1ac0      	subs	r0, r0, r3
 80002a8:	4152      	adcs	r2, r2
 80002aa:	08c3      	lsrs	r3, r0, #3
 80002ac:	428b      	cmp	r3, r1
 80002ae:	d301      	bcc.n	80002b4 <__aeabi_uidiv+0xd8>
 80002b0:	00cb      	lsls	r3, r1, #3
 80002b2:	1ac0      	subs	r0, r0, r3
 80002b4:	4152      	adcs	r2, r2
 80002b6:	0883      	lsrs	r3, r0, #2
 80002b8:	428b      	cmp	r3, r1
 80002ba:	d301      	bcc.n	80002c0 <__aeabi_uidiv+0xe4>
 80002bc:	008b      	lsls	r3, r1, #2
 80002be:	1ac0      	subs	r0, r0, r3
 80002c0:	4152      	adcs	r2, r2
 80002c2:	0843      	lsrs	r3, r0, #1
 80002c4:	428b      	cmp	r3, r1
 80002c6:	d301      	bcc.n	80002cc <__aeabi_uidiv+0xf0>
 80002c8:	004b      	lsls	r3, r1, #1
 80002ca:	1ac0      	subs	r0, r0, r3
 80002cc:	4152      	adcs	r2, r2
 80002ce:	1a41      	subs	r1, r0, r1
 80002d0:	d200      	bcs.n	80002d4 <__aeabi_uidiv+0xf8>
 80002d2:	4601      	mov	r1, r0
 80002d4:	4152      	adcs	r2, r2
 80002d6:	4610      	mov	r0, r2
 80002d8:	4770      	bx	lr
 80002da:	e7ff      	b.n	80002dc <__aeabi_uidiv+0x100>
 80002dc:	b501      	push	{r0, lr}
 80002de:	2000      	movs	r0, #0
 80002e0:	f000 f806 	bl	80002f0 <__aeabi_idiv0>
 80002e4:	bd02      	pop	{r1, pc}
 80002e6:	46c0      	nop			; (mov r8, r8)

080002e8 <__aeabi_uidivmod>:
 80002e8:	2900      	cmp	r1, #0
 80002ea:	d0f7      	beq.n	80002dc <__aeabi_uidiv+0x100>
 80002ec:	e776      	b.n	80001dc <__aeabi_uidiv>
 80002ee:	4770      	bx	lr

080002f0 <__aeabi_idiv0>:
 80002f0:	4770      	bx	lr
 80002f2:	46c0      	nop			; (mov r8, r8)
	...

08000300 <pwm_lld_start>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_start(PWMDriver *pwmp) {
 8000300:	b500      	push	{lr}
 8000302:	b085      	sub	sp, #20
 8000304:	9001      	str	r0, [sp, #4]
  uint32_t psc;
  uint32_t ccer;

  if (pwmp->state == PWM_STOP) {
 8000306:	9b01      	ldr	r3, [sp, #4]
 8000308:	781b      	ldrb	r3, [r3, #0]
 800030a:	2b01      	cmp	r3, #1
 800030c:	d128      	bne.n	8000360 <pwm_lld_start+0x60>
    /* Clock activation and timer reset.*/
#if STM32_PWM_USE_TIM1
    if (&PWMD1 == pwmp) {
 800030e:	9a01      	ldr	r2, [sp, #4]
 8000310:	4b6b      	ldr	r3, [pc, #428]	; (80004c0 <pwm_lld_start+0x1c0>)
 8000312:	429a      	cmp	r2, r3
 8000314:	d11b      	bne.n	800034e <pwm_lld_start+0x4e>
      rccEnableTIM1(FALSE);
 8000316:	4b6b      	ldr	r3, [pc, #428]	; (80004c4 <pwm_lld_start+0x1c4>)
 8000318:	4a6a      	ldr	r2, [pc, #424]	; (80004c4 <pwm_lld_start+0x1c4>)
 800031a:	6992      	ldr	r2, [r2, #24]
 800031c:	2180      	movs	r1, #128	; 0x80
 800031e:	0109      	lsls	r1, r1, #4
 8000320:	430a      	orrs	r2, r1
 8000322:	619a      	str	r2, [r3, #24]
      rccResetTIM1();
 8000324:	4b67      	ldr	r3, [pc, #412]	; (80004c4 <pwm_lld_start+0x1c4>)
 8000326:	4a67      	ldr	r2, [pc, #412]	; (80004c4 <pwm_lld_start+0x1c4>)
 8000328:	68d2      	ldr	r2, [r2, #12]
 800032a:	2180      	movs	r1, #128	; 0x80
 800032c:	0109      	lsls	r1, r1, #4
 800032e:	430a      	orrs	r2, r1
 8000330:	60da      	str	r2, [r3, #12]
 8000332:	4b64      	ldr	r3, [pc, #400]	; (80004c4 <pwm_lld_start+0x1c4>)
 8000334:	2200      	movs	r2, #0
 8000336:	60da      	str	r2, [r3, #12]
#if !defined(STM32_TIM1_SUPPRESS_ISR)
      nvicEnableVector(STM32_TIM1_UP_NUMBER, STM32_PWM_TIM1_IRQ_PRIORITY);
 8000338:	2103      	movs	r1, #3
 800033a:	200d      	movs	r0, #13
 800033c:	f000 fd08 	bl	8000d50 <nvicEnableVector>
      nvicEnableVector(STM32_TIM1_CC_NUMBER, STM32_PWM_TIM1_IRQ_PRIORITY);
 8000340:	2103      	movs	r1, #3
 8000342:	200e      	movs	r0, #14
 8000344:	f000 fd04 	bl	8000d50 <nvicEnableVector>
#endif
#if defined(STM32_TIM1CLK)
      pwmp->clock = STM32_TIM1CLK;
#else
      pwmp->clock = STM32_TIMCLK2;
 8000348:	9b01      	ldr	r3, [sp, #4]
 800034a:	4a5f      	ldr	r2, [pc, #380]	; (80004c8 <pwm_lld_start+0x1c8>)
 800034c:	615a      	str	r2, [r3, #20]
    }
#endif

    /* All channels configured in PWM1 mode with preload enabled and will
       stay that way until the driver is stopped.*/
    pwmp->tim->CCMR1 = STM32_TIM_CCMR1_OC1M(6) | STM32_TIM_CCMR1_OC1PE |
 800034e:	9b01      	ldr	r3, [sp, #4]
 8000350:	699b      	ldr	r3, [r3, #24]
 8000352:	4a5e      	ldr	r2, [pc, #376]	; (80004cc <pwm_lld_start+0x1cc>)
 8000354:	619a      	str	r2, [r3, #24]
                       STM32_TIM_CCMR1_OC2M(6) | STM32_TIM_CCMR1_OC2PE;
    pwmp->tim->CCMR2 = STM32_TIM_CCMR2_OC3M(6) | STM32_TIM_CCMR2_OC3PE |
 8000356:	9b01      	ldr	r3, [sp, #4]
 8000358:	699b      	ldr	r3, [r3, #24]
 800035a:	4a5c      	ldr	r2, [pc, #368]	; (80004cc <pwm_lld_start+0x1cc>)
 800035c:	61da      	str	r2, [r3, #28]
 800035e:	e017      	b.n	8000390 <pwm_lld_start+0x90>
                       STM32_TIM_CCMR3_OC6M(6) | STM32_TIM_CCMR3_OC6PE;
#endif
  }
  else {
    /* Driver re-configuration scenario, it must be stopped first.*/
    pwmp->tim->CR1    = 0;                  /* Timer disabled.              */
 8000360:	9b01      	ldr	r3, [sp, #4]
 8000362:	699b      	ldr	r3, [r3, #24]
 8000364:	2200      	movs	r2, #0
 8000366:	601a      	str	r2, [r3, #0]
    pwmp->tim->CCR[0] = 0;                  /* Comparator 1 disabled.       */
 8000368:	9b01      	ldr	r3, [sp, #4]
 800036a:	699b      	ldr	r3, [r3, #24]
 800036c:	2200      	movs	r2, #0
 800036e:	635a      	str	r2, [r3, #52]	; 0x34
    pwmp->tim->CCR[1] = 0;                  /* Comparator 2 disabled.       */
 8000370:	9b01      	ldr	r3, [sp, #4]
 8000372:	699b      	ldr	r3, [r3, #24]
 8000374:	2200      	movs	r2, #0
 8000376:	639a      	str	r2, [r3, #56]	; 0x38
    pwmp->tim->CCR[2] = 0;                  /* Comparator 3 disabled.       */
 8000378:	9b01      	ldr	r3, [sp, #4]
 800037a:	699b      	ldr	r3, [r3, #24]
 800037c:	2200      	movs	r2, #0
 800037e:	63da      	str	r2, [r3, #60]	; 0x3c
    pwmp->tim->CCR[3] = 0;                  /* Comparator 4 disabled.       */
 8000380:	9b01      	ldr	r3, [sp, #4]
 8000382:	699b      	ldr	r3, [r3, #24]
 8000384:	2200      	movs	r2, #0
 8000386:	641a      	str	r2, [r3, #64]	; 0x40
    if (pwmp->channels > 4) {
      pwmp->tim->CCXR[0] = 0;               /* Comparator 5 disabled.       */
      pwmp->tim->CCXR[1] = 0;               /* Comparator 6 disabled.       */
    }
#endif
    pwmp->tim->CNT  = 0;                    /* Counter reset to zero.       */
 8000388:	9b01      	ldr	r3, [sp, #4]
 800038a:	699b      	ldr	r3, [r3, #24]
 800038c:	2200      	movs	r2, #0
 800038e:	625a      	str	r2, [r3, #36]	; 0x24
  }

  /* Timer configuration.*/
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
 8000390:	9b01      	ldr	r3, [sp, #4]
 8000392:	695a      	ldr	r2, [r3, #20]
 8000394:	9b01      	ldr	r3, [sp, #4]
 8000396:	685b      	ldr	r3, [r3, #4]
 8000398:	681b      	ldr	r3, [r3, #0]
 800039a:	0019      	movs	r1, r3
 800039c:	0010      	movs	r0, r2
 800039e:	f7ff ff1d 	bl	80001dc <__aeabi_uidiv>
 80003a2:	0003      	movs	r3, r0
 80003a4:	3b01      	subs	r3, #1
 80003a6:	9302      	str	r3, [sp, #8]
  osalDbgAssert((psc <= 0xFFFF) &&
 80003a8:	9b02      	ldr	r3, [sp, #8]
 80003aa:	4a49      	ldr	r2, [pc, #292]	; (80004d0 <pwm_lld_start+0x1d0>)
 80003ac:	4293      	cmp	r3, r2
 80003ae:	d809      	bhi.n	80003c4 <pwm_lld_start+0xc4>
 80003b0:	9b02      	ldr	r3, [sp, #8]
 80003b2:	1c5a      	adds	r2, r3, #1
 80003b4:	9b01      	ldr	r3, [sp, #4]
 80003b6:	685b      	ldr	r3, [r3, #4]
 80003b8:	681b      	ldr	r3, [r3, #0]
 80003ba:	435a      	muls	r2, r3
 80003bc:	9b01      	ldr	r3, [sp, #4]
 80003be:	695b      	ldr	r3, [r3, #20]
 80003c0:	429a      	cmp	r2, r3
 80003c2:	d003      	beq.n	80003cc <pwm_lld_start+0xcc>
 80003c4:	4b43      	ldr	r3, [pc, #268]	; (80004d4 <pwm_lld_start+0x1d4>)
 80003c6:	0018      	movs	r0, r3
 80003c8:	f002 fc2a 	bl	8002c20 <chSysHalt>
                ((psc + 1) * pwmp->config->frequency) == pwmp->clock,
                "invalid frequency");
  pwmp->tim->PSC  = psc;
 80003cc:	9b01      	ldr	r3, [sp, #4]
 80003ce:	699b      	ldr	r3, [r3, #24]
 80003d0:	9a02      	ldr	r2, [sp, #8]
 80003d2:	629a      	str	r2, [r3, #40]	; 0x28
  pwmp->tim->ARR  = pwmp->period - 1;
 80003d4:	9b01      	ldr	r3, [sp, #4]
 80003d6:	699b      	ldr	r3, [r3, #24]
 80003d8:	9a01      	ldr	r2, [sp, #4]
 80003da:	6892      	ldr	r2, [r2, #8]
 80003dc:	3a01      	subs	r2, #1
 80003de:	62da      	str	r2, [r3, #44]	; 0x2c
  pwmp->tim->CR2  = pwmp->config->cr2;
 80003e0:	9b01      	ldr	r3, [sp, #4]
 80003e2:	699b      	ldr	r3, [r3, #24]
 80003e4:	9a01      	ldr	r2, [sp, #4]
 80003e6:	6852      	ldr	r2, [r2, #4]
 80003e8:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80003ea:	605a      	str	r2, [r3, #4]

  /* Output enables and polarities setup.*/
  ccer = 0;
 80003ec:	2300      	movs	r3, #0
 80003ee:	9303      	str	r3, [sp, #12]
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 80003f0:	9b01      	ldr	r3, [sp, #4]
 80003f2:	685b      	ldr	r3, [r3, #4]
 80003f4:	68db      	ldr	r3, [r3, #12]
 80003f6:	220f      	movs	r2, #15
 80003f8:	4013      	ands	r3, r2
 80003fa:	2b01      	cmp	r3, #1
 80003fc:	d005      	beq.n	800040a <pwm_lld_start+0x10a>
 80003fe:	2b02      	cmp	r3, #2
 8000400:	d107      	bne.n	8000412 <pwm_lld_start+0x112>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC1P;
 8000402:	9b03      	ldr	r3, [sp, #12]
 8000404:	2202      	movs	r2, #2
 8000406:	4313      	orrs	r3, r2
 8000408:	9303      	str	r3, [sp, #12]
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC1E;
 800040a:	9b03      	ldr	r3, [sp, #12]
 800040c:	2201      	movs	r2, #1
 800040e:	4313      	orrs	r3, r2
 8000410:	9303      	str	r3, [sp, #12]
  default:
    ;
  }
  switch (pwmp->config->channels[1].mode & PWM_OUTPUT_MASK) {
 8000412:	9b01      	ldr	r3, [sp, #4]
 8000414:	685b      	ldr	r3, [r3, #4]
 8000416:	695b      	ldr	r3, [r3, #20]
 8000418:	220f      	movs	r2, #15
 800041a:	4013      	ands	r3, r2
 800041c:	2b01      	cmp	r3, #1
 800041e:	d005      	beq.n	800042c <pwm_lld_start+0x12c>
 8000420:	2b02      	cmp	r3, #2
 8000422:	d107      	bne.n	8000434 <pwm_lld_start+0x134>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC2P;
 8000424:	9b03      	ldr	r3, [sp, #12]
 8000426:	2220      	movs	r2, #32
 8000428:	4313      	orrs	r3, r2
 800042a:	9303      	str	r3, [sp, #12]
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC2E;
 800042c:	9b03      	ldr	r3, [sp, #12]
 800042e:	2210      	movs	r2, #16
 8000430:	4313      	orrs	r3, r2
 8000432:	9303      	str	r3, [sp, #12]
  default:
    ;
  }
  switch (pwmp->config->channels[2].mode & PWM_OUTPUT_MASK) {
 8000434:	9b01      	ldr	r3, [sp, #4]
 8000436:	685b      	ldr	r3, [r3, #4]
 8000438:	69db      	ldr	r3, [r3, #28]
 800043a:	220f      	movs	r2, #15
 800043c:	4013      	ands	r3, r2
 800043e:	2b01      	cmp	r3, #1
 8000440:	d006      	beq.n	8000450 <pwm_lld_start+0x150>
 8000442:	2b02      	cmp	r3, #2
 8000444:	d109      	bne.n	800045a <pwm_lld_start+0x15a>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC3P;
 8000446:	9b03      	ldr	r3, [sp, #12]
 8000448:	2280      	movs	r2, #128	; 0x80
 800044a:	0092      	lsls	r2, r2, #2
 800044c:	4313      	orrs	r3, r2
 800044e:	9303      	str	r3, [sp, #12]
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC3E;
 8000450:	9b03      	ldr	r3, [sp, #12]
 8000452:	2280      	movs	r2, #128	; 0x80
 8000454:	0052      	lsls	r2, r2, #1
 8000456:	4313      	orrs	r3, r2
 8000458:	9303      	str	r3, [sp, #12]
  default:
    ;
  }
  switch (pwmp->config->channels[3].mode & PWM_OUTPUT_MASK) {
 800045a:	9b01      	ldr	r3, [sp, #4]
 800045c:	685b      	ldr	r3, [r3, #4]
 800045e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000460:	220f      	movs	r2, #15
 8000462:	4013      	ands	r3, r2
 8000464:	2b01      	cmp	r3, #1
 8000466:	d006      	beq.n	8000476 <pwm_lld_start+0x176>
 8000468:	2b02      	cmp	r3, #2
 800046a:	d109      	bne.n	8000480 <pwm_lld_start+0x180>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC4P;
 800046c:	9b03      	ldr	r3, [sp, #12]
 800046e:	2280      	movs	r2, #128	; 0x80
 8000470:	0192      	lsls	r2, r2, #6
 8000472:	4313      	orrs	r3, r2
 8000474:	9303      	str	r3, [sp, #12]
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC4E;
 8000476:	9b03      	ldr	r3, [sp, #12]
 8000478:	2280      	movs	r2, #128	; 0x80
 800047a:	0152      	lsls	r2, r2, #5
 800047c:	4313      	orrs	r3, r2
 800047e:	9303      	str	r3, [sp, #12]
      ;
    }
  }
#endif /* STM32_PWM_USE_ADVANCED*/

  pwmp->tim->CCER  = ccer;
 8000480:	9b01      	ldr	r3, [sp, #4]
 8000482:	699b      	ldr	r3, [r3, #24]
 8000484:	9a03      	ldr	r2, [sp, #12]
 8000486:	621a      	str	r2, [r3, #32]
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
 8000488:	9b01      	ldr	r3, [sp, #4]
 800048a:	699b      	ldr	r3, [r3, #24]
 800048c:	2201      	movs	r2, #1
 800048e:	615a      	str	r2, [r3, #20]
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
 8000490:	9b01      	ldr	r3, [sp, #4]
 8000492:	699b      	ldr	r3, [r3, #24]
 8000494:	2200      	movs	r2, #0
 8000496:	611a      	str	r2, [r3, #16]
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 8000498:	9b01      	ldr	r3, [sp, #4]
 800049a:	699b      	ldr	r3, [r3, #24]
 800049c:	9a01      	ldr	r2, [sp, #4]
 800049e:	6852      	ldr	r2, [r2, #4]
 80004a0:	6b12      	ldr	r2, [r2, #48]	; 0x30
 80004a2:	21ff      	movs	r1, #255	; 0xff
 80004a4:	438a      	bics	r2, r1
 80004a6:	60da      	str	r2, [r3, #12]
                     ~STM32_TIM_DIER_IRQ_MASK;
#if STM32_PWM_USE_TIM1 || STM32_PWM_USE_TIM8
#if STM32_PWM_USE_ADVANCED
  pwmp->tim->BDTR  = pwmp->config->bdtr | STM32_TIM_BDTR_MOE;
#else
  pwmp->tim->BDTR  = STM32_TIM_BDTR_MOE;
 80004a8:	9b01      	ldr	r3, [sp, #4]
 80004aa:	699b      	ldr	r3, [r3, #24]
 80004ac:	2280      	movs	r2, #128	; 0x80
 80004ae:	0212      	lsls	r2, r2, #8
 80004b0:	645a      	str	r2, [r3, #68]	; 0x44
#endif
#endif
  /* Timer configured and started.*/
  pwmp->tim->CR1   = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS |
 80004b2:	9b01      	ldr	r3, [sp, #4]
 80004b4:	699b      	ldr	r3, [r3, #24]
 80004b6:	2285      	movs	r2, #133	; 0x85
 80004b8:	601a      	str	r2, [r3, #0]
                     STM32_TIM_CR1_CEN;
}
 80004ba:	b005      	add	sp, #20
 80004bc:	bd00      	pop	{pc}
 80004be:	46c0      	nop			; (mov r8, r8)
 80004c0:	20000df0 	.word	0x20000df0
 80004c4:	40021000 	.word	0x40021000
 80004c8:	02dc6c00 	.word	0x02dc6c00
 80004cc:	00006868 	.word	0x00006868
 80004d0:	0000ffff 	.word	0x0000ffff
 80004d4:	08003e7c 	.word	0x08003e7c
	...

080004e0 <pwm_lld_stop>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_stop(PWMDriver *pwmp) {
 80004e0:	b500      	push	{lr}
 80004e2:	b083      	sub	sp, #12
 80004e4:	9001      	str	r0, [sp, #4]

  /* If in ready state then disables the PWM clock.*/
  if (pwmp->state == PWM_READY) {
 80004e6:	9b01      	ldr	r3, [sp, #4]
 80004e8:	781b      	ldrb	r3, [r3, #0]
 80004ea:	2b02      	cmp	r3, #2
 80004ec:	d11f      	bne.n	800052e <pwm_lld_stop+0x4e>
    pwmp->tim->CR1  = 0;                    /* Timer disabled.              */
 80004ee:	9b01      	ldr	r3, [sp, #4]
 80004f0:	699b      	ldr	r3, [r3, #24]
 80004f2:	2200      	movs	r2, #0
 80004f4:	601a      	str	r2, [r3, #0]
    pwmp->tim->DIER = 0;                    /* All IRQs disabled.           */
 80004f6:	9b01      	ldr	r3, [sp, #4]
 80004f8:	699b      	ldr	r3, [r3, #24]
 80004fa:	2200      	movs	r2, #0
 80004fc:	60da      	str	r2, [r3, #12]
    pwmp->tim->SR   = 0;                    /* Clear eventual pending IRQs. */
 80004fe:	9b01      	ldr	r3, [sp, #4]
 8000500:	699b      	ldr	r3, [r3, #24]
 8000502:	2200      	movs	r2, #0
 8000504:	611a      	str	r2, [r3, #16]
#if STM32_PWM_USE_TIM1 || STM32_PWM_USE_TIM8
    pwmp->tim->BDTR  = 0;
 8000506:	9b01      	ldr	r3, [sp, #4]
 8000508:	699b      	ldr	r3, [r3, #24]
 800050a:	2200      	movs	r2, #0
 800050c:	645a      	str	r2, [r3, #68]	; 0x44
#endif

#if STM32_PWM_USE_TIM1
    if (&PWMD1 == pwmp) {
 800050e:	9a01      	ldr	r2, [sp, #4]
 8000510:	4b08      	ldr	r3, [pc, #32]	; (8000534 <pwm_lld_stop+0x54>)
 8000512:	429a      	cmp	r2, r3
 8000514:	d10b      	bne.n	800052e <pwm_lld_stop+0x4e>
#if !defined(STM32_TIM1_SUPPRESS_ISR)
      nvicDisableVector(STM32_TIM1_UP_NUMBER);
 8000516:	200d      	movs	r0, #13
 8000518:	f000 fc5a 	bl	8000dd0 <nvicDisableVector>
      nvicDisableVector(STM32_TIM1_CC_NUMBER);
 800051c:	200e      	movs	r0, #14
 800051e:	f000 fc57 	bl	8000dd0 <nvicDisableVector>
#endif
      rccDisableTIM1(FALSE);
 8000522:	4b05      	ldr	r3, [pc, #20]	; (8000538 <pwm_lld_stop+0x58>)
 8000524:	4a04      	ldr	r2, [pc, #16]	; (8000538 <pwm_lld_stop+0x58>)
 8000526:	6992      	ldr	r2, [r2, #24]
 8000528:	4904      	ldr	r1, [pc, #16]	; (800053c <pwm_lld_stop+0x5c>)
 800052a:	400a      	ands	r2, r1
 800052c:	619a      	str	r2, [r3, #24]
#endif
      rccDisableTIM9(FALSE);
    }
#endif
  }
}
 800052e:	b003      	add	sp, #12
 8000530:	bd00      	pop	{pc}
 8000532:	46c0      	nop			; (mov r8, r8)
 8000534:	20000df0 	.word	0x20000df0
 8000538:	40021000 	.word	0x40021000
 800053c:	fffff7ff 	.word	0xfffff7ff

08000540 <pwm_lld_enable_channel>:
 *
 * @notapi
 */
void pwm_lld_enable_channel(PWMDriver *pwmp,
                            pwmchannel_t channel,
                            pwmcnt_t width) {
 8000540:	b084      	sub	sp, #16
 8000542:	9003      	str	r0, [sp, #12]
 8000544:	9201      	str	r2, [sp, #4]
 8000546:	230b      	movs	r3, #11
 8000548:	446b      	add	r3, sp
 800054a:	1c0a      	adds	r2, r1, #0
 800054c:	701a      	strb	r2, [r3, #0]

  /* Changing channel duty cycle on the fly.*/
#if STM32_TIM_MAX_CHANNELS <= 4
  pwmp->tim->CCR[channel] = width;
 800054e:	9b03      	ldr	r3, [sp, #12]
 8000550:	699a      	ldr	r2, [r3, #24]
 8000552:	230b      	movs	r3, #11
 8000554:	446b      	add	r3, sp
 8000556:	781b      	ldrb	r3, [r3, #0]
 8000558:	330c      	adds	r3, #12
 800055a:	009b      	lsls	r3, r3, #2
 800055c:	18d3      	adds	r3, r2, r3
 800055e:	3304      	adds	r3, #4
 8000560:	9a01      	ldr	r2, [sp, #4]
 8000562:	601a      	str	r2, [r3, #0]
  if (channel < 4)
    pwmp->tim->CCR[channel] = width;
  else
    pwmp->tim->CCXR[channel - 4] = width;
#endif
}
 8000564:	b004      	add	sp, #16
 8000566:	4770      	bx	lr
	...

08000570 <pwm_lld_disable_channel>:
 * @param[in] pwmp      pointer to a @p PWMDriver object
 * @param[in] channel   PWM channel identifier (0...channels-1)
 *
 * @notapi
 */
void pwm_lld_disable_channel(PWMDriver *pwmp, pwmchannel_t channel) {
 8000570:	b082      	sub	sp, #8
 8000572:	9001      	str	r0, [sp, #4]
 8000574:	000a      	movs	r2, r1
 8000576:	466b      	mov	r3, sp
 8000578:	3303      	adds	r3, #3
 800057a:	701a      	strb	r2, [r3, #0]

#if STM32_TIM_MAX_CHANNELS <= 4
  pwmp->tim->CCR[channel] = 0;
 800057c:	9b01      	ldr	r3, [sp, #4]
 800057e:	699a      	ldr	r2, [r3, #24]
 8000580:	466b      	mov	r3, sp
 8000582:	3303      	adds	r3, #3
 8000584:	781b      	ldrb	r3, [r3, #0]
 8000586:	330c      	adds	r3, #12
 8000588:	009b      	lsls	r3, r3, #2
 800058a:	18d3      	adds	r3, r2, r3
 800058c:	3304      	adds	r3, #4
 800058e:	2200      	movs	r2, #0
 8000590:	601a      	str	r2, [r3, #0]
  pwmp->tim->DIER &= ~(2 << channel);
 8000592:	9b01      	ldr	r3, [sp, #4]
 8000594:	699b      	ldr	r3, [r3, #24]
 8000596:	9a01      	ldr	r2, [sp, #4]
 8000598:	6992      	ldr	r2, [r2, #24]
 800059a:	68d2      	ldr	r2, [r2, #12]
 800059c:	4669      	mov	r1, sp
 800059e:	3103      	adds	r1, #3
 80005a0:	7809      	ldrb	r1, [r1, #0]
 80005a2:	2002      	movs	r0, #2
 80005a4:	4088      	lsls	r0, r1
 80005a6:	0001      	movs	r1, r0
 80005a8:	43c9      	mvns	r1, r1
 80005aa:	400a      	ands	r2, r1
 80005ac:	60da      	str	r2, [r3, #12]
    pwmp->tim->DIER &= ~(2 << channel);
  }
  else
    pwmp->tim->CCXR[channel - 4] = 0;
#endif
}
 80005ae:	b002      	add	sp, #8
 80005b0:	4770      	bx	lr
 80005b2:	46c0      	nop			; (mov r8, r8)
	...

080005c0 <pwm_lld_enable_periodic_notification>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_enable_periodic_notification(PWMDriver *pwmp) {
 80005c0:	b084      	sub	sp, #16
 80005c2:	9001      	str	r0, [sp, #4]
  uint32_t dier = pwmp->tim->DIER;
 80005c4:	9b01      	ldr	r3, [sp, #4]
 80005c6:	699b      	ldr	r3, [r3, #24]
 80005c8:	68db      	ldr	r3, [r3, #12]
 80005ca:	9303      	str	r3, [sp, #12]

  /* If the IRQ is not already enabled care must be taken to clear it,
     it is probably already pending because the timer is running.*/
  if ((dier & STM32_TIM_DIER_UIE) == 0) {
 80005cc:	9b03      	ldr	r3, [sp, #12]
 80005ce:	2201      	movs	r2, #1
 80005d0:	4013      	ands	r3, r2
 80005d2:	d10d      	bne.n	80005f0 <pwm_lld_enable_periodic_notification+0x30>
    pwmp->tim->DIER = dier | STM32_TIM_DIER_UIE;
 80005d4:	9b01      	ldr	r3, [sp, #4]
 80005d6:	699b      	ldr	r3, [r3, #24]
 80005d8:	9a03      	ldr	r2, [sp, #12]
 80005da:	2101      	movs	r1, #1
 80005dc:	430a      	orrs	r2, r1
 80005de:	60da      	str	r2, [r3, #12]
    pwmp->tim->SR &= STM32_TIM_SR_UIF;
 80005e0:	9b01      	ldr	r3, [sp, #4]
 80005e2:	699b      	ldr	r3, [r3, #24]
 80005e4:	9a01      	ldr	r2, [sp, #4]
 80005e6:	6992      	ldr	r2, [r2, #24]
 80005e8:	6912      	ldr	r2, [r2, #16]
 80005ea:	2101      	movs	r1, #1
 80005ec:	400a      	ands	r2, r1
 80005ee:	611a      	str	r2, [r3, #16]
  }
}
 80005f0:	b004      	add	sp, #16
 80005f2:	4770      	bx	lr
	...

08000600 <pwm_lld_enable_channel_notification>:
 * @param[in] channel   PWM channel identifier (0...channels-1)
 *
 * @notapi
 */
void pwm_lld_enable_channel_notification(PWMDriver *pwmp,
                                         pwmchannel_t channel) {
 8000600:	b084      	sub	sp, #16
 8000602:	9001      	str	r0, [sp, #4]
 8000604:	000a      	movs	r2, r1
 8000606:	466b      	mov	r3, sp
 8000608:	3303      	adds	r3, #3
 800060a:	701a      	strb	r2, [r3, #0]
  uint32_t dier = pwmp->tim->DIER;
 800060c:	9b01      	ldr	r3, [sp, #4]
 800060e:	699b      	ldr	r3, [r3, #24]
 8000610:	68db      	ldr	r3, [r3, #12]
 8000612:	9303      	str	r3, [sp, #12]
  osalDbgAssert(channel < 4, "callback not supported");
#endif

  /* If the IRQ is not already enabled care must be taken to clear it,
     it is probably already pending because the timer is running.*/
  if ((dier & (2 << channel)) == 0) {
 8000614:	466b      	mov	r3, sp
 8000616:	3303      	adds	r3, #3
 8000618:	781b      	ldrb	r3, [r3, #0]
 800061a:	2202      	movs	r2, #2
 800061c:	409a      	lsls	r2, r3
 800061e:	0013      	movs	r3, r2
 8000620:	001a      	movs	r2, r3
 8000622:	9b03      	ldr	r3, [sp, #12]
 8000624:	4013      	ands	r3, r2
 8000626:	d115      	bne.n	8000654 <pwm_lld_enable_channel_notification+0x54>
    pwmp->tim->DIER = dier | (2 << channel);
 8000628:	9b01      	ldr	r3, [sp, #4]
 800062a:	699b      	ldr	r3, [r3, #24]
 800062c:	466a      	mov	r2, sp
 800062e:	3203      	adds	r2, #3
 8000630:	7812      	ldrb	r2, [r2, #0]
 8000632:	2102      	movs	r1, #2
 8000634:	4091      	lsls	r1, r2
 8000636:	000a      	movs	r2, r1
 8000638:	0011      	movs	r1, r2
 800063a:	9a03      	ldr	r2, [sp, #12]
 800063c:	430a      	orrs	r2, r1
 800063e:	60da      	str	r2, [r3, #12]
    pwmp->tim->SR   = ~(2 << channel);
 8000640:	9b01      	ldr	r3, [sp, #4]
 8000642:	699b      	ldr	r3, [r3, #24]
 8000644:	466a      	mov	r2, sp
 8000646:	3203      	adds	r2, #3
 8000648:	7812      	ldrb	r2, [r2, #0]
 800064a:	2102      	movs	r1, #2
 800064c:	4091      	lsls	r1, r2
 800064e:	000a      	movs	r2, r1
 8000650:	43d2      	mvns	r2, r2
 8000652:	611a      	str	r2, [r3, #16]
  }
}
 8000654:	b004      	add	sp, #16
 8000656:	4770      	bx	lr
	...

08000660 <pwm_lld_serve_interrupt>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
 8000660:	b500      	push	{lr}
 8000662:	b085      	sub	sp, #20
 8000664:	9001      	str	r0, [sp, #4]
  uint32_t sr;

  sr  = pwmp->tim->SR;
 8000666:	9b01      	ldr	r3, [sp, #4]
 8000668:	699b      	ldr	r3, [r3, #24]
 800066a:	691b      	ldr	r3, [r3, #16]
 800066c:	9303      	str	r3, [sp, #12]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 800066e:	9b01      	ldr	r3, [sp, #4]
 8000670:	699b      	ldr	r3, [r3, #24]
 8000672:	68db      	ldr	r3, [r3, #12]
 8000674:	22ff      	movs	r2, #255	; 0xff
 8000676:	401a      	ands	r2, r3
 8000678:	9b03      	ldr	r3, [sp, #12]
 800067a:	4013      	ands	r3, r2
 800067c:	9303      	str	r3, [sp, #12]
  pwmp->tim->SR = ~sr;
 800067e:	9b01      	ldr	r3, [sp, #4]
 8000680:	699b      	ldr	r3, [r3, #24]
 8000682:	9a03      	ldr	r2, [sp, #12]
 8000684:	43d2      	mvns	r2, r2
 8000686:	611a      	str	r2, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8000688:	9b03      	ldr	r3, [sp, #12]
 800068a:	2202      	movs	r2, #2
 800068c:	4013      	ands	r3, r2
 800068e:	d00a      	beq.n	80006a6 <pwm_lld_serve_interrupt+0x46>
      (pwmp->config->channels[0].callback != NULL))
 8000690:	9b01      	ldr	r3, [sp, #4]
 8000692:	685b      	ldr	r3, [r3, #4]
 8000694:	691b      	ldr	r3, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8000696:	2b00      	cmp	r3, #0
 8000698:	d005      	beq.n	80006a6 <pwm_lld_serve_interrupt+0x46>
    pwmp->config->channels[0].callback(pwmp);
 800069a:	9b01      	ldr	r3, [sp, #4]
 800069c:	685b      	ldr	r3, [r3, #4]
 800069e:	691b      	ldr	r3, [r3, #16]
 80006a0:	9a01      	ldr	r2, [sp, #4]
 80006a2:	0010      	movs	r0, r2
 80006a4:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 80006a6:	9b03      	ldr	r3, [sp, #12]
 80006a8:	2204      	movs	r2, #4
 80006aa:	4013      	ands	r3, r2
 80006ac:	d00a      	beq.n	80006c4 <pwm_lld_serve_interrupt+0x64>
      (pwmp->config->channels[1].callback != NULL))
 80006ae:	9b01      	ldr	r3, [sp, #4]
 80006b0:	685b      	ldr	r3, [r3, #4]
 80006b2:	699b      	ldr	r3, [r3, #24]
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 80006b4:	2b00      	cmp	r3, #0
 80006b6:	d005      	beq.n	80006c4 <pwm_lld_serve_interrupt+0x64>
    pwmp->config->channels[1].callback(pwmp);
 80006b8:	9b01      	ldr	r3, [sp, #4]
 80006ba:	685b      	ldr	r3, [r3, #4]
 80006bc:	699b      	ldr	r3, [r3, #24]
 80006be:	9a01      	ldr	r2, [sp, #4]
 80006c0:	0010      	movs	r0, r2
 80006c2:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 80006c4:	9b03      	ldr	r3, [sp, #12]
 80006c6:	2208      	movs	r2, #8
 80006c8:	4013      	ands	r3, r2
 80006ca:	d00a      	beq.n	80006e2 <pwm_lld_serve_interrupt+0x82>
      (pwmp->config->channels[2].callback != NULL))
 80006cc:	9b01      	ldr	r3, [sp, #4]
 80006ce:	685b      	ldr	r3, [r3, #4]
 80006d0:	6a1b      	ldr	r3, [r3, #32]
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 80006d2:	2b00      	cmp	r3, #0
 80006d4:	d005      	beq.n	80006e2 <pwm_lld_serve_interrupt+0x82>
    pwmp->config->channels[2].callback(pwmp);
 80006d6:	9b01      	ldr	r3, [sp, #4]
 80006d8:	685b      	ldr	r3, [r3, #4]
 80006da:	6a1b      	ldr	r3, [r3, #32]
 80006dc:	9a01      	ldr	r2, [sp, #4]
 80006de:	0010      	movs	r0, r2
 80006e0:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 80006e2:	9b03      	ldr	r3, [sp, #12]
 80006e4:	2210      	movs	r2, #16
 80006e6:	4013      	ands	r3, r2
 80006e8:	d00a      	beq.n	8000700 <pwm_lld_serve_interrupt+0xa0>
      (pwmp->config->channels[3].callback != NULL))
 80006ea:	9b01      	ldr	r3, [sp, #4]
 80006ec:	685b      	ldr	r3, [r3, #4]
 80006ee:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 80006f0:	2b00      	cmp	r3, #0
 80006f2:	d005      	beq.n	8000700 <pwm_lld_serve_interrupt+0xa0>
    pwmp->config->channels[3].callback(pwmp);
 80006f4:	9b01      	ldr	r3, [sp, #4]
 80006f6:	685b      	ldr	r3, [r3, #4]
 80006f8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80006fa:	9a01      	ldr	r2, [sp, #4]
 80006fc:	0010      	movs	r0, r2
 80006fe:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
 8000700:	9b03      	ldr	r3, [sp, #12]
 8000702:	2201      	movs	r2, #1
 8000704:	4013      	ands	r3, r2
 8000706:	d00a      	beq.n	800071e <pwm_lld_serve_interrupt+0xbe>
 8000708:	9b01      	ldr	r3, [sp, #4]
 800070a:	685b      	ldr	r3, [r3, #4]
 800070c:	689b      	ldr	r3, [r3, #8]
 800070e:	2b00      	cmp	r3, #0
 8000710:	d005      	beq.n	800071e <pwm_lld_serve_interrupt+0xbe>
    pwmp->config->callback(pwmp);
 8000712:	9b01      	ldr	r3, [sp, #4]
 8000714:	685b      	ldr	r3, [r3, #4]
 8000716:	689b      	ldr	r3, [r3, #8]
 8000718:	9a01      	ldr	r2, [sp, #4]
 800071a:	0010      	movs	r0, r2
 800071c:	4798      	blx	r3
}
 800071e:	b005      	add	sp, #20
 8000720:	bd00      	pop	{pc}
 8000722:	46c0      	nop			; (mov r8, r8)
	...

08000730 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
 8000730:	b510      	push	{r4, lr}

  stm32_clock_init();
 8000732:	f000 fbd5 	bl	8000ee0 <stm32_clock_init>
}
 8000736:	bd10      	pop	{r4, pc}
	...

08000740 <boardInit>:
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
}
 8000740:	4770      	bx	lr
 8000742:	46c0      	nop			; (mov r8, r8)
	...

08000750 <pwmpcb>:

#include "ch.h"
#include "hal.h"
#include "board.h"

static void pwmpcb(PWMDriver *pwmp) {
 8000750:	b082      	sub	sp, #8
 8000752:	9001      	str	r0, [sp, #4]

  (void)pwmp;
//  palClearPad(GPIOC, GPIOC_LED4);
  palClearPad(GPIOC, GPIOC_PIN8);
 8000754:	4b02      	ldr	r3, [pc, #8]	; (8000760 <pwmpcb+0x10>)
 8000756:	2280      	movs	r2, #128	; 0x80
 8000758:	0052      	lsls	r2, r2, #1
 800075a:	835a      	strh	r2, [r3, #26]
}
 800075c:	b002      	add	sp, #8
 800075e:	4770      	bx	lr
 8000760:	48000800 	.word	0x48000800
	...

08000770 <pwmc1cb>:

static void pwmc1cb(PWMDriver *pwmp) {
 8000770:	b082      	sub	sp, #8
 8000772:	9001      	str	r0, [sp, #4]

  (void)pwmp;
//  palSetPad(GPIOC, GPIOC_LED4);
  palSetPad(GPIOC, GPIOC_PIN8);
 8000774:	4b02      	ldr	r3, [pc, #8]	; (8000780 <pwmc1cb+0x10>)
 8000776:	2280      	movs	r2, #128	; 0x80
 8000778:	0052      	lsls	r2, r2, #1
 800077a:	831a      	strh	r2, [r3, #24]
}
 800077c:	b002      	add	sp, #8
 800077e:	4770      	bx	lr
 8000780:	48000800 	.word	0x48000800
	...

08000790 <icuwidthcb>:
  0
};

icucnt_t last_width, last_period;

static void icuwidthcb(ICUDriver *icup) {
 8000790:	b082      	sub	sp, #8
 8000792:	9001      	str	r0, [sp, #4]

//  palSetPad(GPIOC, GPIOC_LED3);
  palSetPad(GPIOC, GPIOC_PIN9);
 8000794:	4b05      	ldr	r3, [pc, #20]	; (80007ac <icuwidthcb+0x1c>)
 8000796:	2280      	movs	r2, #128	; 0x80
 8000798:	0092      	lsls	r2, r2, #2
 800079a:	831a      	strh	r2, [r3, #24]
  last_width = icuGetWidthX(icup);
 800079c:	9b01      	ldr	r3, [sp, #4]
 800079e:	691b      	ldr	r3, [r3, #16]
 80007a0:	681b      	ldr	r3, [r3, #0]
 80007a2:	1c5a      	adds	r2, r3, #1
 80007a4:	4b02      	ldr	r3, [pc, #8]	; (80007b0 <icuwidthcb+0x20>)
 80007a6:	601a      	str	r2, [r3, #0]
}
 80007a8:	b002      	add	sp, #8
 80007aa:	4770      	bx	lr
 80007ac:	48000800 	.word	0x48000800
 80007b0:	20000e0c 	.word	0x20000e0c
	...

080007c0 <icuperiodcb>:

static void icuperiodcb(ICUDriver *icup) {
 80007c0:	b082      	sub	sp, #8
 80007c2:	9001      	str	r0, [sp, #4]

//  palClearPad(GPIOC, GPIOC_LED3);
  palClearPad(GPIOC, GPIOC_PIN9);
 80007c4:	4b05      	ldr	r3, [pc, #20]	; (80007dc <icuperiodcb+0x1c>)
 80007c6:	2280      	movs	r2, #128	; 0x80
 80007c8:	0092      	lsls	r2, r2, #2
 80007ca:	835a      	strh	r2, [r3, #26]
  last_period = icuGetPeriodX(icup);
 80007cc:	9b01      	ldr	r3, [sp, #4]
 80007ce:	695b      	ldr	r3, [r3, #20]
 80007d0:	681b      	ldr	r3, [r3, #0]
 80007d2:	1c5a      	adds	r2, r3, #1
 80007d4:	4b02      	ldr	r3, [pc, #8]	; (80007e0 <icuperiodcb+0x20>)
 80007d6:	601a      	str	r2, [r3, #0]
}
 80007d8:	b002      	add	sp, #8
 80007da:	4770      	bx	lr
 80007dc:	48000800 	.word	0x48000800
 80007e0:	20000e10 	.word	0x20000e10
	...

080007f0 <icuoverflowcb>:

static void icuoverflowcb(ICUDriver *icup) {
 80007f0:	b082      	sub	sp, #8
 80007f2:	9001      	str	r0, [sp, #4]

  (void)icup;
}
 80007f4:	b002      	add	sp, #8
 80007f6:	4770      	bx	lr
	...

08000800 <main>:
};

/*
 * Application entry point.
 */
int main(void) {
 8000800:	b510      	push	{r4, lr}
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 8000802:	f001 fbb5 	bl	8001f70 <halInit>
  chSysInit();
 8000806:	f002 f9d3 	bl	8002bb0 <chSysInit>
   * Initializes the PWM driver 2 and ICU driver 3.
   * GPIOA6 is the ICU input (CH1).
   * GPIOA8 is the PWM output (CH1).
   * The two pins have to be externally connected together.
   */
  pwmStart(&PWMD1, &pwmcfg);
 800080a:	4a49      	ldr	r2, [pc, #292]	; (8000930 <main+0x130>)
 800080c:	4b49      	ldr	r3, [pc, #292]	; (8000934 <main+0x134>)
 800080e:	0011      	movs	r1, r2
 8000810:	0018      	movs	r0, r3
 8000812:	f000 f8a5 	bl	8000960 <pwmStart>
  pwmEnablePeriodicNotification(&PWMD1);
 8000816:	4b47      	ldr	r3, [pc, #284]	; (8000934 <main+0x134>)
 8000818:	0018      	movs	r0, r3
 800081a:	f000 f9b1 	bl	8000b80 <pwmEnablePeriodicNotification>
  palSetPadMode(GPIOA, 8, PAL_MODE_ALTERNATE(2));
 800081e:	2381      	movs	r3, #129	; 0x81
 8000820:	005a      	lsls	r2, r3, #1
 8000822:	2380      	movs	r3, #128	; 0x80
 8000824:	0059      	lsls	r1, r3, #1
 8000826:	2390      	movs	r3, #144	; 0x90
 8000828:	05db      	lsls	r3, r3, #23
 800082a:	0018      	movs	r0, r3
 800082c:	f000 fc20 	bl	8001070 <_pal_lld_setgroupmode>
  icuStart(&ICUD3, &icucfg);
 8000830:	4a41      	ldr	r2, [pc, #260]	; (8000938 <main+0x138>)
 8000832:	4b42      	ldr	r3, [pc, #264]	; (800093c <main+0x13c>)
 8000834:	0011      	movs	r1, r2
 8000836:	0018      	movs	r0, r3
 8000838:	f001 f842 	bl	80018c0 <icuStart>
  palSetPadMode(GPIOA, 6, PAL_MODE_ALTERNATE(1));
 800083c:	2390      	movs	r3, #144	; 0x90
 800083e:	05db      	lsls	r3, r3, #23
 8000840:	2282      	movs	r2, #130	; 0x82
 8000842:	2140      	movs	r1, #64	; 0x40
 8000844:	0018      	movs	r0, r3
 8000846:	f000 fc13 	bl	8001070 <_pal_lld_setgroupmode>
  icuStartCapture(&ICUD3);
 800084a:	4b3c      	ldr	r3, [pc, #240]	; (800093c <main+0x13c>)
 800084c:	0018      	movs	r0, r3
 800084e:	f001 f88f 	bl	8001970 <icuStartCapture>
  icuEnableNotifications(&ICUD3);
 8000852:	4b3a      	ldr	r3, [pc, #232]	; (800093c <main+0x13c>)
 8000854:	0018      	movs	r0, r3
 8000856:	f001 f8e3 	bl	8001a20 <icuEnableNotifications>
  chThdSleepMilliseconds(2000);
 800085a:	4b39      	ldr	r3, [pc, #228]	; (8000940 <main+0x140>)
 800085c:	0018      	movs	r0, r3
 800085e:	f001 fe5f 	bl	8002520 <chThdSleep>

  /*
   * Starts the PWM channel 0 using 75% duty cycle.
   */
  pwmEnableChannel(&PWMD1, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD1, 7500));
 8000862:	4b34      	ldr	r3, [pc, #208]	; (8000934 <main+0x134>)
 8000864:	689b      	ldr	r3, [r3, #8]
 8000866:	4a37      	ldr	r2, [pc, #220]	; (8000944 <main+0x144>)
 8000868:	4353      	muls	r3, r2
 800086a:	4937      	ldr	r1, [pc, #220]	; (8000948 <main+0x148>)
 800086c:	0018      	movs	r0, r3
 800086e:	f7ff fcb5 	bl	80001dc <__aeabi_uidiv>
 8000872:	0003      	movs	r3, r0
 8000874:	001a      	movs	r2, r3
 8000876:	4b2f      	ldr	r3, [pc, #188]	; (8000934 <main+0x134>)
 8000878:	2100      	movs	r1, #0
 800087a:	0018      	movs	r0, r3
 800087c:	f000 f900 	bl	8000a80 <pwmEnableChannel>
  pwmEnableChannelNotification(&PWMD1, 0);
 8000880:	4b2c      	ldr	r3, [pc, #176]	; (8000934 <main+0x134>)
 8000882:	2100      	movs	r1, #0
 8000884:	0018      	movs	r0, r3
 8000886:	f000 f9a3 	bl	8000bd0 <pwmEnableChannelNotification>
  chThdSleepMilliseconds(5000);
 800088a:	4b30      	ldr	r3, [pc, #192]	; (800094c <main+0x14c>)
 800088c:	0018      	movs	r0, r3
 800088e:	f001 fe47 	bl	8002520 <chThdSleep>

  /*
   * Changes the PWM channel 0 to 50% duty cycle.
   */
  pwmEnableChannel(&PWMD1, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD1, 5000));
 8000892:	4b28      	ldr	r3, [pc, #160]	; (8000934 <main+0x134>)
 8000894:	689b      	ldr	r3, [r3, #8]
 8000896:	4a2e      	ldr	r2, [pc, #184]	; (8000950 <main+0x150>)
 8000898:	4353      	muls	r3, r2
 800089a:	492b      	ldr	r1, [pc, #172]	; (8000948 <main+0x148>)
 800089c:	0018      	movs	r0, r3
 800089e:	f7ff fc9d 	bl	80001dc <__aeabi_uidiv>
 80008a2:	0003      	movs	r3, r0
 80008a4:	001a      	movs	r2, r3
 80008a6:	4b23      	ldr	r3, [pc, #140]	; (8000934 <main+0x134>)
 80008a8:	2100      	movs	r1, #0
 80008aa:	0018      	movs	r0, r3
 80008ac:	f000 f8e8 	bl	8000a80 <pwmEnableChannel>
  chThdSleepMilliseconds(5000);
 80008b0:	4b26      	ldr	r3, [pc, #152]	; (800094c <main+0x14c>)
 80008b2:	0018      	movs	r0, r3
 80008b4:	f001 fe34 	bl	8002520 <chThdSleep>

  /*
   * Changes the PWM channel 0 to 25% duty cycle.
   */
  pwmEnableChannel(&PWMD1, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD1, 2500));
 80008b8:	4b1e      	ldr	r3, [pc, #120]	; (8000934 <main+0x134>)
 80008ba:	689b      	ldr	r3, [r3, #8]
 80008bc:	4a25      	ldr	r2, [pc, #148]	; (8000954 <main+0x154>)
 80008be:	4353      	muls	r3, r2
 80008c0:	4921      	ldr	r1, [pc, #132]	; (8000948 <main+0x148>)
 80008c2:	0018      	movs	r0, r3
 80008c4:	f7ff fc8a 	bl	80001dc <__aeabi_uidiv>
 80008c8:	0003      	movs	r3, r0
 80008ca:	001a      	movs	r2, r3
 80008cc:	4b19      	ldr	r3, [pc, #100]	; (8000934 <main+0x134>)
 80008ce:	2100      	movs	r1, #0
 80008d0:	0018      	movs	r0, r3
 80008d2:	f000 f8d5 	bl	8000a80 <pwmEnableChannel>
  chThdSleepMilliseconds(5000);
 80008d6:	4b1d      	ldr	r3, [pc, #116]	; (800094c <main+0x14c>)
 80008d8:	0018      	movs	r0, r3
 80008da:	f001 fe21 	bl	8002520 <chThdSleep>

  /*
   * Changes PWM period to half second the duty cycle becomes 50%
   * implicitly.
   */
  pwmChangePeriod(&PWMD1, 5000);
 80008de:	4a1c      	ldr	r2, [pc, #112]	; (8000950 <main+0x150>)
 80008e0:	4b14      	ldr	r3, [pc, #80]	; (8000934 <main+0x134>)
 80008e2:	0011      	movs	r1, r2
 80008e4:	0018      	movs	r0, r3
 80008e6:	f000 f8a3 	bl	8000a30 <pwmChangePeriod>
  chThdSleepMilliseconds(5000);
 80008ea:	4b18      	ldr	r3, [pc, #96]	; (800094c <main+0x14c>)
 80008ec:	0018      	movs	r0, r3
 80008ee:	f001 fe17 	bl	8002520 <chThdSleep>

  /*
   * Disables channel 0 and stops the drivers.
   */
  pwmDisableChannel(&PWMD1, 0);
 80008f2:	4b10      	ldr	r3, [pc, #64]	; (8000934 <main+0x134>)
 80008f4:	2100      	movs	r1, #0
 80008f6:	0018      	movs	r0, r3
 80008f8:	f000 f902 	bl	8000b00 <pwmDisableChannel>
  pwmStop(&PWMD1);
 80008fc:	4b0d      	ldr	r3, [pc, #52]	; (8000934 <main+0x134>)
 80008fe:	0018      	movs	r0, r3
 8000900:	f000 f866 	bl	80009d0 <pwmStop>
  icuStopCapture(&ICUD3);
 8000904:	4b0d      	ldr	r3, [pc, #52]	; (800093c <main+0x13c>)
 8000906:	0018      	movs	r0, r3
 8000908:	f001 f85a 	bl	80019c0 <icuStopCapture>
  icuStop(&ICUD3);
 800090c:	4b0b      	ldr	r3, [pc, #44]	; (800093c <main+0x13c>)
 800090e:	0018      	movs	r0, r3
 8000910:	f001 f806 	bl	8001920 <icuStop>
//  palClearPad(GPIOC, GPIOC_LED3);
  palClearPad(GPIOC, GPIOC_PIN9);
 8000914:	4b10      	ldr	r3, [pc, #64]	; (8000958 <main+0x158>)
 8000916:	2280      	movs	r2, #128	; 0x80
 8000918:	0092      	lsls	r2, r2, #2
 800091a:	835a      	strh	r2, [r3, #26]
//  palClearPad(GPIOC, GPIOC_LED4);
  palClearPad(GPIOC, GPIOC_PIN8);
 800091c:	4b0e      	ldr	r3, [pc, #56]	; (8000958 <main+0x158>)
 800091e:	2280      	movs	r2, #128	; 0x80
 8000920:	0052      	lsls	r2, r2, #1
 8000922:	835a      	strh	r2, [r3, #26]

  /*
   * Normal main() thread activity, in this demo it does nothing.
   */
  while (true) {
    chThdSleepMilliseconds(500);
 8000924:	4b0a      	ldr	r3, [pc, #40]	; (8000950 <main+0x150>)
 8000926:	0018      	movs	r0, r3
 8000928:	f001 fdfa 	bl	8002520 <chThdSleep>
 800092c:	e7fa      	b.n	8000924 <main+0x124>
 800092e:	46c0      	nop			; (mov r8, r8)
 8000930:	20000400 	.word	0x20000400
 8000934:	20000df0 	.word	0x20000df0
 8000938:	20000434 	.word	0x20000434
 800093c:	20000dd8 	.word	0x20000dd8
 8000940:	00004e20 	.word	0x00004e20
 8000944:	00001d4c 	.word	0x00001d4c
 8000948:	00002710 	.word	0x00002710
 800094c:	0000c350 	.word	0x0000c350
 8000950:	00001388 	.word	0x00001388
 8000954:	000009c4 	.word	0x000009c4
 8000958:	48000800 	.word	0x48000800
 800095c:	00000000 	.word	0x00000000

08000960 <pwmStart>:
 * @param[in] pwmp      pointer to a @p PWMDriver object
 * @param[in] config    pointer to a @p PWMConfig object
 *
 * @api
 */
void pwmStart(PWMDriver *pwmp, const PWMConfig *config) {
 8000960:	b500      	push	{lr}
 8000962:	b083      	sub	sp, #12
 8000964:	9001      	str	r0, [sp, #4]
 8000966:	9100      	str	r1, [sp, #0]

  osalDbgCheck((pwmp != NULL) && (config != NULL));
 8000968:	9b01      	ldr	r3, [sp, #4]
 800096a:	2b00      	cmp	r3, #0
 800096c:	d002      	beq.n	8000974 <pwmStart+0x14>
 800096e:	9b00      	ldr	r3, [sp, #0]
 8000970:	2b00      	cmp	r3, #0
 8000972:	d103      	bne.n	800097c <pwmStart+0x1c>
 8000974:	4b13      	ldr	r3, [pc, #76]	; (80009c4 <pwmStart+0x64>)
 8000976:	0018      	movs	r0, r3
 8000978:	f002 f952 	bl	8002c20 <chSysHalt>

  osalSysLock();
 800097c:	f001 f8b0 	bl	8001ae0 <osalSysLock.lto_priv.66>
  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
 8000980:	9b01      	ldr	r3, [sp, #4]
 8000982:	781b      	ldrb	r3, [r3, #0]
 8000984:	2b01      	cmp	r3, #1
 8000986:	d007      	beq.n	8000998 <pwmStart+0x38>
 8000988:	9b01      	ldr	r3, [sp, #4]
 800098a:	781b      	ldrb	r3, [r3, #0]
 800098c:	2b02      	cmp	r3, #2
 800098e:	d003      	beq.n	8000998 <pwmStart+0x38>
 8000990:	4b0c      	ldr	r3, [pc, #48]	; (80009c4 <pwmStart+0x64>)
 8000992:	0018      	movs	r0, r3
 8000994:	f002 f944 	bl	8002c20 <chSysHalt>
                "invalid state");
  pwmp->config = config;
 8000998:	9b01      	ldr	r3, [sp, #4]
 800099a:	9a00      	ldr	r2, [sp, #0]
 800099c:	605a      	str	r2, [r3, #4]
  pwmp->period = config->period;
 800099e:	9b00      	ldr	r3, [sp, #0]
 80009a0:	685a      	ldr	r2, [r3, #4]
 80009a2:	9b01      	ldr	r3, [sp, #4]
 80009a4:	609a      	str	r2, [r3, #8]
  pwm_lld_start(pwmp);
 80009a6:	9b01      	ldr	r3, [sp, #4]
 80009a8:	0018      	movs	r0, r3
 80009aa:	f7ff fca9 	bl	8000300 <pwm_lld_start>
  pwmp->enabled = 0;
 80009ae:	9b01      	ldr	r3, [sp, #4]
 80009b0:	2200      	movs	r2, #0
 80009b2:	60da      	str	r2, [r3, #12]
  pwmp->state = PWM_READY;
 80009b4:	9b01      	ldr	r3, [sp, #4]
 80009b6:	2202      	movs	r2, #2
 80009b8:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 80009ba:	f001 f899 	bl	8001af0 <osalSysUnlock.lto_priv.64>
}
 80009be:	b003      	add	sp, #12
 80009c0:	bd00      	pop	{pc}
 80009c2:	46c0      	nop			; (mov r8, r8)
 80009c4:	08003d88 	.word	0x08003d88
	...

080009d0 <pwmStop>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @api
 */
void pwmStop(PWMDriver *pwmp) {
 80009d0:	b500      	push	{lr}
 80009d2:	b083      	sub	sp, #12
 80009d4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(pwmp != NULL);
 80009d6:	9b01      	ldr	r3, [sp, #4]
 80009d8:	2b00      	cmp	r3, #0
 80009da:	d103      	bne.n	80009e4 <pwmStop+0x14>
 80009dc:	4b11      	ldr	r3, [pc, #68]	; (8000a24 <pwmStop+0x54>)
 80009de:	0018      	movs	r0, r3
 80009e0:	f002 f91e 	bl	8002c20 <chSysHalt>

  osalSysLock();
 80009e4:	f001 f87c 	bl	8001ae0 <osalSysLock.lto_priv.66>

  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
 80009e8:	9b01      	ldr	r3, [sp, #4]
 80009ea:	781b      	ldrb	r3, [r3, #0]
 80009ec:	2b01      	cmp	r3, #1
 80009ee:	d007      	beq.n	8000a00 <pwmStop+0x30>
 80009f0:	9b01      	ldr	r3, [sp, #4]
 80009f2:	781b      	ldrb	r3, [r3, #0]
 80009f4:	2b02      	cmp	r3, #2
 80009f6:	d003      	beq.n	8000a00 <pwmStop+0x30>
 80009f8:	4b0a      	ldr	r3, [pc, #40]	; (8000a24 <pwmStop+0x54>)
 80009fa:	0018      	movs	r0, r3
 80009fc:	f002 f910 	bl	8002c20 <chSysHalt>
                "invalid state");

  pwm_lld_stop(pwmp);
 8000a00:	9b01      	ldr	r3, [sp, #4]
 8000a02:	0018      	movs	r0, r3
 8000a04:	f7ff fd6c 	bl	80004e0 <pwm_lld_stop>
  pwmp->enabled = 0;
 8000a08:	9b01      	ldr	r3, [sp, #4]
 8000a0a:	2200      	movs	r2, #0
 8000a0c:	60da      	str	r2, [r3, #12]
  pwmp->config  = NULL;
 8000a0e:	9b01      	ldr	r3, [sp, #4]
 8000a10:	2200      	movs	r2, #0
 8000a12:	605a      	str	r2, [r3, #4]
  pwmp->state   = PWM_STOP;
 8000a14:	9b01      	ldr	r3, [sp, #4]
 8000a16:	2201      	movs	r2, #1
 8000a18:	701a      	strb	r2, [r3, #0]

  osalSysUnlock();
 8000a1a:	f001 f869 	bl	8001af0 <osalSysUnlock.lto_priv.64>
}
 8000a1e:	b003      	add	sp, #12
 8000a20:	bd00      	pop	{pc}
 8000a22:	46c0      	nop			; (mov r8, r8)
 8000a24:	08003da0 	.word	0x08003da0
	...

08000a30 <pwmChangePeriod>:
 * @param[in] pwmp      pointer to a @p PWMDriver object
 * @param[in] period    new cycle time in ticks
 *
 * @api
 */
void pwmChangePeriod(PWMDriver *pwmp, pwmcnt_t period) {
 8000a30:	b500      	push	{lr}
 8000a32:	b083      	sub	sp, #12
 8000a34:	9001      	str	r0, [sp, #4]
 8000a36:	9100      	str	r1, [sp, #0]

  osalDbgCheck(pwmp != NULL);
 8000a38:	9b01      	ldr	r3, [sp, #4]
 8000a3a:	2b00      	cmp	r3, #0
 8000a3c:	d103      	bne.n	8000a46 <pwmChangePeriod+0x16>
 8000a3e:	4b0d      	ldr	r3, [pc, #52]	; (8000a74 <pwmChangePeriod+0x44>)
 8000a40:	0018      	movs	r0, r3
 8000a42:	f002 f8ed 	bl	8002c20 <chSysHalt>

  osalSysLock();
 8000a46:	f001 f84b 	bl	8001ae0 <osalSysLock.lto_priv.66>
  osalDbgAssert(pwmp->state == PWM_READY, "invalid state");
 8000a4a:	9b01      	ldr	r3, [sp, #4]
 8000a4c:	781b      	ldrb	r3, [r3, #0]
 8000a4e:	2b02      	cmp	r3, #2
 8000a50:	d003      	beq.n	8000a5a <pwmChangePeriod+0x2a>
 8000a52:	4b08      	ldr	r3, [pc, #32]	; (8000a74 <pwmChangePeriod+0x44>)
 8000a54:	0018      	movs	r0, r3
 8000a56:	f002 f8e3 	bl	8002c20 <chSysHalt>
  pwmChangePeriodI(pwmp, period);
 8000a5a:	9b01      	ldr	r3, [sp, #4]
 8000a5c:	9a00      	ldr	r2, [sp, #0]
 8000a5e:	609a      	str	r2, [r3, #8]
 8000a60:	9b01      	ldr	r3, [sp, #4]
 8000a62:	699b      	ldr	r3, [r3, #24]
 8000a64:	9a00      	ldr	r2, [sp, #0]
 8000a66:	3a01      	subs	r2, #1
 8000a68:	62da      	str	r2, [r3, #44]	; 0x2c
  osalSysUnlock();
 8000a6a:	f001 f841 	bl	8001af0 <osalSysUnlock.lto_priv.64>
}
 8000a6e:	b003      	add	sp, #12
 8000a70:	bd00      	pop	{pc}
 8000a72:	46c0      	nop			; (mov r8, r8)
 8000a74:	08003da8 	.word	0x08003da8
	...

08000a80 <pwmEnableChannel>:
 *
 * @api
 */
void pwmEnableChannel(PWMDriver *pwmp,
                      pwmchannel_t channel,
                      pwmcnt_t width) {
 8000a80:	b500      	push	{lr}
 8000a82:	b085      	sub	sp, #20
 8000a84:	9003      	str	r0, [sp, #12]
 8000a86:	9201      	str	r2, [sp, #4]
 8000a88:	230b      	movs	r3, #11
 8000a8a:	446b      	add	r3, sp
 8000a8c:	1c0a      	adds	r2, r1, #0
 8000a8e:	701a      	strb	r2, [r3, #0]

  osalDbgCheck((pwmp != NULL) && (channel < pwmp->channels));
 8000a90:	9b03      	ldr	r3, [sp, #12]
 8000a92:	2b00      	cmp	r3, #0
 8000a94:	d006      	beq.n	8000aa4 <pwmEnableChannel+0x24>
 8000a96:	9b03      	ldr	r3, [sp, #12]
 8000a98:	7c1b      	ldrb	r3, [r3, #16]
 8000a9a:	220b      	movs	r2, #11
 8000a9c:	446a      	add	r2, sp
 8000a9e:	7812      	ldrb	r2, [r2, #0]
 8000aa0:	429a      	cmp	r2, r3
 8000aa2:	d303      	bcc.n	8000aac <pwmEnableChannel+0x2c>
 8000aa4:	4b12      	ldr	r3, [pc, #72]	; (8000af0 <pwmEnableChannel+0x70>)
 8000aa6:	0018      	movs	r0, r3
 8000aa8:	f002 f8ba 	bl	8002c20 <chSysHalt>

  osalSysLock();
 8000aac:	f001 f818 	bl	8001ae0 <osalSysLock.lto_priv.66>

  osalDbgAssert(pwmp->state == PWM_READY, "not ready");
 8000ab0:	9b03      	ldr	r3, [sp, #12]
 8000ab2:	781b      	ldrb	r3, [r3, #0]
 8000ab4:	2b02      	cmp	r3, #2
 8000ab6:	d003      	beq.n	8000ac0 <pwmEnableChannel+0x40>
 8000ab8:	4b0d      	ldr	r3, [pc, #52]	; (8000af0 <pwmEnableChannel+0x70>)
 8000aba:	0018      	movs	r0, r3
 8000abc:	f002 f8b0 	bl	8002c20 <chSysHalt>

  pwmEnableChannelI(pwmp, channel, width);
 8000ac0:	9b03      	ldr	r3, [sp, #12]
 8000ac2:	68da      	ldr	r2, [r3, #12]
 8000ac4:	230b      	movs	r3, #11
 8000ac6:	446b      	add	r3, sp
 8000ac8:	781b      	ldrb	r3, [r3, #0]
 8000aca:	2101      	movs	r1, #1
 8000acc:	4099      	lsls	r1, r3
 8000ace:	000b      	movs	r3, r1
 8000ad0:	431a      	orrs	r2, r3
 8000ad2:	9b03      	ldr	r3, [sp, #12]
 8000ad4:	60da      	str	r2, [r3, #12]
 8000ad6:	9a01      	ldr	r2, [sp, #4]
 8000ad8:	230b      	movs	r3, #11
 8000ada:	446b      	add	r3, sp
 8000adc:	7819      	ldrb	r1, [r3, #0]
 8000ade:	9b03      	ldr	r3, [sp, #12]
 8000ae0:	0018      	movs	r0, r3
 8000ae2:	f7ff fd2d 	bl	8000540 <pwm_lld_enable_channel>

  osalSysUnlock();
 8000ae6:	f001 f803 	bl	8001af0 <osalSysUnlock.lto_priv.64>
}
 8000aea:	b005      	add	sp, #20
 8000aec:	bd00      	pop	{pc}
 8000aee:	46c0      	nop			; (mov r8, r8)
 8000af0:	08003db8 	.word	0x08003db8
	...

08000b00 <pwmDisableChannel>:
 * @param[in] pwmp      pointer to a @p PWMDriver object
 * @param[in] channel   PWM channel identifier (0...channels-1)
 *
 * @api
 */
void pwmDisableChannel(PWMDriver *pwmp, pwmchannel_t channel) {
 8000b00:	b500      	push	{lr}
 8000b02:	b083      	sub	sp, #12
 8000b04:	9001      	str	r0, [sp, #4]
 8000b06:	000a      	movs	r2, r1
 8000b08:	466b      	mov	r3, sp
 8000b0a:	3303      	adds	r3, #3
 8000b0c:	701a      	strb	r2, [r3, #0]

  osalDbgCheck((pwmp != NULL) && (channel < pwmp->channels));
 8000b0e:	9b01      	ldr	r3, [sp, #4]
 8000b10:	2b00      	cmp	r3, #0
 8000b12:	d006      	beq.n	8000b22 <pwmDisableChannel+0x22>
 8000b14:	9b01      	ldr	r3, [sp, #4]
 8000b16:	7c1b      	ldrb	r3, [r3, #16]
 8000b18:	466a      	mov	r2, sp
 8000b1a:	3203      	adds	r2, #3
 8000b1c:	7812      	ldrb	r2, [r2, #0]
 8000b1e:	429a      	cmp	r2, r3
 8000b20:	d303      	bcc.n	8000b2a <pwmDisableChannel+0x2a>
 8000b22:	4b13      	ldr	r3, [pc, #76]	; (8000b70 <pwmDisableChannel+0x70>)
 8000b24:	0018      	movs	r0, r3
 8000b26:	f002 f87b 	bl	8002c20 <chSysHalt>

  osalSysLock();
 8000b2a:	f000 ffd9 	bl	8001ae0 <osalSysLock.lto_priv.66>

  osalDbgAssert(pwmp->state == PWM_READY, "not ready");
 8000b2e:	9b01      	ldr	r3, [sp, #4]
 8000b30:	781b      	ldrb	r3, [r3, #0]
 8000b32:	2b02      	cmp	r3, #2
 8000b34:	d003      	beq.n	8000b3e <pwmDisableChannel+0x3e>
 8000b36:	4b0e      	ldr	r3, [pc, #56]	; (8000b70 <pwmDisableChannel+0x70>)
 8000b38:	0018      	movs	r0, r3
 8000b3a:	f002 f871 	bl	8002c20 <chSysHalt>

  pwmDisableChannelI(pwmp, channel);
 8000b3e:	9b01      	ldr	r3, [sp, #4]
 8000b40:	68db      	ldr	r3, [r3, #12]
 8000b42:	466a      	mov	r2, sp
 8000b44:	3203      	adds	r2, #3
 8000b46:	7812      	ldrb	r2, [r2, #0]
 8000b48:	2101      	movs	r1, #1
 8000b4a:	4091      	lsls	r1, r2
 8000b4c:	000a      	movs	r2, r1
 8000b4e:	43d2      	mvns	r2, r2
 8000b50:	401a      	ands	r2, r3
 8000b52:	9b01      	ldr	r3, [sp, #4]
 8000b54:	60da      	str	r2, [r3, #12]
 8000b56:	466b      	mov	r3, sp
 8000b58:	3303      	adds	r3, #3
 8000b5a:	781a      	ldrb	r2, [r3, #0]
 8000b5c:	9b01      	ldr	r3, [sp, #4]
 8000b5e:	0011      	movs	r1, r2
 8000b60:	0018      	movs	r0, r3
 8000b62:	f7ff fd05 	bl	8000570 <pwm_lld_disable_channel>

  osalSysUnlock();
 8000b66:	f000 ffc3 	bl	8001af0 <osalSysUnlock.lto_priv.64>
}
 8000b6a:	b003      	add	sp, #12
 8000b6c:	bd00      	pop	{pc}
 8000b6e:	46c0      	nop			; (mov r8, r8)
 8000b70:	08003dcc 	.word	0x08003dcc
	...

08000b80 <pwmEnablePeriodicNotification>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @api
 */
void pwmEnablePeriodicNotification(PWMDriver *pwmp) {
 8000b80:	b500      	push	{lr}
 8000b82:	b083      	sub	sp, #12
 8000b84:	9001      	str	r0, [sp, #4]

  osalDbgCheck(pwmp != NULL);
 8000b86:	9b01      	ldr	r3, [sp, #4]
 8000b88:	2b00      	cmp	r3, #0
 8000b8a:	d103      	bne.n	8000b94 <pwmEnablePeriodicNotification+0x14>
 8000b8c:	4b0f      	ldr	r3, [pc, #60]	; (8000bcc <pwmEnablePeriodicNotification+0x4c>)
 8000b8e:	0018      	movs	r0, r3
 8000b90:	f002 f846 	bl	8002c20 <chSysHalt>

  osalSysLock();
 8000b94:	f000 ffa4 	bl	8001ae0 <osalSysLock.lto_priv.66>

  osalDbgAssert(pwmp->state == PWM_READY, "not ready");
 8000b98:	9b01      	ldr	r3, [sp, #4]
 8000b9a:	781b      	ldrb	r3, [r3, #0]
 8000b9c:	2b02      	cmp	r3, #2
 8000b9e:	d003      	beq.n	8000ba8 <pwmEnablePeriodicNotification+0x28>
 8000ba0:	4b0a      	ldr	r3, [pc, #40]	; (8000bcc <pwmEnablePeriodicNotification+0x4c>)
 8000ba2:	0018      	movs	r0, r3
 8000ba4:	f002 f83c 	bl	8002c20 <chSysHalt>
  osalDbgAssert(pwmp->config->callback != NULL, "undefined periodic callback");
 8000ba8:	9b01      	ldr	r3, [sp, #4]
 8000baa:	685b      	ldr	r3, [r3, #4]
 8000bac:	689b      	ldr	r3, [r3, #8]
 8000bae:	2b00      	cmp	r3, #0
 8000bb0:	d103      	bne.n	8000bba <pwmEnablePeriodicNotification+0x3a>
 8000bb2:	4b06      	ldr	r3, [pc, #24]	; (8000bcc <pwmEnablePeriodicNotification+0x4c>)
 8000bb4:	0018      	movs	r0, r3
 8000bb6:	f002 f833 	bl	8002c20 <chSysHalt>

  pwmEnablePeriodicNotificationI(pwmp);
 8000bba:	9b01      	ldr	r3, [sp, #4]
 8000bbc:	0018      	movs	r0, r3
 8000bbe:	f7ff fcff 	bl	80005c0 <pwm_lld_enable_periodic_notification>

  osalSysUnlock();
 8000bc2:	f000 ff95 	bl	8001af0 <osalSysUnlock.lto_priv.64>
}
 8000bc6:	b003      	add	sp, #12
 8000bc8:	bd00      	pop	{pc}
 8000bca:	46c0      	nop			; (mov r8, r8)
 8000bcc:	08003de0 	.word	0x08003de0

08000bd0 <pwmEnableChannelNotification>:
 * @param[in] pwmp      pointer to a @p PWMDriver object
 * @param[in] channel   PWM channel identifier (0...channels-1)
 *
 * @api
 */
void pwmEnableChannelNotification(PWMDriver *pwmp, pwmchannel_t channel) {
 8000bd0:	b500      	push	{lr}
 8000bd2:	b083      	sub	sp, #12
 8000bd4:	9001      	str	r0, [sp, #4]
 8000bd6:	000a      	movs	r2, r1
 8000bd8:	466b      	mov	r3, sp
 8000bda:	3303      	adds	r3, #3
 8000bdc:	701a      	strb	r2, [r3, #0]

  osalDbgCheck((pwmp != NULL) && (channel < pwmp->channels));
 8000bde:	9b01      	ldr	r3, [sp, #4]
 8000be0:	2b00      	cmp	r3, #0
 8000be2:	d006      	beq.n	8000bf2 <pwmEnableChannelNotification+0x22>
 8000be4:	9b01      	ldr	r3, [sp, #4]
 8000be6:	7c1b      	ldrb	r3, [r3, #16]
 8000be8:	466a      	mov	r2, sp
 8000bea:	3203      	adds	r2, #3
 8000bec:	7812      	ldrb	r2, [r2, #0]
 8000bee:	429a      	cmp	r2, r3
 8000bf0:	d303      	bcc.n	8000bfa <pwmEnableChannelNotification+0x2a>
 8000bf2:	4b1c      	ldr	r3, [pc, #112]	; (8000c64 <pwmEnableChannelNotification+0x94>)
 8000bf4:	0018      	movs	r0, r3
 8000bf6:	f002 f813 	bl	8002c20 <chSysHalt>

  osalSysLock();
 8000bfa:	f000 ff71 	bl	8001ae0 <osalSysLock.lto_priv.66>

  osalDbgAssert(pwmp->state == PWM_READY, "not ready");
 8000bfe:	9b01      	ldr	r3, [sp, #4]
 8000c00:	781b      	ldrb	r3, [r3, #0]
 8000c02:	2b02      	cmp	r3, #2
 8000c04:	d003      	beq.n	8000c0e <pwmEnableChannelNotification+0x3e>
 8000c06:	4b17      	ldr	r3, [pc, #92]	; (8000c64 <pwmEnableChannelNotification+0x94>)
 8000c08:	0018      	movs	r0, r3
 8000c0a:	f002 f809 	bl	8002c20 <chSysHalt>
  osalDbgAssert((pwmp->enabled & ((pwmchnmsk_t)1U << (pwmchnmsk_t)channel)) != 0U,
 8000c0e:	9b01      	ldr	r3, [sp, #4]
 8000c10:	68da      	ldr	r2, [r3, #12]
 8000c12:	466b      	mov	r3, sp
 8000c14:	3303      	adds	r3, #3
 8000c16:	781b      	ldrb	r3, [r3, #0]
 8000c18:	40da      	lsrs	r2, r3
 8000c1a:	0013      	movs	r3, r2
 8000c1c:	2201      	movs	r2, #1
 8000c1e:	4013      	ands	r3, r2
 8000c20:	d103      	bne.n	8000c2a <pwmEnableChannelNotification+0x5a>
 8000c22:	4b10      	ldr	r3, [pc, #64]	; (8000c64 <pwmEnableChannelNotification+0x94>)
 8000c24:	0018      	movs	r0, r3
 8000c26:	f001 fffb 	bl	8002c20 <chSysHalt>
                "channel not enabled");
  osalDbgAssert(pwmp->config->channels[channel].callback != NULL,
 8000c2a:	9b01      	ldr	r3, [sp, #4]
 8000c2c:	685a      	ldr	r2, [r3, #4]
 8000c2e:	466b      	mov	r3, sp
 8000c30:	3303      	adds	r3, #3
 8000c32:	781b      	ldrb	r3, [r3, #0]
 8000c34:	3301      	adds	r3, #1
 8000c36:	00db      	lsls	r3, r3, #3
 8000c38:	18d3      	adds	r3, r2, r3
 8000c3a:	3308      	adds	r3, #8
 8000c3c:	681b      	ldr	r3, [r3, #0]
 8000c3e:	2b00      	cmp	r3, #0
 8000c40:	d103      	bne.n	8000c4a <pwmEnableChannelNotification+0x7a>
 8000c42:	4b08      	ldr	r3, [pc, #32]	; (8000c64 <pwmEnableChannelNotification+0x94>)
 8000c44:	0018      	movs	r0, r3
 8000c46:	f001 ffeb 	bl	8002c20 <chSysHalt>
                "undefined channel callback");

  pwmEnableChannelNotificationI(pwmp, channel);
 8000c4a:	466b      	mov	r3, sp
 8000c4c:	3303      	adds	r3, #3
 8000c4e:	781a      	ldrb	r2, [r3, #0]
 8000c50:	9b01      	ldr	r3, [sp, #4]
 8000c52:	0011      	movs	r1, r2
 8000c54:	0018      	movs	r0, r3
 8000c56:	f7ff fcd3 	bl	8000600 <pwm_lld_enable_channel_notification>

  osalSysUnlock();
 8000c5a:	f000 ff49 	bl	8001af0 <osalSysUnlock.lto_priv.64>
}
 8000c5e:	b003      	add	sp, #12
 8000c60:	bd00      	pop	{pc}
 8000c62:	46c0      	nop			; (mov r8, r8)
 8000c64:	08003e00 	.word	0x08003e00
	...

08000c70 <st_lld_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {
 8000c70:	b082      	sub	sp, #8
 8000c72:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000c74:	2380      	movs	r3, #128	; 0x80
 8000c76:	05db      	lsls	r3, r3, #23
 8000c78:	9a01      	ldr	r2, [sp, #4]
 8000c7a:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8000c7c:	2380      	movs	r3, #128	; 0x80
 8000c7e:	05db      	lsls	r3, r3, #23
 8000c80:	2200      	movs	r2, #0
 8000c82:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000c84:	2380      	movs	r3, #128	; 0x80
 8000c86:	05db      	lsls	r3, r3, #23
 8000c88:	2202      	movs	r2, #2
 8000c8a:	60da      	str	r2, [r3, #12]
}
 8000c8c:	b002      	add	sp, #8
 8000c8e:	4770      	bx	lr

08000c90 <st_lld_stop_alarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8000c90:	2380      	movs	r3, #128	; 0x80
 8000c92:	05db      	lsls	r3, r3, #23
 8000c94:	2200      	movs	r2, #0
 8000c96:	60da      	str	r2, [r3, #12]
}
 8000c98:	4770      	bx	lr
 8000c9a:	46c0      	nop			; (mov r8, r8)
 8000c9c:	0000      	movs	r0, r0
	...

08000ca0 <st_lld_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {
 8000ca0:	b082      	sub	sp, #8
 8000ca2:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000ca4:	2380      	movs	r3, #128	; 0x80
 8000ca6:	05db      	lsls	r3, r3, #23
 8000ca8:	9a01      	ldr	r2, [sp, #4]
 8000caa:	635a      	str	r2, [r3, #52]	; 0x34
}
 8000cac:	b002      	add	sp, #8
 8000cae:	4770      	bx	lr

08000cb0 <st_lld_is_alarm_active>:
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8000cb0:	2380      	movs	r3, #128	; 0x80
 8000cb2:	05db      	lsls	r3, r3, #23
 8000cb4:	68db      	ldr	r3, [r3, #12]
 8000cb6:	2202      	movs	r2, #2
 8000cb8:	4013      	ands	r3, r2
 8000cba:	1e5a      	subs	r2, r3, #1
 8000cbc:	4193      	sbcs	r3, r2
 8000cbe:	b2db      	uxtb	r3, r3
}
 8000cc0:	0018      	movs	r0, r3
 8000cc2:	4770      	bx	lr
	...

08000cd0 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 8000cd0:	b510      	push	{r4, lr}

  st_lld_init();
 8000cd2:	f000 faf5 	bl	80012c0 <st_lld_init>
}
 8000cd6:	bd10      	pop	{r4, pc}
	...

08000ce0 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 8000ce0:	b500      	push	{lr}
 8000ce2:	b083      	sub	sp, #12
 8000ce4:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8000ce6:	f7ff ffe3 	bl	8000cb0 <st_lld_is_alarm_active>
 8000cea:	1e03      	subs	r3, r0, #0
 8000cec:	d003      	beq.n	8000cf6 <stStartAlarm+0x16>
 8000cee:	4b05      	ldr	r3, [pc, #20]	; (8000d04 <stStartAlarm+0x24>)
 8000cf0:	0018      	movs	r0, r3
 8000cf2:	f001 ff95 	bl	8002c20 <chSysHalt>

  st_lld_start_alarm(abstime);
 8000cf6:	9b01      	ldr	r3, [sp, #4]
 8000cf8:	0018      	movs	r0, r3
 8000cfa:	f7ff ffb9 	bl	8000c70 <st_lld_start_alarm>
}
 8000cfe:	b003      	add	sp, #12
 8000d00:	bd00      	pop	{pc}
 8000d02:	46c0      	nop			; (mov r8, r8)
 8000d04:	08003e20 	.word	0x08003e20
	...

08000d10 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 8000d10:	b510      	push	{r4, lr}

  st_lld_stop_alarm();
 8000d12:	f7ff ffbd 	bl	8000c90 <st_lld_stop_alarm>
}
 8000d16:	bd10      	pop	{r4, pc}
	...

08000d20 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8000d20:	b500      	push	{lr}
 8000d22:	b083      	sub	sp, #12
 8000d24:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8000d26:	f7ff ffc3 	bl	8000cb0 <st_lld_is_alarm_active>
 8000d2a:	0003      	movs	r3, r0
 8000d2c:	001a      	movs	r2, r3
 8000d2e:	2301      	movs	r3, #1
 8000d30:	4053      	eors	r3, r2
 8000d32:	b2db      	uxtb	r3, r3
 8000d34:	2b00      	cmp	r3, #0
 8000d36:	d003      	beq.n	8000d40 <stSetAlarm+0x20>
 8000d38:	4b04      	ldr	r3, [pc, #16]	; (8000d4c <stSetAlarm+0x2c>)
 8000d3a:	0018      	movs	r0, r3
 8000d3c:	f001 ff70 	bl	8002c20 <chSysHalt>

  st_lld_set_alarm(abstime);
 8000d40:	9b01      	ldr	r3, [sp, #4]
 8000d42:	0018      	movs	r0, r3
 8000d44:	f7ff ffac 	bl	8000ca0 <st_lld_set_alarm>
}
 8000d48:	b003      	add	sp, #12
 8000d4a:	bd00      	pop	{pc}
 8000d4c:	08003e30 	.word	0x08003e30

08000d50 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8000d50:	b530      	push	{r4, r5, lr}
 8000d52:	b083      	sub	sp, #12
 8000d54:	9001      	str	r0, [sp, #4]
 8000d56:	9100      	str	r1, [sp, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8000d58:	4c1b      	ldr	r4, [pc, #108]	; (8000dc8 <nvicEnableVector+0x78>)
 8000d5a:	9b01      	ldr	r3, [sp, #4]
 8000d5c:	089b      	lsrs	r3, r3, #2
 8000d5e:	491a      	ldr	r1, [pc, #104]	; (8000dc8 <nvicEnableVector+0x78>)
 8000d60:	9a01      	ldr	r2, [sp, #4]
 8000d62:	0892      	lsrs	r2, r2, #2
 8000d64:	32c0      	adds	r2, #192	; 0xc0
 8000d66:	0092      	lsls	r2, r2, #2
 8000d68:	5852      	ldr	r2, [r2, r1]
 8000d6a:	9901      	ldr	r1, [sp, #4]
 8000d6c:	2003      	movs	r0, #3
 8000d6e:	4001      	ands	r1, r0
 8000d70:	00c9      	lsls	r1, r1, #3
 8000d72:	20ff      	movs	r0, #255	; 0xff
 8000d74:	4088      	lsls	r0, r1
 8000d76:	0001      	movs	r1, r0
 8000d78:	43c9      	mvns	r1, r1
 8000d7a:	4011      	ands	r1, r2
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
 8000d7c:	9a00      	ldr	r2, [sp, #0]
 8000d7e:	0190      	lsls	r0, r2, #6
 8000d80:	9a01      	ldr	r2, [sp, #4]
 8000d82:	2503      	movs	r5, #3
 8000d84:	402a      	ands	r2, r5
 8000d86:	00d2      	lsls	r2, r2, #3
 8000d88:	4090      	lsls	r0, r2
 8000d8a:	0002      	movs	r2, r0
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8000d8c:	430a      	orrs	r2, r1
 8000d8e:	33c0      	adds	r3, #192	; 0xc0
 8000d90:	009b      	lsls	r3, r3, #2
 8000d92:	511a      	str	r2, [r3, r4]
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000d94:	490c      	ldr	r1, [pc, #48]	; (8000dc8 <nvicEnableVector+0x78>)
 8000d96:	9b01      	ldr	r3, [sp, #4]
 8000d98:	095b      	lsrs	r3, r3, #5
 8000d9a:	9a01      	ldr	r2, [sp, #4]
 8000d9c:	201f      	movs	r0, #31
 8000d9e:	4002      	ands	r2, r0
 8000da0:	2001      	movs	r0, #1
 8000da2:	4090      	lsls	r0, r2
 8000da4:	0002      	movs	r2, r0
 8000da6:	3360      	adds	r3, #96	; 0x60
 8000da8:	009b      	lsls	r3, r3, #2
 8000daa:	505a      	str	r2, [r3, r1]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000dac:	4906      	ldr	r1, [pc, #24]	; (8000dc8 <nvicEnableVector+0x78>)
 8000dae:	9b01      	ldr	r3, [sp, #4]
 8000db0:	095b      	lsrs	r3, r3, #5
 8000db2:	9a01      	ldr	r2, [sp, #4]
 8000db4:	201f      	movs	r0, #31
 8000db6:	4002      	ands	r2, r0
 8000db8:	2001      	movs	r0, #1
 8000dba:	4090      	lsls	r0, r2
 8000dbc:	0002      	movs	r2, r0
 8000dbe:	009b      	lsls	r3, r3, #2
 8000dc0:	505a      	str	r2, [r3, r1]
}
 8000dc2:	b003      	add	sp, #12
 8000dc4:	bd30      	pop	{r4, r5, pc}
 8000dc6:	46c0      	nop			; (mov r8, r8)
 8000dc8:	e000e100 	.word	0xe000e100
 8000dcc:	00000000 	.word	0x00000000

08000dd0 <nvicDisableVector>:
/**
 * @brief   Disables an interrupt handler.
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {
 8000dd0:	b510      	push	{r4, lr}
 8000dd2:	b082      	sub	sp, #8
 8000dd4:	9001      	str	r0, [sp, #4]

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8000dd6:	4911      	ldr	r1, [pc, #68]	; (8000e1c <nvicDisableVector+0x4c>)
 8000dd8:	9b01      	ldr	r3, [sp, #4]
 8000dda:	095b      	lsrs	r3, r3, #5
 8000ddc:	9a01      	ldr	r2, [sp, #4]
 8000dde:	201f      	movs	r0, #31
 8000de0:	4002      	ands	r2, r0
 8000de2:	2001      	movs	r0, #1
 8000de4:	4090      	lsls	r0, r2
 8000de6:	0002      	movs	r2, r0
 8000de8:	3320      	adds	r3, #32
 8000dea:	009b      	lsls	r3, r3, #2
 8000dec:	505a      	str	r2, [r3, r1]
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
 8000dee:	480b      	ldr	r0, [pc, #44]	; (8000e1c <nvicDisableVector+0x4c>)
 8000df0:	9b01      	ldr	r3, [sp, #4]
 8000df2:	089b      	lsrs	r3, r3, #2
 8000df4:	4909      	ldr	r1, [pc, #36]	; (8000e1c <nvicDisableVector+0x4c>)
 8000df6:	9a01      	ldr	r2, [sp, #4]
 8000df8:	0892      	lsrs	r2, r2, #2
 8000dfa:	32c0      	adds	r2, #192	; 0xc0
 8000dfc:	0092      	lsls	r2, r2, #2
 8000dfe:	5852      	ldr	r2, [r2, r1]
 8000e00:	9901      	ldr	r1, [sp, #4]
 8000e02:	2403      	movs	r4, #3
 8000e04:	4021      	ands	r1, r4
 8000e06:	00c9      	lsls	r1, r1, #3
 8000e08:	24ff      	movs	r4, #255	; 0xff
 8000e0a:	408c      	lsls	r4, r1
 8000e0c:	0021      	movs	r1, r4
 8000e0e:	43c9      	mvns	r1, r1
 8000e10:	400a      	ands	r2, r1
 8000e12:	33c0      	adds	r3, #192	; 0xc0
 8000e14:	009b      	lsls	r3, r3, #2
 8000e16:	501a      	str	r2, [r3, r0]
#else
  NVIC->IP[n] = 0U;
#endif
}
 8000e18:	b002      	add	sp, #8
 8000e1a:	bd10      	pop	{r4, pc}
 8000e1c:	e000e100 	.word	0xe000e100

08000e20 <hal_lld_backup_domain_init>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8000e20:	4b15      	ldr	r3, [pc, #84]	; (8000e78 <hal_lld_backup_domain_init+0x58>)
 8000e22:	4a15      	ldr	r2, [pc, #84]	; (8000e78 <hal_lld_backup_domain_init+0x58>)
 8000e24:	6812      	ldr	r2, [r2, #0]
 8000e26:	2180      	movs	r1, #128	; 0x80
 8000e28:	0049      	lsls	r1, r1, #1
 8000e2a:	430a      	orrs	r2, r1
 8000e2c:	601a      	str	r2, [r3, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 8000e2e:	4b13      	ldr	r3, [pc, #76]	; (8000e7c <hal_lld_backup_domain_init+0x5c>)
 8000e30:	6a1a      	ldr	r2, [r3, #32]
 8000e32:	23c0      	movs	r3, #192	; 0xc0
 8000e34:	009b      	lsls	r3, r3, #2
 8000e36:	401a      	ands	r2, r3
 8000e38:	2380      	movs	r3, #128	; 0x80
 8000e3a:	009b      	lsls	r3, r3, #2
 8000e3c:	429a      	cmp	r2, r3
 8000e3e:	d006      	beq.n	8000e4e <hal_lld_backup_domain_init+0x2e>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8000e40:	4b0e      	ldr	r3, [pc, #56]	; (8000e7c <hal_lld_backup_domain_init+0x5c>)
 8000e42:	2280      	movs	r2, #128	; 0x80
 8000e44:	0252      	lsls	r2, r2, #9
 8000e46:	621a      	str	r2, [r3, #32]
    RCC->BDCR = 0;
 8000e48:	4b0c      	ldr	r3, [pc, #48]	; (8000e7c <hal_lld_backup_domain_init+0x5c>)
 8000e4a:	2200      	movs	r2, #0
 8000e4c:	621a      	str	r2, [r3, #32]
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 8000e4e:	4b0b      	ldr	r3, [pc, #44]	; (8000e7c <hal_lld_backup_domain_init+0x5c>)
 8000e50:	6a1a      	ldr	r2, [r3, #32]
 8000e52:	2380      	movs	r3, #128	; 0x80
 8000e54:	021b      	lsls	r3, r3, #8
 8000e56:	4013      	ands	r3, r2
 8000e58:	d10d      	bne.n	8000e76 <hal_lld_backup_domain_init+0x56>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 8000e5a:	4b08      	ldr	r3, [pc, #32]	; (8000e7c <hal_lld_backup_domain_init+0x5c>)
 8000e5c:	4a07      	ldr	r2, [pc, #28]	; (8000e7c <hal_lld_backup_domain_init+0x5c>)
 8000e5e:	6a12      	ldr	r2, [r2, #32]
 8000e60:	2180      	movs	r1, #128	; 0x80
 8000e62:	0089      	lsls	r1, r1, #2
 8000e64:	430a      	orrs	r2, r1
 8000e66:	621a      	str	r2, [r3, #32]

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 8000e68:	4b04      	ldr	r3, [pc, #16]	; (8000e7c <hal_lld_backup_domain_init+0x5c>)
 8000e6a:	4a04      	ldr	r2, [pc, #16]	; (8000e7c <hal_lld_backup_domain_init+0x5c>)
 8000e6c:	6a12      	ldr	r2, [r2, #32]
 8000e6e:	2180      	movs	r1, #128	; 0x80
 8000e70:	0209      	lsls	r1, r1, #8
 8000e72:	430a      	orrs	r2, r1
 8000e74:	621a      	str	r2, [r3, #32]
  }
#endif /* STM32_RTCSEL != STM32_RTCSEL_NOCLOCK */
}
 8000e76:	4770      	bx	lr
 8000e78:	40007000 	.word	0x40007000
 8000e7c:	40021000 	.word	0x40021000

08000e80 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 8000e80:	b510      	push	{r4, lr}

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 8000e82:	4b12      	ldr	r3, [pc, #72]	; (8000ecc <hal_lld_init+0x4c>)
 8000e84:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8000e86:	4b11      	ldr	r3, [pc, #68]	; (8000ecc <hal_lld_init+0x4c>)
 8000e88:	2201      	movs	r2, #1
 8000e8a:	4252      	negs	r2, r2
 8000e8c:	629a      	str	r2, [r3, #40]	; 0x28
 8000e8e:	4b0f      	ldr	r3, [pc, #60]	; (8000ecc <hal_lld_init+0x4c>)
 8000e90:	2200      	movs	r2, #0
 8000e92:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 8000e94:	4b0d      	ldr	r3, [pc, #52]	; (8000ecc <hal_lld_init+0x4c>)
 8000e96:	691b      	ldr	r3, [r3, #16]
 8000e98:	4b0c      	ldr	r3, [pc, #48]	; (8000ecc <hal_lld_init+0x4c>)
 8000e9a:	2201      	movs	r2, #1
 8000e9c:	4252      	negs	r2, r2
 8000e9e:	611a      	str	r2, [r3, #16]
 8000ea0:	4b0a      	ldr	r3, [pc, #40]	; (8000ecc <hal_lld_init+0x4c>)
 8000ea2:	2200      	movs	r2, #0
 8000ea4:	611a      	str	r2, [r3, #16]
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8000ea6:	4b09      	ldr	r3, [pc, #36]	; (8000ecc <hal_lld_init+0x4c>)
 8000ea8:	4a08      	ldr	r2, [pc, #32]	; (8000ecc <hal_lld_init+0x4c>)
 8000eaa:	68d2      	ldr	r2, [r2, #12]
 8000eac:	4908      	ldr	r1, [pc, #32]	; (8000ed0 <hal_lld_init+0x50>)
 8000eae:	430a      	orrs	r2, r1
 8000eb0:	60da      	str	r2, [r3, #12]
 8000eb2:	4b06      	ldr	r3, [pc, #24]	; (8000ecc <hal_lld_init+0x4c>)
 8000eb4:	2200      	movs	r2, #0
 8000eb6:	60da      	str	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8000eb8:	4b04      	ldr	r3, [pc, #16]	; (8000ecc <hal_lld_init+0x4c>)
 8000eba:	4a04      	ldr	r2, [pc, #16]	; (8000ecc <hal_lld_init+0x4c>)
 8000ebc:	69d2      	ldr	r2, [r2, #28]
 8000ebe:	2180      	movs	r1, #128	; 0x80
 8000ec0:	0549      	lsls	r1, r1, #21
 8000ec2:	430a      	orrs	r2, r1
 8000ec4:	61da      	str	r2, [r3, #28]

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 8000ec6:	f7ff ffab 	bl	8000e20 <hal_lld_backup_domain_init>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 8000eca:	bd10      	pop	{r4, pc}
 8000ecc:	40021000 	.word	0x40021000
 8000ed0:	ffbfffff 	.word	0xffbfffff
	...

08000ee0 <stm32_clock_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8000ee0:	4b32      	ldr	r3, [pc, #200]	; (8000fac <stm32_clock_init+0xcc>)
 8000ee2:	4a32      	ldr	r2, [pc, #200]	; (8000fac <stm32_clock_init+0xcc>)
 8000ee4:	6812      	ldr	r2, [r2, #0]
 8000ee6:	2101      	movs	r1, #1
 8000ee8:	430a      	orrs	r2, r1
 8000eea:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8000eec:	4b2f      	ldr	r3, [pc, #188]	; (8000fac <stm32_clock_init+0xcc>)
 8000eee:	681b      	ldr	r3, [r3, #0]
 8000ef0:	2202      	movs	r2, #2
 8000ef2:	4013      	ands	r3, r2
 8000ef4:	d0fa      	beq.n	8000eec <stm32_clock_init+0xc>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8000ef6:	4b2d      	ldr	r3, [pc, #180]	; (8000fac <stm32_clock_init+0xcc>)
 8000ef8:	4a2c      	ldr	r2, [pc, #176]	; (8000fac <stm32_clock_init+0xcc>)
 8000efa:	6852      	ldr	r2, [r2, #4]
 8000efc:	2103      	movs	r1, #3
 8000efe:	438a      	bics	r2, r1
 8000f00:	605a      	str	r2, [r3, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8000f02:	4b2a      	ldr	r3, [pc, #168]	; (8000fac <stm32_clock_init+0xcc>)
 8000f04:	4a29      	ldr	r2, [pc, #164]	; (8000fac <stm32_clock_init+0xcc>)
 8000f06:	6852      	ldr	r2, [r2, #4]
 8000f08:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8000f0a:	4b28      	ldr	r3, [pc, #160]	; (8000fac <stm32_clock_init+0xcc>)
 8000f0c:	685b      	ldr	r3, [r3, #4]
 8000f0e:	220c      	movs	r2, #12
 8000f10:	4013      	ands	r3, r2
 8000f12:	d1fa      	bne.n	8000f0a <stm32_clock_init+0x2a>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8000f14:	4b25      	ldr	r3, [pc, #148]	; (8000fac <stm32_clock_init+0xcc>)
 8000f16:	4a25      	ldr	r2, [pc, #148]	; (8000fac <stm32_clock_init+0xcc>)
 8000f18:	6812      	ldr	r2, [r2, #0]
 8000f1a:	21f9      	movs	r1, #249	; 0xf9
 8000f1c:	400a      	ands	r2, r1
 8000f1e:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8000f20:	4b22      	ldr	r3, [pc, #136]	; (8000fac <stm32_clock_init+0xcc>)
 8000f22:	2200      	movs	r2, #0
 8000f24:	605a      	str	r2, [r3, #4]
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_HSI14_ENABLED
  /* HSI14 activation.*/
  RCC->CR2 |= RCC_CR2_HSI14ON;
 8000f26:	4b21      	ldr	r3, [pc, #132]	; (8000fac <stm32_clock_init+0xcc>)
 8000f28:	4a20      	ldr	r2, [pc, #128]	; (8000fac <stm32_clock_init+0xcc>)
 8000f2a:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8000f2c:	2101      	movs	r1, #1
 8000f2e:	430a      	orrs	r2, r1
 8000f30:	635a      	str	r2, [r3, #52]	; 0x34
  while (!(RCC->CR2 & RCC_CR2_HSI14RDY))
 8000f32:	4b1e      	ldr	r3, [pc, #120]	; (8000fac <stm32_clock_init+0xcc>)
 8000f34:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8000f36:	2202      	movs	r2, #2
 8000f38:	4013      	ands	r3, r2
 8000f3a:	d0fa      	beq.n	8000f32 <stm32_clock_init+0x52>
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8000f3c:	4b1b      	ldr	r3, [pc, #108]	; (8000fac <stm32_clock_init+0xcc>)
 8000f3e:	4a1b      	ldr	r2, [pc, #108]	; (8000fac <stm32_clock_init+0xcc>)
 8000f40:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8000f42:	2101      	movs	r1, #1
 8000f44:	430a      	orrs	r2, r1
 8000f46:	625a      	str	r2, [r3, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8000f48:	4b18      	ldr	r3, [pc, #96]	; (8000fac <stm32_clock_init+0xcc>)
 8000f4a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000f4c:	2202      	movs	r2, #2
 8000f4e:	4013      	ands	r3, r2
 8000f50:	d0fa      	beq.n	8000f48 <stm32_clock_init+0x68>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  /* CFGR2 must be configured first since CFGR value could change CFGR2 */
  RCC->CFGR2 = STM32_PREDIV;
 8000f52:	4b16      	ldr	r3, [pc, #88]	; (8000fac <stm32_clock_init+0xcc>)
 8000f54:	2200      	movs	r2, #0
 8000f56:	62da      	str	r2, [r3, #44]	; 0x2c
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 8000f58:	4b14      	ldr	r3, [pc, #80]	; (8000fac <stm32_clock_init+0xcc>)
 8000f5a:	22a0      	movs	r2, #160	; 0xa0
 8000f5c:	0392      	lsls	r2, r2, #14
 8000f5e:	605a      	str	r2, [r3, #4]
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE |
               ((STM32_PREDIV & STM32_PLLXTPRE_MASK) << STM32_PLLXTPRE_OFFSET);
#if STM32_CECSW == STM32_CECSW_OFF
  RCC->CFGR3 = STM32_USBSW  | STM32_I2C1SW | STM32_USART1SW;
#else
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
 8000f60:	4b12      	ldr	r3, [pc, #72]	; (8000fac <stm32_clock_init+0xcc>)
 8000f62:	2200      	movs	r2, #0
 8000f64:	631a      	str	r2, [r3, #48]	; 0x30
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8000f66:	4b11      	ldr	r3, [pc, #68]	; (8000fac <stm32_clock_init+0xcc>)
 8000f68:	4a10      	ldr	r2, [pc, #64]	; (8000fac <stm32_clock_init+0xcc>)
 8000f6a:	6812      	ldr	r2, [r2, #0]
 8000f6c:	2180      	movs	r1, #128	; 0x80
 8000f6e:	0449      	lsls	r1, r1, #17
 8000f70:	430a      	orrs	r2, r1
 8000f72:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8000f74:	4b0d      	ldr	r3, [pc, #52]	; (8000fac <stm32_clock_init+0xcc>)
 8000f76:	681a      	ldr	r2, [r3, #0]
 8000f78:	2380      	movs	r3, #128	; 0x80
 8000f7a:	049b      	lsls	r3, r3, #18
 8000f7c:	4013      	ands	r3, r2
 8000f7e:	d0f9      	beq.n	8000f74 <stm32_clock_init+0x94>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8000f80:	4b0b      	ldr	r3, [pc, #44]	; (8000fb0 <stm32_clock_init+0xd0>)
 8000f82:	2211      	movs	r2, #17
 8000f84:	601a      	str	r2, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8000f86:	4b09      	ldr	r3, [pc, #36]	; (8000fac <stm32_clock_init+0xcc>)
 8000f88:	4a08      	ldr	r2, [pc, #32]	; (8000fac <stm32_clock_init+0xcc>)
 8000f8a:	6852      	ldr	r2, [r2, #4]
 8000f8c:	2102      	movs	r1, #2
 8000f8e:	430a      	orrs	r2, r1
 8000f90:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8000f92:	4b06      	ldr	r3, [pc, #24]	; (8000fac <stm32_clock_init+0xcc>)
 8000f94:	685b      	ldr	r3, [r3, #4]
 8000f96:	220c      	movs	r2, #12
 8000f98:	4013      	ands	r3, r2
 8000f9a:	2b08      	cmp	r3, #8
 8000f9c:	d1f9      	bne.n	8000f92 <stm32_clock_init+0xb2>
    ;                                       /* Waits selection complete.    */
#endif

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8000f9e:	4b03      	ldr	r3, [pc, #12]	; (8000fac <stm32_clock_init+0xcc>)
 8000fa0:	4a02      	ldr	r2, [pc, #8]	; (8000fac <stm32_clock_init+0xcc>)
 8000fa2:	6992      	ldr	r2, [r2, #24]
 8000fa4:	2101      	movs	r1, #1
 8000fa6:	430a      	orrs	r2, r1
 8000fa8:	619a      	str	r2, [r3, #24]
#endif /* !STM32_NO_INIT */
}
 8000faa:	4770      	bx	lr
 8000fac:	40021000 	.word	0x40021000
 8000fb0:	40022000 	.word	0x40022000
	...

08000fc0 <initgpio>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {
 8000fc0:	b082      	sub	sp, #8
 8000fc2:	9001      	str	r0, [sp, #4]
 8000fc4:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 8000fc6:	9b00      	ldr	r3, [sp, #0]
 8000fc8:	685a      	ldr	r2, [r3, #4]
 8000fca:	9b01      	ldr	r3, [sp, #4]
 8000fcc:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000fce:	9b00      	ldr	r3, [sp, #0]
 8000fd0:	689a      	ldr	r2, [r3, #8]
 8000fd2:	9b01      	ldr	r3, [sp, #4]
 8000fd4:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8000fd6:	9b00      	ldr	r3, [sp, #0]
 8000fd8:	68da      	ldr	r2, [r3, #12]
 8000fda:	9b01      	ldr	r3, [sp, #4]
 8000fdc:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 8000fde:	9b00      	ldr	r3, [sp, #0]
 8000fe0:	691a      	ldr	r2, [r3, #16]
 8000fe2:	9b01      	ldr	r3, [sp, #4]
 8000fe4:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8000fe6:	9b00      	ldr	r3, [sp, #0]
 8000fe8:	695a      	ldr	r2, [r3, #20]
 8000fea:	9b01      	ldr	r3, [sp, #4]
 8000fec:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8000fee:	9b00      	ldr	r3, [sp, #0]
 8000ff0:	699a      	ldr	r2, [r3, #24]
 8000ff2:	9b01      	ldr	r3, [sp, #4]
 8000ff4:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000ff6:	9b00      	ldr	r3, [sp, #0]
 8000ff8:	681a      	ldr	r2, [r3, #0]
 8000ffa:	9b01      	ldr	r3, [sp, #4]
 8000ffc:	601a      	str	r2, [r3, #0]
}
 8000ffe:	b002      	add	sp, #8
 8001000:	4770      	bx	lr
 8001002:	46c0      	nop			; (mov r8, r8)
	...

08001010 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 8001010:	b500      	push	{lr}
 8001012:	b083      	sub	sp, #12
 8001014:	9001      	str	r0, [sp, #4]
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8001016:	4b12      	ldr	r3, [pc, #72]	; (8001060 <_pal_lld_init+0x50>)
 8001018:	4a11      	ldr	r2, [pc, #68]	; (8001060 <_pal_lld_init+0x50>)
 800101a:	6952      	ldr	r2, [r2, #20]
 800101c:	219c      	movs	r1, #156	; 0x9c
 800101e:	03c9      	lsls	r1, r1, #15
 8001020:	430a      	orrs	r2, r1
 8001022:	615a      	str	r2, [r3, #20]

  /*
   * Initial GPIO setup.
   */
#if STM32_HAS_GPIOA
  initgpio(GPIOA, &config->PAData);
 8001024:	9a01      	ldr	r2, [sp, #4]
 8001026:	2390      	movs	r3, #144	; 0x90
 8001028:	05db      	lsls	r3, r3, #23
 800102a:	0011      	movs	r1, r2
 800102c:	0018      	movs	r0, r3
 800102e:	f7ff ffc7 	bl	8000fc0 <initgpio>
#endif
#if STM32_HAS_GPIOB
  initgpio(GPIOB, &config->PBData);
 8001032:	9b01      	ldr	r3, [sp, #4]
 8001034:	331c      	adds	r3, #28
 8001036:	4a0b      	ldr	r2, [pc, #44]	; (8001064 <_pal_lld_init+0x54>)
 8001038:	0019      	movs	r1, r3
 800103a:	0010      	movs	r0, r2
 800103c:	f7ff ffc0 	bl	8000fc0 <initgpio>
#endif
#if STM32_HAS_GPIOC
  initgpio(GPIOC, &config->PCData);
 8001040:	9b01      	ldr	r3, [sp, #4]
 8001042:	3338      	adds	r3, #56	; 0x38
 8001044:	4a08      	ldr	r2, [pc, #32]	; (8001068 <_pal_lld_init+0x58>)
 8001046:	0019      	movs	r1, r3
 8001048:	0010      	movs	r0, r2
 800104a:	f7ff ffb9 	bl	8000fc0 <initgpio>
#endif
#if STM32_HAS_GPIOE
  initgpio(GPIOE, &config->PEData);
#endif
#if STM32_HAS_GPIOF
  initgpio(GPIOF, &config->PFData);
 800104e:	9b01      	ldr	r3, [sp, #4]
 8001050:	3354      	adds	r3, #84	; 0x54
 8001052:	4a06      	ldr	r2, [pc, #24]	; (800106c <_pal_lld_init+0x5c>)
 8001054:	0019      	movs	r1, r3
 8001056:	0010      	movs	r0, r2
 8001058:	f7ff ffb2 	bl	8000fc0 <initgpio>
  initgpio(GPIOJ, &config->PJData);
#endif
#if STM32_HAS_GPIOK
  initgpio(GPIOK, &config->PKData);
#endif
}
 800105c:	b003      	add	sp, #12
 800105e:	bd00      	pop	{pc}
 8001060:	40021000 	.word	0x40021000
 8001064:	48000400 	.word	0x48000400
 8001068:	48000800 	.word	0x48000800
 800106c:	48001400 	.word	0x48001400

08001070 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8001070:	b08e      	sub	sp, #56	; 0x38
 8001072:	9003      	str	r0, [sp, #12]
 8001074:	9102      	str	r1, [sp, #8]
 8001076:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8001078:	9b01      	ldr	r3, [sp, #4]
 800107a:	2203      	movs	r2, #3
 800107c:	4013      	ands	r3, r2
 800107e:	930d      	str	r3, [sp, #52]	; 0x34
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8001080:	9b01      	ldr	r3, [sp, #4]
 8001082:	089b      	lsrs	r3, r3, #2
 8001084:	2201      	movs	r2, #1
 8001086:	4013      	ands	r3, r2
 8001088:	930c      	str	r3, [sp, #48]	; 0x30
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 800108a:	9b01      	ldr	r3, [sp, #4]
 800108c:	08db      	lsrs	r3, r3, #3
 800108e:	2203      	movs	r2, #3
 8001090:	4013      	ands	r3, r2
 8001092:	930b      	str	r3, [sp, #44]	; 0x2c
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 8001094:	9b01      	ldr	r3, [sp, #4]
 8001096:	095b      	lsrs	r3, r3, #5
 8001098:	2203      	movs	r2, #3
 800109a:	4013      	ands	r3, r2
 800109c:	930a      	str	r3, [sp, #40]	; 0x28
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 800109e:	9b01      	ldr	r3, [sp, #4]
 80010a0:	09db      	lsrs	r3, r3, #7
 80010a2:	220f      	movs	r2, #15
 80010a4:	4013      	ands	r3, r2
 80010a6:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
 80010a8:	2300      	movs	r3, #0
 80010aa:	9309      	str	r3, [sp, #36]	; 0x24
  while (true) {
    if ((mask & 1) != 0) {
 80010ac:	9b02      	ldr	r3, [sp, #8]
 80010ae:	2201      	movs	r2, #1
 80010b0:	4013      	ands	r3, r2
 80010b2:	d100      	bne.n	80010b6 <_pal_lld_setgroupmode+0x46>
 80010b4:	e079      	b.n	80011aa <_pal_lld_setgroupmode+0x13a>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 80010b6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80010b8:	2207      	movs	r2, #7
 80010ba:	4013      	ands	r3, r2
 80010bc:	009b      	lsls	r3, r3, #2
 80010be:	9a08      	ldr	r2, [sp, #32]
 80010c0:	409a      	lsls	r2, r3
 80010c2:	0013      	movs	r3, r2
 80010c4:	9307      	str	r3, [sp, #28]
      m1 = 1 << bit;
 80010c6:	2201      	movs	r2, #1
 80010c8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80010ca:	409a      	lsls	r2, r3
 80010cc:	0013      	movs	r3, r2
 80010ce:	9306      	str	r3, [sp, #24]
      m2 = 3 << (bit * 2);
 80010d0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80010d2:	005b      	lsls	r3, r3, #1
 80010d4:	2203      	movs	r2, #3
 80010d6:	409a      	lsls	r2, r3
 80010d8:	0013      	movs	r3, r2
 80010da:	9305      	str	r3, [sp, #20]
      m4 = 15 << ((bit & 7) * 4);
 80010dc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80010de:	2207      	movs	r2, #7
 80010e0:	4013      	ands	r3, r2
 80010e2:	009b      	lsls	r3, r3, #2
 80010e4:	220f      	movs	r2, #15
 80010e6:	409a      	lsls	r2, r3
 80010e8:	0013      	movs	r3, r2
 80010ea:	9304      	str	r3, [sp, #16]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 80010ec:	9b03      	ldr	r3, [sp, #12]
 80010ee:	685b      	ldr	r3, [r3, #4]
 80010f0:	9a06      	ldr	r2, [sp, #24]
 80010f2:	43d2      	mvns	r2, r2
 80010f4:	401a      	ands	r2, r3
 80010f6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80010f8:	431a      	orrs	r2, r3
 80010fa:	9b03      	ldr	r3, [sp, #12]
 80010fc:	605a      	str	r2, [r3, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 80010fe:	9b03      	ldr	r3, [sp, #12]
 8001100:	689b      	ldr	r3, [r3, #8]
 8001102:	9a05      	ldr	r2, [sp, #20]
 8001104:	43d2      	mvns	r2, r2
 8001106:	401a      	ands	r2, r3
 8001108:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800110a:	431a      	orrs	r2, r3
 800110c:	9b03      	ldr	r3, [sp, #12]
 800110e:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8001110:	9b03      	ldr	r3, [sp, #12]
 8001112:	68db      	ldr	r3, [r3, #12]
 8001114:	9a05      	ldr	r2, [sp, #20]
 8001116:	43d2      	mvns	r2, r2
 8001118:	401a      	ands	r2, r3
 800111a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800111c:	431a      	orrs	r2, r3
 800111e:	9b03      	ldr	r3, [sp, #12]
 8001120:	60da      	str	r2, [r3, #12]
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 8001122:	9b01      	ldr	r3, [sp, #4]
 8001124:	2203      	movs	r2, #3
 8001126:	4013      	ands	r3, r2
 8001128:	2b02      	cmp	r3, #2
 800112a:	d11f      	bne.n	800116c <_pal_lld_setgroupmode+0xfc>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 800112c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800112e:	2b07      	cmp	r3, #7
 8001130:	d809      	bhi.n	8001146 <_pal_lld_setgroupmode+0xd6>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8001132:	9b03      	ldr	r3, [sp, #12]
 8001134:	6a1b      	ldr	r3, [r3, #32]
 8001136:	9a04      	ldr	r2, [sp, #16]
 8001138:	43d2      	mvns	r2, r2
 800113a:	401a      	ands	r2, r3
 800113c:	9b07      	ldr	r3, [sp, #28]
 800113e:	431a      	orrs	r2, r3
 8001140:	9b03      	ldr	r3, [sp, #12]
 8001142:	621a      	str	r2, [r3, #32]
 8001144:	e008      	b.n	8001158 <_pal_lld_setgroupmode+0xe8>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8001146:	9b03      	ldr	r3, [sp, #12]
 8001148:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800114a:	9a04      	ldr	r2, [sp, #16]
 800114c:	43d2      	mvns	r2, r2
 800114e:	401a      	ands	r2, r3
 8001150:	9b07      	ldr	r3, [sp, #28]
 8001152:	431a      	orrs	r2, r3
 8001154:	9b03      	ldr	r3, [sp, #12]
 8001156:	625a      	str	r2, [r3, #36]	; 0x24
        port->MODER   = (port->MODER & ~m2) | moder;
 8001158:	9b03      	ldr	r3, [sp, #12]
 800115a:	681b      	ldr	r3, [r3, #0]
 800115c:	9a05      	ldr	r2, [sp, #20]
 800115e:	43d2      	mvns	r2, r2
 8001160:	401a      	ands	r2, r3
 8001162:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8001164:	431a      	orrs	r2, r3
 8001166:	9b03      	ldr	r3, [sp, #12]
 8001168:	601a      	str	r2, [r3, #0]
 800116a:	e01e      	b.n	80011aa <_pal_lld_setgroupmode+0x13a>
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 800116c:	9b03      	ldr	r3, [sp, #12]
 800116e:	681b      	ldr	r3, [r3, #0]
 8001170:	9a05      	ldr	r2, [sp, #20]
 8001172:	43d2      	mvns	r2, r2
 8001174:	401a      	ands	r2, r3
 8001176:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8001178:	431a      	orrs	r2, r3
 800117a:	9b03      	ldr	r3, [sp, #12]
 800117c:	601a      	str	r2, [r3, #0]
        if (bit < 8)
 800117e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8001180:	2b07      	cmp	r3, #7
 8001182:	d809      	bhi.n	8001198 <_pal_lld_setgroupmode+0x128>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8001184:	9b03      	ldr	r3, [sp, #12]
 8001186:	6a1b      	ldr	r3, [r3, #32]
 8001188:	9a04      	ldr	r2, [sp, #16]
 800118a:	43d2      	mvns	r2, r2
 800118c:	401a      	ands	r2, r3
 800118e:	9b07      	ldr	r3, [sp, #28]
 8001190:	431a      	orrs	r2, r3
 8001192:	9b03      	ldr	r3, [sp, #12]
 8001194:	621a      	str	r2, [r3, #32]
 8001196:	e008      	b.n	80011aa <_pal_lld_setgroupmode+0x13a>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8001198:	9b03      	ldr	r3, [sp, #12]
 800119a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800119c:	9a04      	ldr	r2, [sp, #16]
 800119e:	43d2      	mvns	r2, r2
 80011a0:	401a      	ands	r2, r3
 80011a2:	9b07      	ldr	r3, [sp, #28]
 80011a4:	431a      	orrs	r2, r3
 80011a6:	9b03      	ldr	r3, [sp, #12]
 80011a8:	625a      	str	r2, [r3, #36]	; 0x24
      }
    }
    mask >>= 1;
 80011aa:	9b02      	ldr	r3, [sp, #8]
 80011ac:	085b      	lsrs	r3, r3, #1
 80011ae:	9302      	str	r3, [sp, #8]
    if (!mask)
 80011b0:	9b02      	ldr	r3, [sp, #8]
 80011b2:	2b00      	cmp	r3, #0
 80011b4:	d00f      	beq.n	80011d6 <_pal_lld_setgroupmode+0x166>
      return;
    otyper <<= 1;
 80011b6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80011b8:	005b      	lsls	r3, r3, #1
 80011ba:	930c      	str	r3, [sp, #48]	; 0x30
    ospeedr <<= 2;
 80011bc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80011be:	009b      	lsls	r3, r3, #2
 80011c0:	930b      	str	r3, [sp, #44]	; 0x2c
    pupdr <<= 2;
 80011c2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80011c4:	009b      	lsls	r3, r3, #2
 80011c6:	930a      	str	r3, [sp, #40]	; 0x28
    moder <<= 2;
 80011c8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80011ca:	009b      	lsls	r3, r3, #2
 80011cc:	930d      	str	r3, [sp, #52]	; 0x34
    bit++;
 80011ce:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80011d0:	3301      	adds	r3, #1
 80011d2:	9309      	str	r3, [sp, #36]	; 0x24
 80011d4:	e76a      	b.n	80010ac <_pal_lld_setgroupmode+0x3c>
  }
}
 80011d6:	b00e      	add	sp, #56	; 0x38
 80011d8:	4770      	bx	lr
 80011da:	46c0      	nop			; (mov r8, r8)
 80011dc:	0000      	movs	r0, r0
	...

080011e0 <port_lock.lto_priv.70>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80011e0:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 80011e2:	4770      	bx	lr
	...

080011f0 <port_unlock.lto_priv.68>:
  __ASM volatile ("cpsie i" : : : "memory");
 80011f0:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 80011f2:	4770      	bx	lr
	...

08001200 <port_lock_from_isr>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8001200:	b510      	push	{r4, lr}

  port_lock();
 8001202:	f7ff ffed 	bl	80011e0 <port_lock.lto_priv.70>
}
 8001206:	bd10      	pop	{r4, pc}
	...

08001210 <port_unlock_from_isr>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8001210:	b510      	push	{r4, lr}

  port_unlock();
 8001212:	f7ff ffed 	bl	80011f0 <port_unlock.lto_priv.68>
}
 8001216:	bd10      	pop	{r4, pc}
	...

08001220 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8001220:	b510      	push	{r4, lr}

  port_lock_from_isr();
 8001222:	f7ff ffed 	bl	8001200 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8001226:	f001 fd7b 	bl	8002d20 <_dbg_check_lock_from_isr>
}
 800122a:	bd10      	pop	{r4, pc}
 800122c:	0000      	movs	r0, r0
	...

08001230 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8001230:	b510      	push	{r4, lr}

  _dbg_check_unlock_from_isr();
 8001232:	f001 fd8d 	bl	8002d50 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8001236:	f7ff ffeb 	bl	8001210 <port_unlock_from_isr>
}
 800123a:	bd10      	pop	{r4, pc}
 800123c:	0000      	movs	r0, r0
	...

08001240 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8001240:	b510      	push	{r4, lr}

  chSysLockFromISR();
 8001242:	f7ff ffed 	bl	8001220 <chSysLockFromISR>
}
 8001246:	bd10      	pop	{r4, pc}
	...

08001250 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8001250:	b510      	push	{r4, lr}

  chSysUnlockFromISR();
 8001252:	f7ff ffed 	bl	8001230 <chSysUnlockFromISR>
}
 8001256:	bd10      	pop	{r4, pc}
	...

08001260 <osalOsTimerHandlerI>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
 8001260:	b510      	push	{r4, lr}

  chSysTimerHandlerI();
 8001262:	f001 fced 	bl	8002c40 <chSysTimerHandlerI>
}
 8001266:	bd10      	pop	{r4, pc}
	...

08001270 <Vector7C>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8001270:	b500      	push	{lr}
 8001272:	b083      	sub	sp, #12
 8001274:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 8001276:	9301      	str	r3, [sp, #4]
 8001278:	4b10      	ldr	r3, [pc, #64]	; (80012bc <Vector7C+0x4c>)
 800127a:	0018      	movs	r0, r3
 800127c:	f001 feb0 	bl	8002fe0 <_trace_isr_enter>
 8001280:	f001 fd7e 	bl	8002d80 <_dbg_check_enter_isr>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8001284:	2380      	movs	r3, #128	; 0x80
 8001286:	05db      	lsls	r3, r3, #23
 8001288:	691b      	ldr	r3, [r3, #16]
 800128a:	2202      	movs	r2, #2
 800128c:	4013      	ands	r3, r2
 800128e:	d009      	beq.n	80012a4 <Vector7C+0x34>
    STM32_ST_TIM->SR = 0U;
 8001290:	2380      	movs	r3, #128	; 0x80
 8001292:	05db      	lsls	r3, r3, #23
 8001294:	2200      	movs	r2, #0
 8001296:	611a      	str	r2, [r3, #16]

    osalSysLockFromISR();
 8001298:	f7ff ffd2 	bl	8001240 <osalSysLockFromISR>
    osalOsTimerHandlerI();
 800129c:	f7ff ffe0 	bl	8001260 <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
 80012a0:	f7ff ffd6 	bl	8001250 <osalSysUnlockFromISR>
  }

  OSAL_IRQ_EPILOGUE();
 80012a4:	f001 fd8c 	bl	8002dc0 <_dbg_check_leave_isr>
 80012a8:	4b04      	ldr	r3, [pc, #16]	; (80012bc <Vector7C+0x4c>)
 80012aa:	0018      	movs	r0, r3
 80012ac:	f001 fec0 	bl	8003030 <_trace_isr_leave>
 80012b0:	9b01      	ldr	r3, [sp, #4]
 80012b2:	0018      	movs	r0, r3
 80012b4:	f000 fe24 	bl	8001f00 <_port_irq_epilogue>
}
 80012b8:	b003      	add	sp, #12
 80012ba:	bd00      	pop	{pc}
 80012bc:	08003e3c 	.word	0x08003e3c

080012c0 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 80012c0:	b510      	push	{r4, lr}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80012c2:	4b19      	ldr	r3, [pc, #100]	; (8001328 <st_lld_init+0x68>)
 80012c4:	4a18      	ldr	r2, [pc, #96]	; (8001328 <st_lld_init+0x68>)
 80012c6:	69d2      	ldr	r2, [r2, #28]
 80012c8:	2101      	movs	r1, #1
 80012ca:	430a      	orrs	r2, r1
 80012cc:	61da      	str	r2, [r3, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80012ce:	4b17      	ldr	r3, [pc, #92]	; (800132c <st_lld_init+0x6c>)
 80012d0:	4a16      	ldr	r2, [pc, #88]	; (800132c <st_lld_init+0x6c>)
 80012d2:	6892      	ldr	r2, [r2, #8]
 80012d4:	2101      	movs	r1, #1
 80012d6:	430a      	orrs	r2, r1
 80012d8:	609a      	str	r2, [r3, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80012da:	2380      	movs	r3, #128	; 0x80
 80012dc:	05db      	lsls	r3, r3, #23
 80012de:	4a14      	ldr	r2, [pc, #80]	; (8001330 <st_lld_init+0x70>)
 80012e0:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80012e2:	2380      	movs	r3, #128	; 0x80
 80012e4:	05db      	lsls	r3, r3, #23
 80012e6:	2201      	movs	r2, #1
 80012e8:	4252      	negs	r2, r2
 80012ea:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 80012ec:	2380      	movs	r3, #128	; 0x80
 80012ee:	05db      	lsls	r3, r3, #23
 80012f0:	2200      	movs	r2, #0
 80012f2:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 80012f4:	2380      	movs	r3, #128	; 0x80
 80012f6:	05db      	lsls	r3, r3, #23
 80012f8:	2200      	movs	r2, #0
 80012fa:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 80012fc:	2380      	movs	r3, #128	; 0x80
 80012fe:	05db      	lsls	r3, r3, #23
 8001300:	2200      	movs	r2, #0
 8001302:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8001304:	2380      	movs	r3, #128	; 0x80
 8001306:	05db      	lsls	r3, r3, #23
 8001308:	2200      	movs	r2, #0
 800130a:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800130c:	2380      	movs	r3, #128	; 0x80
 800130e:	05db      	lsls	r3, r3, #23
 8001310:	2201      	movs	r2, #1
 8001312:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8001314:	2380      	movs	r3, #128	; 0x80
 8001316:	05db      	lsls	r3, r3, #23
 8001318:	2201      	movs	r2, #1
 800131a:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 800131c:	2102      	movs	r1, #2
 800131e:	200f      	movs	r0, #15
 8001320:	f7ff fd16 	bl	8000d50 <nvicEnableVector>
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8001324:	bd10      	pop	{r4, pc}
 8001326:	46c0      	nop			; (mov r8, r8)
 8001328:	40021000 	.word	0x40021000
 800132c:	40015800 	.word	0x40015800
 8001330:	000012bf 	.word	0x000012bf
	...

08001340 <Vector80>:
/**
 * @brief   TIM3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM3_HANDLER) {
 8001340:	b500      	push	{lr}
 8001342:	b083      	sub	sp, #12
 8001344:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 8001346:	9301      	str	r3, [sp, #4]
 8001348:	4b0a      	ldr	r3, [pc, #40]	; (8001374 <Vector80+0x34>)
 800134a:	0018      	movs	r0, r3
 800134c:	f001 fe48 	bl	8002fe0 <_trace_isr_enter>
 8001350:	f001 fd16 	bl	8002d80 <_dbg_check_enter_isr>

  icu_lld_serve_interrupt(&ICUD3);
 8001354:	4b08      	ldr	r3, [pc, #32]	; (8001378 <Vector80+0x38>)
 8001356:	0018      	movs	r0, r3
 8001358:	f000 f982 	bl	8001660 <icu_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 800135c:	f001 fd30 	bl	8002dc0 <_dbg_check_leave_isr>
 8001360:	4b04      	ldr	r3, [pc, #16]	; (8001374 <Vector80+0x34>)
 8001362:	0018      	movs	r0, r3
 8001364:	f001 fe64 	bl	8003030 <_trace_isr_leave>
 8001368:	9b01      	ldr	r3, [sp, #4]
 800136a:	0018      	movs	r0, r3
 800136c:	f000 fdc8 	bl	8001f00 <_port_irq_epilogue>
}
 8001370:	b003      	add	sp, #12
 8001372:	bd00      	pop	{pc}
 8001374:	08003e48 	.word	0x08003e48
 8001378:	20000dd8 	.word	0x20000dd8
 800137c:	00000000 	.word	0x00000000

08001380 <icu_lld_init>:
/**
 * @brief   Low level ICU driver initialization.
 *
 * @notapi
 */
void icu_lld_init(void) {
 8001380:	b510      	push	{r4, lr}
  ICUD2.tim = STM32_TIM2;
#endif

#if STM32_ICU_USE_TIM3
  /* Driver initialization.*/
  icuObjectInit(&ICUD3);
 8001382:	4b04      	ldr	r3, [pc, #16]	; (8001394 <icu_lld_init+0x14>)
 8001384:	0018      	movs	r0, r3
 8001386:	f000 fa8b 	bl	80018a0 <icuObjectInit>
  ICUD3.tim = STM32_TIM3;
 800138a:	4b02      	ldr	r3, [pc, #8]	; (8001394 <icu_lld_init+0x14>)
 800138c:	4a02      	ldr	r2, [pc, #8]	; (8001398 <icu_lld_init+0x18>)
 800138e:	60da      	str	r2, [r3, #12]
#if STM32_ICU_USE_TIM9
  /* Driver initialization.*/
  icuObjectInit(&ICUD9);
  ICUD9.tim = STM32_TIM9;
#endif
}
 8001390:	bd10      	pop	{r4, pc}
 8001392:	46c0      	nop			; (mov r8, r8)
 8001394:	20000dd8 	.word	0x20000dd8
 8001398:	40000400 	.word	0x40000400
 800139c:	00000000 	.word	0x00000000

080013a0 <icu_lld_start>:
 *
 * @param[in] icup      pointer to the @p ICUDriver object
 *
 * @notapi
 */
void icu_lld_start(ICUDriver *icup) {
 80013a0:	b500      	push	{lr}
 80013a2:	b085      	sub	sp, #20
 80013a4:	9001      	str	r0, [sp, #4]
  uint32_t psc;

  osalDbgAssert((icup->config->channel == ICU_CHANNEL_1) ||
 80013a6:	9b01      	ldr	r3, [sp, #4]
 80013a8:	685b      	ldr	r3, [r3, #4]
 80013aa:	7d1b      	ldrb	r3, [r3, #20]
 80013ac:	2b00      	cmp	r3, #0
 80013ae:	d008      	beq.n	80013c2 <icu_lld_start+0x22>
 80013b0:	9b01      	ldr	r3, [sp, #4]
 80013b2:	685b      	ldr	r3, [r3, #4]
 80013b4:	7d1b      	ldrb	r3, [r3, #20]
 80013b6:	2b01      	cmp	r3, #1
 80013b8:	d003      	beq.n	80013c2 <icu_lld_start+0x22>
 80013ba:	4b5a      	ldr	r3, [pc, #360]	; (8001524 <icu_lld_start+0x184>)
 80013bc:	0018      	movs	r0, r3
 80013be:	f001 fc2f 	bl	8002c20 <chSysHalt>
                (icup->config->channel == ICU_CHANNEL_2),
                "invalid input");

  if (icup->state == ICU_STOP) {
 80013c2:	9b01      	ldr	r3, [sp, #4]
 80013c4:	781b      	ldrb	r3, [r3, #0]
 80013c6:	2b01      	cmp	r3, #1
 80013c8:	d11a      	bne.n	8001400 <icu_lld_start+0x60>
#endif
    }
#endif

#if STM32_ICU_USE_TIM3
    if (&ICUD3 == icup) {
 80013ca:	9a01      	ldr	r2, [sp, #4]
 80013cc:	4b56      	ldr	r3, [pc, #344]	; (8001528 <icu_lld_start+0x188>)
 80013ce:	429a      	cmp	r2, r3
 80013d0:	d127      	bne.n	8001422 <icu_lld_start+0x82>
      rccEnableTIM3(FALSE);
 80013d2:	4b56      	ldr	r3, [pc, #344]	; (800152c <icu_lld_start+0x18c>)
 80013d4:	4a55      	ldr	r2, [pc, #340]	; (800152c <icu_lld_start+0x18c>)
 80013d6:	69d2      	ldr	r2, [r2, #28]
 80013d8:	2102      	movs	r1, #2
 80013da:	430a      	orrs	r2, r1
 80013dc:	61da      	str	r2, [r3, #28]
      rccResetTIM3();
 80013de:	4b53      	ldr	r3, [pc, #332]	; (800152c <icu_lld_start+0x18c>)
 80013e0:	4a52      	ldr	r2, [pc, #328]	; (800152c <icu_lld_start+0x18c>)
 80013e2:	6912      	ldr	r2, [r2, #16]
 80013e4:	2102      	movs	r1, #2
 80013e6:	430a      	orrs	r2, r1
 80013e8:	611a      	str	r2, [r3, #16]
 80013ea:	4b50      	ldr	r3, [pc, #320]	; (800152c <icu_lld_start+0x18c>)
 80013ec:	2200      	movs	r2, #0
 80013ee:	611a      	str	r2, [r3, #16]
#if !defined(STM32_TIM3_SUPPRESS_ISR)
      nvicEnableVector(STM32_TIM3_NUMBER, STM32_ICU_TIM3_IRQ_PRIORITY);
 80013f0:	2103      	movs	r1, #3
 80013f2:	2010      	movs	r0, #16
 80013f4:	f7ff fcac 	bl	8000d50 <nvicEnableVector>
#endif
#if defined(STM32_TIM3CLK)
      icup->clock = STM32_TIM3CLK;
#else
     icup->clock = STM32_TIMCLK1;
 80013f8:	9b01      	ldr	r3, [sp, #4]
 80013fa:	4a4d      	ldr	r2, [pc, #308]	; (8001530 <icu_lld_start+0x190>)
 80013fc:	609a      	str	r2, [r3, #8]
 80013fe:	e011      	b.n	8001424 <icu_lld_start+0x84>
    }
#endif
  }
  else {
    /* Driver re-configuration scenario, it must be stopped first.*/
    icup->tim->CR1    = 0;                  /* Timer disabled.              */
 8001400:	9b01      	ldr	r3, [sp, #4]
 8001402:	68db      	ldr	r3, [r3, #12]
 8001404:	2200      	movs	r2, #0
 8001406:	601a      	str	r2, [r3, #0]
    icup->tim->CCR[0] = 0;                  /* Comparator 1 disabled.       */
 8001408:	9b01      	ldr	r3, [sp, #4]
 800140a:	68db      	ldr	r3, [r3, #12]
 800140c:	2200      	movs	r2, #0
 800140e:	635a      	str	r2, [r3, #52]	; 0x34
    icup->tim->CCR[1] = 0;                  /* Comparator 2 disabled.       */
 8001410:	9b01      	ldr	r3, [sp, #4]
 8001412:	68db      	ldr	r3, [r3, #12]
 8001414:	2200      	movs	r2, #0
 8001416:	639a      	str	r2, [r3, #56]	; 0x38
    icup->tim->CNT    = 0;                  /* Counter reset to zero.       */
 8001418:	9b01      	ldr	r3, [sp, #4]
 800141a:	68db      	ldr	r3, [r3, #12]
 800141c:	2200      	movs	r2, #0
 800141e:	625a      	str	r2, [r3, #36]	; 0x24
 8001420:	e000      	b.n	8001424 <icu_lld_start+0x84>
     icup->clock = STM32_TIMCLK1;
 8001422:	46c0      	nop			; (mov r8, r8)
  }

  /* Timer configuration.*/
  icup->tim->SR   = 0;                      /* Clear eventual pending IRQs. */
 8001424:	9b01      	ldr	r3, [sp, #4]
 8001426:	68db      	ldr	r3, [r3, #12]
 8001428:	2200      	movs	r2, #0
 800142a:	611a      	str	r2, [r3, #16]
  icup->tim->DIER = icup->config->dier &    /* DMA-related DIER settings.   */
 800142c:	9b01      	ldr	r3, [sp, #4]
 800142e:	68db      	ldr	r3, [r3, #12]
 8001430:	9a01      	ldr	r2, [sp, #4]
 8001432:	6852      	ldr	r2, [r2, #4]
 8001434:	6992      	ldr	r2, [r2, #24]
 8001436:	21ff      	movs	r1, #255	; 0xff
 8001438:	438a      	bics	r2, r1
 800143a:	60da      	str	r2, [r3, #12]
                    ~STM32_TIM_DIER_IRQ_MASK;
  psc = (icup->clock / icup->config->frequency) - 1;
 800143c:	9b01      	ldr	r3, [sp, #4]
 800143e:	689a      	ldr	r2, [r3, #8]
 8001440:	9b01      	ldr	r3, [sp, #4]
 8001442:	685b      	ldr	r3, [r3, #4]
 8001444:	685b      	ldr	r3, [r3, #4]
 8001446:	0019      	movs	r1, r3
 8001448:	0010      	movs	r0, r2
 800144a:	f7fe fec7 	bl	80001dc <__aeabi_uidiv>
 800144e:	0003      	movs	r3, r0
 8001450:	3b01      	subs	r3, #1
 8001452:	9303      	str	r3, [sp, #12]
  osalDbgAssert((psc <= 0xFFFF) &&
 8001454:	9b03      	ldr	r3, [sp, #12]
 8001456:	4a37      	ldr	r2, [pc, #220]	; (8001534 <icu_lld_start+0x194>)
 8001458:	4293      	cmp	r3, r2
 800145a:	d809      	bhi.n	8001470 <icu_lld_start+0xd0>
 800145c:	9b03      	ldr	r3, [sp, #12]
 800145e:	1c5a      	adds	r2, r3, #1
 8001460:	9b01      	ldr	r3, [sp, #4]
 8001462:	685b      	ldr	r3, [r3, #4]
 8001464:	685b      	ldr	r3, [r3, #4]
 8001466:	435a      	muls	r2, r3
 8001468:	9b01      	ldr	r3, [sp, #4]
 800146a:	689b      	ldr	r3, [r3, #8]
 800146c:	429a      	cmp	r2, r3
 800146e:	d003      	beq.n	8001478 <icu_lld_start+0xd8>
 8001470:	4b2c      	ldr	r3, [pc, #176]	; (8001524 <icu_lld_start+0x184>)
 8001472:	0018      	movs	r0, r3
 8001474:	f001 fbd4 	bl	8002c20 <chSysHalt>
                ((psc + 1) * icup->config->frequency) == icup->clock,
                "invalid frequency");
  icup->tim->PSC  = psc;
 8001478:	9b01      	ldr	r3, [sp, #4]
 800147a:	68db      	ldr	r3, [r3, #12]
 800147c:	9a03      	ldr	r2, [sp, #12]
 800147e:	629a      	str	r2, [r3, #40]	; 0x28
  icup->tim->ARR  = 0xFFFF;
 8001480:	9b01      	ldr	r3, [sp, #4]
 8001482:	68db      	ldr	r3, [r3, #12]
 8001484:	4a2b      	ldr	r2, [pc, #172]	; (8001534 <icu_lld_start+0x194>)
 8001486:	62da      	str	r2, [r3, #44]	; 0x2c

  if (icup->config->channel == ICU_CHANNEL_1) {
 8001488:	9b01      	ldr	r3, [sp, #4]
 800148a:	685b      	ldr	r3, [r3, #4]
 800148c:	7d1b      	ldrb	r3, [r3, #20]
 800148e:	2b00      	cmp	r3, #0
 8001490:	d122      	bne.n	80014d8 <icu_lld_start+0x138>
    /* Selected input 1.
       CCMR1_CC1S = 01 = CH1 Input on TI1.
       CCMR1_CC2S = 10 = CH2 Input on TI1.*/
    icup->tim->CCMR1 = STM32_TIM_CCMR1_CC1S(1) | STM32_TIM_CCMR1_CC2S(2);
 8001492:	9b01      	ldr	r3, [sp, #4]
 8001494:	68db      	ldr	r3, [r3, #12]
 8001496:	4a28      	ldr	r2, [pc, #160]	; (8001538 <icu_lld_start+0x198>)
 8001498:	619a      	str	r2, [r3, #24]

    /* SMCR_TS  = 101, input is TI1FP1.
       SMCR_SMS = 100, reset on rising edge.*/
    icup->tim->SMCR  = STM32_TIM_SMCR_TS(5) | STM32_TIM_SMCR_SMS(4);
 800149a:	9b01      	ldr	r3, [sp, #4]
 800149c:	68db      	ldr	r3, [r3, #12]
 800149e:	2254      	movs	r2, #84	; 0x54
 80014a0:	609a      	str	r2, [r3, #8]

    /* The CCER settings depend on the selected trigger mode.
       ICU_INPUT_ACTIVE_HIGH: Active on rising edge, idle on falling edge.
       ICU_INPUT_ACTIVE_LOW:  Active on falling edge, idle on rising edge.*/
    if (icup->config->mode == ICU_INPUT_ACTIVE_HIGH)
 80014a2:	9b01      	ldr	r3, [sp, #4]
 80014a4:	685b      	ldr	r3, [r3, #4]
 80014a6:	781b      	ldrb	r3, [r3, #0]
 80014a8:	2b00      	cmp	r3, #0
 80014aa:	d104      	bne.n	80014b6 <icu_lld_start+0x116>
      icup->tim->CCER = STM32_TIM_CCER_CC1E |
 80014ac:	9b01      	ldr	r3, [sp, #4]
 80014ae:	68db      	ldr	r3, [r3, #12]
 80014b0:	2231      	movs	r2, #49	; 0x31
 80014b2:	621a      	str	r2, [r3, #32]
 80014b4:	e003      	b.n	80014be <icu_lld_start+0x11e>
                        STM32_TIM_CCER_CC2E | STM32_TIM_CCER_CC2P;
    else
      icup->tim->CCER = STM32_TIM_CCER_CC1E | STM32_TIM_CCER_CC1P |
 80014b6:	9b01      	ldr	r3, [sp, #4]
 80014b8:	68db      	ldr	r3, [r3, #12]
 80014ba:	2213      	movs	r2, #19
 80014bc:	621a      	str	r2, [r3, #32]
                        STM32_TIM_CCER_CC2E;

    /* Direct pointers to the capture registers in order to make reading
       data faster from within callbacks.*/
    icup->wccrp = &icup->tim->CCR[1];
 80014be:	9b01      	ldr	r3, [sp, #4]
 80014c0:	68db      	ldr	r3, [r3, #12]
 80014c2:	3338      	adds	r3, #56	; 0x38
 80014c4:	001a      	movs	r2, r3
 80014c6:	9b01      	ldr	r3, [sp, #4]
 80014c8:	611a      	str	r2, [r3, #16]
    icup->pccrp = &icup->tim->CCR[0];
 80014ca:	9b01      	ldr	r3, [sp, #4]
 80014cc:	68db      	ldr	r3, [r3, #12]
 80014ce:	3334      	adds	r3, #52	; 0x34
 80014d0:	001a      	movs	r2, r3
 80014d2:	9b01      	ldr	r3, [sp, #4]
 80014d4:	615a      	str	r2, [r3, #20]
 80014d6:	e022      	b.n	800151e <icu_lld_start+0x17e>
  }
  else {
    /* Selected input 2.
       CCMR1_CC1S = 10 = CH1 Input on TI2.
       CCMR1_CC2S = 01 = CH2 Input on TI2.*/
    icup->tim->CCMR1 = STM32_TIM_CCMR1_CC1S(2) | STM32_TIM_CCMR1_CC2S(1);
 80014d8:	9b01      	ldr	r3, [sp, #4]
 80014da:	68db      	ldr	r3, [r3, #12]
 80014dc:	2281      	movs	r2, #129	; 0x81
 80014de:	0052      	lsls	r2, r2, #1
 80014e0:	619a      	str	r2, [r3, #24]

    /* SMCR_TS  = 110, input is TI2FP2.
       SMCR_SMS = 100, reset on rising edge.*/
    icup->tim->SMCR  = STM32_TIM_SMCR_TS(6) | STM32_TIM_SMCR_SMS(4);
 80014e2:	9b01      	ldr	r3, [sp, #4]
 80014e4:	68db      	ldr	r3, [r3, #12]
 80014e6:	2264      	movs	r2, #100	; 0x64
 80014e8:	609a      	str	r2, [r3, #8]

    /* The CCER settings depend on the selected trigger mode.
       ICU_INPUT_ACTIVE_HIGH: Active on rising edge, idle on falling edge.
       ICU_INPUT_ACTIVE_LOW:  Active on falling edge, idle on rising edge.*/
    if (icup->config->mode == ICU_INPUT_ACTIVE_HIGH)
 80014ea:	9b01      	ldr	r3, [sp, #4]
 80014ec:	685b      	ldr	r3, [r3, #4]
 80014ee:	781b      	ldrb	r3, [r3, #0]
 80014f0:	2b00      	cmp	r3, #0
 80014f2:	d104      	bne.n	80014fe <icu_lld_start+0x15e>
      icup->tim->CCER = STM32_TIM_CCER_CC1E | STM32_TIM_CCER_CC1P |
 80014f4:	9b01      	ldr	r3, [sp, #4]
 80014f6:	68db      	ldr	r3, [r3, #12]
 80014f8:	2213      	movs	r2, #19
 80014fa:	621a      	str	r2, [r3, #32]
 80014fc:	e003      	b.n	8001506 <icu_lld_start+0x166>
                        STM32_TIM_CCER_CC2E;
    else
      icup->tim->CCER = STM32_TIM_CCER_CC1E |
 80014fe:	9b01      	ldr	r3, [sp, #4]
 8001500:	68db      	ldr	r3, [r3, #12]
 8001502:	2231      	movs	r2, #49	; 0x31
 8001504:	621a      	str	r2, [r3, #32]
                        STM32_TIM_CCER_CC2E | STM32_TIM_CCER_CC2P;

    /* Direct pointers to the capture registers in order to make reading
       data faster from within callbacks.*/
    icup->wccrp = &icup->tim->CCR[0];
 8001506:	9b01      	ldr	r3, [sp, #4]
 8001508:	68db      	ldr	r3, [r3, #12]
 800150a:	3334      	adds	r3, #52	; 0x34
 800150c:	001a      	movs	r2, r3
 800150e:	9b01      	ldr	r3, [sp, #4]
 8001510:	611a      	str	r2, [r3, #16]
    icup->pccrp = &icup->tim->CCR[1];
 8001512:	9b01      	ldr	r3, [sp, #4]
 8001514:	68db      	ldr	r3, [r3, #12]
 8001516:	3338      	adds	r3, #56	; 0x38
 8001518:	001a      	movs	r2, r3
 800151a:	9b01      	ldr	r3, [sp, #4]
 800151c:	615a      	str	r2, [r3, #20]
  }
}
 800151e:	b005      	add	sp, #20
 8001520:	bd00      	pop	{pc}
 8001522:	46c0      	nop			; (mov r8, r8)
 8001524:	08003e54 	.word	0x08003e54
 8001528:	20000dd8 	.word	0x20000dd8
 800152c:	40021000 	.word	0x40021000
 8001530:	02dc6c00 	.word	0x02dc6c00
 8001534:	0000ffff 	.word	0x0000ffff
 8001538:	00000201 	.word	0x00000201
 800153c:	00000000 	.word	0x00000000

08001540 <icu_lld_stop>:
 *
 * @param[in] icup      pointer to the @p ICUDriver object
 *
 * @notapi
 */
void icu_lld_stop(ICUDriver *icup) {
 8001540:	b500      	push	{lr}
 8001542:	b083      	sub	sp, #12
 8001544:	9001      	str	r0, [sp, #4]

  if (icup->state == ICU_READY) {
 8001546:	9b01      	ldr	r3, [sp, #4]
 8001548:	781b      	ldrb	r3, [r3, #0]
 800154a:	2b02      	cmp	r3, #2
 800154c:	d118      	bne.n	8001580 <icu_lld_stop+0x40>
    /* Clock deactivation.*/
    icup->tim->CR1  = 0;                    /* Timer disabled.              */
 800154e:	9b01      	ldr	r3, [sp, #4]
 8001550:	68db      	ldr	r3, [r3, #12]
 8001552:	2200      	movs	r2, #0
 8001554:	601a      	str	r2, [r3, #0]
    icup->tim->DIER = 0;                    /* All IRQs disabled.           */
 8001556:	9b01      	ldr	r3, [sp, #4]
 8001558:	68db      	ldr	r3, [r3, #12]
 800155a:	2200      	movs	r2, #0
 800155c:	60da      	str	r2, [r3, #12]
    icup->tim->SR   = 0;                    /* Clear eventual pending IRQs. */
 800155e:	9b01      	ldr	r3, [sp, #4]
 8001560:	68db      	ldr	r3, [r3, #12]
 8001562:	2200      	movs	r2, #0
 8001564:	611a      	str	r2, [r3, #16]
      rccDisableTIM2(FALSE);
    }
#endif

#if STM32_ICU_USE_TIM3
    if (&ICUD3 == icup) {
 8001566:	9a01      	ldr	r2, [sp, #4]
 8001568:	4b06      	ldr	r3, [pc, #24]	; (8001584 <icu_lld_stop+0x44>)
 800156a:	429a      	cmp	r2, r3
 800156c:	d108      	bne.n	8001580 <icu_lld_stop+0x40>
#if !defined(STM32_TIM3_SUPPRESS_ISR)
      nvicDisableVector(STM32_TIM3_NUMBER);
 800156e:	2010      	movs	r0, #16
 8001570:	f7ff fc2e 	bl	8000dd0 <nvicDisableVector>
#endif
      rccDisableTIM3(FALSE);
 8001574:	4b04      	ldr	r3, [pc, #16]	; (8001588 <icu_lld_stop+0x48>)
 8001576:	4a04      	ldr	r2, [pc, #16]	; (8001588 <icu_lld_stop+0x48>)
 8001578:	69d2      	ldr	r2, [r2, #28]
 800157a:	2102      	movs	r1, #2
 800157c:	438a      	bics	r2, r1
 800157e:	61da      	str	r2, [r3, #28]
#endif
      rccDisableTIM9(FALSE);
    }
#endif
  }
}
 8001580:	b003      	add	sp, #12
 8001582:	bd00      	pop	{pc}
 8001584:	20000dd8 	.word	0x20000dd8
 8001588:	40021000 	.word	0x40021000
 800158c:	00000000 	.word	0x00000000

08001590 <icu_lld_start_capture>:
 *
 * @param[in] icup      pointer to the @p ICUDriver object
 *
 * @notapi
 */
void icu_lld_start_capture(ICUDriver *icup) {
 8001590:	b082      	sub	sp, #8
 8001592:	9001      	str	r0, [sp, #4]

  /* Triggering an UG and clearing the IRQ status.*/
  icup->tim->EGR |= STM32_TIM_EGR_UG;
 8001594:	9b01      	ldr	r3, [sp, #4]
 8001596:	68db      	ldr	r3, [r3, #12]
 8001598:	9a01      	ldr	r2, [sp, #4]
 800159a:	68d2      	ldr	r2, [r2, #12]
 800159c:	6952      	ldr	r2, [r2, #20]
 800159e:	2101      	movs	r1, #1
 80015a0:	430a      	orrs	r2, r1
 80015a2:	615a      	str	r2, [r3, #20]
  icup->tim->SR = 0;
 80015a4:	9b01      	ldr	r3, [sp, #4]
 80015a6:	68db      	ldr	r3, [r3, #12]
 80015a8:	2200      	movs	r2, #0
 80015aa:	611a      	str	r2, [r3, #16]

  /* Timer is started.*/
  icup->tim->CR1 = STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
 80015ac:	9b01      	ldr	r3, [sp, #4]
 80015ae:	68db      	ldr	r3, [r3, #12]
 80015b0:	2205      	movs	r2, #5
 80015b2:	601a      	str	r2, [r3, #0]
}
 80015b4:	b002      	add	sp, #8
 80015b6:	4770      	bx	lr
	...

080015c0 <icu_lld_stop_capture>:
 *
 * @param[in] icup      pointer to the @p ICUDriver object
 *
 * @notapi
 */
void icu_lld_stop_capture(ICUDriver *icup) {
 80015c0:	b082      	sub	sp, #8
 80015c2:	9001      	str	r0, [sp, #4]

  /* Timer stopped.*/
  icup->tim->CR1   = 0;
 80015c4:	9b01      	ldr	r3, [sp, #4]
 80015c6:	68db      	ldr	r3, [r3, #12]
 80015c8:	2200      	movs	r2, #0
 80015ca:	601a      	str	r2, [r3, #0]

  /* All interrupts disabled.*/
  icup->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
 80015cc:	9b01      	ldr	r3, [sp, #4]
 80015ce:	68db      	ldr	r3, [r3, #12]
 80015d0:	9a01      	ldr	r2, [sp, #4]
 80015d2:	68d2      	ldr	r2, [r2, #12]
 80015d4:	68d2      	ldr	r2, [r2, #12]
 80015d6:	21ff      	movs	r1, #255	; 0xff
 80015d8:	438a      	bics	r2, r1
 80015da:	60da      	str	r2, [r3, #12]
}
 80015dc:	b002      	add	sp, #8
 80015de:	4770      	bx	lr

080015e0 <icu_lld_enable_notifications>:
 *
 * @param[in] icup      pointer to the @p ICUDriver object
 *
 * @notapi
 */
void icu_lld_enable_notifications(ICUDriver *icup) {
 80015e0:	b084      	sub	sp, #16
 80015e2:	9001      	str	r0, [sp, #4]
  uint32_t dier = icup->tim->DIER;
 80015e4:	9b01      	ldr	r3, [sp, #4]
 80015e6:	68db      	ldr	r3, [r3, #12]
 80015e8:	68db      	ldr	r3, [r3, #12]
 80015ea:	9303      	str	r3, [sp, #12]

  /* If interrupts were already enabled then the operation is skipped.
     This is done in order to avoid clearing the SR and risk losing
     pending interrupts.*/
  if ((dier & STM32_TIM_DIER_IRQ_MASK) == 0) {
 80015ec:	9b03      	ldr	r3, [sp, #12]
 80015ee:	22ff      	movs	r2, #255	; 0xff
 80015f0:	4013      	ands	r3, r2
 80015f2:	d132      	bne.n	800165a <icu_lld_enable_notifications+0x7a>
    /* Previously triggered IRQs are ignored, status cleared.*/
    icup->tim->SR = 0;
 80015f4:	9b01      	ldr	r3, [sp, #4]
 80015f6:	68db      	ldr	r3, [r3, #12]
 80015f8:	2200      	movs	r2, #0
 80015fa:	611a      	str	r2, [r3, #16]

    if (icup->config->channel == ICU_CHANNEL_1) {
 80015fc:	9b01      	ldr	r3, [sp, #4]
 80015fe:	685b      	ldr	r3, [r3, #4]
 8001600:	7d1b      	ldrb	r3, [r3, #20]
 8001602:	2b00      	cmp	r3, #0
 8001604:	d10d      	bne.n	8001622 <icu_lld_enable_notifications+0x42>
      /* Enabling periodic callback on CC1.*/
      dier |= STM32_TIM_DIER_CC1IE;
 8001606:	9b03      	ldr	r3, [sp, #12]
 8001608:	2202      	movs	r2, #2
 800160a:	4313      	orrs	r3, r2
 800160c:	9303      	str	r3, [sp, #12]

      /* Optionally enabling width callback on CC2.*/
      if (icup->config->width_cb != NULL)
 800160e:	9b01      	ldr	r3, [sp, #4]
 8001610:	685b      	ldr	r3, [r3, #4]
 8001612:	689b      	ldr	r3, [r3, #8]
 8001614:	2b00      	cmp	r3, #0
 8001616:	d012      	beq.n	800163e <icu_lld_enable_notifications+0x5e>
        dier |= STM32_TIM_DIER_CC2IE;
 8001618:	9b03      	ldr	r3, [sp, #12]
 800161a:	2204      	movs	r2, #4
 800161c:	4313      	orrs	r3, r2
 800161e:	9303      	str	r3, [sp, #12]
 8001620:	e00e      	b.n	8001640 <icu_lld_enable_notifications+0x60>
    }
    else {
      /* Enabling periodic callback on CC2.*/
      dier |= STM32_TIM_DIER_CC2IE;
 8001622:	9b03      	ldr	r3, [sp, #12]
 8001624:	2204      	movs	r2, #4
 8001626:	4313      	orrs	r3, r2
 8001628:	9303      	str	r3, [sp, #12]

      /* Optionally enabling width callback on CC1.*/
      if (icup->config->width_cb != NULL)
 800162a:	9b01      	ldr	r3, [sp, #4]
 800162c:	685b      	ldr	r3, [r3, #4]
 800162e:	689b      	ldr	r3, [r3, #8]
 8001630:	2b00      	cmp	r3, #0
 8001632:	d005      	beq.n	8001640 <icu_lld_enable_notifications+0x60>
        dier |= STM32_TIM_DIER_CC1IE;
 8001634:	9b03      	ldr	r3, [sp, #12]
 8001636:	2202      	movs	r2, #2
 8001638:	4313      	orrs	r3, r2
 800163a:	9303      	str	r3, [sp, #12]
 800163c:	e000      	b.n	8001640 <icu_lld_enable_notifications+0x60>
        dier |= STM32_TIM_DIER_CC2IE;
 800163e:	46c0      	nop			; (mov r8, r8)
    }

    /* If an overflow callback is defined then also the overflow callback
       is enabled.*/
    if (icup->config->overflow_cb != NULL)
 8001640:	9b01      	ldr	r3, [sp, #4]
 8001642:	685b      	ldr	r3, [r3, #4]
 8001644:	691b      	ldr	r3, [r3, #16]
 8001646:	2b00      	cmp	r3, #0
 8001648:	d003      	beq.n	8001652 <icu_lld_enable_notifications+0x72>
      dier |= STM32_TIM_DIER_UIE;
 800164a:	9b03      	ldr	r3, [sp, #12]
 800164c:	2201      	movs	r2, #1
 800164e:	4313      	orrs	r3, r2
 8001650:	9303      	str	r3, [sp, #12]

    /* One single atomic write.*/
    icup->tim->DIER = dier;
 8001652:	9b01      	ldr	r3, [sp, #4]
 8001654:	68db      	ldr	r3, [r3, #12]
 8001656:	9a03      	ldr	r2, [sp, #12]
 8001658:	60da      	str	r2, [r3, #12]
  }
}
 800165a:	b004      	add	sp, #16
 800165c:	4770      	bx	lr
 800165e:	46c0      	nop			; (mov r8, r8)

08001660 <icu_lld_serve_interrupt>:
 *
 * @param[in] icup      pointer to the @p ICUDriver object
 *
 * @notapi
 */
void icu_lld_serve_interrupt(ICUDriver *icup) {
 8001660:	b500      	push	{lr}
 8001662:	b085      	sub	sp, #20
 8001664:	9001      	str	r0, [sp, #4]
  uint32_t sr;

  sr  = icup->tim->SR;
 8001666:	9b01      	ldr	r3, [sp, #4]
 8001668:	68db      	ldr	r3, [r3, #12]
 800166a:	691b      	ldr	r3, [r3, #16]
 800166c:	9303      	str	r3, [sp, #12]
  sr &= icup->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 800166e:	9b01      	ldr	r3, [sp, #4]
 8001670:	68db      	ldr	r3, [r3, #12]
 8001672:	68db      	ldr	r3, [r3, #12]
 8001674:	22ff      	movs	r2, #255	; 0xff
 8001676:	401a      	ands	r2, r3
 8001678:	9b03      	ldr	r3, [sp, #12]
 800167a:	4013      	ands	r3, r2
 800167c:	9303      	str	r3, [sp, #12]
  icup->tim->SR = ~sr;
 800167e:	9b01      	ldr	r3, [sp, #4]
 8001680:	68db      	ldr	r3, [r3, #12]
 8001682:	9a03      	ldr	r2, [sp, #12]
 8001684:	43d2      	mvns	r2, r2
 8001686:	611a      	str	r2, [r3, #16]
  if (icup->config->channel == ICU_CHANNEL_1) {
 8001688:	9b01      	ldr	r3, [sp, #4]
 800168a:	685b      	ldr	r3, [r3, #4]
 800168c:	7d1b      	ldrb	r3, [r3, #20]
 800168e:	2b00      	cmp	r3, #0
 8001690:	d129      	bne.n	80016e6 <icu_lld_serve_interrupt+0x86>
    if ((sr & STM32_TIM_SR_CC2IF) != 0)
 8001692:	9b03      	ldr	r3, [sp, #12]
 8001694:	2204      	movs	r2, #4
 8001696:	4013      	ands	r3, r2
 8001698:	d00e      	beq.n	80016b8 <icu_lld_serve_interrupt+0x58>
      _icu_isr_invoke_width_cb(icup);
 800169a:	9b01      	ldr	r3, [sp, #4]
 800169c:	781b      	ldrb	r3, [r3, #0]
 800169e:	2b04      	cmp	r3, #4
 80016a0:	d10a      	bne.n	80016b8 <icu_lld_serve_interrupt+0x58>
 80016a2:	9b01      	ldr	r3, [sp, #4]
 80016a4:	685b      	ldr	r3, [r3, #4]
 80016a6:	689b      	ldr	r3, [r3, #8]
 80016a8:	2b00      	cmp	r3, #0
 80016aa:	d005      	beq.n	80016b8 <icu_lld_serve_interrupt+0x58>
 80016ac:	9b01      	ldr	r3, [sp, #4]
 80016ae:	685b      	ldr	r3, [r3, #4]
 80016b0:	689b      	ldr	r3, [r3, #8]
 80016b2:	9a01      	ldr	r2, [sp, #4]
 80016b4:	0010      	movs	r0, r2
 80016b6:	4798      	blx	r3
    if ((sr & STM32_TIM_SR_CC1IF) != 0)
 80016b8:	9b03      	ldr	r3, [sp, #12]
 80016ba:	2202      	movs	r2, #2
 80016bc:	4013      	ands	r3, r2
 80016be:	d03c      	beq.n	800173a <icu_lld_serve_interrupt+0xda>
      _icu_isr_invoke_period_cb(icup);
 80016c0:	9b01      	ldr	r3, [sp, #4]
 80016c2:	781b      	ldrb	r3, [r3, #0]
 80016c4:	2b04      	cmp	r3, #4
 80016c6:	d10a      	bne.n	80016de <icu_lld_serve_interrupt+0x7e>
 80016c8:	9b01      	ldr	r3, [sp, #4]
 80016ca:	685b      	ldr	r3, [r3, #4]
 80016cc:	68db      	ldr	r3, [r3, #12]
 80016ce:	2b00      	cmp	r3, #0
 80016d0:	d005      	beq.n	80016de <icu_lld_serve_interrupt+0x7e>
 80016d2:	9b01      	ldr	r3, [sp, #4]
 80016d4:	685b      	ldr	r3, [r3, #4]
 80016d6:	68db      	ldr	r3, [r3, #12]
 80016d8:	9a01      	ldr	r2, [sp, #4]
 80016da:	0010      	movs	r0, r2
 80016dc:	4798      	blx	r3
 80016de:	9b01      	ldr	r3, [sp, #4]
 80016e0:	2204      	movs	r2, #4
 80016e2:	701a      	strb	r2, [r3, #0]
 80016e4:	e02a      	b.n	800173c <icu_lld_serve_interrupt+0xdc>
  }
  else {
    if ((sr & STM32_TIM_SR_CC1IF) != 0)
 80016e6:	9b03      	ldr	r3, [sp, #12]
 80016e8:	2202      	movs	r2, #2
 80016ea:	4013      	ands	r3, r2
 80016ec:	d00e      	beq.n	800170c <icu_lld_serve_interrupt+0xac>
      _icu_isr_invoke_width_cb(icup);
 80016ee:	9b01      	ldr	r3, [sp, #4]
 80016f0:	781b      	ldrb	r3, [r3, #0]
 80016f2:	2b04      	cmp	r3, #4
 80016f4:	d10a      	bne.n	800170c <icu_lld_serve_interrupt+0xac>
 80016f6:	9b01      	ldr	r3, [sp, #4]
 80016f8:	685b      	ldr	r3, [r3, #4]
 80016fa:	689b      	ldr	r3, [r3, #8]
 80016fc:	2b00      	cmp	r3, #0
 80016fe:	d005      	beq.n	800170c <icu_lld_serve_interrupt+0xac>
 8001700:	9b01      	ldr	r3, [sp, #4]
 8001702:	685b      	ldr	r3, [r3, #4]
 8001704:	689b      	ldr	r3, [r3, #8]
 8001706:	9a01      	ldr	r2, [sp, #4]
 8001708:	0010      	movs	r0, r2
 800170a:	4798      	blx	r3
    if ((sr & STM32_TIM_SR_CC2IF) != 0)
 800170c:	9b03      	ldr	r3, [sp, #12]
 800170e:	2204      	movs	r2, #4
 8001710:	4013      	ands	r3, r2
 8001712:	d013      	beq.n	800173c <icu_lld_serve_interrupt+0xdc>
      _icu_isr_invoke_period_cb(icup);
 8001714:	9b01      	ldr	r3, [sp, #4]
 8001716:	781b      	ldrb	r3, [r3, #0]
 8001718:	2b04      	cmp	r3, #4
 800171a:	d10a      	bne.n	8001732 <icu_lld_serve_interrupt+0xd2>
 800171c:	9b01      	ldr	r3, [sp, #4]
 800171e:	685b      	ldr	r3, [r3, #4]
 8001720:	68db      	ldr	r3, [r3, #12]
 8001722:	2b00      	cmp	r3, #0
 8001724:	d005      	beq.n	8001732 <icu_lld_serve_interrupt+0xd2>
 8001726:	9b01      	ldr	r3, [sp, #4]
 8001728:	685b      	ldr	r3, [r3, #4]
 800172a:	68db      	ldr	r3, [r3, #12]
 800172c:	9a01      	ldr	r2, [sp, #4]
 800172e:	0010      	movs	r0, r2
 8001730:	4798      	blx	r3
 8001732:	9b01      	ldr	r3, [sp, #4]
 8001734:	2204      	movs	r2, #4
 8001736:	701a      	strb	r2, [r3, #0]
 8001738:	e000      	b.n	800173c <icu_lld_serve_interrupt+0xdc>
      _icu_isr_invoke_period_cb(icup);
 800173a:	46c0      	nop			; (mov r8, r8)
  }
  if ((sr & STM32_TIM_SR_UIF) != 0)
 800173c:	9b03      	ldr	r3, [sp, #12]
 800173e:	2201      	movs	r2, #1
 8001740:	4013      	ands	r3, r2
 8001742:	d008      	beq.n	8001756 <icu_lld_serve_interrupt+0xf6>
    _icu_isr_invoke_overflow_cb(icup);
 8001744:	9b01      	ldr	r3, [sp, #4]
 8001746:	685b      	ldr	r3, [r3, #4]
 8001748:	691b      	ldr	r3, [r3, #16]
 800174a:	9a01      	ldr	r2, [sp, #4]
 800174c:	0010      	movs	r0, r2
 800174e:	4798      	blx	r3
 8001750:	9b01      	ldr	r3, [sp, #4]
 8001752:	2203      	movs	r2, #3
 8001754:	701a      	strb	r2, [r3, #0]
}
 8001756:	b005      	add	sp, #20
 8001758:	bd00      	pop	{pc}
 800175a:	46c0      	nop			; (mov r8, r8)
 800175c:	0000      	movs	r0, r0
	...

08001760 <Vector74>:
OSAL_IRQ_HANDLER(STM32_TIM1_UP_HANDLER) {
 8001760:	b500      	push	{lr}
 8001762:	b083      	sub	sp, #12
 8001764:	4673      	mov	r3, lr
  OSAL_IRQ_PROLOGUE();
 8001766:	9301      	str	r3, [sp, #4]
 8001768:	4b0a      	ldr	r3, [pc, #40]	; (8001794 <Vector74+0x34>)
 800176a:	0018      	movs	r0, r3
 800176c:	f001 fc38 	bl	8002fe0 <_trace_isr_enter>
 8001770:	f001 fb06 	bl	8002d80 <_dbg_check_enter_isr>
  pwm_lld_serve_interrupt(&PWMD1);
 8001774:	4b08      	ldr	r3, [pc, #32]	; (8001798 <Vector74+0x38>)
 8001776:	0018      	movs	r0, r3
 8001778:	f7fe ff72 	bl	8000660 <pwm_lld_serve_interrupt>
  OSAL_IRQ_EPILOGUE();
 800177c:	f001 fb20 	bl	8002dc0 <_dbg_check_leave_isr>
 8001780:	4b04      	ldr	r3, [pc, #16]	; (8001794 <Vector74+0x34>)
 8001782:	0018      	movs	r0, r3
 8001784:	f001 fc54 	bl	8003030 <_trace_isr_leave>
 8001788:	9b01      	ldr	r3, [sp, #4]
 800178a:	0018      	movs	r0, r3
 800178c:	f000 fbb8 	bl	8001f00 <_port_irq_epilogue>
}
 8001790:	b003      	add	sp, #12
 8001792:	bd00      	pop	{pc}
 8001794:	08003e64 	.word	0x08003e64
 8001798:	20000df0 	.word	0x20000df0
 800179c:	00000000 	.word	0x00000000

080017a0 <Vector78>:
OSAL_IRQ_HANDLER(STM32_TIM1_CC_HANDLER) {
 80017a0:	b500      	push	{lr}
 80017a2:	b083      	sub	sp, #12
 80017a4:	4673      	mov	r3, lr
  OSAL_IRQ_PROLOGUE();
 80017a6:	9301      	str	r3, [sp, #4]
 80017a8:	4b0a      	ldr	r3, [pc, #40]	; (80017d4 <Vector78+0x34>)
 80017aa:	0018      	movs	r0, r3
 80017ac:	f001 fc18 	bl	8002fe0 <_trace_isr_enter>
 80017b0:	f001 fae6 	bl	8002d80 <_dbg_check_enter_isr>
  pwm_lld_serve_interrupt(&PWMD1);
 80017b4:	4b08      	ldr	r3, [pc, #32]	; (80017d8 <Vector78+0x38>)
 80017b6:	0018      	movs	r0, r3
 80017b8:	f7fe ff52 	bl	8000660 <pwm_lld_serve_interrupt>
  OSAL_IRQ_EPILOGUE();
 80017bc:	f001 fb00 	bl	8002dc0 <_dbg_check_leave_isr>
 80017c0:	4b04      	ldr	r3, [pc, #16]	; (80017d4 <Vector78+0x34>)
 80017c2:	0018      	movs	r0, r3
 80017c4:	f001 fc34 	bl	8003030 <_trace_isr_leave>
 80017c8:	9b01      	ldr	r3, [sp, #4]
 80017ca:	0018      	movs	r0, r3
 80017cc:	f000 fb98 	bl	8001f00 <_port_irq_epilogue>
}
 80017d0:	b003      	add	sp, #12
 80017d2:	bd00      	pop	{pc}
 80017d4:	08003e70 	.word	0x08003e70
 80017d8:	20000df0 	.word	0x20000df0
 80017dc:	00000000 	.word	0x00000000

080017e0 <pwm_lld_init>:
void pwm_lld_init(void) {
 80017e0:	b510      	push	{r4, lr}
  pwmObjectInit(&PWMD1);
 80017e2:	4b05      	ldr	r3, [pc, #20]	; (80017f8 <pwm_lld_init+0x18>)
 80017e4:	0018      	movs	r0, r3
 80017e6:	f000 f993 	bl	8001b10 <pwmObjectInit>
  PWMD1.channels = STM32_TIM1_CHANNELS;
 80017ea:	4b03      	ldr	r3, [pc, #12]	; (80017f8 <pwm_lld_init+0x18>)
 80017ec:	2204      	movs	r2, #4
 80017ee:	741a      	strb	r2, [r3, #16]
  PWMD1.tim = STM32_TIM1;
 80017f0:	4b01      	ldr	r3, [pc, #4]	; (80017f8 <pwm_lld_init+0x18>)
 80017f2:	4a02      	ldr	r2, [pc, #8]	; (80017fc <pwm_lld_init+0x1c>)
 80017f4:	619a      	str	r2, [r3, #24]
}
 80017f6:	bd10      	pop	{r4, pc}
 80017f8:	20000df0 	.word	0x20000df0
 80017fc:	40012c00 	.word	0x40012c00

08001800 <port_lock.lto_priv.92>:
  __ASM volatile ("cpsid i" : : : "memory");
 8001800:	b672      	cpsid	i
}
 8001802:	4770      	bx	lr
	...

08001810 <port_unlock.lto_priv.89>:
  __ASM volatile ("cpsie i" : : : "memory");
 8001810:	b662      	cpsie	i
}
 8001812:	4770      	bx	lr
	...

08001820 <chSysLock.lto_priv.86>:
static inline void chSysLock(void) {
 8001820:	b510      	push	{r4, lr}
  port_lock();
 8001822:	f7ff ffed 	bl	8001800 <port_lock.lto_priv.92>
  _dbg_check_lock();
 8001826:	f001 fa4b 	bl	8002cc0 <_dbg_check_lock>
}
 800182a:	bd10      	pop	{r4, pc}
 800182c:	0000      	movs	r0, r0
	...

08001830 <chSysUnlock.lto_priv.83>:
static inline void chSysUnlock(void) {
 8001830:	b510      	push	{r4, lr}
  _dbg_check_unlock();
 8001832:	f001 fa5d 	bl	8002cf0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001836:	4b0a      	ldr	r3, [pc, #40]	; (8001860 <chSysUnlock.lto_priv.83+0x30>)
 8001838:	681a      	ldr	r2, [r3, #0]
 800183a:	4b09      	ldr	r3, [pc, #36]	; (8001860 <chSysUnlock.lto_priv.83+0x30>)
 800183c:	429a      	cmp	r2, r3
 800183e:	d00b      	beq.n	8001858 <chSysUnlock.lto_priv.83+0x28>
 8001840:	4b07      	ldr	r3, [pc, #28]	; (8001860 <chSysUnlock.lto_priv.83+0x30>)
 8001842:	699b      	ldr	r3, [r3, #24]
 8001844:	689a      	ldr	r2, [r3, #8]
 8001846:	4b06      	ldr	r3, [pc, #24]	; (8001860 <chSysUnlock.lto_priv.83+0x30>)
 8001848:	681b      	ldr	r3, [r3, #0]
 800184a:	689b      	ldr	r3, [r3, #8]
 800184c:	429a      	cmp	r2, r3
 800184e:	d203      	bcs.n	8001858 <chSysUnlock.lto_priv.83+0x28>
 8001850:	4b04      	ldr	r3, [pc, #16]	; (8001864 <chSysUnlock.lto_priv.83+0x34>)
 8001852:	0018      	movs	r0, r3
 8001854:	f001 f9e4 	bl	8002c20 <chSysHalt>
  port_unlock();
 8001858:	f7ff ffda 	bl	8001810 <port_unlock.lto_priv.89>
}
 800185c:	bd10      	pop	{r4, pc}
 800185e:	46c0      	nop			; (mov r8, r8)
 8001860:	20000528 	.word	0x20000528
 8001864:	08003d3c 	.word	0x08003d3c
	...

08001870 <osalSysLock.lto_priv.106>:
static inline void osalSysLock(void) {
 8001870:	b510      	push	{r4, lr}
  chSysLock();
 8001872:	f7ff ffd5 	bl	8001820 <chSysLock.lto_priv.86>
}
 8001876:	bd10      	pop	{r4, pc}
	...

08001880 <osalSysUnlock.lto_priv.103>:
static inline void osalSysUnlock(void) {
 8001880:	b510      	push	{r4, lr}
  chSysUnlock();
 8001882:	f7ff ffd5 	bl	8001830 <chSysUnlock.lto_priv.83>
}
 8001886:	bd10      	pop	{r4, pc}
	...

08001890 <icuInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void icuInit(void) {
 8001890:	b510      	push	{r4, lr}

  icu_lld_init();
 8001892:	f7ff fd75 	bl	8001380 <icu_lld_init>
}
 8001896:	bd10      	pop	{r4, pc}
	...

080018a0 <icuObjectInit>:
 *
 * @param[out] icup     pointer to the @p ICUDriver object
 *
 * @init
 */
void icuObjectInit(ICUDriver *icup) {
 80018a0:	b082      	sub	sp, #8
 80018a2:	9001      	str	r0, [sp, #4]

  icup->state  = ICU_STOP;
 80018a4:	9b01      	ldr	r3, [sp, #4]
 80018a6:	2201      	movs	r2, #1
 80018a8:	701a      	strb	r2, [r3, #0]
  icup->config = NULL;
 80018aa:	9b01      	ldr	r3, [sp, #4]
 80018ac:	2200      	movs	r2, #0
 80018ae:	605a      	str	r2, [r3, #4]
}
 80018b0:	b002      	add	sp, #8
 80018b2:	4770      	bx	lr
	...

080018c0 <icuStart>:
 * @param[in] icup      pointer to the @p ICUDriver object
 * @param[in] config    pointer to the @p ICUConfig object
 *
 * @api
 */
void icuStart(ICUDriver *icup, const ICUConfig *config) {
 80018c0:	b500      	push	{lr}
 80018c2:	b083      	sub	sp, #12
 80018c4:	9001      	str	r0, [sp, #4]
 80018c6:	9100      	str	r1, [sp, #0]

  osalDbgCheck((icup != NULL) && (config != NULL));
 80018c8:	9b01      	ldr	r3, [sp, #4]
 80018ca:	2b00      	cmp	r3, #0
 80018cc:	d002      	beq.n	80018d4 <icuStart+0x14>
 80018ce:	9b00      	ldr	r3, [sp, #0]
 80018d0:	2b00      	cmp	r3, #0
 80018d2:	d103      	bne.n	80018dc <icuStart+0x1c>
 80018d4:	4b0f      	ldr	r3, [pc, #60]	; (8001914 <icuStart+0x54>)
 80018d6:	0018      	movs	r0, r3
 80018d8:	f001 f9a2 	bl	8002c20 <chSysHalt>

  osalSysLock();
 80018dc:	f7ff ffc8 	bl	8001870 <osalSysLock.lto_priv.106>
  osalDbgAssert((icup->state == ICU_STOP) || (icup->state == ICU_READY),
 80018e0:	9b01      	ldr	r3, [sp, #4]
 80018e2:	781b      	ldrb	r3, [r3, #0]
 80018e4:	2b01      	cmp	r3, #1
 80018e6:	d007      	beq.n	80018f8 <icuStart+0x38>
 80018e8:	9b01      	ldr	r3, [sp, #4]
 80018ea:	781b      	ldrb	r3, [r3, #0]
 80018ec:	2b02      	cmp	r3, #2
 80018ee:	d003      	beq.n	80018f8 <icuStart+0x38>
 80018f0:	4b08      	ldr	r3, [pc, #32]	; (8001914 <icuStart+0x54>)
 80018f2:	0018      	movs	r0, r3
 80018f4:	f001 f994 	bl	8002c20 <chSysHalt>
                "invalid state");
  icup->config = config;
 80018f8:	9b01      	ldr	r3, [sp, #4]
 80018fa:	9a00      	ldr	r2, [sp, #0]
 80018fc:	605a      	str	r2, [r3, #4]
  icu_lld_start(icup);
 80018fe:	9b01      	ldr	r3, [sp, #4]
 8001900:	0018      	movs	r0, r3
 8001902:	f7ff fd4d 	bl	80013a0 <icu_lld_start>
  icup->state = ICU_READY;
 8001906:	9b01      	ldr	r3, [sp, #4]
 8001908:	2202      	movs	r2, #2
 800190a:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 800190c:	f7ff ffb8 	bl	8001880 <osalSysUnlock.lto_priv.103>
}
 8001910:	b003      	add	sp, #12
 8001912:	bd00      	pop	{pc}
 8001914:	08003d30 	.word	0x08003d30
	...

08001920 <icuStop>:
 *
 * @param[in] icup      pointer to the @p ICUDriver object
 *
 * @api
 */
void icuStop(ICUDriver *icup) {
 8001920:	b500      	push	{lr}
 8001922:	b083      	sub	sp, #12
 8001924:	9001      	str	r0, [sp, #4]

  osalDbgCheck(icup != NULL);
 8001926:	9b01      	ldr	r3, [sp, #4]
 8001928:	2b00      	cmp	r3, #0
 800192a:	d103      	bne.n	8001934 <icuStop+0x14>
 800192c:	4b0f      	ldr	r3, [pc, #60]	; (800196c <icuStop+0x4c>)
 800192e:	0018      	movs	r0, r3
 8001930:	f001 f976 	bl	8002c20 <chSysHalt>

  osalSysLock();
 8001934:	f7ff ff9c 	bl	8001870 <osalSysLock.lto_priv.106>

  osalDbgAssert((icup->state == ICU_STOP) || (icup->state == ICU_READY),
 8001938:	9b01      	ldr	r3, [sp, #4]
 800193a:	781b      	ldrb	r3, [r3, #0]
 800193c:	2b01      	cmp	r3, #1
 800193e:	d007      	beq.n	8001950 <icuStop+0x30>
 8001940:	9b01      	ldr	r3, [sp, #4]
 8001942:	781b      	ldrb	r3, [r3, #0]
 8001944:	2b02      	cmp	r3, #2
 8001946:	d003      	beq.n	8001950 <icuStop+0x30>
 8001948:	4b08      	ldr	r3, [pc, #32]	; (800196c <icuStop+0x4c>)
 800194a:	0018      	movs	r0, r3
 800194c:	f001 f968 	bl	8002c20 <chSysHalt>
                "invalid state");

  icu_lld_stop(icup);
 8001950:	9b01      	ldr	r3, [sp, #4]
 8001952:	0018      	movs	r0, r3
 8001954:	f7ff fdf4 	bl	8001540 <icu_lld_stop>
  icup->config = NULL;
 8001958:	9b01      	ldr	r3, [sp, #4]
 800195a:	2200      	movs	r2, #0
 800195c:	605a      	str	r2, [r3, #4]
  icup->state  = ICU_STOP;
 800195e:	9b01      	ldr	r3, [sp, #4]
 8001960:	2201      	movs	r2, #1
 8001962:	701a      	strb	r2, [r3, #0]

  osalSysUnlock();
 8001964:	f7ff ff8c 	bl	8001880 <osalSysUnlock.lto_priv.103>
}
 8001968:	b003      	add	sp, #12
 800196a:	bd00      	pop	{pc}
 800196c:	08003d48 	.word	0x08003d48

08001970 <icuStartCapture>:
 *
 * @param[in] icup      pointer to the @p ICUDriver object
 *
 * @api
 */
void icuStartCapture(ICUDriver *icup) {
 8001970:	b500      	push	{lr}
 8001972:	b083      	sub	sp, #12
 8001974:	9001      	str	r0, [sp, #4]

  osalDbgCheck(icup != NULL);
 8001976:	9b01      	ldr	r3, [sp, #4]
 8001978:	2b00      	cmp	r3, #0
 800197a:	d103      	bne.n	8001984 <icuStartCapture+0x14>
 800197c:	4b0c      	ldr	r3, [pc, #48]	; (80019b0 <icuStartCapture+0x40>)
 800197e:	0018      	movs	r0, r3
 8001980:	f001 f94e 	bl	8002c20 <chSysHalt>

  osalSysLock();
 8001984:	f7ff ff74 	bl	8001870 <osalSysLock.lto_priv.106>
  osalDbgAssert(icup->state == ICU_READY, "invalid state");
 8001988:	9b01      	ldr	r3, [sp, #4]
 800198a:	781b      	ldrb	r3, [r3, #0]
 800198c:	2b02      	cmp	r3, #2
 800198e:	d003      	beq.n	8001998 <icuStartCapture+0x28>
 8001990:	4b07      	ldr	r3, [pc, #28]	; (80019b0 <icuStartCapture+0x40>)
 8001992:	0018      	movs	r0, r3
 8001994:	f001 f944 	bl	8002c20 <chSysHalt>
  icuStartCaptureI(icup);
 8001998:	9b01      	ldr	r3, [sp, #4]
 800199a:	0018      	movs	r0, r3
 800199c:	f7ff fdf8 	bl	8001590 <icu_lld_start_capture>
 80019a0:	9b01      	ldr	r3, [sp, #4]
 80019a2:	2203      	movs	r2, #3
 80019a4:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 80019a6:	f7ff ff6b 	bl	8001880 <osalSysUnlock.lto_priv.103>
}
 80019aa:	b003      	add	sp, #12
 80019ac:	bd00      	pop	{pc}
 80019ae:	46c0      	nop			; (mov r8, r8)
 80019b0:	08003d50 	.word	0x08003d50
	...

080019c0 <icuStopCapture>:
 *
 * @param[in] icup      pointer to the @p ICUDriver object
 *
 * @api
 */
void icuStopCapture(ICUDriver *icup) {
 80019c0:	b500      	push	{lr}
 80019c2:	b083      	sub	sp, #12
 80019c4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(icup != NULL);
 80019c6:	9b01      	ldr	r3, [sp, #4]
 80019c8:	2b00      	cmp	r3, #0
 80019ca:	d103      	bne.n	80019d4 <icuStopCapture+0x14>
 80019cc:	4b10      	ldr	r3, [pc, #64]	; (8001a10 <icuStopCapture+0x50>)
 80019ce:	0018      	movs	r0, r3
 80019d0:	f001 f926 	bl	8002c20 <chSysHalt>

  osalSysLock();
 80019d4:	f7ff ff4c 	bl	8001870 <osalSysLock.lto_priv.106>
  osalDbgAssert((icup->state == ICU_READY) || (icup->state == ICU_WAITING) ||
 80019d8:	9b01      	ldr	r3, [sp, #4]
 80019da:	781b      	ldrb	r3, [r3, #0]
 80019dc:	2b02      	cmp	r3, #2
 80019de:	d00b      	beq.n	80019f8 <icuStopCapture+0x38>
 80019e0:	9b01      	ldr	r3, [sp, #4]
 80019e2:	781b      	ldrb	r3, [r3, #0]
 80019e4:	2b03      	cmp	r3, #3
 80019e6:	d007      	beq.n	80019f8 <icuStopCapture+0x38>
 80019e8:	9b01      	ldr	r3, [sp, #4]
 80019ea:	781b      	ldrb	r3, [r3, #0]
 80019ec:	2b04      	cmp	r3, #4
 80019ee:	d003      	beq.n	80019f8 <icuStopCapture+0x38>
 80019f0:	4b07      	ldr	r3, [pc, #28]	; (8001a10 <icuStopCapture+0x50>)
 80019f2:	0018      	movs	r0, r3
 80019f4:	f001 f914 	bl	8002c20 <chSysHalt>
                (icup->state == ICU_ACTIVE),
                "invalid state");
  icuStopCaptureI(icup);
 80019f8:	9b01      	ldr	r3, [sp, #4]
 80019fa:	0018      	movs	r0, r3
 80019fc:	f7ff fde0 	bl	80015c0 <icu_lld_stop_capture>
 8001a00:	9b01      	ldr	r3, [sp, #4]
 8001a02:	2202      	movs	r2, #2
 8001a04:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 8001a06:	f7ff ff3b 	bl	8001880 <osalSysUnlock.lto_priv.103>
}
 8001a0a:	b003      	add	sp, #12
 8001a0c:	bd00      	pop	{pc}
 8001a0e:	46c0      	nop			; (mov r8, r8)
 8001a10:	08003d60 	.word	0x08003d60
	...

08001a20 <icuEnableNotifications>:
 *
 * @param[in] icup      pointer to the @p ICUDriver object
 *
 * @api
 */
void icuEnableNotifications(ICUDriver *icup) {
 8001a20:	b500      	push	{lr}
 8001a22:	b083      	sub	sp, #12
 8001a24:	9001      	str	r0, [sp, #4]

  osalDbgCheck(icup != NULL);
 8001a26:	9b01      	ldr	r3, [sp, #4]
 8001a28:	2b00      	cmp	r3, #0
 8001a2a:	d103      	bne.n	8001a34 <icuEnableNotifications+0x14>
 8001a2c:	4b0c      	ldr	r3, [pc, #48]	; (8001a60 <icuEnableNotifications+0x40>)
 8001a2e:	0018      	movs	r0, r3
 8001a30:	f001 f8f6 	bl	8002c20 <chSysHalt>

  osalSysLock();
 8001a34:	f7ff ff1c 	bl	8001870 <osalSysLock.lto_priv.106>
  osalDbgAssert((icup->state == ICU_WAITING) || (icup->state == ICU_ACTIVE),
 8001a38:	9b01      	ldr	r3, [sp, #4]
 8001a3a:	781b      	ldrb	r3, [r3, #0]
 8001a3c:	2b03      	cmp	r3, #3
 8001a3e:	d007      	beq.n	8001a50 <icuEnableNotifications+0x30>
 8001a40:	9b01      	ldr	r3, [sp, #4]
 8001a42:	781b      	ldrb	r3, [r3, #0]
 8001a44:	2b04      	cmp	r3, #4
 8001a46:	d003      	beq.n	8001a50 <icuEnableNotifications+0x30>
 8001a48:	4b05      	ldr	r3, [pc, #20]	; (8001a60 <icuEnableNotifications+0x40>)
 8001a4a:	0018      	movs	r0, r3
 8001a4c:	f001 f8e8 	bl	8002c20 <chSysHalt>
                "invalid state");
  icuEnableNotificationsI(icup);
 8001a50:	9b01      	ldr	r3, [sp, #4]
 8001a52:	0018      	movs	r0, r3
 8001a54:	f7ff fdc4 	bl	80015e0 <icu_lld_enable_notifications>
  osalSysUnlock();
 8001a58:	f7ff ff12 	bl	8001880 <osalSysUnlock.lto_priv.103>
}
 8001a5c:	b003      	add	sp, #12
 8001a5e:	bd00      	pop	{pc}
 8001a60:	08003d70 	.word	0x08003d70
	...

08001a70 <port_lock.lto_priv.93>:
  __ASM volatile ("cpsid i" : : : "memory");
 8001a70:	b672      	cpsid	i
}
 8001a72:	4770      	bx	lr
	...

08001a80 <port_unlock.lto_priv.90>:
  __ASM volatile ("cpsie i" : : : "memory");
 8001a80:	b662      	cpsie	i
}
 8001a82:	4770      	bx	lr
	...

08001a90 <chSysLock.lto_priv.87>:
static inline void chSysLock(void) {
 8001a90:	b510      	push	{r4, lr}
  port_lock();
 8001a92:	f7ff ffed 	bl	8001a70 <port_lock.lto_priv.93>
  _dbg_check_lock();
 8001a96:	f001 f913 	bl	8002cc0 <_dbg_check_lock>
}
 8001a9a:	bd10      	pop	{r4, pc}
 8001a9c:	0000      	movs	r0, r0
	...

08001aa0 <chSysUnlock.lto_priv.84>:
static inline void chSysUnlock(void) {
 8001aa0:	b510      	push	{r4, lr}
  _dbg_check_unlock();
 8001aa2:	f001 f925 	bl	8002cf0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001aa6:	4b0a      	ldr	r3, [pc, #40]	; (8001ad0 <chSysUnlock.lto_priv.84+0x30>)
 8001aa8:	681a      	ldr	r2, [r3, #0]
 8001aaa:	4b09      	ldr	r3, [pc, #36]	; (8001ad0 <chSysUnlock.lto_priv.84+0x30>)
 8001aac:	429a      	cmp	r2, r3
 8001aae:	d00b      	beq.n	8001ac8 <chSysUnlock.lto_priv.84+0x28>
 8001ab0:	4b07      	ldr	r3, [pc, #28]	; (8001ad0 <chSysUnlock.lto_priv.84+0x30>)
 8001ab2:	699b      	ldr	r3, [r3, #24]
 8001ab4:	689a      	ldr	r2, [r3, #8]
 8001ab6:	4b06      	ldr	r3, [pc, #24]	; (8001ad0 <chSysUnlock.lto_priv.84+0x30>)
 8001ab8:	681b      	ldr	r3, [r3, #0]
 8001aba:	689b      	ldr	r3, [r3, #8]
 8001abc:	429a      	cmp	r2, r3
 8001abe:	d203      	bcs.n	8001ac8 <chSysUnlock.lto_priv.84+0x28>
 8001ac0:	4b04      	ldr	r3, [pc, #16]	; (8001ad4 <chSysUnlock.lto_priv.84+0x34>)
 8001ac2:	0018      	movs	r0, r3
 8001ac4:	f001 f8ac 	bl	8002c20 <chSysHalt>
  port_unlock();
 8001ac8:	f7ff ffda 	bl	8001a80 <port_unlock.lto_priv.90>
}
 8001acc:	bd10      	pop	{r4, pc}
 8001ace:	46c0      	nop			; (mov r8, r8)
 8001ad0:	20000528 	.word	0x20000528
 8001ad4:	08003d94 	.word	0x08003d94
	...

08001ae0 <osalSysLock.lto_priv.66>:
static inline void osalSysLock(void) {
 8001ae0:	b510      	push	{r4, lr}
  chSysLock();
 8001ae2:	f7ff ffd5 	bl	8001a90 <chSysLock.lto_priv.87>
}
 8001ae6:	bd10      	pop	{r4, pc}
	...

08001af0 <osalSysUnlock.lto_priv.64>:
static inline void osalSysUnlock(void) {
 8001af0:	b510      	push	{r4, lr}
  chSysUnlock();
 8001af2:	f7ff ffd5 	bl	8001aa0 <chSysUnlock.lto_priv.84>
}
 8001af6:	bd10      	pop	{r4, pc}
	...

08001b00 <pwmInit>:
void pwmInit(void) {
 8001b00:	b510      	push	{r4, lr}
  pwm_lld_init();
 8001b02:	f7ff fe6d 	bl	80017e0 <pwm_lld_init>
}
 8001b06:	bd10      	pop	{r4, pc}
	...

08001b10 <pwmObjectInit>:
void pwmObjectInit(PWMDriver *pwmp) {
 8001b10:	b082      	sub	sp, #8
 8001b12:	9001      	str	r0, [sp, #4]
  pwmp->state    = PWM_STOP;
 8001b14:	9b01      	ldr	r3, [sp, #4]
 8001b16:	2201      	movs	r2, #1
 8001b18:	701a      	strb	r2, [r3, #0]
  pwmp->config   = NULL;
 8001b1a:	9b01      	ldr	r3, [sp, #4]
 8001b1c:	2200      	movs	r2, #0
 8001b1e:	605a      	str	r2, [r3, #4]
  pwmp->enabled  = 0;
 8001b20:	9b01      	ldr	r3, [sp, #4]
 8001b22:	2200      	movs	r2, #0
 8001b24:	60da      	str	r2, [r3, #12]
  pwmp->channels = 0;
 8001b26:	9b01      	ldr	r3, [sp, #4]
 8001b28:	2200      	movs	r2, #0
 8001b2a:	741a      	strb	r2, [r3, #16]
}
 8001b2c:	b002      	add	sp, #8
 8001b2e:	4770      	bx	lr

08001b30 <port_lock.lto_priv.143>:
  __ASM volatile ("cpsid i" : : : "memory");
 8001b30:	b672      	cpsid	i
}
 8001b32:	4770      	bx	lr
	...

08001b40 <port_unlock.lto_priv.139>:
  __ASM volatile ("cpsie i" : : : "memory");
 8001b40:	b662      	cpsie	i
}
 8001b42:	4770      	bx	lr
	...

08001b50 <chSysLock.lto_priv.136>:
static inline void chSysLock(void) {
 8001b50:	b510      	push	{r4, lr}
  port_lock();
 8001b52:	f7ff ffed 	bl	8001b30 <port_lock.lto_priv.143>
  _dbg_check_lock();
 8001b56:	f001 f8b3 	bl	8002cc0 <_dbg_check_lock>
}
 8001b5a:	bd10      	pop	{r4, pc}
 8001b5c:	0000      	movs	r0, r0
	...

08001b60 <chSysUnlock.lto_priv.132>:
static inline void chSysUnlock(void) {
 8001b60:	b510      	push	{r4, lr}
  _dbg_check_unlock();
 8001b62:	f001 f8c5 	bl	8002cf0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001b66:	4b0a      	ldr	r3, [pc, #40]	; (8001b90 <chSysUnlock.lto_priv.132+0x30>)
 8001b68:	681a      	ldr	r2, [r3, #0]
 8001b6a:	4b09      	ldr	r3, [pc, #36]	; (8001b90 <chSysUnlock.lto_priv.132+0x30>)
 8001b6c:	429a      	cmp	r2, r3
 8001b6e:	d00b      	beq.n	8001b88 <chSysUnlock.lto_priv.132+0x28>
 8001b70:	4b07      	ldr	r3, [pc, #28]	; (8001b90 <chSysUnlock.lto_priv.132+0x30>)
 8001b72:	699b      	ldr	r3, [r3, #24]
 8001b74:	689a      	ldr	r2, [r3, #8]
 8001b76:	4b06      	ldr	r3, [pc, #24]	; (8001b90 <chSysUnlock.lto_priv.132+0x30>)
 8001b78:	681b      	ldr	r3, [r3, #0]
 8001b7a:	689b      	ldr	r3, [r3, #8]
 8001b7c:	429a      	cmp	r2, r3
 8001b7e:	d203      	bcs.n	8001b88 <chSysUnlock.lto_priv.132+0x28>
 8001b80:	4b04      	ldr	r3, [pc, #16]	; (8001b94 <chSysUnlock.lto_priv.132+0x34>)
 8001b82:	0018      	movs	r0, r3
 8001b84:	f001 f84c 	bl	8002c20 <chSysHalt>
  port_unlock();
 8001b88:	f7ff ffda 	bl	8001b40 <port_unlock.lto_priv.139>
}
 8001b8c:	bd10      	pop	{r4, pc}
 8001b8e:	46c0      	nop			; (mov r8, r8)
 8001b90:	20000528 	.word	0x20000528
 8001b94:	08003d00 	.word	0x08003d00
	...

08001ba0 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = __heap_base__;
 8001ba0:	4b03      	ldr	r3, [pc, #12]	; (8001bb0 <_core_init+0x10>)
 8001ba2:	4a04      	ldr	r2, [pc, #16]	; (8001bb4 <_core_init+0x14>)
 8001ba4:	601a      	str	r2, [r3, #0]
  endmem  = __heap_end__;
 8001ba6:	4b04      	ldr	r3, [pc, #16]	; (8001bb8 <_core_init+0x18>)
 8001ba8:	4a04      	ldr	r2, [pc, #16]	; (8001bbc <_core_init+0x1c>)
 8001baa:	601a      	str	r2, [r3, #0]
  static uint8_t static_heap[CH_CFG_MEMCORE_SIZE];

  nextmem = &static_heap[0];
  endmem  = &static_heap[CH_CFG_MEMCORE_SIZE];
#endif
}
 8001bac:	4770      	bx	lr
 8001bae:	46c0      	nop			; (mov r8, r8)
 8001bb0:	20000dac 	.word	0x20000dac
 8001bb4:	20000e18 	.word	0x20000e18
 8001bb8:	20000db0 	.word	0x20000db0
 8001bbc:	20001800 	.word	0x20001800

08001bc0 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocAlignedI(size_t size, unsigned align) {
 8001bc0:	b500      	push	{lr}
 8001bc2:	b085      	sub	sp, #20
 8001bc4:	9001      	str	r0, [sp, #4]
 8001bc6:	9100      	str	r1, [sp, #0]
  uint8_t *p;

  chDbgCheckClassI();
 8001bc8:	f001 f91a 	bl	8002e00 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 8001bcc:	9b00      	ldr	r3, [sp, #0]
 8001bce:	2b00      	cmp	r3, #0
 8001bd0:	d004      	beq.n	8001bdc <chCoreAllocAlignedI+0x1c>
 8001bd2:	9b00      	ldr	r3, [sp, #0]
 8001bd4:	3b01      	subs	r3, #1
 8001bd6:	9a00      	ldr	r2, [sp, #0]
 8001bd8:	4013      	ands	r3, r2
 8001bda:	d003      	beq.n	8001be4 <chCoreAllocAlignedI+0x24>
 8001bdc:	4b14      	ldr	r3, [pc, #80]	; (8001c30 <chCoreAllocAlignedI+0x70>)
 8001bde:	0018      	movs	r0, r3
 8001be0:	f001 f81e 	bl	8002c20 <chSysHalt>

  size = MEM_ALIGN_NEXT(size, align);
 8001be4:	9a00      	ldr	r2, [sp, #0]
 8001be6:	9b01      	ldr	r3, [sp, #4]
 8001be8:	18d3      	adds	r3, r2, r3
 8001bea:	3b01      	subs	r3, #1
 8001bec:	9a00      	ldr	r2, [sp, #0]
 8001bee:	4252      	negs	r2, r2
 8001bf0:	4013      	ands	r3, r2
 8001bf2:	9301      	str	r3, [sp, #4]
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 8001bf4:	4b0f      	ldr	r3, [pc, #60]	; (8001c34 <chCoreAllocAlignedI+0x74>)
 8001bf6:	681b      	ldr	r3, [r3, #0]
 8001bf8:	001a      	movs	r2, r3
 8001bfa:	9b00      	ldr	r3, [sp, #0]
 8001bfc:	18d3      	adds	r3, r2, r3
 8001bfe:	3b01      	subs	r3, #1
 8001c00:	9a00      	ldr	r2, [sp, #0]
 8001c02:	4252      	negs	r2, r2
 8001c04:	4013      	ands	r3, r2
 8001c06:	9303      	str	r3, [sp, #12]

  if (((size_t)endmem - (size_t)p) < size) {
 8001c08:	4b0b      	ldr	r3, [pc, #44]	; (8001c38 <chCoreAllocAlignedI+0x78>)
 8001c0a:	681b      	ldr	r3, [r3, #0]
 8001c0c:	001a      	movs	r2, r3
 8001c0e:	9b03      	ldr	r3, [sp, #12]
 8001c10:	1ad2      	subs	r2, r2, r3
 8001c12:	9b01      	ldr	r3, [sp, #4]
 8001c14:	429a      	cmp	r2, r3
 8001c16:	d201      	bcs.n	8001c1c <chCoreAllocAlignedI+0x5c>
    return NULL;
 8001c18:	2300      	movs	r3, #0
 8001c1a:	e005      	b.n	8001c28 <chCoreAllocAlignedI+0x68>
  }
  nextmem = p + size;
 8001c1c:	9a03      	ldr	r2, [sp, #12]
 8001c1e:	9b01      	ldr	r3, [sp, #4]
 8001c20:	18d2      	adds	r2, r2, r3
 8001c22:	4b04      	ldr	r3, [pc, #16]	; (8001c34 <chCoreAllocAlignedI+0x74>)
 8001c24:	601a      	str	r2, [r3, #0]

  return p;
 8001c26:	9b03      	ldr	r3, [sp, #12]
}
 8001c28:	0018      	movs	r0, r3
 8001c2a:	b005      	add	sp, #20
 8001c2c:	bd00      	pop	{pc}
 8001c2e:	46c0      	nop			; (mov r8, r8)
 8001c30:	08003cec 	.word	0x08003cec
 8001c34:	20000dac 	.word	0x20000dac
 8001c38:	20000db0 	.word	0x20000db0
 8001c3c:	00000000 	.word	0x00000000

08001c40 <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
 8001c40:	b500      	push	{lr}
 8001c42:	b085      	sub	sp, #20
 8001c44:	9001      	str	r0, [sp, #4]
 8001c46:	9100      	str	r1, [sp, #0]
  void *p;

  chSysLock();
 8001c48:	f7ff ff82 	bl	8001b50 <chSysLock.lto_priv.136>
  p = chCoreAllocAlignedI(size, align);
 8001c4c:	9a00      	ldr	r2, [sp, #0]
 8001c4e:	9b01      	ldr	r3, [sp, #4]
 8001c50:	0011      	movs	r1, r2
 8001c52:	0018      	movs	r0, r3
 8001c54:	f7ff ffb4 	bl	8001bc0 <chCoreAllocAlignedI>
 8001c58:	0003      	movs	r3, r0
 8001c5a:	9303      	str	r3, [sp, #12]
  chSysUnlock();
 8001c5c:	f7ff ff80 	bl	8001b60 <chSysUnlock.lto_priv.132>

  return p;
 8001c60:	9b03      	ldr	r3, [sp, #12]
}
 8001c62:	0018      	movs	r0, r3
 8001c64:	b005      	add	sp, #20
 8001c66:	bd00      	pop	{pc}
	...

08001c70 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
 8001c70:	b510      	push	{r4, lr}

  default_heap.provider = chCoreAllocAligned;
 8001c72:	4b07      	ldr	r3, [pc, #28]	; (8001c90 <_heap_init+0x20>)
 8001c74:	4a07      	ldr	r2, [pc, #28]	; (8001c94 <_heap_init+0x24>)
 8001c76:	601a      	str	r2, [r3, #0]
  H_NEXT(&default_heap.header) = NULL;
 8001c78:	4b05      	ldr	r3, [pc, #20]	; (8001c90 <_heap_init+0x20>)
 8001c7a:	2200      	movs	r2, #0
 8001c7c:	609a      	str	r2, [r3, #8]
  H_PAGES(&default_heap.header) = 0;
 8001c7e:	4b04      	ldr	r3, [pc, #16]	; (8001c90 <_heap_init+0x20>)
 8001c80:	2200      	movs	r2, #0
 8001c82:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
 8001c84:	4b04      	ldr	r3, [pc, #16]	; (8001c98 <_heap_init+0x28>)
 8001c86:	0018      	movs	r0, r3
 8001c88:	f000 f98a 	bl	8001fa0 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
#endif
}
 8001c8c:	bd10      	pop	{r4, pc}
 8001c8e:	46c0      	nop			; (mov r8, r8)
 8001c90:	20000db8 	.word	0x20000db8
 8001c94:	08001c41 	.word	0x08001c41
 8001c98:	20000dc8 	.word	0x20000dc8
 8001c9c:	00000000 	.word	0x00000000

08001ca0 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8001ca0:	b500      	push	{lr}
 8001ca2:	b087      	sub	sp, #28
 8001ca4:	9001      	str	r0, [sp, #4]
  heap_header_t *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
 8001ca6:	9b01      	ldr	r3, [sp, #4]
 8001ca8:	2b00      	cmp	r3, #0
 8001caa:	d003      	beq.n	8001cb4 <chHeapFree+0x14>
 8001cac:	9b01      	ldr	r3, [sp, #4]
 8001cae:	2207      	movs	r2, #7
 8001cb0:	4013      	ands	r3, r2
 8001cb2:	d003      	beq.n	8001cbc <chHeapFree+0x1c>
 8001cb4:	4b3e      	ldr	r3, [pc, #248]	; (8001db0 <chHeapFree+0x110>)
 8001cb6:	0018      	movs	r0, r3
 8001cb8:	f000 ffb2 	bl	8002c20 <chSysHalt>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
 8001cbc:	9b01      	ldr	r3, [sp, #4]
 8001cbe:	3b08      	subs	r3, #8
 8001cc0:	9304      	str	r3, [sp, #16]
  /*lint -restore*/
  heapp = H_HEAP(hp);
 8001cc2:	9b04      	ldr	r3, [sp, #16]
 8001cc4:	681b      	ldr	r3, [r3, #0]
 8001cc6:	9303      	str	r3, [sp, #12]
  qp = &heapp->header;
 8001cc8:	9b03      	ldr	r3, [sp, #12]
 8001cca:	3308      	adds	r3, #8
 8001ccc:	9305      	str	r3, [sp, #20]

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8001cce:	9b04      	ldr	r3, [sp, #16]
 8001cd0:	685b      	ldr	r3, [r3, #4]
 8001cd2:	3307      	adds	r3, #7
 8001cd4:	2207      	movs	r2, #7
 8001cd6:	4393      	bics	r3, r2
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8001cd8:	08da      	lsrs	r2, r3, #3
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8001cda:	9b04      	ldr	r3, [sp, #16]
 8001cdc:	605a      	str	r2, [r3, #4]

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8001cde:	9b03      	ldr	r3, [sp, #12]
 8001ce0:	3310      	adds	r3, #16
 8001ce2:	0018      	movs	r0, r3
 8001ce4:	f000 f974 	bl	8001fd0 <chMtxLock>

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 8001ce8:	9a04      	ldr	r2, [sp, #16]
 8001cea:	9b05      	ldr	r3, [sp, #20]
 8001cec:	429a      	cmp	r2, r3
 8001cee:	d30c      	bcc.n	8001d0a <chHeapFree+0x6a>
 8001cf0:	9b05      	ldr	r3, [sp, #20]
 8001cf2:	685b      	ldr	r3, [r3, #4]
 8001cf4:	3301      	adds	r3, #1
 8001cf6:	00db      	lsls	r3, r3, #3
 8001cf8:	9a05      	ldr	r2, [sp, #20]
 8001cfa:	18d2      	adds	r2, r2, r3
 8001cfc:	9b04      	ldr	r3, [sp, #16]
 8001cfe:	429a      	cmp	r2, r3
 8001d00:	d903      	bls.n	8001d0a <chHeapFree+0x6a>
 8001d02:	4b2b      	ldr	r3, [pc, #172]	; (8001db0 <chHeapFree+0x110>)
 8001d04:	0018      	movs	r0, r3
 8001d06:	f000 ff8b 	bl	8002c20 <chSysHalt>

    if (((qp == &heapp->header) || (hp > qp)) &&
 8001d0a:	9b03      	ldr	r3, [sp, #12]
 8001d0c:	3308      	adds	r3, #8
 8001d0e:	001a      	movs	r2, r3
 8001d10:	9b05      	ldr	r3, [sp, #20]
 8001d12:	429a      	cmp	r2, r3
 8001d14:	d003      	beq.n	8001d1e <chHeapFree+0x7e>
 8001d16:	9a04      	ldr	r2, [sp, #16]
 8001d18:	9b05      	ldr	r3, [sp, #20]
 8001d1a:	429a      	cmp	r2, r3
 8001d1c:	d942      	bls.n	8001da4 <chHeapFree+0x104>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8001d1e:	9b05      	ldr	r3, [sp, #20]
 8001d20:	681b      	ldr	r3, [r3, #0]
    if (((qp == &heapp->header) || (hp > qp)) &&
 8001d22:	2b00      	cmp	r3, #0
 8001d24:	d004      	beq.n	8001d30 <chHeapFree+0x90>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8001d26:	9b05      	ldr	r3, [sp, #20]
 8001d28:	681a      	ldr	r2, [r3, #0]
 8001d2a:	9b04      	ldr	r3, [sp, #16]
 8001d2c:	429a      	cmp	r2, r3
 8001d2e:	d939      	bls.n	8001da4 <chHeapFree+0x104>
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
 8001d30:	9b05      	ldr	r3, [sp, #20]
 8001d32:	681a      	ldr	r2, [r3, #0]
 8001d34:	9b04      	ldr	r3, [sp, #16]
 8001d36:	601a      	str	r2, [r3, #0]
      H_NEXT(qp) = hp;
 8001d38:	9b05      	ldr	r3, [sp, #20]
 8001d3a:	9a04      	ldr	r2, [sp, #16]
 8001d3c:	601a      	str	r2, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8001d3e:	9b04      	ldr	r3, [sp, #16]
 8001d40:	685b      	ldr	r3, [r3, #4]
 8001d42:	3301      	adds	r3, #1
 8001d44:	00db      	lsls	r3, r3, #3
 8001d46:	9a04      	ldr	r2, [sp, #16]
 8001d48:	18d2      	adds	r2, r2, r3
 8001d4a:	9b04      	ldr	r3, [sp, #16]
 8001d4c:	681b      	ldr	r3, [r3, #0]
 8001d4e:	429a      	cmp	r2, r3
 8001d50:	d10d      	bne.n	8001d6e <chHeapFree+0xce>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8001d52:	9b04      	ldr	r3, [sp, #16]
 8001d54:	685a      	ldr	r2, [r3, #4]
 8001d56:	9b04      	ldr	r3, [sp, #16]
 8001d58:	681b      	ldr	r3, [r3, #0]
 8001d5a:	685b      	ldr	r3, [r3, #4]
 8001d5c:	18d3      	adds	r3, r2, r3
 8001d5e:	1c5a      	adds	r2, r3, #1
 8001d60:	9b04      	ldr	r3, [sp, #16]
 8001d62:	605a      	str	r2, [r3, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 8001d64:	9b04      	ldr	r3, [sp, #16]
 8001d66:	681b      	ldr	r3, [r3, #0]
 8001d68:	681a      	ldr	r2, [r3, #0]
 8001d6a:	9b04      	ldr	r3, [sp, #16]
 8001d6c:	601a      	str	r2, [r3, #0]
      }
      if ((H_LIMIT(qp) == hp)) {
 8001d6e:	9b05      	ldr	r3, [sp, #20]
 8001d70:	685b      	ldr	r3, [r3, #4]
 8001d72:	3301      	adds	r3, #1
 8001d74:	00db      	lsls	r3, r3, #3
 8001d76:	9a05      	ldr	r2, [sp, #20]
 8001d78:	18d2      	adds	r2, r2, r3
 8001d7a:	9b04      	ldr	r3, [sp, #16]
 8001d7c:	429a      	cmp	r2, r3
 8001d7e:	d10b      	bne.n	8001d98 <chHeapFree+0xf8>
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8001d80:	9b05      	ldr	r3, [sp, #20]
 8001d82:	685a      	ldr	r2, [r3, #4]
 8001d84:	9b04      	ldr	r3, [sp, #16]
 8001d86:	685b      	ldr	r3, [r3, #4]
 8001d88:	18d3      	adds	r3, r2, r3
 8001d8a:	1c5a      	adds	r2, r3, #1
 8001d8c:	9b05      	ldr	r3, [sp, #20]
 8001d8e:	605a      	str	r2, [r3, #4]
        H_NEXT(qp) = H_NEXT(hp);
 8001d90:	9b04      	ldr	r3, [sp, #16]
 8001d92:	681a      	ldr	r2, [r3, #0]
 8001d94:	9b05      	ldr	r3, [sp, #20]
 8001d96:	601a      	str	r2, [r3, #0]
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 8001d98:	9b03      	ldr	r3, [sp, #12]
 8001d9a:	3310      	adds	r3, #16
 8001d9c:	0018      	movs	r0, r3
 8001d9e:	f000 f9af 	bl	8002100 <chMtxUnlock>
 8001da2:	e003      	b.n	8001dac <chHeapFree+0x10c>
    qp = H_NEXT(qp);
 8001da4:	9b05      	ldr	r3, [sp, #20]
 8001da6:	681b      	ldr	r3, [r3, #0]
 8001da8:	9305      	str	r3, [sp, #20]
 8001daa:	e79d      	b.n	8001ce8 <chHeapFree+0x48>

  return;
}
 8001dac:	b007      	add	sp, #28
 8001dae:	bd00      	pop	{pc}
 8001db0:	08003d0c 	.word	0x08003d0c
	...

08001dc0 <port_lock.lto_priv.144>:
  __ASM volatile ("cpsid i" : : : "memory");
 8001dc0:	b672      	cpsid	i
}
 8001dc2:	4770      	bx	lr
	...

08001dd0 <port_unlock.lto_priv.140>:
  __ASM volatile ("cpsie i" : : : "memory");
 8001dd0:	b662      	cpsie	i
}
 8001dd2:	4770      	bx	lr
	...

08001de0 <chSysLock.lto_priv.137>:
static inline void chSysLock(void) {
 8001de0:	b510      	push	{r4, lr}
  port_lock();
 8001de2:	f7ff ffed 	bl	8001dc0 <port_lock.lto_priv.144>
  _dbg_check_lock();
 8001de6:	f000 ff6b 	bl	8002cc0 <_dbg_check_lock>
}
 8001dea:	bd10      	pop	{r4, pc}
 8001dec:	0000      	movs	r0, r0
	...

08001df0 <chSysUnlock.lto_priv.133>:
static inline void chSysUnlock(void) {
 8001df0:	b510      	push	{r4, lr}
  _dbg_check_unlock();
 8001df2:	f000 ff7d 	bl	8002cf0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001df6:	4b0a      	ldr	r3, [pc, #40]	; (8001e20 <chSysUnlock.lto_priv.133+0x30>)
 8001df8:	681a      	ldr	r2, [r3, #0]
 8001dfa:	4b09      	ldr	r3, [pc, #36]	; (8001e20 <chSysUnlock.lto_priv.133+0x30>)
 8001dfc:	429a      	cmp	r2, r3
 8001dfe:	d00b      	beq.n	8001e18 <chSysUnlock.lto_priv.133+0x28>
 8001e00:	4b07      	ldr	r3, [pc, #28]	; (8001e20 <chSysUnlock.lto_priv.133+0x30>)
 8001e02:	699b      	ldr	r3, [r3, #24]
 8001e04:	689a      	ldr	r2, [r3, #8]
 8001e06:	4b06      	ldr	r3, [pc, #24]	; (8001e20 <chSysUnlock.lto_priv.133+0x30>)
 8001e08:	681b      	ldr	r3, [r3, #0]
 8001e0a:	689b      	ldr	r3, [r3, #8]
 8001e0c:	429a      	cmp	r2, r3
 8001e0e:	d203      	bcs.n	8001e18 <chSysUnlock.lto_priv.133+0x28>
 8001e10:	4b04      	ldr	r3, [pc, #16]	; (8001e24 <chSysUnlock.lto_priv.133+0x34>)
 8001e12:	0018      	movs	r0, r3
 8001e14:	f000 ff04 	bl	8002c20 <chSysHalt>
  port_unlock();
 8001e18:	f7ff ffda 	bl	8001dd0 <port_unlock.lto_priv.140>
}
 8001e1c:	bd10      	pop	{r4, pc}
 8001e1e:	46c0      	nop			; (mov r8, r8)
 8001e20:	20000528 	.word	0x20000528
 8001e24:	08003d18 	.word	0x08003d18
	...

08001e30 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
 8001e30:	b500      	push	{lr}
 8001e32:	b085      	sub	sp, #20
 8001e34:	9001      	str	r0, [sp, #4]
 8001e36:	9100      	str	r1, [sp, #0]
  struct pool_header *php = objp;
 8001e38:	9b00      	ldr	r3, [sp, #0]
 8001e3a:	9303      	str	r3, [sp, #12]

  chDbgCheckClassI();
 8001e3c:	f000 ffe0 	bl	8002e00 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) && (objp != NULL));
 8001e40:	9b01      	ldr	r3, [sp, #4]
 8001e42:	2b00      	cmp	r3, #0
 8001e44:	d002      	beq.n	8001e4c <chPoolFreeI+0x1c>
 8001e46:	9b00      	ldr	r3, [sp, #0]
 8001e48:	2b00      	cmp	r3, #0
 8001e4a:	d103      	bne.n	8001e54 <chPoolFreeI+0x24>
 8001e4c:	4b06      	ldr	r3, [pc, #24]	; (8001e68 <chPoolFreeI+0x38>)
 8001e4e:	0018      	movs	r0, r3
 8001e50:	f000 fee6 	bl	8002c20 <chSysHalt>

  php->next = mp->next;
 8001e54:	9b01      	ldr	r3, [sp, #4]
 8001e56:	681a      	ldr	r2, [r3, #0]
 8001e58:	9b03      	ldr	r3, [sp, #12]
 8001e5a:	601a      	str	r2, [r3, #0]
  mp->next = php;
 8001e5c:	9b01      	ldr	r3, [sp, #4]
 8001e5e:	9a03      	ldr	r2, [sp, #12]
 8001e60:	601a      	str	r2, [r3, #0]
}
 8001e62:	b005      	add	sp, #20
 8001e64:	bd00      	pop	{pc}
 8001e66:	46c0      	nop			; (mov r8, r8)
 8001e68:	08003d24 	.word	0x08003d24
 8001e6c:	00000000 	.word	0x00000000

08001e70 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
 8001e70:	b500      	push	{lr}
 8001e72:	b083      	sub	sp, #12
 8001e74:	9001      	str	r0, [sp, #4]
 8001e76:	9100      	str	r1, [sp, #0]

  chSysLock();
 8001e78:	f7ff ffb2 	bl	8001de0 <chSysLock.lto_priv.137>
  chPoolFreeI(mp, objp);
 8001e7c:	9a00      	ldr	r2, [sp, #0]
 8001e7e:	9b01      	ldr	r3, [sp, #4]
 8001e80:	0011      	movs	r1, r2
 8001e82:	0018      	movs	r0, r3
 8001e84:	f7ff ffd4 	bl	8001e30 <chPoolFreeI>
  chSysUnlock();
 8001e88:	f7ff ffb2 	bl	8001df0 <chSysUnlock.lto_priv.133>
}
 8001e8c:	b003      	add	sp, #12
 8001e8e:	bd00      	pop	{pc}

08001e90 <port_lock.lto_priv.145>:
  __ASM volatile ("cpsid i" : : : "memory");
 8001e90:	b672      	cpsid	i
}
 8001e92:	4770      	bx	lr
	...

08001ea0 <port_unlock.lto_priv.141>:
  __ASM volatile ("cpsie i" : : : "memory");
 8001ea0:	b662      	cpsie	i
}
 8001ea2:	4770      	bx	lr
	...

08001eb0 <port_lock_from_isr>:
static inline void port_lock_from_isr(void) {
 8001eb0:	b510      	push	{r4, lr}
  port_lock();
 8001eb2:	f7ff ffed 	bl	8001e90 <port_lock.lto_priv.145>
}
 8001eb6:	bd10      	pop	{r4, pc}
	...

08001ec0 <port_unlock_from_isr>:
static inline void port_unlock_from_isr(void) {
 8001ec0:	b510      	push	{r4, lr}
  port_unlock();
 8001ec2:	f7ff ffed 	bl	8001ea0 <port_unlock.lto_priv.141>
}
 8001ec6:	bd10      	pop	{r4, pc}
	...

08001ed0 <NMI_Handler>:
 * @brief   NMI vector.
 * @details The NMI vector is used for exception mode re-entering after a
 *          context switch.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void NMI_Handler(void) {
 8001ed0:	b510      	push	{r4, lr}
 8001ed2:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8001ed4:	f3ef 8309 	mrs	r3, PSP
 8001ed8:	001c      	movs	r4, r3
  return(result);
 8001eda:	0023      	movs	r3, r4
/*lint -restore*/

  /* The port_extctx structure is pointed by the PSP register.*/
  struct port_extctx *ctxp = (struct port_extctx *)__get_PSP();
 8001edc:	9301      	str	r3, [sp, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8001ede:	9b01      	ldr	r3, [sp, #4]
 8001ee0:	3320      	adds	r3, #32
 8001ee2:	9301      	str	r3, [sp, #4]

  /* Writing back the modified PSP value.*/
  __set_PSP((uint32_t)ctxp);
 8001ee4:	9b01      	ldr	r3, [sp, #4]
 8001ee6:	9300      	str	r3, [sp, #0]
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8001ee8:	9b00      	ldr	r3, [sp, #0]
 8001eea:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 8001eee:	f7ff ffe7 	bl	8001ec0 <port_unlock_from_isr>
}
 8001ef2:	b002      	add	sp, #8
 8001ef4:	bd10      	pop	{r4, pc}
 8001ef6:	46c0      	nop			; (mov r8, r8)
	...

08001f00 <_port_irq_epilogue>:
/**
 * @brief   IRQ epilogue code.
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {
 8001f00:	b510      	push	{r4, lr}
 8001f02:	b084      	sub	sp, #16
 8001f04:	9001      	str	r0, [sp, #4]

  if (lr != (regarm_t)0xFFFFFFF1U) {
 8001f06:	9b01      	ldr	r3, [sp, #4]
 8001f08:	330f      	adds	r3, #15
 8001f0a:	d01d      	beq.n	8001f48 <_port_irq_epilogue+0x48>
    struct port_extctx *ctxp;

    port_lock_from_isr();
 8001f0c:	f7ff ffd0 	bl	8001eb0 <port_lock_from_isr>
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8001f10:	f3ef 8309 	mrs	r3, PSP
 8001f14:	001c      	movs	r4, r3
  return(result);
 8001f16:	0023      	movs	r3, r4

    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
 8001f18:	9303      	str	r3, [sp, #12]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8001f1a:	9b03      	ldr	r3, [sp, #12]
 8001f1c:	3b20      	subs	r3, #32
 8001f1e:	9303      	str	r3, [sp, #12]

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
 8001f20:	9b03      	ldr	r3, [sp, #12]
 8001f22:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8001f24:	9b02      	ldr	r3, [sp, #8]
 8001f26:	f383 8809 	msr	PSP, r3

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8001f2a:	9b03      	ldr	r3, [sp, #12]
 8001f2c:	2280      	movs	r2, #128	; 0x80
 8001f2e:	0452      	lsls	r2, r2, #17
 8001f30:	61da      	str	r2, [r3, #28]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8001f32:	f001 fc9d 	bl	8003870 <chSchIsPreemptionRequired>
 8001f36:	1e03      	subs	r3, r0, #0
 8001f38:	d003      	beq.n	8001f42 <_port_irq_epilogue+0x42>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8001f3a:	9b03      	ldr	r3, [sp, #12]
 8001f3c:	4a03      	ldr	r2, [pc, #12]	; (8001f4c <_port_irq_epilogue+0x4c>)
 8001f3e:	619a      	str	r2, [r3, #24]
 8001f40:	e002      	b.n	8001f48 <_port_irq_epilogue+0x48>
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8001f42:	9b03      	ldr	r3, [sp, #12]
 8001f44:	4a02      	ldr	r2, [pc, #8]	; (8001f50 <_port_irq_epilogue+0x50>)
 8001f46:	619a      	str	r2, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
  }
}
 8001f48:	b004      	add	sp, #16
 8001f4a:	bd10      	pop	{r4, pc}
 8001f4c:	080001c1 	.word	0x080001c1
 8001f50:	080001cc 	.word	0x080001cc
	...

08001f60 <osalInit>:
}
 8001f60:	4770      	bx	lr
 8001f62:	46c0      	nop			; (mov r8, r8)
	...

08001f70 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8001f70:	b510      	push	{r4, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8001f72:	f7ff fff5 	bl	8001f60 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 8001f76:	f7fe ff83 	bl	8000e80 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 8001f7a:	4b06      	ldr	r3, [pc, #24]	; (8001f94 <halInit+0x24>)
 8001f7c:	0018      	movs	r0, r3
 8001f7e:	f7ff f847 	bl	8001010 <_pal_lld_init>
#endif
#if (HAL_USE_I2S == TRUE) || defined(__DOXYGEN__)
  i2sInit();
#endif
#if (HAL_USE_ICU == TRUE) || defined(__DOXYGEN__)
  icuInit();
 8001f82:	f7ff fc85 	bl	8001890 <icuInit>
#endif
#if (HAL_USE_MAC == TRUE) || defined(__DOXYGEN__)
  macInit();
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
 8001f86:	f7ff fdbb 	bl	8001b00 <pwmInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8001f8a:	f7fe fbd9 	bl	8000740 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 8001f8e:	f7fe fe9f 	bl	8000cd0 <stInit>
#endif
}
 8001f92:	bd10      	pop	{r4, pc}
 8001f94:	08003e8c 	.word	0x08003e8c
	...

08001fa0 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 8001fa0:	b500      	push	{lr}
 8001fa2:	b083      	sub	sp, #12
 8001fa4:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);
 8001fa6:	9b01      	ldr	r3, [sp, #4]
 8001fa8:	2b00      	cmp	r3, #0
 8001faa:	d103      	bne.n	8001fb4 <chMtxObjectInit+0x14>
 8001fac:	4b06      	ldr	r3, [pc, #24]	; (8001fc8 <chMtxObjectInit+0x28>)
 8001fae:	0018      	movs	r0, r3
 8001fb0:	f000 fe36 	bl	8002c20 <chSysHalt>

  queue_init(&mp->queue);
 8001fb4:	9b01      	ldr	r3, [sp, #4]
 8001fb6:	0018      	movs	r0, r3
 8001fb8:	f000 fb7a 	bl	80026b0 <queue_init.lto_priv.158>
  mp->owner = NULL;
 8001fbc:	9b01      	ldr	r3, [sp, #4]
 8001fbe:	2200      	movs	r2, #0
 8001fc0:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
#endif
}
 8001fc2:	b003      	add	sp, #12
 8001fc4:	bd00      	pop	{pc}
 8001fc6:	46c0      	nop			; (mov r8, r8)
 8001fc8:	08003cb8 	.word	0x08003cb8
 8001fcc:	00000000 	.word	0x00000000

08001fd0 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 8001fd0:	b500      	push	{lr}
 8001fd2:	b083      	sub	sp, #12
 8001fd4:	9001      	str	r0, [sp, #4]

  chSysLock();
 8001fd6:	f000 fbdb 	bl	8002790 <chSysLock.lto_priv.177>
  chMtxLockS(mp);
 8001fda:	9b01      	ldr	r3, [sp, #4]
 8001fdc:	0018      	movs	r0, r3
 8001fde:	f000 f807 	bl	8001ff0 <chMtxLockS>
  chSysUnlock();
 8001fe2:	f000 fbdd 	bl	80027a0 <chSysUnlock.lto_priv.172>
}
 8001fe6:	b003      	add	sp, #12
 8001fe8:	bd00      	pop	{pc}
 8001fea:	46c0      	nop			; (mov r8, r8)
 8001fec:	0000      	movs	r0, r0
	...

08001ff0 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8001ff0:	b500      	push	{lr}
 8001ff2:	b085      	sub	sp, #20
 8001ff4:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8001ff6:	4b3e      	ldr	r3, [pc, #248]	; (80020f0 <chMtxLockS+0x100>)
 8001ff8:	699b      	ldr	r3, [r3, #24]
 8001ffa:	9302      	str	r3, [sp, #8]

  chDbgCheckClassS();
 8001ffc:	f000 ff18 	bl	8002e30 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 8002000:	9b01      	ldr	r3, [sp, #4]
 8002002:	2b00      	cmp	r3, #0
 8002004:	d103      	bne.n	800200e <chMtxLockS+0x1e>
 8002006:	4b3b      	ldr	r3, [pc, #236]	; (80020f4 <chMtxLockS+0x104>)
 8002008:	0018      	movs	r0, r3
 800200a:	f000 fe09 	bl	8002c20 <chSysHalt>

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 800200e:	9b01      	ldr	r3, [sp, #4]
 8002010:	689b      	ldr	r3, [r3, #8]
 8002012:	2b00      	cmp	r3, #0
 8002014:	d05f      	beq.n	80020d6 <chMtxLockS+0xe6>
    else {
#endif
      /* Priority inheritance protocol; explores the thread-mutex dependencies
         boosting the priority of all the affected threads to equal the
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;
 8002016:	9b01      	ldr	r3, [sp, #4]
 8002018:	689b      	ldr	r3, [r3, #8]
 800201a:	9303      	str	r3, [sp, #12]
 800201c:	e036      	b.n	800208c <chMtxLockS+0x9c>

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;
 800201e:	9b02      	ldr	r3, [sp, #8]
 8002020:	689a      	ldr	r2, [r3, #8]
 8002022:	9b03      	ldr	r3, [sp, #12]
 8002024:	609a      	str	r2, [r3, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8002026:	9b03      	ldr	r3, [sp, #12]
 8002028:	2220      	movs	r2, #32
 800202a:	5c9b      	ldrb	r3, [r3, r2]
 800202c:	2b06      	cmp	r3, #6
 800202e:	d004      	beq.n	800203a <chMtxLockS+0x4a>
 8002030:	2b07      	cmp	r3, #7
 8002032:	d012      	beq.n	800205a <chMtxLockS+0x6a>
 8002034:	2b00      	cmp	r3, #0
 8002036:	d01c      	beq.n	8002072 <chMtxLockS+0x82>
 8002038:	e02e      	b.n	8002098 <chMtxLockS+0xa8>
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 800203a:	9b03      	ldr	r3, [sp, #12]
 800203c:	0018      	movs	r0, r3
 800203e:	f000 fb97 	bl	8002770 <queue_dequeue.lto_priv.193>
 8002042:	0002      	movs	r2, r0
 8002044:	9b03      	ldr	r3, [sp, #12]
 8002046:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002048:	0019      	movs	r1, r3
 800204a:	0010      	movs	r0, r2
 800204c:	f000 fb50 	bl	80026f0 <queue_prio_insert.lto_priv.189>
          tp = tp->u.wtmtxp->owner;
 8002050:	9b03      	ldr	r3, [sp, #12]
 8002052:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002054:	689b      	ldr	r3, [r3, #8]
 8002056:	9303      	str	r3, [sp, #12]
 8002058:	e018      	b.n	800208c <chMtxLockS+0x9c>
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 800205a:	9b03      	ldr	r3, [sp, #12]
 800205c:	0018      	movs	r0, r3
 800205e:	f000 fb87 	bl	8002770 <queue_dequeue.lto_priv.193>
 8002062:	0002      	movs	r2, r0
 8002064:	9b03      	ldr	r3, [sp, #12]
 8002066:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002068:	0019      	movs	r1, r3
 800206a:	0010      	movs	r0, r2
 800206c:	f000 fb40 	bl	80026f0 <queue_prio_insert.lto_priv.189>
 8002070:	e012      	b.n	8002098 <chMtxLockS+0xa8>
          break;
#endif
        case CH_STATE_READY:
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
 8002072:	9b03      	ldr	r3, [sp, #12]
 8002074:	2220      	movs	r2, #32
 8002076:	2101      	movs	r1, #1
 8002078:	5499      	strb	r1, [r3, r2]
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 800207a:	9b03      	ldr	r3, [sp, #12]
 800207c:	0018      	movs	r0, r3
 800207e:	f000 fb77 	bl	8002770 <queue_dequeue.lto_priv.193>
 8002082:	0003      	movs	r3, r0
 8002084:	0018      	movs	r0, r3
 8002086:	f001 fa53 	bl	8003530 <chSchReadyI>
 800208a:	e005      	b.n	8002098 <chMtxLockS+0xa8>
      while (tp->prio < ctp->prio) {
 800208c:	9b03      	ldr	r3, [sp, #12]
 800208e:	689a      	ldr	r2, [r3, #8]
 8002090:	9b02      	ldr	r3, [sp, #8]
 8002092:	689b      	ldr	r3, [r3, #8]
 8002094:	429a      	cmp	r2, r3
 8002096:	d3c2      	bcc.n	800201e <chMtxLockS+0x2e>
        }
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
 8002098:	9a01      	ldr	r2, [sp, #4]
 800209a:	9b02      	ldr	r3, [sp, #8]
 800209c:	0011      	movs	r1, r2
 800209e:	0018      	movs	r0, r3
 80020a0:	f000 fb26 	bl	80026f0 <queue_prio_insert.lto_priv.189>
      ctp->u.wtmtxp = mp;
 80020a4:	9b02      	ldr	r3, [sp, #8]
 80020a6:	9a01      	ldr	r2, [sp, #4]
 80020a8:	625a      	str	r2, [r3, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 80020aa:	2006      	movs	r0, #6
 80020ac:	f001 fac0 	bl	8003630 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == ctp, "not owner");
 80020b0:	9b01      	ldr	r3, [sp, #4]
 80020b2:	689a      	ldr	r2, [r3, #8]
 80020b4:	9b02      	ldr	r3, [sp, #8]
 80020b6:	429a      	cmp	r2, r3
 80020b8:	d003      	beq.n	80020c2 <chMtxLockS+0xd2>
 80020ba:	4b0e      	ldr	r3, [pc, #56]	; (80020f4 <chMtxLockS+0x104>)
 80020bc:	0018      	movs	r0, r3
 80020be:	f000 fdaf 	bl	8002c20 <chSysHalt>
      chDbgAssert(ctp->mtxlist == mp, "not owned");
 80020c2:	9b02      	ldr	r3, [sp, #8]
 80020c4:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80020c6:	9b01      	ldr	r3, [sp, #4]
 80020c8:	429a      	cmp	r2, r3
 80020ca:	d00e      	beq.n	80020ea <chMtxLockS+0xfa>
 80020cc:	4b09      	ldr	r3, [pc, #36]	; (80020f4 <chMtxLockS+0x104>)
 80020ce:	0018      	movs	r0, r3
 80020d0:	f000 fda6 	bl	8002c20 <chSysHalt>
 80020d4:	e009      	b.n	80020ea <chMtxLockS+0xfa>
    chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
 80020d6:	9b01      	ldr	r3, [sp, #4]
 80020d8:	9a02      	ldr	r2, [sp, #8]
 80020da:	609a      	str	r2, [r3, #8]
    mp->next = ctp->mtxlist;
 80020dc:	9b02      	ldr	r3, [sp, #8]
 80020de:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80020e0:	9b01      	ldr	r3, [sp, #4]
 80020e2:	60da      	str	r2, [r3, #12]
    ctp->mtxlist = mp;
 80020e4:	9b02      	ldr	r3, [sp, #8]
 80020e6:	9a01      	ldr	r2, [sp, #4]
 80020e8:	639a      	str	r2, [r3, #56]	; 0x38
  }
}
 80020ea:	b005      	add	sp, #20
 80020ec:	bd00      	pop	{pc}
 80020ee:	46c0      	nop			; (mov r8, r8)
 80020f0:	20000528 	.word	0x20000528
 80020f4:	08003cd4 	.word	0x08003cd4
	...

08002100 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8002100:	b500      	push	{lr}
 8002102:	b087      	sub	sp, #28
 8002104:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8002106:	4b37      	ldr	r3, [pc, #220]	; (80021e4 <chMtxUnlock+0xe4>)
 8002108:	699b      	ldr	r3, [r3, #24]
 800210a:	9303      	str	r3, [sp, #12]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 800210c:	9b01      	ldr	r3, [sp, #4]
 800210e:	2b00      	cmp	r3, #0
 8002110:	d103      	bne.n	800211a <chMtxUnlock+0x1a>
 8002112:	4b35      	ldr	r3, [pc, #212]	; (80021e8 <chMtxUnlock+0xe8>)
 8002114:	0018      	movs	r0, r3
 8002116:	f000 fd83 	bl	8002c20 <chSysHalt>

  chSysLock();
 800211a:	f000 fb39 	bl	8002790 <chSysLock.lto_priv.177>

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 800211e:	9b03      	ldr	r3, [sp, #12]
 8002120:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002122:	2b00      	cmp	r3, #0
 8002124:	d103      	bne.n	800212e <chMtxUnlock+0x2e>
 8002126:	4b30      	ldr	r3, [pc, #192]	; (80021e8 <chMtxUnlock+0xe8>)
 8002128:	0018      	movs	r0, r3
 800212a:	f000 fd79 	bl	8002c20 <chSysHalt>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
 800212e:	9b03      	ldr	r3, [sp, #12]
 8002130:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002132:	689a      	ldr	r2, [r3, #8]
 8002134:	9b03      	ldr	r3, [sp, #12]
 8002136:	429a      	cmp	r2, r3
 8002138:	d003      	beq.n	8002142 <chMtxUnlock+0x42>
 800213a:	4b2b      	ldr	r3, [pc, #172]	; (80021e8 <chMtxUnlock+0xe8>)
 800213c:	0018      	movs	r0, r3
 800213e:	f000 fd6f 	bl	8002c20 <chSysHalt>
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
#endif

    chDbgAssert(ctp->mtxlist == mp, "not next in list");
 8002142:	9b03      	ldr	r3, [sp, #12]
 8002144:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002146:	9b01      	ldr	r3, [sp, #4]
 8002148:	429a      	cmp	r2, r3
 800214a:	d003      	beq.n	8002154 <chMtxUnlock+0x54>
 800214c:	4b26      	ldr	r3, [pc, #152]	; (80021e8 <chMtxUnlock+0xe8>)
 800214e:	0018      	movs	r0, r3
 8002150:	f000 fd66 	bl	8002c20 <chSysHalt>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 8002154:	9b01      	ldr	r3, [sp, #4]
 8002156:	68da      	ldr	r2, [r3, #12]
 8002158:	9b03      	ldr	r3, [sp, #12]
 800215a:	639a      	str	r2, [r3, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 800215c:	9b01      	ldr	r3, [sp, #4]
 800215e:	0018      	movs	r0, r3
 8002160:	f000 fb3e 	bl	80027e0 <chMtxQueueNotEmptyS.lto_priv.192>
 8002164:	1e03      	subs	r3, r0, #0
 8002166:	d036      	beq.n	80021d6 <chMtxUnlock+0xd6>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 8002168:	9b03      	ldr	r3, [sp, #12]
 800216a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800216c:	9304      	str	r3, [sp, #16]
      lmp = ctp->mtxlist;
 800216e:	9b03      	ldr	r3, [sp, #12]
 8002170:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002172:	9305      	str	r3, [sp, #20]
 8002174:	e012      	b.n	800219c <chMtxUnlock+0x9c>
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8002176:	9b05      	ldr	r3, [sp, #20]
 8002178:	0018      	movs	r0, r3
 800217a:	f000 fb31 	bl	80027e0 <chMtxQueueNotEmptyS.lto_priv.192>
 800217e:	1e03      	subs	r3, r0, #0
 8002180:	d009      	beq.n	8002196 <chMtxUnlock+0x96>
            (lmp->queue.next->prio > newprio)) {
 8002182:	9b05      	ldr	r3, [sp, #20]
 8002184:	681b      	ldr	r3, [r3, #0]
 8002186:	689a      	ldr	r2, [r3, #8]
        if (chMtxQueueNotEmptyS(lmp) &&
 8002188:	9b04      	ldr	r3, [sp, #16]
 800218a:	429a      	cmp	r2, r3
 800218c:	d903      	bls.n	8002196 <chMtxUnlock+0x96>
          newprio = lmp->queue.next->prio;
 800218e:	9b05      	ldr	r3, [sp, #20]
 8002190:	681b      	ldr	r3, [r3, #0]
 8002192:	689b      	ldr	r3, [r3, #8]
 8002194:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->next;
 8002196:	9b05      	ldr	r3, [sp, #20]
 8002198:	68db      	ldr	r3, [r3, #12]
 800219a:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
 800219c:	9b05      	ldr	r3, [sp, #20]
 800219e:	2b00      	cmp	r3, #0
 80021a0:	d1e9      	bne.n	8002176 <chMtxUnlock+0x76>
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 80021a2:	9b03      	ldr	r3, [sp, #12]
 80021a4:	9a04      	ldr	r2, [sp, #16]
 80021a6:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
 80021a8:	9b01      	ldr	r3, [sp, #4]
 80021aa:	0018      	movs	r0, r3
 80021ac:	f000 fac8 	bl	8002740 <queue_fifo_remove.lto_priv.182>
 80021b0:	0003      	movs	r3, r0
 80021b2:	9302      	str	r3, [sp, #8]
      mp->owner = tp;
 80021b4:	9b01      	ldr	r3, [sp, #4]
 80021b6:	9a02      	ldr	r2, [sp, #8]
 80021b8:	609a      	str	r2, [r3, #8]
      mp->next = tp->mtxlist;
 80021ba:	9b02      	ldr	r3, [sp, #8]
 80021bc:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80021be:	9b01      	ldr	r3, [sp, #4]
 80021c0:	60da      	str	r2, [r3, #12]
      tp->mtxlist = mp;
 80021c2:	9b02      	ldr	r3, [sp, #8]
 80021c4:	9a01      	ldr	r2, [sp, #4]
 80021c6:	639a      	str	r2, [r3, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 80021c8:	9b02      	ldr	r3, [sp, #8]
 80021ca:	0018      	movs	r0, r3
 80021cc:	f001 f9b0 	bl	8003530 <chSchReadyI>
      chSchRescheduleS();
 80021d0:	f001 fb3e 	bl	8003850 <chSchRescheduleS>
 80021d4:	e002      	b.n	80021dc <chMtxUnlock+0xdc>
    }
    else {
      mp->owner = NULL;
 80021d6:	9b01      	ldr	r3, [sp, #4]
 80021d8:	2200      	movs	r2, #0
 80021da:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
 80021dc:	f000 fae0 	bl	80027a0 <chSysUnlock.lto_priv.172>
}
 80021e0:	b007      	add	sp, #28
 80021e2:	bd00      	pop	{pc}
 80021e4:	20000528 	.word	0x20000528
 80021e8:	08003ce0 	.word	0x08003ce0
 80021ec:	00000000 	.word	0x00000000

080021f0 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {
 80021f0:	b500      	push	{lr}
 80021f2:	b085      	sub	sp, #20
 80021f4:	9003      	str	r0, [sp, #12]
 80021f6:	9102      	str	r1, [sp, #8]
 80021f8:	9201      	str	r2, [sp, #4]

  tp->prio      = prio;
 80021fa:	9b03      	ldr	r3, [sp, #12]
 80021fc:	9a01      	ldr	r2, [sp, #4]
 80021fe:	609a      	str	r2, [r3, #8]
  tp->state     = CH_STATE_WTSTART;
 8002200:	9b03      	ldr	r3, [sp, #12]
 8002202:	2220      	movs	r2, #32
 8002204:	2102      	movs	r1, #2
 8002206:	5499      	strb	r1, [r3, r2]
  tp->flags     = CH_FLAG_MODE_STATIC;
 8002208:	9b03      	ldr	r3, [sp, #12]
 800220a:	2221      	movs	r2, #33	; 0x21
 800220c:	2100      	movs	r1, #0
 800220e:	5499      	strb	r1, [r3, r2]
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8002210:	9b03      	ldr	r3, [sp, #12]
 8002212:	9a01      	ldr	r2, [sp, #4]
 8002214:	63da      	str	r2, [r3, #60]	; 0x3c
  tp->mtxlist   = NULL;
 8002216:	9b03      	ldr	r3, [sp, #12]
 8002218:	2200      	movs	r2, #0
 800221a:	639a      	str	r2, [r3, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 800221c:	9b03      	ldr	r3, [sp, #12]
 800221e:	2200      	movs	r2, #0
 8002220:	635a      	str	r2, [r3, #52]	; 0x34
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8002222:	9b03      	ldr	r3, [sp, #12]
 8002224:	2222      	movs	r2, #34	; 0x22
 8002226:	2101      	movs	r1, #1
 8002228:	5499      	strb	r1, [r3, r2]
  tp->name      = name;
 800222a:	9b03      	ldr	r3, [sp, #12]
 800222c:	9a02      	ldr	r2, [sp, #8]
 800222e:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
 8002230:	9b03      	ldr	r3, [sp, #12]
 8002232:	4a0d      	ldr	r2, [pc, #52]	; (8002268 <_thread_init+0x78>)
 8002234:	611a      	str	r2, [r3, #16]
 8002236:	4b0c      	ldr	r3, [pc, #48]	; (8002268 <_thread_init+0x78>)
 8002238:	695a      	ldr	r2, [r3, #20]
 800223a:	9b03      	ldr	r3, [sp, #12]
 800223c:	615a      	str	r2, [r3, #20]
 800223e:	9b03      	ldr	r3, [sp, #12]
 8002240:	695b      	ldr	r3, [r3, #20]
 8002242:	9a03      	ldr	r2, [sp, #12]
 8002244:	611a      	str	r2, [r3, #16]
 8002246:	4b08      	ldr	r3, [pc, #32]	; (8002268 <_thread_init+0x78>)
 8002248:	9a03      	ldr	r2, [sp, #12]
 800224a:	615a      	str	r2, [r3, #20]
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
 800224c:	9b03      	ldr	r3, [sp, #12]
 800224e:	3328      	adds	r3, #40	; 0x28
 8002250:	0018      	movs	r0, r3
 8002252:	f001 fbb5 	bl	80039c0 <list_init.lto_priv.243>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
 8002256:	9b03      	ldr	r3, [sp, #12]
 8002258:	332c      	adds	r3, #44	; 0x2c
 800225a:	0018      	movs	r0, r3
 800225c:	f001 fbc8 	bl	80039f0 <queue_init.lto_priv.217>
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
 8002260:	9b03      	ldr	r3, [sp, #12]
}
 8002262:	0018      	movs	r0, r3
 8002264:	b005      	add	sp, #20
 8002266:	bd00      	pop	{pc}
 8002268:	20000528 	.word	0x20000528
 800226c:	00000000 	.word	0x00000000

08002270 <_thread_memfill>:
 * @param[in] endp      last address to fill +1
 * @param[in] v         filler value
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {
 8002270:	b084      	sub	sp, #16
 8002272:	9003      	str	r0, [sp, #12]
 8002274:	9102      	str	r1, [sp, #8]
 8002276:	466b      	mov	r3, sp
 8002278:	3307      	adds	r3, #7
 800227a:	701a      	strb	r2, [r3, #0]
 800227c:	e006      	b.n	800228c <_thread_memfill+0x1c>

  while (startp < endp) {
    *startp++ = v;
 800227e:	9b03      	ldr	r3, [sp, #12]
 8002280:	1c5a      	adds	r2, r3, #1
 8002282:	9203      	str	r2, [sp, #12]
 8002284:	466a      	mov	r2, sp
 8002286:	3207      	adds	r2, #7
 8002288:	7812      	ldrb	r2, [r2, #0]
 800228a:	701a      	strb	r2, [r3, #0]
  while (startp < endp) {
 800228c:	9a03      	ldr	r2, [sp, #12]
 800228e:	9b02      	ldr	r3, [sp, #8]
 8002290:	429a      	cmp	r2, r3
 8002292:	d3f4      	bcc.n	800227e <_thread_memfill+0xe>
  }
}
 8002294:	b004      	add	sp, #16
 8002296:	4770      	bx	lr
	...

080022a0 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 80022a0:	b500      	push	{lr}
 80022a2:	b085      	sub	sp, #20
 80022a4:	9001      	str	r0, [sp, #4]
  thread_t *tp;

  chDbgCheckClassI();
 80022a6:	f000 fdab 	bl	8002e00 <chDbgCheckClassI>
  chDbgCheck(tdp != NULL);
 80022aa:	9b01      	ldr	r3, [sp, #4]
 80022ac:	2b00      	cmp	r3, #0
 80022ae:	d103      	bne.n	80022b8 <chThdCreateSuspendedI+0x18>
 80022b0:	4b2a      	ldr	r3, [pc, #168]	; (800235c <chThdCreateSuspendedI+0xbc>)
 80022b2:	0018      	movs	r0, r3
 80022b4:	f000 fcb4 	bl	8002c20 <chSysHalt>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
 80022b8:	9b01      	ldr	r3, [sp, #4]
 80022ba:	685b      	ldr	r3, [r3, #4]
 80022bc:	001a      	movs	r2, r3
 80022be:	2307      	movs	r3, #7
 80022c0:	4013      	ands	r3, r2
 80022c2:	d113      	bne.n	80022ec <chThdCreateSuspendedI+0x4c>
 80022c4:	9b01      	ldr	r3, [sp, #4]
 80022c6:	689b      	ldr	r3, [r3, #8]
 80022c8:	001a      	movs	r2, r3
 80022ca:	2307      	movs	r3, #7
 80022cc:	4013      	ands	r3, r2
 80022ce:	d10d      	bne.n	80022ec <chThdCreateSuspendedI+0x4c>
 80022d0:	9b01      	ldr	r3, [sp, #4]
 80022d2:	689a      	ldr	r2, [r3, #8]
 80022d4:	9b01      	ldr	r3, [sp, #4]
 80022d6:	685b      	ldr	r3, [r3, #4]
 80022d8:	429a      	cmp	r2, r3
 80022da:	d907      	bls.n	80022ec <chThdCreateSuspendedI+0x4c>
 80022dc:	9b01      	ldr	r3, [sp, #4]
 80022de:	689b      	ldr	r3, [r3, #8]
 80022e0:	001a      	movs	r2, r3
 80022e2:	9b01      	ldr	r3, [sp, #4]
 80022e4:	685b      	ldr	r3, [r3, #4]
 80022e6:	1ad3      	subs	r3, r2, r3
 80022e8:	2bc7      	cmp	r3, #199	; 0xc7
 80022ea:	d803      	bhi.n	80022f4 <chThdCreateSuspendedI+0x54>
 80022ec:	4b1b      	ldr	r3, [pc, #108]	; (800235c <chThdCreateSuspendedI+0xbc>)
 80022ee:	0018      	movs	r0, r3
 80022f0:	f000 fc96 	bl	8002c20 <chSysHalt>
             MEM_IS_ALIGNED(tdp->wend, PORT_STACK_ALIGN) &&
             (tdp->wend > tdp->wbase) &&
             (((size_t)tdp->wend - (size_t)tdp->wbase) >= THD_WORKING_AREA_SIZE(0)));
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));
 80022f4:	9b01      	ldr	r3, [sp, #4]
 80022f6:	68db      	ldr	r3, [r3, #12]
 80022f8:	2bff      	cmp	r3, #255	; 0xff
 80022fa:	d803      	bhi.n	8002304 <chThdCreateSuspendedI+0x64>
 80022fc:	9b01      	ldr	r3, [sp, #4]
 80022fe:	691b      	ldr	r3, [r3, #16]
 8002300:	2b00      	cmp	r3, #0
 8002302:	d103      	bne.n	800230c <chThdCreateSuspendedI+0x6c>
 8002304:	4b15      	ldr	r3, [pc, #84]	; (800235c <chThdCreateSuspendedI+0xbc>)
 8002306:	0018      	movs	r0, r3
 8002308:	f000 fc8a 	bl	8002c20 <chSysHalt>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
 800230c:	9b01      	ldr	r3, [sp, #4]
 800230e:	689b      	ldr	r3, [r3, #8]
 8002310:	3b48      	subs	r3, #72	; 0x48
 8002312:	9303      	str	r3, [sp, #12]
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8002314:	9b01      	ldr	r3, [sp, #4]
 8002316:	685a      	ldr	r2, [r3, #4]
 8002318:	9b03      	ldr	r3, [sp, #12]
 800231a:	61da      	str	r2, [r3, #28]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800231c:	9b03      	ldr	r3, [sp, #12]
 800231e:	3b24      	subs	r3, #36	; 0x24
 8002320:	001a      	movs	r2, r3
 8002322:	9b03      	ldr	r3, [sp, #12]
 8002324:	60da      	str	r2, [r3, #12]
 8002326:	9b03      	ldr	r3, [sp, #12]
 8002328:	68db      	ldr	r3, [r3, #12]
 800232a:	9a01      	ldr	r2, [sp, #4]
 800232c:	6912      	ldr	r2, [r2, #16]
 800232e:	611a      	str	r2, [r3, #16]
 8002330:	9b03      	ldr	r3, [sp, #12]
 8002332:	68db      	ldr	r3, [r3, #12]
 8002334:	9a01      	ldr	r2, [sp, #4]
 8002336:	6952      	ldr	r2, [r2, #20]
 8002338:	615a      	str	r2, [r3, #20]
 800233a:	9b03      	ldr	r3, [sp, #12]
 800233c:	68db      	ldr	r3, [r3, #12]
 800233e:	4a08      	ldr	r2, [pc, #32]	; (8002360 <chThdCreateSuspendedI+0xc0>)
 8002340:	621a      	str	r2, [r3, #32]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 8002342:	9b01      	ldr	r3, [sp, #4]
 8002344:	6819      	ldr	r1, [r3, #0]
 8002346:	9b01      	ldr	r3, [sp, #4]
 8002348:	68da      	ldr	r2, [r3, #12]
 800234a:	9b03      	ldr	r3, [sp, #12]
 800234c:	0018      	movs	r0, r3
 800234e:	f7ff ff4f 	bl	80021f0 <_thread_init>
 8002352:	0003      	movs	r3, r0
}
 8002354:	0018      	movs	r0, r3
 8002356:	b005      	add	sp, #20
 8002358:	bd00      	pop	{pc}
 800235a:	46c0      	nop			; (mov r8, r8)
 800235c:	08003c2c 	.word	0x08003c2c
 8002360:	080001b1 	.word	0x080001b1
	...

08002370 <chThdCreate>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
 8002370:	b500      	push	{lr}
 8002372:	b085      	sub	sp, #20
 8002374:	9001      	str	r0, [sp, #4]
  thread_t *tp;

#if CH_CFG_USE_REGISTRY == TRUE
  chDbgAssert(chRegFindThreadByWorkingArea(tdp->wbase) == NULL,
 8002376:	9b01      	ldr	r3, [sp, #4]
 8002378:	685b      	ldr	r3, [r3, #4]
 800237a:	0018      	movs	r0, r3
 800237c:	f000 f968 	bl	8002650 <chRegFindThreadByWorkingArea>
 8002380:	1e03      	subs	r3, r0, #0
 8002382:	d003      	beq.n	800238c <chThdCreate+0x1c>
 8002384:	4b0f      	ldr	r3, [pc, #60]	; (80023c4 <chThdCreate+0x54>)
 8002386:	0018      	movs	r0, r3
 8002388:	f000 fc4a 	bl	8002c20 <chSysHalt>
              "working area in use");
#endif

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)tdp->wbase,
 800238c:	9b01      	ldr	r3, [sp, #4]
 800238e:	6858      	ldr	r0, [r3, #4]
                  (uint8_t *)tdp->wend,
 8002390:	9b01      	ldr	r3, [sp, #4]
 8002392:	689b      	ldr	r3, [r3, #8]
  _thread_memfill((uint8_t *)tdp->wbase,
 8002394:	2255      	movs	r2, #85	; 0x55
 8002396:	0019      	movs	r1, r3
 8002398:	f7ff ff6a 	bl	8002270 <_thread_memfill>
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 800239c:	f001 fb48 	bl	8003a30 <chSysLock.lto_priv.210>
  tp = chThdCreateSuspendedI(tdp);
 80023a0:	9b01      	ldr	r3, [sp, #4]
 80023a2:	0018      	movs	r0, r3
 80023a4:	f7ff ff7c 	bl	80022a0 <chThdCreateSuspendedI>
 80023a8:	0003      	movs	r3, r0
 80023aa:	9303      	str	r3, [sp, #12]
  chSchWakeupS(tp, MSG_OK);
 80023ac:	9b03      	ldr	r3, [sp, #12]
 80023ae:	2100      	movs	r1, #0
 80023b0:	0018      	movs	r0, r3
 80023b2:	f001 f9ed 	bl	8003790 <chSchWakeupS>
  chSysUnlock();
 80023b6:	f001 fb43 	bl	8003a40 <chSysUnlock.lto_priv.207>

  return tp;
 80023ba:	9b03      	ldr	r3, [sp, #12]
}
 80023bc:	0018      	movs	r0, r3
 80023be:	b005      	add	sp, #20
 80023c0:	bd00      	pop	{pc}
 80023c2:	46c0      	nop			; (mov r8, r8)
 80023c4:	08003c50 	.word	0x08003c50
	...

080023d0 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 80023d0:	b510      	push	{r4, lr}
 80023d2:	b082      	sub	sp, #8
 80023d4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80023d6:	f001 fb2b 	bl	8003a30 <chSysLock.lto_priv.210>
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 80023da:	9b01      	ldr	r3, [sp, #4]
 80023dc:	2222      	movs	r2, #34	; 0x22
 80023de:	5c9b      	ldrb	r3, [r3, r2]
 80023e0:	2b00      	cmp	r3, #0
 80023e2:	d103      	bne.n	80023ec <chThdRelease+0x1c>
 80023e4:	4b22      	ldr	r3, [pc, #136]	; (8002470 <chThdRelease+0xa0>)
 80023e6:	0018      	movs	r0, r3
 80023e8:	f000 fc1a 	bl	8002c20 <chSysHalt>
  tp->refs--;
 80023ec:	9b01      	ldr	r3, [sp, #4]
 80023ee:	2222      	movs	r2, #34	; 0x22
 80023f0:	5c9b      	ldrb	r3, [r3, r2]
 80023f2:	3b01      	subs	r3, #1
 80023f4:	b2d9      	uxtb	r1, r3
 80023f6:	9b01      	ldr	r3, [sp, #4]
 80023f8:	2222      	movs	r2, #34	; 0x22
 80023fa:	5499      	strb	r1, [r3, r2]

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 80023fc:	9b01      	ldr	r3, [sp, #4]
 80023fe:	2222      	movs	r2, #34	; 0x22
 8002400:	5c9b      	ldrb	r3, [r3, r2]
 8002402:	2b00      	cmp	r3, #0
 8002404:	d130      	bne.n	8002468 <chThdRelease+0x98>
 8002406:	9b01      	ldr	r3, [sp, #4]
 8002408:	2220      	movs	r2, #32
 800240a:	5c9b      	ldrb	r3, [r3, r2]
 800240c:	2b0f      	cmp	r3, #15
 800240e:	d12b      	bne.n	8002468 <chThdRelease+0x98>
    REG_REMOVE(tp);
 8002410:	9b01      	ldr	r3, [sp, #4]
 8002412:	695b      	ldr	r3, [r3, #20]
 8002414:	9a01      	ldr	r2, [sp, #4]
 8002416:	6912      	ldr	r2, [r2, #16]
 8002418:	611a      	str	r2, [r3, #16]
 800241a:	9b01      	ldr	r3, [sp, #4]
 800241c:	691b      	ldr	r3, [r3, #16]
 800241e:	9a01      	ldr	r2, [sp, #4]
 8002420:	6952      	ldr	r2, [r2, #20]
 8002422:	615a      	str	r2, [r3, #20]
    chSysUnlock();
 8002424:	f001 fb0c 	bl	8003a40 <chSysUnlock.lto_priv.207>

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 8002428:	9b01      	ldr	r3, [sp, #4]
 800242a:	2221      	movs	r2, #33	; 0x21
 800242c:	5c9b      	ldrb	r3, [r3, r2]
 800242e:	001a      	movs	r2, r3
 8002430:	2303      	movs	r3, #3
 8002432:	4013      	ands	r3, r2
 8002434:	2b01      	cmp	r3, #1
 8002436:	d002      	beq.n	800243e <chThdRelease+0x6e>
 8002438:	2b02      	cmp	r3, #2
 800243a:	d009      	beq.n	8002450 <chThdRelease+0x80>
 800243c:	e016      	b.n	800246c <chThdRelease+0x9c>
#if CH_CFG_USE_HEAP == TRUE
    case CH_FLAG_MODE_HEAP:
      chHeapFree(chThdGetWorkingAreaX(tp));
 800243e:	9b01      	ldr	r3, [sp, #4]
 8002440:	0018      	movs	r0, r3
 8002442:	f001 fb1d 	bl	8003a80 <chThdGetWorkingAreaX.lto_priv.220>
 8002446:	0003      	movs	r3, r0
 8002448:	0018      	movs	r0, r3
 800244a:	f7ff fc29 	bl	8001ca0 <chHeapFree>
 800244e:	e00d      	b.n	800246c <chThdRelease+0x9c>
      break;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 8002450:	9b01      	ldr	r3, [sp, #4]
 8002452:	6c1c      	ldr	r4, [r3, #64]	; 0x40
 8002454:	9b01      	ldr	r3, [sp, #4]
 8002456:	0018      	movs	r0, r3
 8002458:	f001 fb12 	bl	8003a80 <chThdGetWorkingAreaX.lto_priv.220>
 800245c:	0003      	movs	r3, r0
 800245e:	0019      	movs	r1, r3
 8002460:	0020      	movs	r0, r4
 8002462:	f7ff fd05 	bl	8001e70 <chPoolFree>
 8002466:	e001      	b.n	800246c <chThdRelease+0x9c>
      break;
    }
#endif /* CH_CFG_USE_DYNAMIC == TRUE */
    return;
  }
  chSysUnlock();
 8002468:	f001 faea 	bl	8003a40 <chSysUnlock.lto_priv.207>
}
 800246c:	b002      	add	sp, #8
 800246e:	bd10      	pop	{r4, pc}
 8002470:	08003c5c 	.word	0x08003c5c
	...

08002480 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8002480:	b500      	push	{lr}
 8002482:	b083      	sub	sp, #12
 8002484:	9001      	str	r0, [sp, #4]

  chSysLock();
 8002486:	f001 fad3 	bl	8003a30 <chSysLock.lto_priv.210>
  chThdExitS(msg);
 800248a:	9b01      	ldr	r3, [sp, #4]
 800248c:	0018      	movs	r0, r3
 800248e:	f000 f807 	bl	80024a0 <chThdExitS>
  /* The thread never returns here.*/
}
 8002492:	b003      	add	sp, #12
 8002494:	bd00      	pop	{pc}
 8002496:	46c0      	nop			; (mov r8, r8)
	...

080024a0 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 80024a0:	b500      	push	{lr}
 80024a2:	b085      	sub	sp, #20
 80024a4:	9001      	str	r0, [sp, #4]
  thread_t *tp = currp;
 80024a6:	4b1b      	ldr	r3, [pc, #108]	; (8002514 <chThdExitS+0x74>)
 80024a8:	699b      	ldr	r3, [r3, #24]
 80024aa:	9303      	str	r3, [sp, #12]

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 80024ac:	9b03      	ldr	r3, [sp, #12]
 80024ae:	9a01      	ldr	r2, [sp, #4]
 80024b0:	625a      	str	r2, [r3, #36]	; 0x24
 80024b2:	e008      	b.n	80024c6 <chThdExitS+0x26>
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
    (void) chSchReadyI(list_remove(&tp->waiting));
 80024b4:	9b03      	ldr	r3, [sp, #12]
 80024b6:	3328      	adds	r3, #40	; 0x28
 80024b8:	0018      	movs	r0, r3
 80024ba:	f001 faa9 	bl	8003a10 <list_remove.lto_priv.242>
 80024be:	0003      	movs	r3, r0
 80024c0:	0018      	movs	r0, r3
 80024c2:	f001 f835 	bl	8003530 <chSchReadyI>
  while (list_notempty(&tp->waiting)) {
 80024c6:	9b03      	ldr	r3, [sp, #12]
 80024c8:	3328      	adds	r3, #40	; 0x28
 80024ca:	0018      	movs	r0, r3
 80024cc:	f001 fa80 	bl	80039d0 <list_notempty.lto_priv.241>
 80024d0:	1e03      	subs	r3, r0, #0
 80024d2:	d1ef      	bne.n	80024b4 <chThdExitS+0x14>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 80024d4:	9b03      	ldr	r3, [sp, #12]
 80024d6:	2222      	movs	r2, #34	; 0x22
 80024d8:	5c9b      	ldrb	r3, [r3, r2]
 80024da:	2b00      	cmp	r3, #0
 80024dc:	d110      	bne.n	8002500 <chThdExitS+0x60>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
 80024de:	9b03      	ldr	r3, [sp, #12]
 80024e0:	2221      	movs	r2, #33	; 0x21
 80024e2:	5c9b      	ldrb	r3, [r3, r2]
 80024e4:	001a      	movs	r2, r3
 80024e6:	2303      	movs	r3, #3
 80024e8:	4013      	ands	r3, r2
  if ((tp->refs == (trefs_t)0) &&
 80024ea:	d109      	bne.n	8002500 <chThdExitS+0x60>
    REG_REMOVE(tp);
 80024ec:	9b03      	ldr	r3, [sp, #12]
 80024ee:	695b      	ldr	r3, [r3, #20]
 80024f0:	9a03      	ldr	r2, [sp, #12]
 80024f2:	6912      	ldr	r2, [r2, #16]
 80024f4:	611a      	str	r2, [r3, #16]
 80024f6:	9b03      	ldr	r3, [sp, #12]
 80024f8:	691b      	ldr	r3, [r3, #16]
 80024fa:	9a03      	ldr	r2, [sp, #12]
 80024fc:	6952      	ldr	r2, [r2, #20]
 80024fe:	615a      	str	r2, [r3, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 8002500:	200f      	movs	r0, #15
 8002502:	f001 f895 	bl	8003630 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 8002506:	4b04      	ldr	r3, [pc, #16]	; (8002518 <chThdExitS+0x78>)
 8002508:	0018      	movs	r0, r3
 800250a:	f000 fb89 	bl	8002c20 <chSysHalt>
}
 800250e:	b005      	add	sp, #20
 8002510:	bd00      	pop	{pc}
 8002512:	46c0      	nop			; (mov r8, r8)
 8002514:	20000528 	.word	0x20000528
 8002518:	08003c6c 	.word	0x08003c6c
 800251c:	00000000 	.word	0x00000000

08002520 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8002520:	b500      	push	{lr}
 8002522:	b083      	sub	sp, #12
 8002524:	9001      	str	r0, [sp, #4]

  chSysLock();
 8002526:	f001 fa83 	bl	8003a30 <chSysLock.lto_priv.210>
  chThdSleepS(time);
 800252a:	9b01      	ldr	r3, [sp, #4]
 800252c:	0018      	movs	r0, r3
 800252e:	f001 faaf 	bl	8003a90 <chThdSleepS.lto_priv.237>
  chSysUnlock();
 8002532:	f001 fa85 	bl	8003a40 <chSysUnlock.lto_priv.207>
}
 8002536:	b003      	add	sp, #12
 8002538:	bd00      	pop	{pc}
 800253a:	46c0      	nop			; (mov r8, r8)
 800253c:	0000      	movs	r0, r0
	...

08002540 <port_lock.lto_priv.200>:
  __ASM volatile ("cpsid i" : : : "memory");
 8002540:	b672      	cpsid	i
}
 8002542:	4770      	bx	lr
	...

08002550 <port_unlock.lto_priv.197>:
  __ASM volatile ("cpsie i" : : : "memory");
 8002550:	b662      	cpsie	i
}
 8002552:	4770      	bx	lr
	...

08002560 <chSysLock.lto_priv.211>:
static inline void chSysLock(void) {
 8002560:	b510      	push	{r4, lr}
  port_lock();
 8002562:	f7ff ffed 	bl	8002540 <port_lock.lto_priv.200>
  _dbg_check_lock();
 8002566:	f000 fbab 	bl	8002cc0 <_dbg_check_lock>
}
 800256a:	bd10      	pop	{r4, pc}
 800256c:	0000      	movs	r0, r0
	...

08002570 <chSysUnlock.lto_priv.208>:
static inline void chSysUnlock(void) {
 8002570:	b510      	push	{r4, lr}
  _dbg_check_unlock();
 8002572:	f000 fbbd 	bl	8002cf0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002576:	4b0a      	ldr	r3, [pc, #40]	; (80025a0 <chSysUnlock.lto_priv.208+0x30>)
 8002578:	681a      	ldr	r2, [r3, #0]
 800257a:	4b09      	ldr	r3, [pc, #36]	; (80025a0 <chSysUnlock.lto_priv.208+0x30>)
 800257c:	429a      	cmp	r2, r3
 800257e:	d00b      	beq.n	8002598 <chSysUnlock.lto_priv.208+0x28>
 8002580:	4b07      	ldr	r3, [pc, #28]	; (80025a0 <chSysUnlock.lto_priv.208+0x30>)
 8002582:	699b      	ldr	r3, [r3, #24]
 8002584:	689a      	ldr	r2, [r3, #8]
 8002586:	4b06      	ldr	r3, [pc, #24]	; (80025a0 <chSysUnlock.lto_priv.208+0x30>)
 8002588:	681b      	ldr	r3, [r3, #0]
 800258a:	689b      	ldr	r3, [r3, #8]
 800258c:	429a      	cmp	r2, r3
 800258e:	d203      	bcs.n	8002598 <chSysUnlock.lto_priv.208+0x28>
 8002590:	4b04      	ldr	r3, [pc, #16]	; (80025a4 <chSysUnlock.lto_priv.208+0x34>)
 8002592:	0018      	movs	r0, r3
 8002594:	f000 fb44 	bl	8002c20 <chSysHalt>
  port_unlock();
 8002598:	f7ff ffda 	bl	8002550 <port_unlock.lto_priv.197>
}
 800259c:	bd10      	pop	{r4, pc}
 800259e:	46c0      	nop			; (mov r8, r8)
 80025a0:	20000528 	.word	0x20000528
 80025a4:	08003c9c 	.word	0x08003c9c
	...

080025b0 <chThdGetWorkingAreaX.lto_priv.221>:
 * @param[in] tp        pointer to the thread
 * @return              The working area base pointer.
 *
 * @xclass
 */
static inline stkalign_t *chThdGetWorkingAreaX(thread_t *tp) {
 80025b0:	b082      	sub	sp, #8
 80025b2:	9001      	str	r0, [sp, #4]

  return tp->wabase;
 80025b4:	9b01      	ldr	r3, [sp, #4]
 80025b6:	69db      	ldr	r3, [r3, #28]
}
 80025b8:	0018      	movs	r0, r3
 80025ba:	b002      	add	sp, #8
 80025bc:	4770      	bx	lr
 80025be:	46c0      	nop			; (mov r8, r8)

080025c0 <chRegFirstThread>:
 *
 * @return              A reference to the most ancient thread.
 *
 * @api
 */
thread_t *chRegFirstThread(void) {
 80025c0:	b500      	push	{lr}
 80025c2:	b083      	sub	sp, #12
  thread_t *tp;

  chSysLock();
 80025c4:	f7ff ffcc 	bl	8002560 <chSysLock.lto_priv.211>
  tp = ch.rlist.newer;
 80025c8:	4b08      	ldr	r3, [pc, #32]	; (80025ec <chRegFirstThread+0x2c>)
 80025ca:	691b      	ldr	r3, [r3, #16]
 80025cc:	9301      	str	r3, [sp, #4]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 80025ce:	9b01      	ldr	r3, [sp, #4]
 80025d0:	2222      	movs	r2, #34	; 0x22
 80025d2:	5c9b      	ldrb	r3, [r3, r2]
 80025d4:	3301      	adds	r3, #1
 80025d6:	b2d9      	uxtb	r1, r3
 80025d8:	9b01      	ldr	r3, [sp, #4]
 80025da:	2222      	movs	r2, #34	; 0x22
 80025dc:	5499      	strb	r1, [r3, r2]
#endif
  chSysUnlock();
 80025de:	f7ff ffc7 	bl	8002570 <chSysUnlock.lto_priv.208>

  return tp;
 80025e2:	9b01      	ldr	r3, [sp, #4]
}
 80025e4:	0018      	movs	r0, r3
 80025e6:	b003      	add	sp, #12
 80025e8:	bd00      	pop	{pc}
 80025ea:	46c0      	nop			; (mov r8, r8)
 80025ec:	20000528 	.word	0x20000528

080025f0 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
 80025f0:	b500      	push	{lr}
 80025f2:	b085      	sub	sp, #20
 80025f4:	9001      	str	r0, [sp, #4]
  thread_t *ntp;

  chSysLock();
 80025f6:	f7ff ffb3 	bl	8002560 <chSysLock.lto_priv.211>
  ntp = tp->newer;
 80025fa:	9b01      	ldr	r3, [sp, #4]
 80025fc:	691b      	ldr	r3, [r3, #16]
 80025fe:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 8002600:	9a03      	ldr	r2, [sp, #12]
 8002602:	4b10      	ldr	r3, [pc, #64]	; (8002644 <chRegNextThread+0x54>)
 8002604:	429a      	cmp	r2, r3
 8002606:	d102      	bne.n	800260e <chRegNextThread+0x1e>
  /*lint -restore*/
    ntp = NULL;
 8002608:	2300      	movs	r3, #0
 800260a:	9303      	str	r3, [sp, #12]
 800260c:	e010      	b.n	8002630 <chRegNextThread+0x40>
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 800260e:	9b03      	ldr	r3, [sp, #12]
 8002610:	2222      	movs	r2, #34	; 0x22
 8002612:	5c9b      	ldrb	r3, [r3, r2]
 8002614:	2bff      	cmp	r3, #255	; 0xff
 8002616:	d103      	bne.n	8002620 <chRegNextThread+0x30>
 8002618:	4b0b      	ldr	r3, [pc, #44]	; (8002648 <chRegNextThread+0x58>)
 800261a:	0018      	movs	r0, r3
 800261c:	f000 fb00 	bl	8002c20 <chSysHalt>
    ntp->refs++;
 8002620:	9b03      	ldr	r3, [sp, #12]
 8002622:	2222      	movs	r2, #34	; 0x22
 8002624:	5c9b      	ldrb	r3, [r3, r2]
 8002626:	3301      	adds	r3, #1
 8002628:	b2d9      	uxtb	r1, r3
 800262a:	9b03      	ldr	r3, [sp, #12]
 800262c:	2222      	movs	r2, #34	; 0x22
 800262e:	5499      	strb	r1, [r3, r2]
  }
#endif
  chSysUnlock();
 8002630:	f7ff ff9e 	bl	8002570 <chSysUnlock.lto_priv.208>
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 8002634:	9b01      	ldr	r3, [sp, #4]
 8002636:	0018      	movs	r0, r3
 8002638:	f7ff feca 	bl	80023d0 <chThdRelease>
#endif

  return ntp;
 800263c:	9b03      	ldr	r3, [sp, #12]
}
 800263e:	0018      	movs	r0, r3
 8002640:	b005      	add	sp, #20
 8002642:	bd00      	pop	{pc}
 8002644:	20000528 	.word	0x20000528
 8002648:	08003ca8 	.word	0x08003ca8
 800264c:	00000000 	.word	0x00000000

08002650 <chRegFindThreadByWorkingArea>:
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByWorkingArea(stkalign_t *wa) {
 8002650:	b500      	push	{lr}
 8002652:	b085      	sub	sp, #20
 8002654:	9001      	str	r0, [sp, #4]
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
 8002656:	f7ff ffb3 	bl	80025c0 <chRegFirstThread>
 800265a:	0003      	movs	r3, r0
 800265c:	9303      	str	r3, [sp, #12]
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 800265e:	9b03      	ldr	r3, [sp, #12]
 8002660:	0018      	movs	r0, r3
 8002662:	f7ff ffa5 	bl	80025b0 <chThdGetWorkingAreaX.lto_priv.221>
 8002666:	0002      	movs	r2, r0
 8002668:	9b01      	ldr	r3, [sp, #4]
 800266a:	429a      	cmp	r2, r3
 800266c:	d101      	bne.n	8002672 <chRegFindThreadByWorkingArea+0x22>
      return ctp;
 800266e:	9b03      	ldr	r3, [sp, #12]
 8002670:	e009      	b.n	8002686 <chRegFindThreadByWorkingArea+0x36>
    }
    ctp = chRegNextThread(ctp);
 8002672:	9b03      	ldr	r3, [sp, #12]
 8002674:	0018      	movs	r0, r3
 8002676:	f7ff ffbb 	bl	80025f0 <chRegNextThread>
 800267a:	0003      	movs	r3, r0
 800267c:	9303      	str	r3, [sp, #12]
  } while (ctp != NULL);
 800267e:	9b03      	ldr	r3, [sp, #12]
 8002680:	2b00      	cmp	r3, #0
 8002682:	d1ec      	bne.n	800265e <chRegFindThreadByWorkingArea+0xe>

  return NULL;
 8002684:	2300      	movs	r3, #0
}
 8002686:	0018      	movs	r0, r3
 8002688:	b005      	add	sp, #20
 800268a:	bd00      	pop	{pc}
 800268c:	0000      	movs	r0, r0
	...

08002690 <port_lock.lto_priv.202>:
  __ASM volatile ("cpsid i" : : : "memory");
 8002690:	b672      	cpsid	i
}
 8002692:	4770      	bx	lr
	...

080026a0 <port_unlock.lto_priv.199>:
  __ASM volatile ("cpsie i" : : : "memory");
 80026a0:	b662      	cpsie	i
}
 80026a2:	4770      	bx	lr
	...

080026b0 <queue_init.lto_priv.158>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 80026b0:	b082      	sub	sp, #8
 80026b2:	9001      	str	r0, [sp, #4]

  tqp->next = (thread_t *)tqp;
 80026b4:	9b01      	ldr	r3, [sp, #4]
 80026b6:	9a01      	ldr	r2, [sp, #4]
 80026b8:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80026ba:	9b01      	ldr	r3, [sp, #4]
 80026bc:	9a01      	ldr	r2, [sp, #4]
 80026be:	605a      	str	r2, [r3, #4]
}
 80026c0:	b002      	add	sp, #8
 80026c2:	4770      	bx	lr
	...

080026d0 <queue_notempty.lto_priv.196>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 80026d0:	b082      	sub	sp, #8
 80026d2:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->next != (const thread_t *)tqp);
 80026d4:	9b01      	ldr	r3, [sp, #4]
 80026d6:	681a      	ldr	r2, [r3, #0]
 80026d8:	9b01      	ldr	r3, [sp, #4]
 80026da:	1ad3      	subs	r3, r2, r3
 80026dc:	1e5a      	subs	r2, r3, #1
 80026de:	4193      	sbcs	r3, r2
 80026e0:	b2db      	uxtb	r3, r3
}
 80026e2:	0018      	movs	r0, r3
 80026e4:	b002      	add	sp, #8
 80026e6:	4770      	bx	lr
	...

080026f0 <queue_prio_insert.lto_priv.189>:
  tlp->next = tp->queue.next;

  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {
 80026f0:	b084      	sub	sp, #16
 80026f2:	9001      	str	r0, [sp, #4]
 80026f4:	9100      	str	r1, [sp, #0]

  thread_t *cp = (thread_t *)tqp;
 80026f6:	9b00      	ldr	r3, [sp, #0]
 80026f8:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->queue.next;
 80026fa:	9b03      	ldr	r3, [sp, #12]
 80026fc:	681b      	ldr	r3, [r3, #0]
 80026fe:	9303      	str	r3, [sp, #12]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8002700:	9a03      	ldr	r2, [sp, #12]
 8002702:	9b00      	ldr	r3, [sp, #0]
 8002704:	429a      	cmp	r2, r3
 8002706:	d005      	beq.n	8002714 <queue_prio_insert.lto_priv.189+0x24>
 8002708:	9b03      	ldr	r3, [sp, #12]
 800270a:	689a      	ldr	r2, [r3, #8]
 800270c:	9b01      	ldr	r3, [sp, #4]
 800270e:	689b      	ldr	r3, [r3, #8]
 8002710:	429a      	cmp	r2, r3
 8002712:	d2f2      	bcs.n	80026fa <queue_prio_insert.lto_priv.189+0xa>
  tp->queue.next             = cp;
 8002714:	9b01      	ldr	r3, [sp, #4]
 8002716:	9a03      	ldr	r2, [sp, #12]
 8002718:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 800271a:	9b03      	ldr	r3, [sp, #12]
 800271c:	685a      	ldr	r2, [r3, #4]
 800271e:	9b01      	ldr	r3, [sp, #4]
 8002720:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8002722:	9b01      	ldr	r3, [sp, #4]
 8002724:	685b      	ldr	r3, [r3, #4]
 8002726:	9a01      	ldr	r2, [sp, #4]
 8002728:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 800272a:	9b03      	ldr	r3, [sp, #12]
 800272c:	9a01      	ldr	r2, [sp, #4]
 800272e:	605a      	str	r2, [r3, #4]
}
 8002730:	b004      	add	sp, #16
 8002732:	4770      	bx	lr
	...

08002740 <queue_fifo_remove.lto_priv.182>:
  tp->queue.prev             = tqp->prev;
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8002740:	b084      	sub	sp, #16
 8002742:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
 8002744:	9b01      	ldr	r3, [sp, #4]
 8002746:	681b      	ldr	r3, [r3, #0]
 8002748:	9303      	str	r3, [sp, #12]

  tqp->next             = tp->queue.next;
 800274a:	9b03      	ldr	r3, [sp, #12]
 800274c:	681a      	ldr	r2, [r3, #0]
 800274e:	9b01      	ldr	r3, [sp, #4]
 8002750:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8002752:	9b01      	ldr	r3, [sp, #4]
 8002754:	681b      	ldr	r3, [r3, #0]
 8002756:	9a01      	ldr	r2, [sp, #4]
 8002758:	605a      	str	r2, [r3, #4]

  return tp;
 800275a:	9b03      	ldr	r3, [sp, #12]
}
 800275c:	0018      	movs	r0, r3
 800275e:	b004      	add	sp, #16
 8002760:	4770      	bx	lr
 8002762:	46c0      	nop			; (mov r8, r8)
	...

08002770 <queue_dequeue.lto_priv.193>:
  tqp->prev->queue.next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
 8002770:	b082      	sub	sp, #8
 8002772:	9001      	str	r0, [sp, #4]

  tp->queue.prev->queue.next = tp->queue.next;
 8002774:	9b01      	ldr	r3, [sp, #4]
 8002776:	685b      	ldr	r3, [r3, #4]
 8002778:	9a01      	ldr	r2, [sp, #4]
 800277a:	6812      	ldr	r2, [r2, #0]
 800277c:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800277e:	9b01      	ldr	r3, [sp, #4]
 8002780:	681b      	ldr	r3, [r3, #0]
 8002782:	9a01      	ldr	r2, [sp, #4]
 8002784:	6852      	ldr	r2, [r2, #4]
 8002786:	605a      	str	r2, [r3, #4]

  return tp;
 8002788:	9b01      	ldr	r3, [sp, #4]
}
 800278a:	0018      	movs	r0, r3
 800278c:	b002      	add	sp, #8
 800278e:	4770      	bx	lr

08002790 <chSysLock.lto_priv.177>:
static inline void chSysLock(void) {
 8002790:	b510      	push	{r4, lr}
  port_lock();
 8002792:	f7ff ff7d 	bl	8002690 <port_lock.lto_priv.202>
  _dbg_check_lock();
 8002796:	f000 fa93 	bl	8002cc0 <_dbg_check_lock>
}
 800279a:	bd10      	pop	{r4, pc}
 800279c:	0000      	movs	r0, r0
	...

080027a0 <chSysUnlock.lto_priv.172>:
static inline void chSysUnlock(void) {
 80027a0:	b510      	push	{r4, lr}
  _dbg_check_unlock();
 80027a2:	f000 faa5 	bl	8002cf0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80027a6:	4b0a      	ldr	r3, [pc, #40]	; (80027d0 <chSysUnlock.lto_priv.172+0x30>)
 80027a8:	681a      	ldr	r2, [r3, #0]
 80027aa:	4b09      	ldr	r3, [pc, #36]	; (80027d0 <chSysUnlock.lto_priv.172+0x30>)
 80027ac:	429a      	cmp	r2, r3
 80027ae:	d00b      	beq.n	80027c8 <chSysUnlock.lto_priv.172+0x28>
 80027b0:	4b07      	ldr	r3, [pc, #28]	; (80027d0 <chSysUnlock.lto_priv.172+0x30>)
 80027b2:	699b      	ldr	r3, [r3, #24]
 80027b4:	689a      	ldr	r2, [r3, #8]
 80027b6:	4b06      	ldr	r3, [pc, #24]	; (80027d0 <chSysUnlock.lto_priv.172+0x30>)
 80027b8:	681b      	ldr	r3, [r3, #0]
 80027ba:	689b      	ldr	r3, [r3, #8]
 80027bc:	429a      	cmp	r2, r3
 80027be:	d203      	bcs.n	80027c8 <chSysUnlock.lto_priv.172+0x28>
 80027c0:	4b04      	ldr	r3, [pc, #16]	; (80027d4 <chSysUnlock.lto_priv.172+0x34>)
 80027c2:	0018      	movs	r0, r3
 80027c4:	f000 fa2c 	bl	8002c20 <chSysHalt>
  port_unlock();
 80027c8:	f7ff ff6a 	bl	80026a0 <port_unlock.lto_priv.199>
}
 80027cc:	bd10      	pop	{r4, pc}
 80027ce:	46c0      	nop			; (mov r8, r8)
 80027d0:	20000528 	.word	0x20000528
 80027d4:	08003cc8 	.word	0x08003cc8
	...

080027e0 <chMtxQueueNotEmptyS.lto_priv.192>:
 * @return              The mutex queue status.
 *
 * @deprecated
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {
 80027e0:	b500      	push	{lr}
 80027e2:	b083      	sub	sp, #12
 80027e4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();
 80027e6:	f000 fb23 	bl	8002e30 <chDbgCheckClassS>

  return queue_notempty(&mp->queue);
 80027ea:	9b01      	ldr	r3, [sp, #4]
 80027ec:	0018      	movs	r0, r3
 80027ee:	f7ff ff6f 	bl	80026d0 <queue_notempty.lto_priv.196>
 80027f2:	0003      	movs	r3, r0
}
 80027f4:	0018      	movs	r0, r3
 80027f6:	b003      	add	sp, #12
 80027f8:	bd00      	pop	{pc}
 80027fa:	46c0      	nop			; (mov r8, r8)
 80027fc:	0000      	movs	r0, r0
	...

08002800 <__core_init>:

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8002800:	4770      	bx	lr
 8002802:	46c0      	nop			; (mov r8, r8)
	...

08002810 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8002810:	4770      	bx	lr
 8002812:	46c0      	nop			; (mov r8, r8)
	...

08002820 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8002820:	e7fe      	b.n	8002820 <__default_exit>
 8002822:	46c0      	nop			; (mov r8, r8)
	...

08002830 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8002830:	b084      	sub	sp, #16
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8002832:	4b16      	ldr	r3, [pc, #88]	; (800288c <__init_ram_areas+0x5c>)
 8002834:	9303      	str	r3, [sp, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 8002836:	9b03      	ldr	r3, [sp, #12]
 8002838:	681b      	ldr	r3, [r3, #0]
 800283a:	9302      	str	r3, [sp, #8]
    uint32_t *p = rap->init_area;
 800283c:	9b03      	ldr	r3, [sp, #12]
 800283e:	685b      	ldr	r3, [r3, #4]
 8002840:	9301      	str	r3, [sp, #4]
 8002842:	e009      	b.n	8002858 <__init_ram_areas+0x28>

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
      *p = *tp;
 8002844:	9b02      	ldr	r3, [sp, #8]
 8002846:	681a      	ldr	r2, [r3, #0]
 8002848:	9b01      	ldr	r3, [sp, #4]
 800284a:	601a      	str	r2, [r3, #0]
      p++;
 800284c:	9b01      	ldr	r3, [sp, #4]
 800284e:	3304      	adds	r3, #4
 8002850:	9301      	str	r3, [sp, #4]
      tp++;
 8002852:	9b02      	ldr	r3, [sp, #8]
 8002854:	3304      	adds	r3, #4
 8002856:	9302      	str	r3, [sp, #8]
    while (p < rap->clear_area) {
 8002858:	9b03      	ldr	r3, [sp, #12]
 800285a:	689a      	ldr	r2, [r3, #8]
 800285c:	9b01      	ldr	r3, [sp, #4]
 800285e:	429a      	cmp	r2, r3
 8002860:	d8f0      	bhi.n	8002844 <__init_ram_areas+0x14>
 8002862:	e005      	b.n	8002870 <__init_ram_areas+0x40>
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8002864:	9b01      	ldr	r3, [sp, #4]
 8002866:	2200      	movs	r2, #0
 8002868:	601a      	str	r2, [r3, #0]
      p++;
 800286a:	9b01      	ldr	r3, [sp, #4]
 800286c:	3304      	adds	r3, #4
 800286e:	9301      	str	r3, [sp, #4]
    while (p < rap->no_init_area) {
 8002870:	9b03      	ldr	r3, [sp, #12]
 8002872:	68da      	ldr	r2, [r3, #12]
 8002874:	9b01      	ldr	r3, [sp, #4]
 8002876:	429a      	cmp	r2, r3
 8002878:	d8f4      	bhi.n	8002864 <__init_ram_areas+0x34>
    }
    rap++;
 800287a:	9b03      	ldr	r3, [sp, #12]
 800287c:	3310      	adds	r3, #16
 800287e:	9303      	str	r3, [sp, #12]
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8002880:	9a03      	ldr	r2, [sp, #12]
 8002882:	4b03      	ldr	r3, [pc, #12]	; (8002890 <__init_ram_areas+0x60>)
 8002884:	429a      	cmp	r2, r3
 8002886:	d3d6      	bcc.n	8002836 <__init_ram_areas+0x6>
#endif
}
 8002888:	b004      	add	sp, #16
 800288a:	4770      	bx	lr
 800288c:	08003b3c 	.word	0x08003b3c
 8002890:	08003bbc 	.word	0x08003bbc
	...

080028a0 <BusFault_Handler>:
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
__attribute__((weak))
void _unhandled_exception(void) {
 80028a0:	e7fe      	b.n	80028a0 <BusFault_Handler>
 80028a2:	46c0      	nop			; (mov r8, r8)
	...

080028b0 <NVIC_SetPriority>:
  \note    The priority cannot be set for every core interrupt.
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 80028b0:	b530      	push	{r4, r5, lr}
 80028b2:	b083      	sub	sp, #12
 80028b4:	0002      	movs	r2, r0
 80028b6:	9100      	str	r1, [sp, #0]
 80028b8:	466b      	mov	r3, sp
 80028ba:	3307      	adds	r3, #7
 80028bc:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) < 0)
 80028be:	466b      	mov	r3, sp
 80028c0:	3307      	adds	r3, #7
 80028c2:	781b      	ldrb	r3, [r3, #0]
 80028c4:	2b7f      	cmp	r3, #127	; 0x7f
 80028c6:	d936      	bls.n	8002936 <NVIC_SetPriority+0x86>
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80028c8:	4c32      	ldr	r4, [pc, #200]	; (8002994 <NVIC_SetPriority+0xe4>)
 80028ca:	466b      	mov	r3, sp
 80028cc:	3307      	adds	r3, #7
 80028ce:	781b      	ldrb	r3, [r3, #0]
 80028d0:	001a      	movs	r2, r3
 80028d2:	230f      	movs	r3, #15
 80028d4:	4013      	ands	r3, r2
 80028d6:	3b08      	subs	r3, #8
 80028d8:	0899      	lsrs	r1, r3, #2
 80028da:	4a2e      	ldr	r2, [pc, #184]	; (8002994 <NVIC_SetPriority+0xe4>)
 80028dc:	466b      	mov	r3, sp
 80028de:	3307      	adds	r3, #7
 80028e0:	781b      	ldrb	r3, [r3, #0]
 80028e2:	0018      	movs	r0, r3
 80028e4:	230f      	movs	r3, #15
 80028e6:	4003      	ands	r3, r0
 80028e8:	3b08      	subs	r3, #8
 80028ea:	089b      	lsrs	r3, r3, #2
 80028ec:	3306      	adds	r3, #6
 80028ee:	009b      	lsls	r3, r3, #2
 80028f0:	18d3      	adds	r3, r2, r3
 80028f2:	3304      	adds	r3, #4
 80028f4:	681b      	ldr	r3, [r3, #0]
 80028f6:	466a      	mov	r2, sp
 80028f8:	3207      	adds	r2, #7
 80028fa:	7812      	ldrb	r2, [r2, #0]
 80028fc:	0010      	movs	r0, r2
 80028fe:	2203      	movs	r2, #3
 8002900:	4002      	ands	r2, r0
 8002902:	00d2      	lsls	r2, r2, #3
 8002904:	20ff      	movs	r0, #255	; 0xff
 8002906:	4090      	lsls	r0, r2
 8002908:	0002      	movs	r2, r0
 800290a:	43d2      	mvns	r2, r2
 800290c:	401a      	ands	r2, r3
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 800290e:	9b00      	ldr	r3, [sp, #0]
 8002910:	019b      	lsls	r3, r3, #6
 8002912:	20ff      	movs	r0, #255	; 0xff
 8002914:	4018      	ands	r0, r3
 8002916:	466b      	mov	r3, sp
 8002918:	3307      	adds	r3, #7
 800291a:	781b      	ldrb	r3, [r3, #0]
 800291c:	001d      	movs	r5, r3
 800291e:	2303      	movs	r3, #3
 8002920:	402b      	ands	r3, r5
 8002922:	00db      	lsls	r3, r3, #3
 8002924:	4098      	lsls	r0, r3
 8002926:	0003      	movs	r3, r0
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8002928:	431a      	orrs	r2, r3
 800292a:	1d8b      	adds	r3, r1, #6
 800292c:	009b      	lsls	r3, r3, #2
 800292e:	18e3      	adds	r3, r4, r3
 8002930:	3304      	adds	r3, #4
 8002932:	601a      	str	r2, [r3, #0]
 8002934:	e02b      	b.n	800298e <NVIC_SetPriority+0xde>
  }
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8002936:	4c18      	ldr	r4, [pc, #96]	; (8002998 <NVIC_SetPriority+0xe8>)
 8002938:	466b      	mov	r3, sp
 800293a:	3307      	adds	r3, #7
 800293c:	781b      	ldrb	r3, [r3, #0]
 800293e:	b25b      	sxtb	r3, r3
 8002940:	089b      	lsrs	r3, r3, #2
 8002942:	4915      	ldr	r1, [pc, #84]	; (8002998 <NVIC_SetPriority+0xe8>)
 8002944:	466a      	mov	r2, sp
 8002946:	3207      	adds	r2, #7
 8002948:	7812      	ldrb	r2, [r2, #0]
 800294a:	b252      	sxtb	r2, r2
 800294c:	0892      	lsrs	r2, r2, #2
 800294e:	32c0      	adds	r2, #192	; 0xc0
 8002950:	0092      	lsls	r2, r2, #2
 8002952:	5852      	ldr	r2, [r2, r1]
 8002954:	4669      	mov	r1, sp
 8002956:	3107      	adds	r1, #7
 8002958:	7809      	ldrb	r1, [r1, #0]
 800295a:	0008      	movs	r0, r1
 800295c:	2103      	movs	r1, #3
 800295e:	4001      	ands	r1, r0
 8002960:	00c9      	lsls	r1, r1, #3
 8002962:	20ff      	movs	r0, #255	; 0xff
 8002964:	4088      	lsls	r0, r1
 8002966:	0001      	movs	r1, r0
 8002968:	43c9      	mvns	r1, r1
 800296a:	4011      	ands	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 800296c:	9a00      	ldr	r2, [sp, #0]
 800296e:	0192      	lsls	r2, r2, #6
 8002970:	20ff      	movs	r0, #255	; 0xff
 8002972:	4010      	ands	r0, r2
 8002974:	466a      	mov	r2, sp
 8002976:	3207      	adds	r2, #7
 8002978:	7812      	ldrb	r2, [r2, #0]
 800297a:	0015      	movs	r5, r2
 800297c:	2203      	movs	r2, #3
 800297e:	402a      	ands	r2, r5
 8002980:	00d2      	lsls	r2, r2, #3
 8002982:	4090      	lsls	r0, r2
 8002984:	0002      	movs	r2, r0
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8002986:	430a      	orrs	r2, r1
 8002988:	33c0      	adds	r3, #192	; 0xc0
 800298a:	009b      	lsls	r3, r3, #2
 800298c:	511a      	str	r2, [r3, r4]
  }
}
 800298e:	b003      	add	sp, #12
 8002990:	bd30      	pop	{r4, r5, pc}
 8002992:	46c0      	nop			; (mov r8, r8)
 8002994:	e000ed00 	.word	0xe000ed00
 8002998:	e000e100 	.word	0xe000e100
 800299c:	00000000 	.word	0x00000000

080029a0 <port_init>:
static inline void port_init(void) {
 80029a0:	b510      	push	{r4, lr}
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 80029a2:	2302      	movs	r3, #2
 80029a4:	425b      	negs	r3, r3
 80029a6:	2100      	movs	r1, #0
 80029a8:	0018      	movs	r0, r3
 80029aa:	f7ff ff81 	bl	80028b0 <NVIC_SetPriority>
}
 80029ae:	bd10      	pop	{r4, pc}

080029b0 <port_lock.lto_priv.258>:
  __ASM volatile ("cpsid i" : : : "memory");
 80029b0:	b672      	cpsid	i
}
 80029b2:	4770      	bx	lr
	...

080029c0 <port_unlock.lto_priv.253>:
  __ASM volatile ("cpsie i" : : : "memory");
 80029c0:	b662      	cpsie	i
}
 80029c2:	4770      	bx	lr
	...

080029d0 <port_lock_from_isr.lto_priv.274>:
static inline void port_lock_from_isr(void) {
 80029d0:	b510      	push	{r4, lr}
  port_lock();
 80029d2:	f7ff ffed 	bl	80029b0 <port_lock.lto_priv.258>
}
 80029d6:	bd10      	pop	{r4, pc}
	...

080029e0 <port_unlock_from_isr.lto_priv.270>:
static inline void port_unlock_from_isr(void) {
 80029e0:	b510      	push	{r4, lr}
  port_unlock();
 80029e2:	f7ff ffed 	bl	80029c0 <port_unlock.lto_priv.253>
}
 80029e6:	bd10      	pop	{r4, pc}
	...

080029f0 <port_disable>:
  __ASM volatile ("cpsid i" : : : "memory");
 80029f0:	b672      	cpsid	i
 * @brief   Disables all the interrupt sources.
 */
static inline void port_disable(void) {

  __disable_irq();
}
 80029f2:	4770      	bx	lr
	...

08002a00 <port_enable>:
  __ASM volatile ("cpsie i" : : : "memory");
 8002a00:	b662      	cpsie	i
 * @brief   Enables all the interrupt sources.
 */
static inline void port_enable(void) {

  __enable_irq();
}
 8002a02:	4770      	bx	lr
	...

08002a10 <port_wait_for_interrupt>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 8002a10:	4770      	bx	lr
 8002a12:	46c0      	nop			; (mov r8, r8)
	...

08002a20 <st_lld_get_counter.lto_priv.249>:
  return (systime_t)STM32_ST_TIM->CNT;
 8002a20:	2380      	movs	r3, #128	; 0x80
 8002a22:	05db      	lsls	r3, r3, #23
 8002a24:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8002a26:	0018      	movs	r0, r3
 8002a28:	4770      	bx	lr
 8002a2a:	46c0      	nop			; (mov r8, r8)
 8002a2c:	0000      	movs	r0, r0
	...

08002a30 <port_timer_stop_alarm.lto_priv.283>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 8002a30:	b510      	push	{r4, lr}

  stStopAlarm();
 8002a32:	f7fe f96d 	bl	8000d10 <stStopAlarm>
}
 8002a36:	bd10      	pop	{r4, pc}
	...

08002a40 <port_timer_set_alarm.lto_priv.281>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 8002a40:	b500      	push	{lr}
 8002a42:	b083      	sub	sp, #12
 8002a44:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
 8002a46:	9b01      	ldr	r3, [sp, #4]
 8002a48:	0018      	movs	r0, r3
 8002a4a:	f7fe f969 	bl	8000d20 <stSetAlarm>
}
 8002a4e:	b003      	add	sp, #12
 8002a50:	bd00      	pop	{pc}
 8002a52:	46c0      	nop			; (mov r8, r8)
	...

08002a60 <port_timer_get_time.lto_priv.245>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8002a60:	b510      	push	{r4, lr}

  return stGetCounter();
 8002a62:	f7ff ffdd 	bl	8002a20 <st_lld_get_counter.lto_priv.249>
 8002a66:	0003      	movs	r3, r0
}
 8002a68:	0018      	movs	r0, r3
 8002a6a:	bd10      	pop	{r4, pc}
 8002a6c:	0000      	movs	r0, r0
	...

08002a70 <chSysEnable>:
static inline void chSysEnable(void) {
 8002a70:	b510      	push	{r4, lr}
  _dbg_check_enable();
 8002a72:	f000 f90d 	bl	8002c90 <_dbg_check_enable>
  port_enable();
 8002a76:	f7ff ffc3 	bl	8002a00 <port_enable>
}
 8002a7a:	bd10      	pop	{r4, pc}
 8002a7c:	0000      	movs	r0, r0
	...

08002a80 <chSysLockFromISR.lto_priv.268>:
static inline void chSysLockFromISR(void) {
 8002a80:	b510      	push	{r4, lr}
  port_lock_from_isr();
 8002a82:	f7ff ffa5 	bl	80029d0 <port_lock_from_isr.lto_priv.274>
  _dbg_check_lock_from_isr();
 8002a86:	f000 f94b 	bl	8002d20 <_dbg_check_lock_from_isr>
}
 8002a8a:	bd10      	pop	{r4, pc}
 8002a8c:	0000      	movs	r0, r0
	...

08002a90 <chSysUnlockFromISR.lto_priv.266>:
static inline void chSysUnlockFromISR(void) {
 8002a90:	b510      	push	{r4, lr}
  _dbg_check_unlock_from_isr();
 8002a92:	f000 f95d 	bl	8002d50 <_dbg_check_unlock_from_isr>
  port_unlock_from_isr();
 8002a96:	f7ff ffa3 	bl	80029e0 <port_unlock_from_isr.lto_priv.270>
}
 8002a9a:	bd10      	pop	{r4, pc}
 8002a9c:	0000      	movs	r0, r0
	...

08002aa0 <chVTGetSystemTimeX.lto_priv.278>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8002aa0:	b510      	push	{r4, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8002aa2:	f7ff ffdd 	bl	8002a60 <port_timer_get_time.lto_priv.245>
 8002aa6:	0003      	movs	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8002aa8:	0018      	movs	r0, r3
 8002aaa:	bd10      	pop	{r4, pc}
 8002aac:	0000      	movs	r0, r0
	...

08002ab0 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
 8002ab0:	b500      	push	{lr}
 8002ab2:	b085      	sub	sp, #20

  chDbgCheckClassI();
 8002ab4:	f000 f9a4 	bl	8002e00 <chDbgCheckClassI>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.next;
 8002ab8:	4b33      	ldr	r3, [pc, #204]	; (8002b88 <chVTDoTickI+0xd8>)
 8002aba:	69db      	ldr	r3, [r3, #28]
 8002abc:	9303      	str	r3, [sp, #12]
  now = chVTGetSystemTimeX();
 8002abe:	f7ff ffef 	bl	8002aa0 <chVTGetSystemTimeX.lto_priv.278>
 8002ac2:	0003      	movs	r3, r0
 8002ac4:	9302      	str	r3, [sp, #8]
 8002ac6:	e02b      	b.n	8002b20 <chVTDoTickI+0x70>
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;
 8002ac8:	4b2f      	ldr	r3, [pc, #188]	; (8002b88 <chVTDoTickI+0xd8>)
 8002aca:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8002acc:	9b03      	ldr	r3, [sp, #12]
 8002ace:	689b      	ldr	r3, [r3, #8]
 8002ad0:	18d2      	adds	r2, r2, r3
 8002ad2:	4b2d      	ldr	r3, [pc, #180]	; (8002b88 <chVTDoTickI+0xd8>)
 8002ad4:	629a      	str	r2, [r3, #40]	; 0x28

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8002ad6:	9b03      	ldr	r3, [sp, #12]
 8002ad8:	681b      	ldr	r3, [r3, #0]
 8002ada:	4a2c      	ldr	r2, [pc, #176]	; (8002b8c <chVTDoTickI+0xdc>)
 8002adc:	605a      	str	r2, [r3, #4]
    ch.vtlist.next = vtp->next;
 8002ade:	9b03      	ldr	r3, [sp, #12]
 8002ae0:	681a      	ldr	r2, [r3, #0]
 8002ae2:	4b29      	ldr	r3, [pc, #164]	; (8002b88 <chVTDoTickI+0xd8>)
 8002ae4:	61da      	str	r2, [r3, #28]
    fn = vtp->func;
 8002ae6:	9b03      	ldr	r3, [sp, #12]
 8002ae8:	68db      	ldr	r3, [r3, #12]
 8002aea:	9300      	str	r3, [sp, #0]
    vtp->func = NULL;
 8002aec:	9b03      	ldr	r3, [sp, #12]
 8002aee:	2200      	movs	r2, #0
 8002af0:	60da      	str	r2, [r3, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8002af2:	4b25      	ldr	r3, [pc, #148]	; (8002b88 <chVTDoTickI+0xd8>)
 8002af4:	69da      	ldr	r2, [r3, #28]
 8002af6:	4b25      	ldr	r3, [pc, #148]	; (8002b8c <chVTDoTickI+0xdc>)
 8002af8:	429a      	cmp	r2, r3
 8002afa:	d101      	bne.n	8002b00 <chVTDoTickI+0x50>
      port_timer_stop_alarm();
 8002afc:	f7ff ff98 	bl	8002a30 <port_timer_stop_alarm.lto_priv.283>
    }

    /* Leaving the system critical zone in order to execute the callback
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();
 8002b00:	f7ff ffc6 	bl	8002a90 <chSysUnlockFromISR.lto_priv.266>

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->par);
 8002b04:	9b03      	ldr	r3, [sp, #12]
 8002b06:	691a      	ldr	r2, [r3, #16]
 8002b08:	9b00      	ldr	r3, [sp, #0]
 8002b0a:	0010      	movs	r0, r2
 8002b0c:	4798      	blx	r3

    /* Re-entering the critical zone in order to continue the exploration
       of the list.*/
    chSysLockFromISR();
 8002b0e:	f7ff ffb7 	bl	8002a80 <chSysLockFromISR.lto_priv.268>

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.next;
 8002b12:	4b1d      	ldr	r3, [pc, #116]	; (8002b88 <chVTDoTickI+0xd8>)
 8002b14:	69db      	ldr	r3, [r3, #28]
 8002b16:	9303      	str	r3, [sp, #12]
    now = chVTGetSystemTimeX();
 8002b18:	f7ff ffc2 	bl	8002aa0 <chVTGetSystemTimeX.lto_priv.278>
 8002b1c:	0003      	movs	r3, r0
 8002b1e:	9302      	str	r3, [sp, #8]
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8002b20:	9b03      	ldr	r3, [sp, #12]
 8002b22:	689a      	ldr	r2, [r3, #8]
 8002b24:	4b18      	ldr	r3, [pc, #96]	; (8002b88 <chVTDoTickI+0xd8>)
 8002b26:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002b28:	9902      	ldr	r1, [sp, #8]
 8002b2a:	1acb      	subs	r3, r1, r3
 8002b2c:	429a      	cmp	r2, r3
 8002b2e:	d9cb      	bls.n	8002ac8 <chVTDoTickI+0x18>
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8002b30:	4b15      	ldr	r3, [pc, #84]	; (8002b88 <chVTDoTickI+0xd8>)
 8002b32:	69da      	ldr	r2, [r3, #28]
 8002b34:	4b15      	ldr	r3, [pc, #84]	; (8002b8c <chVTDoTickI+0xdc>)
 8002b36:	429a      	cmp	r2, r3
 8002b38:	d024      	beq.n	8002b84 <chVTDoTickI+0xd4>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.lasttime + vtp->delta - now;
 8002b3a:	4b13      	ldr	r3, [pc, #76]	; (8002b88 <chVTDoTickI+0xd8>)
 8002b3c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8002b3e:	9b03      	ldr	r3, [sp, #12]
 8002b40:	689b      	ldr	r3, [r3, #8]
 8002b42:	18d2      	adds	r2, r2, r3
 8002b44:	9b02      	ldr	r3, [sp, #8]
 8002b46:	1ad3      	subs	r3, r2, r3
 8002b48:	9301      	str	r3, [sp, #4]
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8002b4a:	9b01      	ldr	r3, [sp, #4]
 8002b4c:	2b01      	cmp	r3, #1
 8002b4e:	d801      	bhi.n	8002b54 <chVTDoTickI+0xa4>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8002b50:	2302      	movs	r3, #2
 8002b52:	9301      	str	r3, [sp, #4]
  }
  port_timer_set_alarm(now + delta);
 8002b54:	9a02      	ldr	r2, [sp, #8]
 8002b56:	9b01      	ldr	r3, [sp, #4]
 8002b58:	18d3      	adds	r3, r2, r3
 8002b5a:	0018      	movs	r0, r3
 8002b5c:	f7ff ff70 	bl	8002a40 <port_timer_set_alarm.lto_priv.281>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.lasttime) <=
 8002b60:	f7ff ff9e 	bl	8002aa0 <chVTGetSystemTimeX.lto_priv.278>
 8002b64:	0002      	movs	r2, r0
 8002b66:	4b08      	ldr	r3, [pc, #32]	; (8002b88 <chVTDoTickI+0xd8>)
 8002b68:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002b6a:	1ad2      	subs	r2, r2, r3
 8002b6c:	9902      	ldr	r1, [sp, #8]
 8002b6e:	9b01      	ldr	r3, [sp, #4]
 8002b70:	18c9      	adds	r1, r1, r3
 8002b72:	4b05      	ldr	r3, [pc, #20]	; (8002b88 <chVTDoTickI+0xd8>)
 8002b74:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002b76:	1acb      	subs	r3, r1, r3
 8002b78:	429a      	cmp	r2, r3
 8002b7a:	d903      	bls.n	8002b84 <chVTDoTickI+0xd4>
 8002b7c:	4b04      	ldr	r3, [pc, #16]	; (8002b90 <chVTDoTickI+0xe0>)
 8002b7e:	0018      	movs	r0, r3
 8002b80:	f000 f84e 	bl	8002c20 <chSysHalt>
              (now + delta - ch.vtlist.lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8002b84:	b005      	add	sp, #20
 8002b86:	bd00      	pop	{pc}
 8002b88:	20000528 	.word	0x20000528
 8002b8c:	20000544 	.word	0x20000544
 8002b90:	08003bd4 	.word	0x08003bd4
	...

08002ba0 <_idle_thread.lto_priv.60>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8002ba0:	b500      	push	{lr}
 8002ba2:	b083      	sub	sp, #12
 8002ba4:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 8002ba6:	f7ff ff33 	bl	8002a10 <port_wait_for_interrupt>
 8002baa:	e7fc      	b.n	8002ba6 <_idle_thread.lto_priv.60+0x6>
 8002bac:	0000      	movs	r0, r0
	...

08002bb0 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 8002bb0:	b510      	push	{r4, lr}

  _scheduler_init();
 8002bb2:	f000 fca5 	bl	8003500 <_scheduler_init>
  _vt_init();
 8002bb6:	f000 facb 	bl	8003150 <_vt_init>
  _trace_init();
 8002bba:	f000 f9b1 	bl	8002f20 <_trace_init>

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  ch.dbg.isr_cnt  = (cnt_t)0;
 8002bbe:	4b12      	ldr	r3, [pc, #72]	; (8002c08 <chSysInit+0x58>)
 8002bc0:	2200      	movs	r2, #0
 8002bc2:	631a      	str	r2, [r3, #48]	; 0x30
  ch.dbg.lock_cnt = (cnt_t)0;
 8002bc4:	4b10      	ldr	r3, [pc, #64]	; (8002c08 <chSysInit+0x58>)
 8002bc6:	2200      	movs	r2, #0
 8002bc8:	635a      	str	r2, [r3, #52]	; 0x34
#endif
#if CH_CFG_USE_TM == TRUE
  _tm_init();
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 8002bca:	f7fe ffe9 	bl	8001ba0 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 8002bce:	f7ff f84f 	bl	8001c70 <_heap_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 8002bd2:	490e      	ldr	r1, [pc, #56]	; (8002c0c <chSysInit+0x5c>)
 8002bd4:	4b0e      	ldr	r3, [pc, #56]	; (8002c10 <chSysInit+0x60>)
 8002bd6:	2280      	movs	r2, #128	; 0x80
 8002bd8:	0018      	movs	r0, r3
 8002bda:	f7ff fb09 	bl	80021f0 <_thread_init>
 8002bde:	0002      	movs	r2, r0
 8002be0:	4b09      	ldr	r3, [pc, #36]	; (8002c08 <chSysInit+0x58>)
 8002be2:	619a      	str	r2, [r3, #24]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  {
    /* Setting up the base address of the static main thread stack, the
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
 8002be4:	4b08      	ldr	r3, [pc, #32]	; (8002c08 <chSysInit+0x58>)
 8002be6:	699b      	ldr	r3, [r3, #24]
 8002be8:	4a0a      	ldr	r2, [pc, #40]	; (8002c14 <chSysInit+0x64>)
 8002bea:	61da      	str	r2, [r3, #28]
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 8002bec:	4b06      	ldr	r3, [pc, #24]	; (8002c08 <chSysInit+0x58>)
 8002bee:	699b      	ldr	r3, [r3, #24]
 8002bf0:	2220      	movs	r2, #32
 8002bf2:	2101      	movs	r1, #1
 8002bf4:	5499      	strb	r1, [r3, r2]

  /* Port layer initialization last because it depend on some of the
     initializations performed before.*/
  port_init();
 8002bf6:	f7ff fed3 	bl	80029a0 <port_init>
  /* Starting measurement for this thread.*/
  chTMStartMeasurementX(&currp->stats);
#endif

  /* It is alive now.*/
  chSysEnable();
 8002bfa:	f7ff ff39 	bl	8002a70 <chSysEnable>
    };

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreate(&idle_descriptor);
 8002bfe:	4b06      	ldr	r3, [pc, #24]	; (8002c18 <chSysInit+0x68>)
 8002c00:	0018      	movs	r0, r3
 8002c02:	f7ff fbb5 	bl	8002370 <chThdCreate>
  }
#endif
}
 8002c06:	bd10      	pop	{r4, pc}
 8002c08:	20000528 	.word	0x20000528
 8002c0c:	08003c84 	.word	0x08003c84
 8002c10:	20000d68 	.word	0x20000d68
 8002c14:	20000200 	.word	0x20000200
 8002c18:	08003bbc 	.word	0x08003bbc
 8002c1c:	00000000 	.word	0x00000000

08002c20 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 8002c20:	b500      	push	{lr}
 8002c22:	b083      	sub	sp, #12
 8002c24:	9001      	str	r0, [sp, #4]

  port_disable();
 8002c26:	f7ff fee3 	bl	80029f0 <port_disable>

  /* Logging the event.*/
  _trace_halt(reason);
 8002c2a:	9b01      	ldr	r3, [sp, #4]
 8002c2c:	0018      	movs	r0, r3
 8002c2e:	f000 fa27 	bl	8003080 <_trace_halt>

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8002c32:	4b02      	ldr	r3, [pc, #8]	; (8002c3c <chSysHalt+0x1c>)
 8002c34:	9a01      	ldr	r2, [sp, #4]
 8002c36:	62da      	str	r2, [r3, #44]	; 0x2c
 8002c38:	e7fe      	b.n	8002c38 <chSysHalt+0x18>
 8002c3a:	46c0      	nop			; (mov r8, r8)
 8002c3c:	20000528 	.word	0x20000528

08002c40 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8002c40:	b510      	push	{r4, lr}

  chDbgCheckClassI();
 8002c42:	f000 f8dd 	bl	8002e00 <chDbgCheckClassI>
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->time++;
#endif
  chVTDoTickI();
 8002c46:	f7ff ff33 	bl	8002ab0 <chVTDoTickI>
  CH_CFG_SYSTEM_TICK_HOOK();
}
 8002c4a:	bd10      	pop	{r4, pc}
 8002c4c:	0000      	movs	r0, r0
	...

08002c50 <port_lock.lto_priv.259>:
  __ASM volatile ("cpsid i" : : : "memory");
 8002c50:	b672      	cpsid	i
}
 8002c52:	4770      	bx	lr
	...

08002c60 <port_unlock.lto_priv.254>:
  __ASM volatile ("cpsie i" : : : "memory");
 8002c60:	b662      	cpsie	i
}
 8002c62:	4770      	bx	lr
	...

08002c70 <port_lock_from_isr.lto_priv.275>:
static inline void port_lock_from_isr(void) {
 8002c70:	b510      	push	{r4, lr}
  port_lock();
 8002c72:	f7ff ffed 	bl	8002c50 <port_lock.lto_priv.259>
}
 8002c76:	bd10      	pop	{r4, pc}
	...

08002c80 <port_unlock_from_isr.lto_priv.271>:
static inline void port_unlock_from_isr(void) {
 8002c80:	b510      	push	{r4, lr}
  port_unlock();
 8002c82:	f7ff ffed 	bl	8002c60 <port_unlock.lto_priv.254>
}
 8002c86:	bd10      	pop	{r4, pc}
	...

08002c90 <_dbg_check_enable>:
/**
 * @brief   Guard code for @p chSysEnable().
 *
 * @notapi
 */
void _dbg_check_enable(void) {
 8002c90:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002c92:	4b06      	ldr	r3, [pc, #24]	; (8002cac <_dbg_check_enable+0x1c>)
 8002c94:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002c96:	2b00      	cmp	r3, #0
 8002c98:	d103      	bne.n	8002ca2 <_dbg_check_enable+0x12>
 8002c9a:	4b04      	ldr	r3, [pc, #16]	; (8002cac <_dbg_check_enable+0x1c>)
 8002c9c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002c9e:	2b00      	cmp	r3, #0
 8002ca0:	d003      	beq.n	8002caa <_dbg_check_enable+0x1a>
    chSysHalt("SV#3");
 8002ca2:	4b03      	ldr	r3, [pc, #12]	; (8002cb0 <_dbg_check_enable+0x20>)
 8002ca4:	0018      	movs	r0, r3
 8002ca6:	f7ff ffbb 	bl	8002c20 <chSysHalt>
  }
}
 8002caa:	bd10      	pop	{r4, pc}
 8002cac:	20000528 	.word	0x20000528
 8002cb0:	08003ae4 	.word	0x08003ae4
	...

08002cc0 <_dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void _dbg_check_lock(void) {
 8002cc0:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002cc2:	4b08      	ldr	r3, [pc, #32]	; (8002ce4 <_dbg_check_lock+0x24>)
 8002cc4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002cc6:	2b00      	cmp	r3, #0
 8002cc8:	d103      	bne.n	8002cd2 <_dbg_check_lock+0x12>
 8002cca:	4b06      	ldr	r3, [pc, #24]	; (8002ce4 <_dbg_check_lock+0x24>)
 8002ccc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002cce:	2b00      	cmp	r3, #0
 8002cd0:	d003      	beq.n	8002cda <_dbg_check_lock+0x1a>
    chSysHalt("SV#4");
 8002cd2:	4b05      	ldr	r3, [pc, #20]	; (8002ce8 <_dbg_check_lock+0x28>)
 8002cd4:	0018      	movs	r0, r3
 8002cd6:	f7ff ffa3 	bl	8002c20 <chSysHalt>
  }
  _dbg_enter_lock();
 8002cda:	4b02      	ldr	r3, [pc, #8]	; (8002ce4 <_dbg_check_lock+0x24>)
 8002cdc:	2201      	movs	r2, #1
 8002cde:	635a      	str	r2, [r3, #52]	; 0x34
}
 8002ce0:	bd10      	pop	{r4, pc}
 8002ce2:	46c0      	nop			; (mov r8, r8)
 8002ce4:	20000528 	.word	0x20000528
 8002ce8:	08003aec 	.word	0x08003aec
 8002cec:	00000000 	.word	0x00000000

08002cf0 <_dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void _dbg_check_unlock(void) {
 8002cf0:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002cf2:	4b08      	ldr	r3, [pc, #32]	; (8002d14 <_dbg_check_unlock+0x24>)
 8002cf4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002cf6:	2b00      	cmp	r3, #0
 8002cf8:	d103      	bne.n	8002d02 <_dbg_check_unlock+0x12>
 8002cfa:	4b06      	ldr	r3, [pc, #24]	; (8002d14 <_dbg_check_unlock+0x24>)
 8002cfc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002cfe:	2b00      	cmp	r3, #0
 8002d00:	dc03      	bgt.n	8002d0a <_dbg_check_unlock+0x1a>
    chSysHalt("SV#5");
 8002d02:	4b05      	ldr	r3, [pc, #20]	; (8002d18 <_dbg_check_unlock+0x28>)
 8002d04:	0018      	movs	r0, r3
 8002d06:	f7ff ff8b 	bl	8002c20 <chSysHalt>
  }
  _dbg_leave_lock();
 8002d0a:	4b02      	ldr	r3, [pc, #8]	; (8002d14 <_dbg_check_unlock+0x24>)
 8002d0c:	2200      	movs	r2, #0
 8002d0e:	635a      	str	r2, [r3, #52]	; 0x34
}
 8002d10:	bd10      	pop	{r4, pc}
 8002d12:	46c0      	nop			; (mov r8, r8)
 8002d14:	20000528 	.word	0x20000528
 8002d18:	08003af4 	.word	0x08003af4
 8002d1c:	00000000 	.word	0x00000000

08002d20 <_dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {
 8002d20:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002d22:	4b08      	ldr	r3, [pc, #32]	; (8002d44 <_dbg_check_lock_from_isr+0x24>)
 8002d24:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002d26:	2b00      	cmp	r3, #0
 8002d28:	dd03      	ble.n	8002d32 <_dbg_check_lock_from_isr+0x12>
 8002d2a:	4b06      	ldr	r3, [pc, #24]	; (8002d44 <_dbg_check_lock_from_isr+0x24>)
 8002d2c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002d2e:	2b00      	cmp	r3, #0
 8002d30:	d003      	beq.n	8002d3a <_dbg_check_lock_from_isr+0x1a>
    chSysHalt("SV#6");
 8002d32:	4b05      	ldr	r3, [pc, #20]	; (8002d48 <_dbg_check_lock_from_isr+0x28>)
 8002d34:	0018      	movs	r0, r3
 8002d36:	f7ff ff73 	bl	8002c20 <chSysHalt>
  }
  _dbg_enter_lock();
 8002d3a:	4b02      	ldr	r3, [pc, #8]	; (8002d44 <_dbg_check_lock_from_isr+0x24>)
 8002d3c:	2201      	movs	r2, #1
 8002d3e:	635a      	str	r2, [r3, #52]	; 0x34
}
 8002d40:	bd10      	pop	{r4, pc}
 8002d42:	46c0      	nop			; (mov r8, r8)
 8002d44:	20000528 	.word	0x20000528
 8002d48:	08003afc 	.word	0x08003afc
 8002d4c:	00000000 	.word	0x00000000

08002d50 <_dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {
 8002d50:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002d52:	4b08      	ldr	r3, [pc, #32]	; (8002d74 <_dbg_check_unlock_from_isr+0x24>)
 8002d54:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002d56:	2b00      	cmp	r3, #0
 8002d58:	dd03      	ble.n	8002d62 <_dbg_check_unlock_from_isr+0x12>
 8002d5a:	4b06      	ldr	r3, [pc, #24]	; (8002d74 <_dbg_check_unlock_from_isr+0x24>)
 8002d5c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002d5e:	2b00      	cmp	r3, #0
 8002d60:	dc03      	bgt.n	8002d6a <_dbg_check_unlock_from_isr+0x1a>
    chSysHalt("SV#7");
 8002d62:	4b05      	ldr	r3, [pc, #20]	; (8002d78 <_dbg_check_unlock_from_isr+0x28>)
 8002d64:	0018      	movs	r0, r3
 8002d66:	f7ff ff5b 	bl	8002c20 <chSysHalt>
  }
  _dbg_leave_lock();
 8002d6a:	4b02      	ldr	r3, [pc, #8]	; (8002d74 <_dbg_check_unlock_from_isr+0x24>)
 8002d6c:	2200      	movs	r2, #0
 8002d6e:	635a      	str	r2, [r3, #52]	; 0x34
}
 8002d70:	bd10      	pop	{r4, pc}
 8002d72:	46c0      	nop			; (mov r8, r8)
 8002d74:	20000528 	.word	0x20000528
 8002d78:	08003b04 	.word	0x08003b04
 8002d7c:	00000000 	.word	0x00000000

08002d80 <_dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {
 8002d80:	b510      	push	{r4, lr}

  port_lock_from_isr();
 8002d82:	f7ff ff75 	bl	8002c70 <port_lock_from_isr.lto_priv.275>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002d86:	4b0a      	ldr	r3, [pc, #40]	; (8002db0 <_dbg_check_enter_isr+0x30>)
 8002d88:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002d8a:	2b00      	cmp	r3, #0
 8002d8c:	db03      	blt.n	8002d96 <_dbg_check_enter_isr+0x16>
 8002d8e:	4b08      	ldr	r3, [pc, #32]	; (8002db0 <_dbg_check_enter_isr+0x30>)
 8002d90:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002d92:	2b00      	cmp	r3, #0
 8002d94:	d003      	beq.n	8002d9e <_dbg_check_enter_isr+0x1e>
    chSysHalt("SV#8");
 8002d96:	4b07      	ldr	r3, [pc, #28]	; (8002db4 <_dbg_check_enter_isr+0x34>)
 8002d98:	0018      	movs	r0, r3
 8002d9a:	f7ff ff41 	bl	8002c20 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
 8002d9e:	4b04      	ldr	r3, [pc, #16]	; (8002db0 <_dbg_check_enter_isr+0x30>)
 8002da0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002da2:	1c5a      	adds	r2, r3, #1
 8002da4:	4b02      	ldr	r3, [pc, #8]	; (8002db0 <_dbg_check_enter_isr+0x30>)
 8002da6:	631a      	str	r2, [r3, #48]	; 0x30
  port_unlock_from_isr();
 8002da8:	f7ff ff6a 	bl	8002c80 <port_unlock_from_isr.lto_priv.271>
}
 8002dac:	bd10      	pop	{r4, pc}
 8002dae:	46c0      	nop			; (mov r8, r8)
 8002db0:	20000528 	.word	0x20000528
 8002db4:	08003b0c 	.word	0x08003b0c
	...

08002dc0 <_dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {
 8002dc0:	b510      	push	{r4, lr}

  port_lock_from_isr();
 8002dc2:	f7ff ff55 	bl	8002c70 <port_lock_from_isr.lto_priv.275>
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002dc6:	4b0a      	ldr	r3, [pc, #40]	; (8002df0 <_dbg_check_leave_isr+0x30>)
 8002dc8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002dca:	2b00      	cmp	r3, #0
 8002dcc:	dd03      	ble.n	8002dd6 <_dbg_check_leave_isr+0x16>
 8002dce:	4b08      	ldr	r3, [pc, #32]	; (8002df0 <_dbg_check_leave_isr+0x30>)
 8002dd0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002dd2:	2b00      	cmp	r3, #0
 8002dd4:	d003      	beq.n	8002dde <_dbg_check_leave_isr+0x1e>
    chSysHalt("SV#9");
 8002dd6:	4b07      	ldr	r3, [pc, #28]	; (8002df4 <_dbg_check_leave_isr+0x34>)
 8002dd8:	0018      	movs	r0, r3
 8002dda:	f7ff ff21 	bl	8002c20 <chSysHalt>
  }
  ch.dbg.isr_cnt--;
 8002dde:	4b04      	ldr	r3, [pc, #16]	; (8002df0 <_dbg_check_leave_isr+0x30>)
 8002de0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002de2:	1e5a      	subs	r2, r3, #1
 8002de4:	4b02      	ldr	r3, [pc, #8]	; (8002df0 <_dbg_check_leave_isr+0x30>)
 8002de6:	631a      	str	r2, [r3, #48]	; 0x30
  port_unlock_from_isr();
 8002de8:	f7ff ff4a 	bl	8002c80 <port_unlock_from_isr.lto_priv.271>
}
 8002dec:	bd10      	pop	{r4, pc}
 8002dee:	46c0      	nop			; (mov r8, r8)
 8002df0:	20000528 	.word	0x20000528
 8002df4:	08003b14 	.word	0x08003b14
	...

08002e00 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
 8002e00:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002e02:	4b06      	ldr	r3, [pc, #24]	; (8002e1c <chDbgCheckClassI+0x1c>)
 8002e04:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002e06:	2b00      	cmp	r3, #0
 8002e08:	db03      	blt.n	8002e12 <chDbgCheckClassI+0x12>
 8002e0a:	4b04      	ldr	r3, [pc, #16]	; (8002e1c <chDbgCheckClassI+0x1c>)
 8002e0c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002e0e:	2b00      	cmp	r3, #0
 8002e10:	dc03      	bgt.n	8002e1a <chDbgCheckClassI+0x1a>
    chSysHalt("SV#10");
 8002e12:	4b03      	ldr	r3, [pc, #12]	; (8002e20 <chDbgCheckClassI+0x20>)
 8002e14:	0018      	movs	r0, r3
 8002e16:	f7ff ff03 	bl	8002c20 <chSysHalt>
  }
}
 8002e1a:	bd10      	pop	{r4, pc}
 8002e1c:	20000528 	.word	0x20000528
 8002e20:	08003b1c 	.word	0x08003b1c
	...

08002e30 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 8002e30:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002e32:	4b06      	ldr	r3, [pc, #24]	; (8002e4c <chDbgCheckClassS+0x1c>)
 8002e34:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002e36:	2b00      	cmp	r3, #0
 8002e38:	d103      	bne.n	8002e42 <chDbgCheckClassS+0x12>
 8002e3a:	4b04      	ldr	r3, [pc, #16]	; (8002e4c <chDbgCheckClassS+0x1c>)
 8002e3c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002e3e:	2b00      	cmp	r3, #0
 8002e40:	dc03      	bgt.n	8002e4a <chDbgCheckClassS+0x1a>
    chSysHalt("SV#11");
 8002e42:	4b03      	ldr	r3, [pc, #12]	; (8002e50 <chDbgCheckClassS+0x20>)
 8002e44:	0018      	movs	r0, r3
 8002e46:	f7ff feeb 	bl	8002c20 <chSysHalt>
  }
}
 8002e4a:	bd10      	pop	{r4, pc}
 8002e4c:	20000528 	.word	0x20000528
 8002e50:	08003b24 	.word	0x08003b24
	...

08002e60 <port_lock.lto_priv.260>:
  __ASM volatile ("cpsid i" : : : "memory");
 8002e60:	b672      	cpsid	i
}
 8002e62:	4770      	bx	lr
	...

08002e70 <port_unlock.lto_priv.255>:
  __ASM volatile ("cpsie i" : : : "memory");
 8002e70:	b662      	cpsie	i
}
 8002e72:	4770      	bx	lr
	...

08002e80 <port_lock_from_isr.lto_priv.276>:
static inline void port_lock_from_isr(void) {
 8002e80:	b510      	push	{r4, lr}
  port_lock();
 8002e82:	f7ff ffed 	bl	8002e60 <port_lock.lto_priv.260>
}
 8002e86:	bd10      	pop	{r4, pc}
	...

08002e90 <port_unlock_from_isr.lto_priv.272>:
static inline void port_unlock_from_isr(void) {
 8002e90:	b510      	push	{r4, lr}
  port_unlock();
 8002e92:	f7ff ffed 	bl	8002e70 <port_unlock.lto_priv.255>
}
 8002e96:	bd10      	pop	{r4, pc}
	...

08002ea0 <st_lld_get_counter.lto_priv.250>:
  return (systime_t)STM32_ST_TIM->CNT;
 8002ea0:	2380      	movs	r3, #128	; 0x80
 8002ea2:	05db      	lsls	r3, r3, #23
 8002ea4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8002ea6:	0018      	movs	r0, r3
 8002ea8:	4770      	bx	lr
 8002eaa:	46c0      	nop			; (mov r8, r8)
 8002eac:	0000      	movs	r0, r0
	...

08002eb0 <port_timer_get_time.lto_priv.246>:
static inline systime_t port_timer_get_time(void) {
 8002eb0:	b510      	push	{r4, lr}
  return stGetCounter();
 8002eb2:	f7ff fff5 	bl	8002ea0 <st_lld_get_counter.lto_priv.250>
 8002eb6:	0003      	movs	r3, r0
}
 8002eb8:	0018      	movs	r0, r3
 8002eba:	bd10      	pop	{r4, pc}
 8002ebc:	0000      	movs	r0, r0
	...

08002ec0 <chVTGetSystemTimeX.lto_priv.279>:
static inline systime_t chVTGetSystemTimeX(void) {
 8002ec0:	b510      	push	{r4, lr}
  return port_timer_get_time();
 8002ec2:	f7ff fff5 	bl	8002eb0 <port_timer_get_time.lto_priv.246>
 8002ec6:	0003      	movs	r3, r0
}
 8002ec8:	0018      	movs	r0, r3
 8002eca:	bd10      	pop	{r4, pc}
 8002ecc:	0000      	movs	r0, r0
	...

08002ed0 <trace_next>:
/**
 * @brief   Writes a time stamp and increases the trace buffer pointer.
 *
 * @notapi
 */
static NOINLINE void trace_next(void) {
 8002ed0:	b510      	push	{r4, lr}

  ch.dbg.trace_buffer.ptr->time    = chVTGetSystemTimeX();
 8002ed2:	4b0d      	ldr	r3, [pc, #52]	; (8002f08 <trace_next+0x38>)
 8002ed4:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
 8002ed6:	f7ff fff3 	bl	8002ec0 <chVTGetSystemTimeX.lto_priv.279>
 8002eda:	0003      	movs	r3, r0
 8002edc:	6063      	str	r3, [r4, #4]
#if PORT_SUPPORTS_RT == TRUE
  ch.dbg.trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
#else
  ch.dbg.trace_buffer.ptr->rtstamp = (rtcnt_t)0;
 8002ede:	4b0a      	ldr	r3, [pc, #40]	; (8002f08 <trace_next+0x38>)
 8002ee0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002ee2:	681a      	ldr	r2, [r3, #0]
 8002ee4:	21ff      	movs	r1, #255	; 0xff
 8002ee6:	400a      	ands	r2, r1
 8002ee8:	601a      	str	r2, [r3, #0]
#endif

  /* Trace hook, useful in order to interface debug tools.*/
  CH_CFG_TRACE_HOOK(ch.dbg.trace_buffer.ptr);

  if (++ch.dbg.trace_buffer.ptr >=
 8002eea:	4b07      	ldr	r3, [pc, #28]	; (8002f08 <trace_next+0x38>)
 8002eec:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002eee:	3310      	adds	r3, #16
 8002ef0:	001a      	movs	r2, r3
 8002ef2:	4b05      	ldr	r3, [pc, #20]	; (8002f08 <trace_next+0x38>)
 8002ef4:	63da      	str	r2, [r3, #60]	; 0x3c
 8002ef6:	4b04      	ldr	r3, [pc, #16]	; (8002f08 <trace_next+0x38>)
 8002ef8:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8002efa:	4b04      	ldr	r3, [pc, #16]	; (8002f0c <trace_next+0x3c>)
 8002efc:	429a      	cmp	r2, r3
 8002efe:	d302      	bcc.n	8002f06 <trace_next+0x36>
      &ch.dbg.trace_buffer.buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.ptr = &ch.dbg.trace_buffer.buffer[0];
 8002f00:	4b01      	ldr	r3, [pc, #4]	; (8002f08 <trace_next+0x38>)
 8002f02:	4a03      	ldr	r2, [pc, #12]	; (8002f10 <trace_next+0x40>)
 8002f04:	63da      	str	r2, [r3, #60]	; 0x3c
  }
}
 8002f06:	bd10      	pop	{r4, pc}
 8002f08:	20000528 	.word	0x20000528
 8002f0c:	20000d68 	.word	0x20000d68
 8002f10:	20000568 	.word	0x20000568
	...

08002f20 <_trace_init>:
#if (CH_DBG_TRACE_MASK != CH_DBG_TRACE_MASK_DISABLED) || defined(__DOXYGEN__)
/**
 * @brief   Trace circular buffer subsystem initialization.
 * @note    Internal use only.
 */
void _trace_init(void) {
 8002f20:	b082      	sub	sp, #8
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)CH_DBG_TRACE_MASK;
 8002f22:	4b0f      	ldr	r3, [pc, #60]	; (8002f60 <_trace_init+0x40>)
 8002f24:	220f      	movs	r2, #15
 8002f26:	871a      	strh	r2, [r3, #56]	; 0x38
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
 8002f28:	4b0d      	ldr	r3, [pc, #52]	; (8002f60 <_trace_init+0x40>)
 8002f2a:	2280      	movs	r2, #128	; 0x80
 8002f2c:	875a      	strh	r2, [r3, #58]	; 0x3a
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
 8002f2e:	4b0c      	ldr	r3, [pc, #48]	; (8002f60 <_trace_init+0x40>)
 8002f30:	4a0c      	ldr	r2, [pc, #48]	; (8002f64 <_trace_init+0x44>)
 8002f32:	63da      	str	r2, [r3, #60]	; 0x3c
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8002f34:	2300      	movs	r3, #0
 8002f36:	9301      	str	r3, [sp, #4]
 8002f38:	e00d      	b.n	8002f56 <_trace_init+0x36>
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8002f3a:	4a09      	ldr	r2, [pc, #36]	; (8002f60 <_trace_init+0x40>)
 8002f3c:	9b01      	ldr	r3, [sp, #4]
 8002f3e:	3301      	adds	r3, #1
 8002f40:	2128      	movs	r1, #40	; 0x28
 8002f42:	011b      	lsls	r3, r3, #4
 8002f44:	18d3      	adds	r3, r2, r3
 8002f46:	185b      	adds	r3, r3, r1
 8002f48:	7a1a      	ldrb	r2, [r3, #8]
 8002f4a:	2107      	movs	r1, #7
 8002f4c:	438a      	bics	r2, r1
 8002f4e:	721a      	strb	r2, [r3, #8]
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8002f50:	9b01      	ldr	r3, [sp, #4]
 8002f52:	3301      	adds	r3, #1
 8002f54:	9301      	str	r3, [sp, #4]
 8002f56:	9b01      	ldr	r3, [sp, #4]
 8002f58:	2b7f      	cmp	r3, #127	; 0x7f
 8002f5a:	d9ee      	bls.n	8002f3a <_trace_init+0x1a>
  }
}
 8002f5c:	b002      	add	sp, #8
 8002f5e:	4770      	bx	lr
 8002f60:	20000528 	.word	0x20000528
 8002f64:	20000568 	.word	0x20000568
	...

08002f70 <_trace_switch>:
 * @param[in] ntp       the thread being switched in
 * @param[in] otp       the thread being switched out
 *
 * @notapi
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {
 8002f70:	b500      	push	{lr}
 8002f72:	b083      	sub	sp, #12
 8002f74:	9001      	str	r0, [sp, #4]
 8002f76:	9100      	str	r1, [sp, #0]

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8002f78:	4b16      	ldr	r3, [pc, #88]	; (8002fd4 <_trace_switch+0x64>)
 8002f7a:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8002f7c:	001a      	movs	r2, r3
 8002f7e:	2301      	movs	r3, #1
 8002f80:	4013      	ands	r3, r2
 8002f82:	d125      	bne.n	8002fd0 <_trace_switch+0x60>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8002f84:	4b13      	ldr	r3, [pc, #76]	; (8002fd4 <_trace_switch+0x64>)
 8002f86:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002f88:	781a      	ldrb	r2, [r3, #0]
 8002f8a:	2107      	movs	r1, #7
 8002f8c:	438a      	bics	r2, r1
 8002f8e:	1c11      	adds	r1, r2, #0
 8002f90:	2201      	movs	r2, #1
 8002f92:	430a      	orrs	r2, r1
 8002f94:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8002f96:	4b0f      	ldr	r3, [pc, #60]	; (8002fd4 <_trace_switch+0x64>)
 8002f98:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002f9a:	9a00      	ldr	r2, [sp, #0]
 8002f9c:	2120      	movs	r1, #32
 8002f9e:	5c52      	ldrb	r2, [r2, r1]
 8002fa0:	1c11      	adds	r1, r2, #0
 8002fa2:	221f      	movs	r2, #31
 8002fa4:	400a      	ands	r2, r1
 8002fa6:	b2d2      	uxtb	r2, r2
 8002fa8:	00d0      	lsls	r0, r2, #3
 8002faa:	781a      	ldrb	r2, [r3, #0]
 8002fac:	2107      	movs	r1, #7
 8002fae:	400a      	ands	r2, r1
 8002fb0:	1c11      	adds	r1, r2, #0
 8002fb2:	1c02      	adds	r2, r0, #0
 8002fb4:	430a      	orrs	r2, r1
 8002fb6:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 8002fb8:	4b06      	ldr	r3, [pc, #24]	; (8002fd4 <_trace_switch+0x64>)
 8002fba:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002fbc:	4a05      	ldr	r2, [pc, #20]	; (8002fd4 <_trace_switch+0x64>)
 8002fbe:	6992      	ldr	r2, [r2, #24]
 8002fc0:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8002fc2:	4b04      	ldr	r3, [pc, #16]	; (8002fd4 <_trace_switch+0x64>)
 8002fc4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002fc6:	9a00      	ldr	r2, [sp, #0]
 8002fc8:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8002fca:	60da      	str	r2, [r3, #12]
    trace_next();
 8002fcc:	f7ff ff80 	bl	8002ed0 <trace_next>
  }
}
 8002fd0:	b003      	add	sp, #12
 8002fd2:	bd00      	pop	{pc}
 8002fd4:	20000528 	.word	0x20000528
	...

08002fe0 <_trace_isr_enter>:
 *
 * @param[in] isr       name of the isr
 *
 * @notapi
 */
void _trace_isr_enter(const char *isr) {
 8002fe0:	b500      	push	{lr}
 8002fe2:	b083      	sub	sp, #12
 8002fe4:	9001      	str	r0, [sp, #4]

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002fe6:	4b10      	ldr	r3, [pc, #64]	; (8003028 <_trace_isr_enter+0x48>)
 8002fe8:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8002fea:	001a      	movs	r2, r3
 8002fec:	2302      	movs	r3, #2
 8002fee:	4013      	ands	r3, r2
 8002ff0:	d118      	bne.n	8003024 <_trace_isr_enter+0x44>
    port_lock_from_isr();
 8002ff2:	f7ff ff45 	bl	8002e80 <port_lock_from_isr.lto_priv.276>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8002ff6:	4b0c      	ldr	r3, [pc, #48]	; (8003028 <_trace_isr_enter+0x48>)
 8002ff8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002ffa:	781a      	ldrb	r2, [r3, #0]
 8002ffc:	2107      	movs	r1, #7
 8002ffe:	438a      	bics	r2, r1
 8003000:	1c11      	adds	r1, r2, #0
 8003002:	2202      	movs	r2, #2
 8003004:	430a      	orrs	r2, r1
 8003006:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->state       = 0U;
 8003008:	4b07      	ldr	r3, [pc, #28]	; (8003028 <_trace_isr_enter+0x48>)
 800300a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800300c:	781a      	ldrb	r2, [r3, #0]
 800300e:	2107      	movs	r1, #7
 8003010:	400a      	ands	r2, r1
 8003012:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8003014:	4b04      	ldr	r3, [pc, #16]	; (8003028 <_trace_isr_enter+0x48>)
 8003016:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8003018:	9a01      	ldr	r2, [sp, #4]
 800301a:	609a      	str	r2, [r3, #8]
    trace_next();
 800301c:	f7ff ff58 	bl	8002ed0 <trace_next>
    port_unlock_from_isr();
 8003020:	f7ff ff36 	bl	8002e90 <port_unlock_from_isr.lto_priv.272>
  }
}
 8003024:	b003      	add	sp, #12
 8003026:	bd00      	pop	{pc}
 8003028:	20000528 	.word	0x20000528
 800302c:	00000000 	.word	0x00000000

08003030 <_trace_isr_leave>:
 *
 * @param[in] isr       name of the isr
 *
 * @notapi
 */
void _trace_isr_leave(const char *isr) {
 8003030:	b500      	push	{lr}
 8003032:	b083      	sub	sp, #12
 8003034:	9001      	str	r0, [sp, #4]

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003036:	4b10      	ldr	r3, [pc, #64]	; (8003078 <_trace_isr_leave+0x48>)
 8003038:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800303a:	001a      	movs	r2, r3
 800303c:	2302      	movs	r3, #2
 800303e:	4013      	ands	r3, r2
 8003040:	d118      	bne.n	8003074 <_trace_isr_leave+0x44>
    port_lock_from_isr();
 8003042:	f7ff ff1d 	bl	8002e80 <port_lock_from_isr.lto_priv.276>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003046:	4b0c      	ldr	r3, [pc, #48]	; (8003078 <_trace_isr_leave+0x48>)
 8003048:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800304a:	781a      	ldrb	r2, [r3, #0]
 800304c:	2107      	movs	r1, #7
 800304e:	438a      	bics	r2, r1
 8003050:	1c11      	adds	r1, r2, #0
 8003052:	2203      	movs	r2, #3
 8003054:	430a      	orrs	r2, r1
 8003056:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->state       = 0U;
 8003058:	4b07      	ldr	r3, [pc, #28]	; (8003078 <_trace_isr_leave+0x48>)
 800305a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800305c:	781a      	ldrb	r2, [r3, #0]
 800305e:	2107      	movs	r1, #7
 8003060:	400a      	ands	r2, r1
 8003062:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8003064:	4b04      	ldr	r3, [pc, #16]	; (8003078 <_trace_isr_leave+0x48>)
 8003066:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8003068:	9a01      	ldr	r2, [sp, #4]
 800306a:	609a      	str	r2, [r3, #8]
    trace_next();
 800306c:	f7ff ff30 	bl	8002ed0 <trace_next>
    port_unlock_from_isr();
 8003070:	f7ff ff0e 	bl	8002e90 <port_unlock_from_isr.lto_priv.272>
  }
}
 8003074:	b003      	add	sp, #12
 8003076:	bd00      	pop	{pc}
 8003078:	20000528 	.word	0x20000528
 800307c:	00000000 	.word	0x00000000

08003080 <_trace_halt>:
 *
 * @param[in] reason    the halt error string
 *
 * @notapi
 */
void _trace_halt(const char *reason) {
 8003080:	b500      	push	{lr}
 8003082:	b083      	sub	sp, #12
 8003084:	9001      	str	r0, [sp, #4]

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
 8003086:	4b0e      	ldr	r3, [pc, #56]	; (80030c0 <_trace_halt+0x40>)
 8003088:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800308a:	001a      	movs	r2, r3
 800308c:	2304      	movs	r3, #4
 800308e:	4013      	ands	r3, r2
 8003090:	d114      	bne.n	80030bc <_trace_halt+0x3c>
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 8003092:	4b0b      	ldr	r3, [pc, #44]	; (80030c0 <_trace_halt+0x40>)
 8003094:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8003096:	781a      	ldrb	r2, [r3, #0]
 8003098:	2107      	movs	r1, #7
 800309a:	438a      	bics	r2, r1
 800309c:	1c11      	adds	r1, r2, #0
 800309e:	2204      	movs	r2, #4
 80030a0:	430a      	orrs	r2, r1
 80030a2:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->state         = 0;
 80030a4:	4b06      	ldr	r3, [pc, #24]	; (80030c0 <_trace_halt+0x40>)
 80030a6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80030a8:	781a      	ldrb	r2, [r3, #0]
 80030aa:	2107      	movs	r1, #7
 80030ac:	400a      	ands	r2, r1
 80030ae:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->u.halt.reason = reason;
 80030b0:	4b03      	ldr	r3, [pc, #12]	; (80030c0 <_trace_halt+0x40>)
 80030b2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80030b4:	9a01      	ldr	r2, [sp, #4]
 80030b6:	609a      	str	r2, [r3, #8]
    trace_next();
 80030b8:	f7ff ff0a 	bl	8002ed0 <trace_next>
  }
}
 80030bc:	b003      	add	sp, #12
 80030be:	bd00      	pop	{pc}
 80030c0:	20000528 	.word	0x20000528
	...

080030d0 <st_lld_get_counter.lto_priv.251>:
  return (systime_t)STM32_ST_TIM->CNT;
 80030d0:	2380      	movs	r3, #128	; 0x80
 80030d2:	05db      	lsls	r3, r3, #23
 80030d4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 80030d6:	0018      	movs	r0, r3
 80030d8:	4770      	bx	lr
 80030da:	46c0      	nop			; (mov r8, r8)
 80030dc:	0000      	movs	r0, r0
	...

080030e0 <port_timer_start_alarm>:
static inline void port_timer_start_alarm(systime_t time) {
 80030e0:	b500      	push	{lr}
 80030e2:	b083      	sub	sp, #12
 80030e4:	9001      	str	r0, [sp, #4]
  stStartAlarm(time);
 80030e6:	9b01      	ldr	r3, [sp, #4]
 80030e8:	0018      	movs	r0, r3
 80030ea:	f7fd fdf9 	bl	8000ce0 <stStartAlarm>
}
 80030ee:	b003      	add	sp, #12
 80030f0:	bd00      	pop	{pc}
 80030f2:	46c0      	nop			; (mov r8, r8)
	...

08003100 <port_timer_stop_alarm.lto_priv.284>:
static inline void port_timer_stop_alarm(void) {
 8003100:	b510      	push	{r4, lr}
  stStopAlarm();
 8003102:	f7fd fe05 	bl	8000d10 <stStopAlarm>
}
 8003106:	bd10      	pop	{r4, pc}
	...

08003110 <port_timer_set_alarm.lto_priv.282>:
static inline void port_timer_set_alarm(systime_t time) {
 8003110:	b500      	push	{lr}
 8003112:	b083      	sub	sp, #12
 8003114:	9001      	str	r0, [sp, #4]
  stSetAlarm(time);
 8003116:	9b01      	ldr	r3, [sp, #4]
 8003118:	0018      	movs	r0, r3
 800311a:	f7fd fe01 	bl	8000d20 <stSetAlarm>
}
 800311e:	b003      	add	sp, #12
 8003120:	bd00      	pop	{pc}
 8003122:	46c0      	nop			; (mov r8, r8)
	...

08003130 <port_timer_get_time.lto_priv.247>:
static inline systime_t port_timer_get_time(void) {
 8003130:	b510      	push	{r4, lr}
  return stGetCounter();
 8003132:	f7ff ffcd 	bl	80030d0 <st_lld_get_counter.lto_priv.251>
 8003136:	0003      	movs	r3, r0
}
 8003138:	0018      	movs	r0, r3
 800313a:	bd10      	pop	{r4, pc}
 800313c:	0000      	movs	r0, r0
	...

08003140 <chVTGetSystemTimeX.lto_priv.280>:
static inline systime_t chVTGetSystemTimeX(void) {
 8003140:	b510      	push	{r4, lr}
  return port_timer_get_time();
 8003142:	f7ff fff5 	bl	8003130 <port_timer_get_time.lto_priv.247>
 8003146:	0003      	movs	r3, r0
}
 8003148:	0018      	movs	r0, r3
 800314a:	bd10      	pop	{r4, pc}
 800314c:	0000      	movs	r0, r0
	...

08003150 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8003150:	4b06      	ldr	r3, [pc, #24]	; (800316c <_vt_init+0x1c>)
 8003152:	4a07      	ldr	r2, [pc, #28]	; (8003170 <_vt_init+0x20>)
 8003154:	61da      	str	r2, [r3, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8003156:	4b05      	ldr	r3, [pc, #20]	; (800316c <_vt_init+0x1c>)
 8003158:	4a05      	ldr	r2, [pc, #20]	; (8003170 <_vt_init+0x20>)
 800315a:	621a      	str	r2, [r3, #32]
  ch.vtlist.delta = (systime_t)-1;
 800315c:	4b03      	ldr	r3, [pc, #12]	; (800316c <_vt_init+0x1c>)
 800315e:	2201      	movs	r2, #1
 8003160:	4252      	negs	r2, r2
 8003162:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 8003164:	4b01      	ldr	r3, [pc, #4]	; (800316c <_vt_init+0x1c>)
 8003166:	2200      	movs	r2, #0
 8003168:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800316a:	4770      	bx	lr
 800316c:	20000528 	.word	0x20000528
 8003170:	20000544 	.word	0x20000544
	...

08003180 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8003180:	b500      	push	{lr}
 8003182:	b089      	sub	sp, #36	; 0x24
 8003184:	9003      	str	r0, [sp, #12]
 8003186:	9102      	str	r1, [sp, #8]
 8003188:	9201      	str	r2, [sp, #4]
 800318a:	9300      	str	r3, [sp, #0]
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
 800318c:	f7ff fe38 	bl	8002e00 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8003190:	9b03      	ldr	r3, [sp, #12]
 8003192:	2b00      	cmp	r3, #0
 8003194:	d005      	beq.n	80031a2 <chVTDoSetI+0x22>
 8003196:	9b01      	ldr	r3, [sp, #4]
 8003198:	2b00      	cmp	r3, #0
 800319a:	d002      	beq.n	80031a2 <chVTDoSetI+0x22>
 800319c:	9b02      	ldr	r3, [sp, #8]
 800319e:	2b00      	cmp	r3, #0
 80031a0:	d103      	bne.n	80031aa <chVTDoSetI+0x2a>
 80031a2:	4b42      	ldr	r3, [pc, #264]	; (80032ac <chVTDoSetI+0x12c>)
 80031a4:	0018      	movs	r0, r3
 80031a6:	f7ff fd3b 	bl	8002c20 <chSysHalt>

  vtp->par = par;
 80031aa:	9b03      	ldr	r3, [sp, #12]
 80031ac:	9a00      	ldr	r2, [sp, #0]
 80031ae:	611a      	str	r2, [r3, #16]
  vtp->func = vtfunc;
 80031b0:	9b03      	ldr	r3, [sp, #12]
 80031b2:	9a01      	ldr	r2, [sp, #4]
 80031b4:	60da      	str	r2, [r3, #12]

#if CH_CFG_ST_TIMEDELTA > 0
  {
    systime_t now = chVTGetSystemTimeX();
 80031b6:	f7ff ffc3 	bl	8003140 <chVTGetSystemTimeX.lto_priv.280>
 80031ba:	0003      	movs	r3, r0
 80031bc:	9305      	str	r3, [sp, #20]

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
 80031be:	9b02      	ldr	r3, [sp, #8]
 80031c0:	2b01      	cmp	r3, #1
 80031c2:	d801      	bhi.n	80031c8 <chVTDoSetI+0x48>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 80031c4:	2302      	movs	r3, #2
 80031c6:	9302      	str	r3, [sp, #8]
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80031c8:	4b39      	ldr	r3, [pc, #228]	; (80032b0 <chVTDoSetI+0x130>)
 80031ca:	69da      	ldr	r2, [r3, #28]
 80031cc:	4b39      	ldr	r3, [pc, #228]	; (80032b4 <chVTDoSetI+0x134>)
 80031ce:	429a      	cmp	r2, r3
 80031d0:	d119      	bne.n	8003206 <chVTDoSetI+0x86>

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
 80031d2:	4b37      	ldr	r3, [pc, #220]	; (80032b0 <chVTDoSetI+0x130>)
 80031d4:	9a05      	ldr	r2, [sp, #20]
 80031d6:	629a      	str	r2, [r3, #40]	; 0x28
      ch.vtlist.next = vtp;
 80031d8:	4b35      	ldr	r3, [pc, #212]	; (80032b0 <chVTDoSetI+0x130>)
 80031da:	9a03      	ldr	r2, [sp, #12]
 80031dc:	61da      	str	r2, [r3, #28]
      ch.vtlist.prev = vtp;
 80031de:	4b34      	ldr	r3, [pc, #208]	; (80032b0 <chVTDoSetI+0x130>)
 80031e0:	9a03      	ldr	r2, [sp, #12]
 80031e2:	621a      	str	r2, [r3, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 80031e4:	9b03      	ldr	r3, [sp, #12]
 80031e6:	4a33      	ldr	r2, [pc, #204]	; (80032b4 <chVTDoSetI+0x134>)
 80031e8:	601a      	str	r2, [r3, #0]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 80031ea:	9b03      	ldr	r3, [sp, #12]
 80031ec:	4a31      	ldr	r2, [pc, #196]	; (80032b4 <chVTDoSetI+0x134>)
 80031ee:	605a      	str	r2, [r3, #4]
      vtp->delta = delay;
 80031f0:	9b03      	ldr	r3, [sp, #12]
 80031f2:	9a02      	ldr	r2, [sp, #8]
 80031f4:	609a      	str	r2, [r3, #8]

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.lasttime + delay);
 80031f6:	4b2e      	ldr	r3, [pc, #184]	; (80032b0 <chVTDoSetI+0x130>)
 80031f8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80031fa:	9b02      	ldr	r3, [sp, #8]
 80031fc:	18d3      	adds	r3, r2, r3
 80031fe:	0018      	movs	r0, r3
 8003200:	f7ff ff6e 	bl	80030e0 <port_timer_start_alarm>
 8003204:	e04f      	b.n	80032a6 <chVTDoSetI+0x126>

      return;
    }

    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;
 8003206:	4b2a      	ldr	r3, [pc, #168]	; (80032b0 <chVTDoSetI+0x130>)
 8003208:	69db      	ldr	r3, [r3, #28]
 800320a:	9307      	str	r3, [sp, #28]

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = now - ch.vtlist.lasttime + delay;
 800320c:	4b28      	ldr	r3, [pc, #160]	; (80032b0 <chVTDoSetI+0x130>)
 800320e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003210:	9a05      	ldr	r2, [sp, #20]
 8003212:	1ad2      	subs	r2, r2, r3
 8003214:	9b02      	ldr	r3, [sp, #8]
 8003216:	18d3      	adds	r3, r2, r3
 8003218:	9306      	str	r3, [sp, #24]

    if (delta < now - ch.vtlist.lasttime) {
 800321a:	4b25      	ldr	r3, [pc, #148]	; (80032b0 <chVTDoSetI+0x130>)
 800321c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800321e:	9a05      	ldr	r2, [sp, #20]
 8003220:	1ad2      	subs	r2, r2, r3
 8003222:	9b06      	ldr	r3, [sp, #24]
 8003224:	429a      	cmp	r2, r3
 8003226:	d908      	bls.n	800323a <chVTDoSetI+0xba>
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 8003228:	9b07      	ldr	r3, [sp, #28]
 800322a:	689b      	ldr	r3, [r3, #8]
 800322c:	9a06      	ldr	r2, [sp, #24]
 800322e:	1ad3      	subs	r3, r2, r3
 8003230:	9306      	str	r3, [sp, #24]
      p = p->next;
 8003232:	9b07      	ldr	r3, [sp, #28]
 8003234:	681b      	ldr	r3, [r3, #0]
 8003236:	9307      	str	r3, [sp, #28]
 8003238:	e014      	b.n	8003264 <chVTDoSetI+0xe4>
    }
    else if (delta < p->delta) {
 800323a:	9b07      	ldr	r3, [sp, #28]
 800323c:	689a      	ldr	r2, [r3, #8]
 800323e:	9b06      	ldr	r3, [sp, #24]
 8003240:	429a      	cmp	r2, r3
 8003242:	d90f      	bls.n	8003264 <chVTDoSetI+0xe4>
     /* A small delay that will become the first element in the delta list
        and next deadline.*/
      port_timer_set_alarm(ch.vtlist.lasttime + delta);
 8003244:	4b1a      	ldr	r3, [pc, #104]	; (80032b0 <chVTDoSetI+0x130>)
 8003246:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8003248:	9b06      	ldr	r3, [sp, #24]
 800324a:	18d3      	adds	r3, r2, r3
 800324c:	0018      	movs	r0, r3
 800324e:	f7ff ff5f 	bl	8003110 <port_timer_set_alarm.lto_priv.282>
 8003252:	e007      	b.n	8003264 <chVTDoSetI+0xe4>
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    delta -= p->delta;
 8003254:	9b07      	ldr	r3, [sp, #28]
 8003256:	689b      	ldr	r3, [r3, #8]
 8003258:	9a06      	ldr	r2, [sp, #24]
 800325a:	1ad3      	subs	r3, r2, r3
 800325c:	9306      	str	r3, [sp, #24]
    p = p->next;
 800325e:	9b07      	ldr	r3, [sp, #28]
 8003260:	681b      	ldr	r3, [r3, #0]
 8003262:	9307      	str	r3, [sp, #28]
  while (p->delta < delta) {
 8003264:	9b07      	ldr	r3, [sp, #28]
 8003266:	689a      	ldr	r2, [r3, #8]
 8003268:	9b06      	ldr	r3, [sp, #24]
 800326a:	429a      	cmp	r2, r3
 800326c:	d3f2      	bcc.n	8003254 <chVTDoSetI+0xd4>
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
 800326e:	9b03      	ldr	r3, [sp, #12]
 8003270:	9a07      	ldr	r2, [sp, #28]
 8003272:	601a      	str	r2, [r3, #0]
  vtp->prev = vtp->next->prev;
 8003274:	9b03      	ldr	r3, [sp, #12]
 8003276:	681b      	ldr	r3, [r3, #0]
 8003278:	685a      	ldr	r2, [r3, #4]
 800327a:	9b03      	ldr	r3, [sp, #12]
 800327c:	605a      	str	r2, [r3, #4]
  vtp->prev->next = vtp;
 800327e:	9b03      	ldr	r3, [sp, #12]
 8003280:	685b      	ldr	r3, [r3, #4]
 8003282:	9a03      	ldr	r2, [sp, #12]
 8003284:	601a      	str	r2, [r3, #0]
  p->prev = vtp;
 8003286:	9b07      	ldr	r3, [sp, #28]
 8003288:	9a03      	ldr	r2, [sp, #12]
 800328a:	605a      	str	r2, [r3, #4]
  vtp->delta = delta
 800328c:	9b03      	ldr	r3, [sp, #12]
 800328e:	9a06      	ldr	r2, [sp, #24]
 8003290:	609a      	str	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 8003292:	9b07      	ldr	r3, [sp, #28]
 8003294:	689a      	ldr	r2, [r3, #8]
 8003296:	9b06      	ldr	r3, [sp, #24]
 8003298:	1ad2      	subs	r2, r2, r3
 800329a:	9b07      	ldr	r3, [sp, #28]
 800329c:	609a      	str	r2, [r3, #8]
  ch.vtlist.delta = (systime_t)-1;
 800329e:	4b04      	ldr	r3, [pc, #16]	; (80032b0 <chVTDoSetI+0x130>)
 80032a0:	2201      	movs	r2, #1
 80032a2:	4252      	negs	r2, r2
 80032a4:	625a      	str	r2, [r3, #36]	; 0x24
}
 80032a6:	b009      	add	sp, #36	; 0x24
 80032a8:	bd00      	pop	{pc}
 80032aa:	46c0      	nop			; (mov r8, r8)
 80032ac:	08003be0 	.word	0x08003be0
 80032b0:	20000528 	.word	0x20000528
 80032b4:	20000544 	.word	0x20000544
	...

080032c0 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 80032c0:	b500      	push	{lr}
 80032c2:	b085      	sub	sp, #20
 80032c4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 80032c6:	f7ff fd9b 	bl	8002e00 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
 80032ca:	9b01      	ldr	r3, [sp, #4]
 80032cc:	2b00      	cmp	r3, #0
 80032ce:	d103      	bne.n	80032d8 <chVTDoResetI+0x18>
 80032d0:	4b36      	ldr	r3, [pc, #216]	; (80033ac <chVTDoResetI+0xec>)
 80032d2:	0018      	movs	r0, r3
 80032d4:	f7ff fca4 	bl	8002c20 <chSysHalt>
  chDbgAssert(vtp->func != NULL, "timer not set or already triggered");
 80032d8:	9b01      	ldr	r3, [sp, #4]
 80032da:	68db      	ldr	r3, [r3, #12]
 80032dc:	2b00      	cmp	r3, #0
 80032de:	d103      	bne.n	80032e8 <chVTDoResetI+0x28>
 80032e0:	4b32      	ldr	r3, [pc, #200]	; (80033ac <chVTDoResetI+0xec>)
 80032e2:	0018      	movs	r0, r3
 80032e4:	f7ff fc9c 	bl	8002c20 <chSysHalt>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 80032e8:	4b31      	ldr	r3, [pc, #196]	; (80033b0 <chVTDoResetI+0xf0>)
 80032ea:	69da      	ldr	r2, [r3, #28]
 80032ec:	9b01      	ldr	r3, [sp, #4]
 80032ee:	429a      	cmp	r2, r3
 80032f0:	d01b      	beq.n	800332a <chVTDoResetI+0x6a>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 80032f2:	9b01      	ldr	r3, [sp, #4]
 80032f4:	685b      	ldr	r3, [r3, #4]
 80032f6:	9a01      	ldr	r2, [sp, #4]
 80032f8:	6812      	ldr	r2, [r2, #0]
 80032fa:	601a      	str	r2, [r3, #0]
    vtp->next->prev = vtp->prev;
 80032fc:	9b01      	ldr	r3, [sp, #4]
 80032fe:	681b      	ldr	r3, [r3, #0]
 8003300:	9a01      	ldr	r2, [sp, #4]
 8003302:	6852      	ldr	r2, [r2, #4]
 8003304:	605a      	str	r2, [r3, #4]
    vtp->func = NULL;
 8003306:	9b01      	ldr	r3, [sp, #4]
 8003308:	2200      	movs	r2, #0
 800330a:	60da      	str	r2, [r3, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 800330c:	9b01      	ldr	r3, [sp, #4]
 800330e:	681a      	ldr	r2, [r3, #0]
 8003310:	4b28      	ldr	r3, [pc, #160]	; (80033b4 <chVTDoResetI+0xf4>)
 8003312:	429a      	cmp	r2, r3
 8003314:	d047      	beq.n	80033a6 <chVTDoResetI+0xe6>
      vtp->next->delta += vtp->delta;
 8003316:	9b01      	ldr	r3, [sp, #4]
 8003318:	681b      	ldr	r3, [r3, #0]
 800331a:	9a01      	ldr	r2, [sp, #4]
 800331c:	6812      	ldr	r2, [r2, #0]
 800331e:	6891      	ldr	r1, [r2, #8]
 8003320:	9a01      	ldr	r2, [sp, #4]
 8003322:	6892      	ldr	r2, [r2, #8]
 8003324:	188a      	adds	r2, r1, r2
 8003326:	609a      	str	r2, [r3, #8]
 8003328:	e03e      	b.n	80033a8 <chVTDoResetI+0xe8>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 800332a:	9b01      	ldr	r3, [sp, #4]
 800332c:	681a      	ldr	r2, [r3, #0]
 800332e:	4b20      	ldr	r3, [pc, #128]	; (80033b0 <chVTDoResetI+0xf0>)
 8003330:	61da      	str	r2, [r3, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8003332:	4b1f      	ldr	r3, [pc, #124]	; (80033b0 <chVTDoResetI+0xf0>)
 8003334:	69db      	ldr	r3, [r3, #28]
 8003336:	4a1f      	ldr	r2, [pc, #124]	; (80033b4 <chVTDoResetI+0xf4>)
 8003338:	605a      	str	r2, [r3, #4]
  vtp->func = NULL;
 800333a:	9b01      	ldr	r3, [sp, #4]
 800333c:	2200      	movs	r2, #0
 800333e:	60da      	str	r2, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8003340:	4b1b      	ldr	r3, [pc, #108]	; (80033b0 <chVTDoResetI+0xf0>)
 8003342:	69da      	ldr	r2, [r3, #28]
 8003344:	4b1b      	ldr	r3, [pc, #108]	; (80033b4 <chVTDoResetI+0xf4>)
 8003346:	429a      	cmp	r2, r3
 8003348:	d102      	bne.n	8003350 <chVTDoResetI+0x90>
    port_timer_stop_alarm();
 800334a:	f7ff fed9 	bl	8003100 <port_timer_stop_alarm.lto_priv.284>
 800334e:	e02b      	b.n	80033a8 <chVTDoResetI+0xe8>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 8003350:	4b17      	ldr	r3, [pc, #92]	; (80033b0 <chVTDoResetI+0xf0>)
 8003352:	69db      	ldr	r3, [r3, #28]
 8003354:	4a16      	ldr	r2, [pc, #88]	; (80033b0 <chVTDoResetI+0xf0>)
 8003356:	69d2      	ldr	r2, [r2, #28]
 8003358:	6891      	ldr	r1, [r2, #8]
 800335a:	9a01      	ldr	r2, [sp, #4]
 800335c:	6892      	ldr	r2, [r2, #8]
 800335e:	188a      	adds	r2, r1, r2
 8003360:	609a      	str	r2, [r3, #8]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 8003362:	f7ff feed 	bl	8003140 <chVTGetSystemTimeX.lto_priv.280>
 8003366:	0002      	movs	r2, r0
 8003368:	4b11      	ldr	r3, [pc, #68]	; (80033b0 <chVTDoResetI+0xf0>)
 800336a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800336c:	1ad3      	subs	r3, r2, r3
 800336e:	9302      	str	r3, [sp, #8]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 8003370:	4b0f      	ldr	r3, [pc, #60]	; (80033b0 <chVTDoResetI+0xf0>)
 8003372:	69db      	ldr	r3, [r3, #28]
 8003374:	689a      	ldr	r2, [r3, #8]
 8003376:	9b02      	ldr	r3, [sp, #8]
 8003378:	429a      	cmp	r2, r3
 800337a:	d915      	bls.n	80033a8 <chVTDoResetI+0xe8>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 800337c:	4b0c      	ldr	r3, [pc, #48]	; (80033b0 <chVTDoResetI+0xf0>)
 800337e:	69db      	ldr	r3, [r3, #28]
 8003380:	689a      	ldr	r2, [r3, #8]
 8003382:	9b02      	ldr	r3, [sp, #8]
 8003384:	1ad3      	subs	r3, r2, r3
 8003386:	9303      	str	r3, [sp, #12]

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8003388:	9b03      	ldr	r3, [sp, #12]
 800338a:	2b01      	cmp	r3, #1
 800338c:	d801      	bhi.n	8003392 <chVTDoResetI+0xd2>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800338e:	2302      	movs	r3, #2
 8003390:	9303      	str	r3, [sp, #12]
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
 8003392:	4b07      	ldr	r3, [pc, #28]	; (80033b0 <chVTDoResetI+0xf0>)
 8003394:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8003396:	9b02      	ldr	r3, [sp, #8]
 8003398:	18d2      	adds	r2, r2, r3
 800339a:	9b03      	ldr	r3, [sp, #12]
 800339c:	18d3      	adds	r3, r2, r3
 800339e:	0018      	movs	r0, r3
 80033a0:	f7ff feb6 	bl	8003110 <port_timer_set_alarm.lto_priv.282>
 80033a4:	e000      	b.n	80033a8 <chVTDoResetI+0xe8>
      vtp->next->delta += vtp->delta;
 80033a6:	46c0      	nop			; (mov r8, r8)
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80033a8:	b005      	add	sp, #20
 80033aa:	bd00      	pop	{pc}
 80033ac:	08003bec 	.word	0x08003bec
 80033b0:	20000528 	.word	0x20000528
 80033b4:	20000544 	.word	0x20000544
	...

080033c0 <port_lock.lto_priv.261>:
  __ASM volatile ("cpsid i" : : : "memory");
 80033c0:	b672      	cpsid	i
}
 80033c2:	4770      	bx	lr
	...

080033d0 <port_unlock.lto_priv.256>:
  __ASM volatile ("cpsie i" : : : "memory");
 80033d0:	b662      	cpsie	i
}
 80033d2:	4770      	bx	lr
	...

080033e0 <port_lock_from_isr.lto_priv.277>:
static inline void port_lock_from_isr(void) {
 80033e0:	b510      	push	{r4, lr}
  port_lock();
 80033e2:	f7ff ffed 	bl	80033c0 <port_lock.lto_priv.261>
}
 80033e6:	bd10      	pop	{r4, pc}
	...

080033f0 <port_unlock_from_isr.lto_priv.273>:
static inline void port_unlock_from_isr(void) {
 80033f0:	b510      	push	{r4, lr}
  port_unlock();
 80033f2:	f7ff ffed 	bl	80033d0 <port_unlock.lto_priv.256>
}
 80033f6:	bd10      	pop	{r4, pc}
	...

08003400 <queue_init>:
static inline void queue_init(threads_queue_t *tqp) {
 8003400:	b082      	sub	sp, #8
 8003402:	9001      	str	r0, [sp, #4]
  tqp->next = (thread_t *)tqp;
 8003404:	9b01      	ldr	r3, [sp, #4]
 8003406:	9a01      	ldr	r2, [sp, #4]
 8003408:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800340a:	9b01      	ldr	r3, [sp, #4]
 800340c:	9a01      	ldr	r2, [sp, #4]
 800340e:	605a      	str	r2, [r3, #4]
}
 8003410:	b002      	add	sp, #8
 8003412:	4770      	bx	lr
	...

08003420 <queue_fifo_remove>:
static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8003420:	b084      	sub	sp, #16
 8003422:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
 8003424:	9b01      	ldr	r3, [sp, #4]
 8003426:	681b      	ldr	r3, [r3, #0]
 8003428:	9303      	str	r3, [sp, #12]
  tqp->next             = tp->queue.next;
 800342a:	9b03      	ldr	r3, [sp, #12]
 800342c:	681a      	ldr	r2, [r3, #0]
 800342e:	9b01      	ldr	r3, [sp, #4]
 8003430:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8003432:	9b01      	ldr	r3, [sp, #4]
 8003434:	681b      	ldr	r3, [r3, #0]
 8003436:	9a01      	ldr	r2, [sp, #4]
 8003438:	605a      	str	r2, [r3, #4]
  return tp;
 800343a:	9b03      	ldr	r3, [sp, #12]
}
 800343c:	0018      	movs	r0, r3
 800343e:	b004      	add	sp, #16
 8003440:	4770      	bx	lr
 8003442:	46c0      	nop			; (mov r8, r8)
	...

08003450 <queue_dequeue>:
static inline thread_t *queue_dequeue(thread_t *tp) {
 8003450:	b082      	sub	sp, #8
 8003452:	9001      	str	r0, [sp, #4]
  tp->queue.prev->queue.next = tp->queue.next;
 8003454:	9b01      	ldr	r3, [sp, #4]
 8003456:	685b      	ldr	r3, [r3, #4]
 8003458:	9a01      	ldr	r2, [sp, #4]
 800345a:	6812      	ldr	r2, [r2, #0]
 800345c:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800345e:	9b01      	ldr	r3, [sp, #4]
 8003460:	681b      	ldr	r3, [r3, #0]
 8003462:	9a01      	ldr	r2, [sp, #4]
 8003464:	6852      	ldr	r2, [r2, #4]
 8003466:	605a      	str	r2, [r3, #4]
  return tp;
 8003468:	9b01      	ldr	r3, [sp, #4]
}
 800346a:	0018      	movs	r0, r3
 800346c:	b002      	add	sp, #8
 800346e:	4770      	bx	lr

08003470 <chSchIsRescRequiredI>:
 * @retval false        if rescheduling is not necessary.
 * @retval true         if there is a ready thread at higher priority.
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {
 8003470:	b510      	push	{r4, lr}

  chDbgCheckClassI();
 8003472:	f7ff fcc5 	bl	8002e00 <chDbgCheckClassI>

  return firstprio(&ch.rlist.queue) > currp->prio;
 8003476:	4b06      	ldr	r3, [pc, #24]	; (8003490 <chSchIsRescRequiredI+0x20>)
 8003478:	681b      	ldr	r3, [r3, #0]
 800347a:	689a      	ldr	r2, [r3, #8]
 800347c:	4b04      	ldr	r3, [pc, #16]	; (8003490 <chSchIsRescRequiredI+0x20>)
 800347e:	699b      	ldr	r3, [r3, #24]
 8003480:	689b      	ldr	r3, [r3, #8]
 8003482:	4293      	cmp	r3, r2
 8003484:	419b      	sbcs	r3, r3
 8003486:	425b      	negs	r3, r3
 8003488:	b2db      	uxtb	r3, r3
}
 800348a:	0018      	movs	r0, r3
 800348c:	bd10      	pop	{r4, pc}
 800348e:	46c0      	nop			; (mov r8, r8)
 8003490:	20000528 	.word	0x20000528
	...

080034a0 <chSysLockFromISR.lto_priv.269>:
static inline void chSysLockFromISR(void) {
 80034a0:	b510      	push	{r4, lr}
  port_lock_from_isr();
 80034a2:	f7ff ff9d 	bl	80033e0 <port_lock_from_isr.lto_priv.277>
  _dbg_check_lock_from_isr();
 80034a6:	f7ff fc3b 	bl	8002d20 <_dbg_check_lock_from_isr>
}
 80034aa:	bd10      	pop	{r4, pc}
 80034ac:	0000      	movs	r0, r0
	...

080034b0 <chSysUnlockFromISR.lto_priv.267>:
static inline void chSysUnlockFromISR(void) {
 80034b0:	b510      	push	{r4, lr}
  _dbg_check_unlock_from_isr();
 80034b2:	f7ff fc4d 	bl	8002d50 <_dbg_check_unlock_from_isr>
  port_unlock_from_isr();
 80034b6:	f7ff ff9b 	bl	80033f0 <port_unlock_from_isr.lto_priv.273>
}
 80034ba:	bd10      	pop	{r4, pc}
 80034bc:	0000      	movs	r0, r0
	...

080034c0 <chVTIsArmedI>:
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 80034c0:	b500      	push	{lr}
 80034c2:	b083      	sub	sp, #12
 80034c4:	9001      	str	r0, [sp, #4]
  chDbgCheckClassI();
 80034c6:	f7ff fc9b 	bl	8002e00 <chDbgCheckClassI>
  return (bool)(vtp->func != NULL);
 80034ca:	9b01      	ldr	r3, [sp, #4]
 80034cc:	68db      	ldr	r3, [r3, #12]
 80034ce:	1e5a      	subs	r2, r3, #1
 80034d0:	4193      	sbcs	r3, r2
 80034d2:	b2db      	uxtb	r3, r3
}
 80034d4:	0018      	movs	r0, r3
 80034d6:	b003      	add	sp, #12
 80034d8:	bd00      	pop	{pc}
 80034da:	46c0      	nop			; (mov r8, r8)
 80034dc:	0000      	movs	r0, r0
	...

080034e0 <chSemFastSignalI>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 80034e0:	b500      	push	{lr}
 80034e2:	b083      	sub	sp, #12
 80034e4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 80034e6:	f7ff fc8b 	bl	8002e00 <chDbgCheckClassI>

  sp->cnt++;
 80034ea:	9b01      	ldr	r3, [sp, #4]
 80034ec:	689b      	ldr	r3, [r3, #8]
 80034ee:	1c5a      	adds	r2, r3, #1
 80034f0:	9b01      	ldr	r3, [sp, #4]
 80034f2:	609a      	str	r2, [r3, #8]
}
 80034f4:	b003      	add	sp, #12
 80034f6:	bd00      	pop	{pc}
	...

08003500 <_scheduler_init>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
 8003500:	b510      	push	{r4, lr}

  queue_init(&ch.rlist.queue);
 8003502:	4b07      	ldr	r3, [pc, #28]	; (8003520 <_scheduler_init+0x20>)
 8003504:	0018      	movs	r0, r3
 8003506:	f7ff ff7b 	bl	8003400 <queue_init>
  ch.rlist.prio = NOPRIO;
 800350a:	4b05      	ldr	r3, [pc, #20]	; (8003520 <_scheduler_init+0x20>)
 800350c:	2200      	movs	r2, #0
 800350e:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.newer = (thread_t *)&ch.rlist;
 8003510:	4b03      	ldr	r3, [pc, #12]	; (8003520 <_scheduler_init+0x20>)
 8003512:	4a03      	ldr	r2, [pc, #12]	; (8003520 <_scheduler_init+0x20>)
 8003514:	611a      	str	r2, [r3, #16]
  ch.rlist.older = (thread_t *)&ch.rlist;
 8003516:	4b02      	ldr	r3, [pc, #8]	; (8003520 <_scheduler_init+0x20>)
 8003518:	4a01      	ldr	r2, [pc, #4]	; (8003520 <_scheduler_init+0x20>)
 800351a:	615a      	str	r2, [r3, #20]
#endif
}
 800351c:	bd10      	pop	{r4, pc}
 800351e:	46c0      	nop			; (mov r8, r8)
 8003520:	20000528 	.word	0x20000528
	...

08003530 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8003530:	b500      	push	{lr}
 8003532:	b085      	sub	sp, #20
 8003534:	9001      	str	r0, [sp, #4]
  thread_t *cp;

  chDbgCheckClassI();
 8003536:	f7ff fc63 	bl	8002e00 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800353a:	9b01      	ldr	r3, [sp, #4]
 800353c:	2b00      	cmp	r3, #0
 800353e:	d103      	bne.n	8003548 <chSchReadyI+0x18>
 8003540:	4b19      	ldr	r3, [pc, #100]	; (80035a8 <chSchReadyI+0x78>)
 8003542:	0018      	movs	r0, r3
 8003544:	f7ff fb6c 	bl	8002c20 <chSysHalt>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8003548:	9b01      	ldr	r3, [sp, #4]
 800354a:	2220      	movs	r2, #32
 800354c:	5c9b      	ldrb	r3, [r3, r2]
 800354e:	2b00      	cmp	r3, #0
 8003550:	d004      	beq.n	800355c <chSchReadyI+0x2c>
 8003552:	9b01      	ldr	r3, [sp, #4]
 8003554:	2220      	movs	r2, #32
 8003556:	5c9b      	ldrb	r3, [r3, r2]
 8003558:	2b0f      	cmp	r3, #15
 800355a:	d103      	bne.n	8003564 <chSchReadyI+0x34>
 800355c:	4b12      	ldr	r3, [pc, #72]	; (80035a8 <chSchReadyI+0x78>)
 800355e:	0018      	movs	r0, r3
 8003560:	f7ff fb5e 	bl	8002c20 <chSysHalt>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8003564:	9b01      	ldr	r3, [sp, #4]
 8003566:	2220      	movs	r2, #32
 8003568:	2100      	movs	r1, #0
 800356a:	5499      	strb	r1, [r3, r2]
  cp = (thread_t *)&ch.rlist.queue;
 800356c:	4b0f      	ldr	r3, [pc, #60]	; (80035ac <chSchReadyI+0x7c>)
 800356e:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->queue.next;
 8003570:	9b03      	ldr	r3, [sp, #12]
 8003572:	681b      	ldr	r3, [r3, #0]
 8003574:	9303      	str	r3, [sp, #12]
  } while (cp->prio >= tp->prio);
 8003576:	9b03      	ldr	r3, [sp, #12]
 8003578:	689a      	ldr	r2, [r3, #8]
 800357a:	9b01      	ldr	r3, [sp, #4]
 800357c:	689b      	ldr	r3, [r3, #8]
 800357e:	429a      	cmp	r2, r3
 8003580:	d2f6      	bcs.n	8003570 <chSchReadyI+0x40>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8003582:	9b01      	ldr	r3, [sp, #4]
 8003584:	9a03      	ldr	r2, [sp, #12]
 8003586:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 8003588:	9b03      	ldr	r3, [sp, #12]
 800358a:	685a      	ldr	r2, [r3, #4]
 800358c:	9b01      	ldr	r3, [sp, #4]
 800358e:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8003590:	9b01      	ldr	r3, [sp, #4]
 8003592:	685b      	ldr	r3, [r3, #4]
 8003594:	9a01      	ldr	r2, [sp, #4]
 8003596:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 8003598:	9b03      	ldr	r3, [sp, #12]
 800359a:	9a01      	ldr	r2, [sp, #4]
 800359c:	605a      	str	r2, [r3, #4]

  return tp;
 800359e:	9b01      	ldr	r3, [sp, #4]
}
 80035a0:	0018      	movs	r0, r3
 80035a2:	b005      	add	sp, #20
 80035a4:	bd00      	pop	{pc}
 80035a6:	46c0      	nop			; (mov r8, r8)
 80035a8:	08003bfc 	.word	0x08003bfc
 80035ac:	20000528 	.word	0x20000528

080035b0 <chSchReadyAheadI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyAheadI(thread_t *tp) {
 80035b0:	b500      	push	{lr}
 80035b2:	b085      	sub	sp, #20
 80035b4:	9001      	str	r0, [sp, #4]
  thread_t *cp;

  chDbgCheckClassI();
 80035b6:	f7ff fc23 	bl	8002e00 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 80035ba:	9b01      	ldr	r3, [sp, #4]
 80035bc:	2b00      	cmp	r3, #0
 80035be:	d103      	bne.n	80035c8 <chSchReadyAheadI+0x18>
 80035c0:	4b19      	ldr	r3, [pc, #100]	; (8003628 <chSchReadyAheadI+0x78>)
 80035c2:	0018      	movs	r0, r3
 80035c4:	f7ff fb2c 	bl	8002c20 <chSysHalt>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 80035c8:	9b01      	ldr	r3, [sp, #4]
 80035ca:	2220      	movs	r2, #32
 80035cc:	5c9b      	ldrb	r3, [r3, r2]
 80035ce:	2b00      	cmp	r3, #0
 80035d0:	d004      	beq.n	80035dc <chSchReadyAheadI+0x2c>
 80035d2:	9b01      	ldr	r3, [sp, #4]
 80035d4:	2220      	movs	r2, #32
 80035d6:	5c9b      	ldrb	r3, [r3, r2]
 80035d8:	2b0f      	cmp	r3, #15
 80035da:	d103      	bne.n	80035e4 <chSchReadyAheadI+0x34>
 80035dc:	4b12      	ldr	r3, [pc, #72]	; (8003628 <chSchReadyAheadI+0x78>)
 80035de:	0018      	movs	r0, r3
 80035e0:	f7ff fb1e 	bl	8002c20 <chSysHalt>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80035e4:	9b01      	ldr	r3, [sp, #4]
 80035e6:	2220      	movs	r2, #32
 80035e8:	2100      	movs	r1, #0
 80035ea:	5499      	strb	r1, [r3, r2]
  cp = (thread_t *)&ch.rlist.queue;
 80035ec:	4b0f      	ldr	r3, [pc, #60]	; (800362c <chSchReadyAheadI+0x7c>)
 80035ee:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->queue.next;
 80035f0:	9b03      	ldr	r3, [sp, #12]
 80035f2:	681b      	ldr	r3, [r3, #0]
 80035f4:	9303      	str	r3, [sp, #12]
  } while (cp->prio > tp->prio);
 80035f6:	9b03      	ldr	r3, [sp, #12]
 80035f8:	689a      	ldr	r2, [r3, #8]
 80035fa:	9b01      	ldr	r3, [sp, #4]
 80035fc:	689b      	ldr	r3, [r3, #8]
 80035fe:	429a      	cmp	r2, r3
 8003600:	d8f6      	bhi.n	80035f0 <chSchReadyAheadI+0x40>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8003602:	9b01      	ldr	r3, [sp, #4]
 8003604:	9a03      	ldr	r2, [sp, #12]
 8003606:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 8003608:	9b03      	ldr	r3, [sp, #12]
 800360a:	685a      	ldr	r2, [r3, #4]
 800360c:	9b01      	ldr	r3, [sp, #4]
 800360e:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8003610:	9b01      	ldr	r3, [sp, #4]
 8003612:	685b      	ldr	r3, [r3, #4]
 8003614:	9a01      	ldr	r2, [sp, #4]
 8003616:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 8003618:	9b03      	ldr	r3, [sp, #12]
 800361a:	9a01      	ldr	r2, [sp, #4]
 800361c:	605a      	str	r2, [r3, #4]

  return tp;
 800361e:	9b01      	ldr	r3, [sp, #4]
}
 8003620:	0018      	movs	r0, r3
 8003622:	b005      	add	sp, #20
 8003624:	bd00      	pop	{pc}
 8003626:	46c0      	nop			; (mov r8, r8)
 8003628:	08003c08 	.word	0x08003c08
 800362c:	20000528 	.word	0x20000528

08003630 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8003630:	b510      	push	{r4, lr}
 8003632:	b084      	sub	sp, #16
 8003634:	0002      	movs	r2, r0
 8003636:	466b      	mov	r3, sp
 8003638:	3307      	adds	r3, #7
 800363a:	701a      	strb	r2, [r3, #0]
  thread_t *otp = currp;
 800363c:	4b1b      	ldr	r3, [pc, #108]	; (80036ac <chSchGoSleepS+0x7c>)
 800363e:	699b      	ldr	r3, [r3, #24]
 8003640:	9303      	str	r3, [sp, #12]

  chDbgCheckClassS();
 8003642:	f7ff fbf5 	bl	8002e30 <chDbgCheckClassS>

  /* New state.*/
  otp->state = newstate;
 8003646:	9b03      	ldr	r3, [sp, #12]
 8003648:	466a      	mov	r2, sp
 800364a:	3207      	adds	r2, #7
 800364c:	2120      	movs	r1, #32
 800364e:	7812      	ldrb	r2, [r2, #0]
 8003650:	545a      	strb	r2, [r3, r1]
     time quantum when it will wakeup.*/
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8003652:	4b16      	ldr	r3, [pc, #88]	; (80036ac <chSchGoSleepS+0x7c>)
 8003654:	0018      	movs	r0, r3
 8003656:	f7ff fee3 	bl	8003420 <queue_fifo_remove>
 800365a:	0002      	movs	r2, r0
 800365c:	4b13      	ldr	r3, [pc, #76]	; (80036ac <chSchGoSleepS+0x7c>)
 800365e:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 8003660:	4b12      	ldr	r3, [pc, #72]	; (80036ac <chSchGoSleepS+0x7c>)
 8003662:	699b      	ldr	r3, [r3, #24]
 8003664:	2220      	movs	r2, #32
 8003666:	2101      	movs	r1, #1
 8003668:	5499      	strb	r1, [r3, r2]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800366a:	4b10      	ldr	r3, [pc, #64]	; (80036ac <chSchGoSleepS+0x7c>)
 800366c:	699b      	ldr	r3, [r3, #24]
 800366e:	9a03      	ldr	r2, [sp, #12]
 8003670:	0011      	movs	r1, r2
 8003672:	0018      	movs	r0, r3
 8003674:	f7ff fc7c 	bl	8002f70 <_trace_switch>
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8003678:	f3ef 8309 	mrs	r3, PSP
 800367c:	001c      	movs	r4, r3
  return(result);
 800367e:	0023      	movs	r3, r4
 8003680:	9302      	str	r3, [sp, #8]
 8003682:	9b02      	ldr	r3, [sp, #8]
 8003684:	3b24      	subs	r3, #36	; 0x24
 8003686:	001a      	movs	r2, r3
 8003688:	9b03      	ldr	r3, [sp, #12]
 800368a:	69db      	ldr	r3, [r3, #28]
 800368c:	429a      	cmp	r2, r3
 800368e:	d203      	bcs.n	8003698 <chSchGoSleepS+0x68>
 8003690:	4b07      	ldr	r3, [pc, #28]	; (80036b0 <chSchGoSleepS+0x80>)
 8003692:	0018      	movs	r0, r3
 8003694:	f7ff fac4 	bl	8002c20 <chSysHalt>
 8003698:	4b04      	ldr	r3, [pc, #16]	; (80036ac <chSchGoSleepS+0x7c>)
 800369a:	699b      	ldr	r3, [r3, #24]
 800369c:	9a03      	ldr	r2, [sp, #12]
 800369e:	0011      	movs	r1, r2
 80036a0:	0018      	movs	r0, r3
 80036a2:	f7fc fd75 	bl	8000190 <_port_switch>
}
 80036a6:	b004      	add	sp, #16
 80036a8:	bd10      	pop	{r4, pc}
 80036aa:	46c0      	nop			; (mov r8, r8)
 80036ac:	20000528 	.word	0x20000528
 80036b0:	08003b2c 	.word	0x08003b2c
	...

080036c0 <wakeup>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 80036c0:	b500      	push	{lr}
 80036c2:	b085      	sub	sp, #20
 80036c4:	9001      	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
 80036c6:	9b01      	ldr	r3, [sp, #4]
 80036c8:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
 80036ca:	f7ff fee9 	bl	80034a0 <chSysLockFromISR.lto_priv.269>
  switch (tp->state) {
 80036ce:	9b03      	ldr	r3, [sp, #12]
 80036d0:	2220      	movs	r2, #32
 80036d2:	5c9b      	ldrb	r3, [r3, r2]
 80036d4:	2b07      	cmp	r3, #7
 80036d6:	d815      	bhi.n	8003704 <wakeup+0x44>
 80036d8:	009a      	lsls	r2, r3, #2
 80036da:	4b10      	ldr	r3, [pc, #64]	; (800371c <wakeup+0x5c>)
 80036dc:	18d3      	adds	r3, r2, r3
 80036de:	681b      	ldr	r3, [r3, #0]
 80036e0:	469f      	mov	pc, r3
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 80036e2:	f7ff fee5 	bl	80034b0 <chSysUnlockFromISR.lto_priv.267>
 80036e6:	e017      	b.n	8003718 <wakeup+0x58>
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 80036e8:	9b03      	ldr	r3, [sp, #12]
 80036ea:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80036ec:	2200      	movs	r2, #0
 80036ee:	601a      	str	r2, [r3, #0]
 80036f0:	e008      	b.n	8003704 <wakeup+0x44>
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 80036f2:	9b03      	ldr	r3, [sp, #12]
 80036f4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80036f6:	0018      	movs	r0, r3
 80036f8:	f7ff fef2 	bl	80034e0 <chSemFastSignalI>
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
 80036fc:	9b03      	ldr	r3, [sp, #12]
 80036fe:	0018      	movs	r0, r3
 8003700:	f7ff fea6 	bl	8003450 <queue_dequeue>
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 8003704:	9b03      	ldr	r3, [sp, #12]
 8003706:	2201      	movs	r2, #1
 8003708:	4252      	negs	r2, r2
 800370a:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 800370c:	9b03      	ldr	r3, [sp, #12]
 800370e:	0018      	movs	r0, r3
 8003710:	f7ff ff0e 	bl	8003530 <chSchReadyI>
  chSysUnlockFromISR();
 8003714:	f7ff fecc 	bl	80034b0 <chSysUnlockFromISR.lto_priv.267>
}
 8003718:	b005      	add	sp, #20
 800371a:	bd00      	pop	{pc}
 800371c:	08003efc 	.word	0x08003efc

08003720 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8003720:	b500      	push	{lr}
 8003722:	b089      	sub	sp, #36	; 0x24
 8003724:	0002      	movs	r2, r0
 8003726:	9100      	str	r1, [sp, #0]
 8003728:	466b      	mov	r3, sp
 800372a:	3307      	adds	r3, #7
 800372c:	701a      	strb	r2, [r3, #0]

  chDbgCheckClassS();
 800372e:	f7ff fb7f 	bl	8002e30 <chDbgCheckClassS>

  if (TIME_INFINITE != time) {
 8003732:	9b00      	ldr	r3, [sp, #0]
 8003734:	3301      	adds	r3, #1
 8003736:	d017      	beq.n	8003768 <chSchGoSleepTimeoutS+0x48>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8003738:	4b11      	ldr	r3, [pc, #68]	; (8003780 <chSchGoSleepTimeoutS+0x60>)
 800373a:	699b      	ldr	r3, [r3, #24]
 800373c:	4a11      	ldr	r2, [pc, #68]	; (8003784 <chSchGoSleepTimeoutS+0x64>)
 800373e:	9900      	ldr	r1, [sp, #0]
 8003740:	a803      	add	r0, sp, #12
 8003742:	f7ff fd1d 	bl	8003180 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8003746:	466b      	mov	r3, sp
 8003748:	3307      	adds	r3, #7
 800374a:	781b      	ldrb	r3, [r3, #0]
 800374c:	0018      	movs	r0, r3
 800374e:	f7ff ff6f 	bl	8003630 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8003752:	ab03      	add	r3, sp, #12
 8003754:	0018      	movs	r0, r3
 8003756:	f7ff feb3 	bl	80034c0 <chVTIsArmedI>
 800375a:	1e03      	subs	r3, r0, #0
 800375c:	d00a      	beq.n	8003774 <chSchGoSleepTimeoutS+0x54>
      chVTDoResetI(&vt);
 800375e:	ab03      	add	r3, sp, #12
 8003760:	0018      	movs	r0, r3
 8003762:	f7ff fdad 	bl	80032c0 <chVTDoResetI>
 8003766:	e005      	b.n	8003774 <chSchGoSleepTimeoutS+0x54>
    }
  }
  else {
    chSchGoSleepS(newstate);
 8003768:	466b      	mov	r3, sp
 800376a:	3307      	adds	r3, #7
 800376c:	781b      	ldrb	r3, [r3, #0]
 800376e:	0018      	movs	r0, r3
 8003770:	f7ff ff5e 	bl	8003630 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
 8003774:	4b02      	ldr	r3, [pc, #8]	; (8003780 <chSchGoSleepTimeoutS+0x60>)
 8003776:	699b      	ldr	r3, [r3, #24]
 8003778:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 800377a:	0018      	movs	r0, r3
 800377c:	b009      	add	sp, #36	; 0x24
 800377e:	bd00      	pop	{pc}
 8003780:	20000528 	.word	0x20000528
 8003784:	080036c1 	.word	0x080036c1
	...

08003790 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8003790:	b510      	push	{r4, lr}
 8003792:	b084      	sub	sp, #16
 8003794:	9001      	str	r0, [sp, #4]
 8003796:	9100      	str	r1, [sp, #0]
  thread_t *otp = currp;
 8003798:	4b27      	ldr	r3, [pc, #156]	; (8003838 <chSchWakeupS+0xa8>)
 800379a:	699b      	ldr	r3, [r3, #24]
 800379c:	9303      	str	r3, [sp, #12]

  chDbgCheckClassS();
 800379e:	f7ff fb47 	bl	8002e30 <chDbgCheckClassS>

  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80037a2:	4b25      	ldr	r3, [pc, #148]	; (8003838 <chSchWakeupS+0xa8>)
 80037a4:	681a      	ldr	r2, [r3, #0]
 80037a6:	4b24      	ldr	r3, [pc, #144]	; (8003838 <chSchWakeupS+0xa8>)
 80037a8:	429a      	cmp	r2, r3
 80037aa:	d00b      	beq.n	80037c4 <chSchWakeupS+0x34>
 80037ac:	4b22      	ldr	r3, [pc, #136]	; (8003838 <chSchWakeupS+0xa8>)
 80037ae:	699b      	ldr	r3, [r3, #24]
 80037b0:	689a      	ldr	r2, [r3, #8]
 80037b2:	4b21      	ldr	r3, [pc, #132]	; (8003838 <chSchWakeupS+0xa8>)
 80037b4:	681b      	ldr	r3, [r3, #0]
 80037b6:	689b      	ldr	r3, [r3, #8]
 80037b8:	429a      	cmp	r2, r3
 80037ba:	d203      	bcs.n	80037c4 <chSchWakeupS+0x34>
 80037bc:	4b1f      	ldr	r3, [pc, #124]	; (800383c <chSchWakeupS+0xac>)
 80037be:	0018      	movs	r0, r3
 80037c0:	f7ff fa2e 	bl	8002c20 <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 80037c4:	9b01      	ldr	r3, [sp, #4]
 80037c6:	9a00      	ldr	r2, [sp, #0]
 80037c8:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 80037ca:	9b01      	ldr	r3, [sp, #4]
 80037cc:	689a      	ldr	r2, [r3, #8]
 80037ce:	9b03      	ldr	r3, [sp, #12]
 80037d0:	689b      	ldr	r3, [r3, #8]
 80037d2:	429a      	cmp	r2, r3
 80037d4:	d804      	bhi.n	80037e0 <chSchWakeupS+0x50>
    (void) chSchReadyI(ntp);
 80037d6:	9b01      	ldr	r3, [sp, #4]
 80037d8:	0018      	movs	r0, r3
 80037da:	f7ff fea9 	bl	8003530 <chSchReadyI>
 80037de:	e028      	b.n	8003832 <chSchWakeupS+0xa2>
  }
  else {
    otp = chSchReadyI(otp);
 80037e0:	9b03      	ldr	r3, [sp, #12]
 80037e2:	0018      	movs	r0, r3
 80037e4:	f7ff fea4 	bl	8003530 <chSchReadyI>
 80037e8:	0003      	movs	r3, r0
 80037ea:	9303      	str	r3, [sp, #12]
    if (otp->prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
 80037ec:	4b12      	ldr	r3, [pc, #72]	; (8003838 <chSchWakeupS+0xa8>)
 80037ee:	9a01      	ldr	r2, [sp, #4]
 80037f0:	619a      	str	r2, [r3, #24]
    ntp->state = CH_STATE_CURRENT;
 80037f2:	9b01      	ldr	r3, [sp, #4]
 80037f4:	2220      	movs	r2, #32
 80037f6:	2101      	movs	r1, #1
 80037f8:	5499      	strb	r1, [r3, r2]

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 80037fa:	9a03      	ldr	r2, [sp, #12]
 80037fc:	9b01      	ldr	r3, [sp, #4]
 80037fe:	0011      	movs	r1, r2
 8003800:	0018      	movs	r0, r3
 8003802:	f7ff fbb5 	bl	8002f70 <_trace_switch>
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8003806:	f3ef 8309 	mrs	r3, PSP
 800380a:	001c      	movs	r4, r3
  return(result);
 800380c:	0023      	movs	r3, r4
 800380e:	9302      	str	r3, [sp, #8]
 8003810:	9b02      	ldr	r3, [sp, #8]
 8003812:	3b24      	subs	r3, #36	; 0x24
 8003814:	001a      	movs	r2, r3
 8003816:	9b03      	ldr	r3, [sp, #12]
 8003818:	69db      	ldr	r3, [r3, #28]
 800381a:	429a      	cmp	r2, r3
 800381c:	d203      	bcs.n	8003826 <chSchWakeupS+0x96>
 800381e:	4b08      	ldr	r3, [pc, #32]	; (8003840 <chSchWakeupS+0xb0>)
 8003820:	0018      	movs	r0, r3
 8003822:	f7ff f9fd 	bl	8002c20 <chSysHalt>
 8003826:	9a03      	ldr	r2, [sp, #12]
 8003828:	9b01      	ldr	r3, [sp, #4]
 800382a:	0011      	movs	r1, r2
 800382c:	0018      	movs	r0, r3
 800382e:	f7fc fcaf 	bl	8000190 <_port_switch>
  }
}
 8003832:	b004      	add	sp, #16
 8003834:	bd10      	pop	{r4, pc}
 8003836:	46c0      	nop			; (mov r8, r8)
 8003838:	20000528 	.word	0x20000528
 800383c:	08003c1c 	.word	0x08003c1c
 8003840:	08003b2c 	.word	0x08003b2c
	...

08003850 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 8003850:	b510      	push	{r4, lr}

  chDbgCheckClassS();
 8003852:	f7ff faed 	bl	8002e30 <chDbgCheckClassS>

  if (chSchIsRescRequiredI()) {
 8003856:	f7ff fe0b 	bl	8003470 <chSchIsRescRequiredI>
 800385a:	1e03      	subs	r3, r0, #0
 800385c:	d001      	beq.n	8003862 <chSchRescheduleS+0x12>
    chSchDoRescheduleAhead();
 800385e:	f000 f81f 	bl	80038a0 <chSchDoRescheduleAhead>
  }
}
 8003862:	bd10      	pop	{r4, pc}
	...

08003870 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 8003870:	b082      	sub	sp, #8
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8003872:	4b08      	ldr	r3, [pc, #32]	; (8003894 <chSchIsPreemptionRequired+0x24>)
 8003874:	681b      	ldr	r3, [r3, #0]
 8003876:	689b      	ldr	r3, [r3, #8]
 8003878:	9301      	str	r3, [sp, #4]
  tprio_t p2 = currp->prio;
 800387a:	4b06      	ldr	r3, [pc, #24]	; (8003894 <chSchIsPreemptionRequired+0x24>)
 800387c:	699b      	ldr	r3, [r3, #24]
 800387e:	689b      	ldr	r3, [r3, #8]
 8003880:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 8003882:	9b01      	ldr	r3, [sp, #4]
 8003884:	9a00      	ldr	r2, [sp, #0]
 8003886:	429a      	cmp	r2, r3
 8003888:	419b      	sbcs	r3, r3
 800388a:	425b      	negs	r3, r3
 800388c:	b2db      	uxtb	r3, r3
#endif
}
 800388e:	0018      	movs	r0, r3
 8003890:	b002      	add	sp, #8
 8003892:	4770      	bx	lr
 8003894:	20000528 	.word	0x20000528
	...

080038a0 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 80038a0:	b510      	push	{r4, lr}
 80038a2:	b082      	sub	sp, #8
  thread_t *otp = currp;
 80038a4:	4b1a      	ldr	r3, [pc, #104]	; (8003910 <chSchDoRescheduleAhead+0x70>)
 80038a6:	699b      	ldr	r3, [r3, #24]
 80038a8:	9301      	str	r3, [sp, #4]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 80038aa:	4b19      	ldr	r3, [pc, #100]	; (8003910 <chSchDoRescheduleAhead+0x70>)
 80038ac:	0018      	movs	r0, r3
 80038ae:	f7ff fdb7 	bl	8003420 <queue_fifo_remove>
 80038b2:	0002      	movs	r2, r0
 80038b4:	4b16      	ldr	r3, [pc, #88]	; (8003910 <chSchDoRescheduleAhead+0x70>)
 80038b6:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 80038b8:	4b15      	ldr	r3, [pc, #84]	; (8003910 <chSchDoRescheduleAhead+0x70>)
 80038ba:	699b      	ldr	r3, [r3, #24]
 80038bc:	2220      	movs	r2, #32
 80038be:	2101      	movs	r1, #1
 80038c0:	5499      	strb	r1, [r3, r2]
  if (otp->prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);
 80038c2:	9b01      	ldr	r3, [sp, #4]
 80038c4:	0018      	movs	r0, r3
 80038c6:	f7ff fe73 	bl	80035b0 <chSchReadyAheadI>
 80038ca:	0003      	movs	r3, r0
 80038cc:	9301      	str	r3, [sp, #4]

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 80038ce:	4b10      	ldr	r3, [pc, #64]	; (8003910 <chSchDoRescheduleAhead+0x70>)
 80038d0:	699b      	ldr	r3, [r3, #24]
 80038d2:	9a01      	ldr	r2, [sp, #4]
 80038d4:	0011      	movs	r1, r2
 80038d6:	0018      	movs	r0, r3
 80038d8:	f7ff fb4a 	bl	8002f70 <_trace_switch>
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80038dc:	f3ef 8309 	mrs	r3, PSP
 80038e0:	001c      	movs	r4, r3
  return(result);
 80038e2:	0023      	movs	r3, r4
 80038e4:	9300      	str	r3, [sp, #0]
 80038e6:	9b00      	ldr	r3, [sp, #0]
 80038e8:	3b24      	subs	r3, #36	; 0x24
 80038ea:	001a      	movs	r2, r3
 80038ec:	9b01      	ldr	r3, [sp, #4]
 80038ee:	69db      	ldr	r3, [r3, #28]
 80038f0:	429a      	cmp	r2, r3
 80038f2:	d203      	bcs.n	80038fc <chSchDoRescheduleAhead+0x5c>
 80038f4:	4b07      	ldr	r3, [pc, #28]	; (8003914 <chSchDoRescheduleAhead+0x74>)
 80038f6:	0018      	movs	r0, r3
 80038f8:	f7ff f992 	bl	8002c20 <chSysHalt>
 80038fc:	4b04      	ldr	r3, [pc, #16]	; (8003910 <chSchDoRescheduleAhead+0x70>)
 80038fe:	699b      	ldr	r3, [r3, #24]
 8003900:	9a01      	ldr	r2, [sp, #4]
 8003902:	0011      	movs	r1, r2
 8003904:	0018      	movs	r0, r3
 8003906:	f7fc fc43 	bl	8000190 <_port_switch>
}
 800390a:	b002      	add	sp, #8
 800390c:	bd10      	pop	{r4, pc}
 800390e:	46c0      	nop			; (mov r8, r8)
 8003910:	20000528 	.word	0x20000528
 8003914:	08003b2c 	.word	0x08003b2c
	...

08003920 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8003920:	b510      	push	{r4, lr}
 8003922:	b082      	sub	sp, #8
  thread_t *otp = currp;
 8003924:	4b1a      	ldr	r3, [pc, #104]	; (8003990 <chSchDoReschedule+0x70>)
 8003926:	699b      	ldr	r3, [r3, #24]
 8003928:	9301      	str	r3, [sp, #4]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800392a:	4b19      	ldr	r3, [pc, #100]	; (8003990 <chSchDoReschedule+0x70>)
 800392c:	0018      	movs	r0, r3
 800392e:	f7ff fd77 	bl	8003420 <queue_fifo_remove>
 8003932:	0002      	movs	r2, r0
 8003934:	4b16      	ldr	r3, [pc, #88]	; (8003990 <chSchDoReschedule+0x70>)
 8003936:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 8003938:	4b15      	ldr	r3, [pc, #84]	; (8003990 <chSchDoReschedule+0x70>)
 800393a:	699b      	ldr	r3, [r3, #24]
 800393c:	2220      	movs	r2, #32
 800393e:	2101      	movs	r1, #1
 8003940:	5499      	strb	r1, [r3, r2]
    otp = chSchReadyAheadI(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
 8003942:	9b01      	ldr	r3, [sp, #4]
 8003944:	0018      	movs	r0, r3
 8003946:	f7ff fe33 	bl	80035b0 <chSchReadyAheadI>
 800394a:	0003      	movs	r3, r0
 800394c:	9301      	str	r3, [sp, #4]
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800394e:	4b10      	ldr	r3, [pc, #64]	; (8003990 <chSchDoReschedule+0x70>)
 8003950:	699b      	ldr	r3, [r3, #24]
 8003952:	9a01      	ldr	r2, [sp, #4]
 8003954:	0011      	movs	r1, r2
 8003956:	0018      	movs	r0, r3
 8003958:	f7ff fb0a 	bl	8002f70 <_trace_switch>
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800395c:	f3ef 8309 	mrs	r3, PSP
 8003960:	001c      	movs	r4, r3
  return(result);
 8003962:	0023      	movs	r3, r4
 8003964:	9300      	str	r3, [sp, #0]
 8003966:	9b00      	ldr	r3, [sp, #0]
 8003968:	3b24      	subs	r3, #36	; 0x24
 800396a:	001a      	movs	r2, r3
 800396c:	9b01      	ldr	r3, [sp, #4]
 800396e:	69db      	ldr	r3, [r3, #28]
 8003970:	429a      	cmp	r2, r3
 8003972:	d203      	bcs.n	800397c <chSchDoReschedule+0x5c>
 8003974:	4b07      	ldr	r3, [pc, #28]	; (8003994 <chSchDoReschedule+0x74>)
 8003976:	0018      	movs	r0, r3
 8003978:	f7ff f952 	bl	8002c20 <chSysHalt>
 800397c:	4b04      	ldr	r3, [pc, #16]	; (8003990 <chSchDoReschedule+0x70>)
 800397e:	699b      	ldr	r3, [r3, #24]
 8003980:	9a01      	ldr	r2, [sp, #4]
 8003982:	0011      	movs	r1, r2
 8003984:	0018      	movs	r0, r3
 8003986:	f7fc fc03 	bl	8000190 <_port_switch>
}
 800398a:	b002      	add	sp, #8
 800398c:	bd10      	pop	{r4, pc}
 800398e:	46c0      	nop			; (mov r8, r8)
 8003990:	20000528 	.word	0x20000528
 8003994:	08003b2c 	.word	0x08003b2c
	...

080039a0 <port_lock.lto_priv.262>:
  __ASM volatile ("cpsid i" : : : "memory");
 80039a0:	b672      	cpsid	i
}
 80039a2:	4770      	bx	lr
	...

080039b0 <port_unlock.lto_priv.257>:
  __ASM volatile ("cpsie i" : : : "memory");
 80039b0:	b662      	cpsie	i
}
 80039b2:	4770      	bx	lr
	...

080039c0 <list_init.lto_priv.243>:
static inline void list_init(threads_list_t *tlp) {
 80039c0:	b082      	sub	sp, #8
 80039c2:	9001      	str	r0, [sp, #4]
  tlp->next = (thread_t *)tlp;
 80039c4:	9b01      	ldr	r3, [sp, #4]
 80039c6:	9a01      	ldr	r2, [sp, #4]
 80039c8:	601a      	str	r2, [r3, #0]
}
 80039ca:	b002      	add	sp, #8
 80039cc:	4770      	bx	lr
 80039ce:	46c0      	nop			; (mov r8, r8)

080039d0 <list_notempty.lto_priv.241>:
static inline bool list_notempty(threads_list_t *tlp) {
 80039d0:	b082      	sub	sp, #8
 80039d2:	9001      	str	r0, [sp, #4]
  return (bool)(tlp->next != (thread_t *)tlp);
 80039d4:	9b01      	ldr	r3, [sp, #4]
 80039d6:	681a      	ldr	r2, [r3, #0]
 80039d8:	9b01      	ldr	r3, [sp, #4]
 80039da:	1ad3      	subs	r3, r2, r3
 80039dc:	1e5a      	subs	r2, r3, #1
 80039de:	4193      	sbcs	r3, r2
 80039e0:	b2db      	uxtb	r3, r3
}
 80039e2:	0018      	movs	r0, r3
 80039e4:	b002      	add	sp, #8
 80039e6:	4770      	bx	lr
	...

080039f0 <queue_init.lto_priv.217>:
static inline void queue_init(threads_queue_t *tqp) {
 80039f0:	b082      	sub	sp, #8
 80039f2:	9001      	str	r0, [sp, #4]
  tqp->next = (thread_t *)tqp;
 80039f4:	9b01      	ldr	r3, [sp, #4]
 80039f6:	9a01      	ldr	r2, [sp, #4]
 80039f8:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80039fa:	9b01      	ldr	r3, [sp, #4]
 80039fc:	9a01      	ldr	r2, [sp, #4]
 80039fe:	605a      	str	r2, [r3, #4]
}
 8003a00:	b002      	add	sp, #8
 8003a02:	4770      	bx	lr
	...

08003a10 <list_remove.lto_priv.242>:
static inline thread_t *list_remove(threads_list_t *tlp) {
 8003a10:	b084      	sub	sp, #16
 8003a12:	9001      	str	r0, [sp, #4]
  thread_t *tp = tlp->next;
 8003a14:	9b01      	ldr	r3, [sp, #4]
 8003a16:	681b      	ldr	r3, [r3, #0]
 8003a18:	9303      	str	r3, [sp, #12]
  tlp->next = tp->queue.next;
 8003a1a:	9b03      	ldr	r3, [sp, #12]
 8003a1c:	681a      	ldr	r2, [r3, #0]
 8003a1e:	9b01      	ldr	r3, [sp, #4]
 8003a20:	601a      	str	r2, [r3, #0]
  return tp;
 8003a22:	9b03      	ldr	r3, [sp, #12]
}
 8003a24:	0018      	movs	r0, r3
 8003a26:	b004      	add	sp, #16
 8003a28:	4770      	bx	lr
 8003a2a:	46c0      	nop			; (mov r8, r8)
 8003a2c:	0000      	movs	r0, r0
	...

08003a30 <chSysLock.lto_priv.210>:
static inline void chSysLock(void) {
 8003a30:	b510      	push	{r4, lr}
  port_lock();
 8003a32:	f7ff ffb5 	bl	80039a0 <port_lock.lto_priv.262>
  _dbg_check_lock();
 8003a36:	f7ff f943 	bl	8002cc0 <_dbg_check_lock>
}
 8003a3a:	bd10      	pop	{r4, pc}
 8003a3c:	0000      	movs	r0, r0
	...

08003a40 <chSysUnlock.lto_priv.207>:
static inline void chSysUnlock(void) {
 8003a40:	b510      	push	{r4, lr}
  _dbg_check_unlock();
 8003a42:	f7ff f955 	bl	8002cf0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003a46:	4b0a      	ldr	r3, [pc, #40]	; (8003a70 <chSysUnlock.lto_priv.207+0x30>)
 8003a48:	681a      	ldr	r2, [r3, #0]
 8003a4a:	4b09      	ldr	r3, [pc, #36]	; (8003a70 <chSysUnlock.lto_priv.207+0x30>)
 8003a4c:	429a      	cmp	r2, r3
 8003a4e:	d00b      	beq.n	8003a68 <chSysUnlock.lto_priv.207+0x28>
 8003a50:	4b07      	ldr	r3, [pc, #28]	; (8003a70 <chSysUnlock.lto_priv.207+0x30>)
 8003a52:	699b      	ldr	r3, [r3, #24]
 8003a54:	689a      	ldr	r2, [r3, #8]
 8003a56:	4b06      	ldr	r3, [pc, #24]	; (8003a70 <chSysUnlock.lto_priv.207+0x30>)
 8003a58:	681b      	ldr	r3, [r3, #0]
 8003a5a:	689b      	ldr	r3, [r3, #8]
 8003a5c:	429a      	cmp	r2, r3
 8003a5e:	d203      	bcs.n	8003a68 <chSysUnlock.lto_priv.207+0x28>
 8003a60:	4b04      	ldr	r3, [pc, #16]	; (8003a74 <chSysUnlock.lto_priv.207+0x34>)
 8003a62:	0018      	movs	r0, r3
 8003a64:	f7ff f8dc 	bl	8002c20 <chSysHalt>
  port_unlock();
 8003a68:	f7ff ffa2 	bl	80039b0 <port_unlock.lto_priv.257>
}
 8003a6c:	bd10      	pop	{r4, pc}
 8003a6e:	46c0      	nop			; (mov r8, r8)
 8003a70:	20000528 	.word	0x20000528
 8003a74:	08003c44 	.word	0x08003c44
	...

08003a80 <chThdGetWorkingAreaX.lto_priv.220>:
static inline stkalign_t *chThdGetWorkingAreaX(thread_t *tp) {
 8003a80:	b082      	sub	sp, #8
 8003a82:	9001      	str	r0, [sp, #4]
  return tp->wabase;
 8003a84:	9b01      	ldr	r3, [sp, #4]
 8003a86:	69db      	ldr	r3, [r3, #28]
}
 8003a88:	0018      	movs	r0, r3
 8003a8a:	b002      	add	sp, #8
 8003a8c:	4770      	bx	lr
 8003a8e:	46c0      	nop			; (mov r8, r8)

08003a90 <chThdSleepS.lto_priv.237>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {
 8003a90:	b500      	push	{lr}
 8003a92:	b083      	sub	sp, #12
 8003a94:	9001      	str	r0, [sp, #4]

  chDbgCheck(time != TIME_IMMEDIATE);
 8003a96:	9b01      	ldr	r3, [sp, #4]
 8003a98:	2b00      	cmp	r3, #0
 8003a9a:	d103      	bne.n	8003aa4 <chThdSleepS.lto_priv.237+0x14>
 8003a9c:	4b05      	ldr	r3, [pc, #20]	; (8003ab4 <chThdSleepS.lto_priv.237+0x24>)
 8003a9e:	0018      	movs	r0, r3
 8003aa0:	f7ff f8be 	bl	8002c20 <chSysHalt>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8003aa4:	9b01      	ldr	r3, [sp, #4]
 8003aa6:	0019      	movs	r1, r3
 8003aa8:	2008      	movs	r0, #8
 8003aaa:	f7ff fe39 	bl	8003720 <chSchGoSleepTimeoutS>
}
 8003aae:	b003      	add	sp, #12
 8003ab0:	bd00      	pop	{pc}
 8003ab2:	46c0      	nop			; (mov r8, r8)
 8003ab4:	08003c78 	.word	0x08003c78
