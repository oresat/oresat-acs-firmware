
build/acs_f0_blinky.elf:     file format elf32-littlearm


Disassembly of section .text:

080000c0 <Reset_Handler>:
 80000c0:	b672      	cpsid	i
 80000c2:	4824      	ldr	r0, [pc, #144]	; (8000154 <endfiniloop+0x6>)
 80000c4:	f380 8808 	msr	MSP, r0
 80000c8:	4823      	ldr	r0, [pc, #140]	; (8000158 <endfiniloop+0xa>)
 80000ca:	f380 8809 	msr	PSP, r0
 80000ce:	2002      	movs	r0, #2
 80000d0:	f380 8814 	msr	CONTROL, r0
 80000d4:	f3bf 8f6f 	isb	sy
 80000d8:	f002 fc12 	bl	8002900 <__core_init>
 80000dc:	f000 fa48 	bl	8000570 <__early_init>
 80000e0:	481e      	ldr	r0, [pc, #120]	; (800015c <endfiniloop+0xe>)
 80000e2:	491f      	ldr	r1, [pc, #124]	; (8000160 <endfiniloop+0x12>)
 80000e4:	4a1b      	ldr	r2, [pc, #108]	; (8000154 <endfiniloop+0x6>)

080000e6 <msloop>:
 80000e6:	4291      	cmp	r1, r2
 80000e8:	da02      	bge.n	80000f0 <endmsloop>
 80000ea:	6008      	str	r0, [r1, #0]
 80000ec:	3104      	adds	r1, #4
 80000ee:	e7fa      	b.n	80000e6 <msloop>

080000f0 <endmsloop>:
 80000f0:	491c      	ldr	r1, [pc, #112]	; (8000164 <endfiniloop+0x16>)
 80000f2:	4a19      	ldr	r2, [pc, #100]	; (8000158 <endfiniloop+0xa>)

080000f4 <psloop>:
 80000f4:	4291      	cmp	r1, r2
 80000f6:	da02      	bge.n	80000fe <endpsloop>
 80000f8:	6008      	str	r0, [r1, #0]
 80000fa:	3104      	adds	r1, #4
 80000fc:	e7fa      	b.n	80000f4 <psloop>

080000fe <endpsloop>:
 80000fe:	491a      	ldr	r1, [pc, #104]	; (8000168 <endfiniloop+0x1a>)
 8000100:	4a1a      	ldr	r2, [pc, #104]	; (800016c <endfiniloop+0x1e>)
 8000102:	4b1b      	ldr	r3, [pc, #108]	; (8000170 <endfiniloop+0x22>)

08000104 <dloop>:
 8000104:	429a      	cmp	r2, r3
 8000106:	da04      	bge.n	8000112 <enddloop>
 8000108:	6808      	ldr	r0, [r1, #0]
 800010a:	6010      	str	r0, [r2, #0]
 800010c:	3104      	adds	r1, #4
 800010e:	3204      	adds	r2, #4
 8000110:	e7f8      	b.n	8000104 <dloop>

08000112 <enddloop>:
 8000112:	2000      	movs	r0, #0
 8000114:	4917      	ldr	r1, [pc, #92]	; (8000174 <endfiniloop+0x26>)
 8000116:	4a18      	ldr	r2, [pc, #96]	; (8000178 <endfiniloop+0x2a>)

08000118 <bloop>:
 8000118:	4291      	cmp	r1, r2
 800011a:	da02      	bge.n	8000122 <endbloop>
 800011c:	6008      	str	r0, [r1, #0]
 800011e:	3104      	adds	r1, #4
 8000120:	e7fa      	b.n	8000118 <bloop>

08000122 <endbloop>:
 8000122:	f002 fc05 	bl	8002930 <__init_ram_areas>
 8000126:	f002 fbf3 	bl	8002910 <__late_init>
 800012a:	4c14      	ldr	r4, [pc, #80]	; (800017c <endfiniloop+0x2e>)
 800012c:	4d14      	ldr	r5, [pc, #80]	; (8000180 <endfiniloop+0x32>)

0800012e <initloop>:
 800012e:	42ac      	cmp	r4, r5
 8000130:	da03      	bge.n	800013a <endinitloop>
 8000132:	6821      	ldr	r1, [r4, #0]
 8000134:	4788      	blx	r1
 8000136:	3404      	adds	r4, #4
 8000138:	e7f9      	b.n	800012e <initloop>

0800013a <endinitloop>:
 800013a:	f000 fac9 	bl	80006d0 <main>
 800013e:	4c11      	ldr	r4, [pc, #68]	; (8000184 <endfiniloop+0x36>)
 8000140:	4d11      	ldr	r5, [pc, #68]	; (8000188 <endfiniloop+0x3a>)

08000142 <finiloop>:
 8000142:	42ac      	cmp	r4, r5
 8000144:	da03      	bge.n	800014e <endfiniloop>
 8000146:	6821      	ldr	r1, [r4, #0]
 8000148:	4788      	blx	r1
 800014a:	3404      	adds	r4, #4
 800014c:	e7f9      	b.n	8000142 <finiloop>

0800014e <endfiniloop>:
 800014e:	490f      	ldr	r1, [pc, #60]	; (800018c <endfiniloop+0x3e>)
 8000150:	4708      	bx	r1
 8000152:	0000      	.short	0x0000
 8000154:	20000200 	.word	0x20000200
 8000158:	20000400 	.word	0x20000400
 800015c:	55555555 	.word	0x55555555
 8000160:	20000000 	.word	0x20000000
 8000164:	20000200 	.word	0x20000200
 8000168:	08003b8c 	.word	0x08003b8c
 800016c:	20000400 	.word	0x20000400
 8000170:	20000400 	.word	0x20000400
 8000174:	20000400 	.word	0x20000400
 8000178:	200016c0 	.word	0x200016c0
 800017c:	080000c0 	.word	0x080000c0
 8000180:	080000c0 	.word	0x080000c0
 8000184:	080000c0 	.word	0x080000c0
 8000188:	080000c0 	.word	0x080000c0
 800018c:	08002921 	.word	0x08002921

08000190 <_port_switch>:
 8000190:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000192:	4644      	mov	r4, r8
 8000194:	464d      	mov	r5, r9
 8000196:	4656      	mov	r6, sl
 8000198:	465f      	mov	r7, fp
 800019a:	b4f0      	push	{r4, r5, r6, r7}
 800019c:	466b      	mov	r3, sp
 800019e:	60cb      	str	r3, [r1, #12]
 80001a0:	68c3      	ldr	r3, [r0, #12]
 80001a2:	469d      	mov	sp, r3
 80001a4:	bcf0      	pop	{r4, r5, r6, r7}
 80001a6:	46a0      	mov	r8, r4
 80001a8:	46a9      	mov	r9, r5
 80001aa:	46b2      	mov	sl, r6
 80001ac:	46bb      	mov	fp, r7
 80001ae:	bdf0      	pop	{r4, r5, r6, r7, pc}

080001b0 <_port_thread_start>:
 80001b0:	f002 fe1e 	bl	8002df0 <_dbg_check_unlock>
 80001b4:	b662      	cpsie	i
 80001b6:	1c28      	adds	r0, r5, #0
 80001b8:	47a0      	blx	r4
 80001ba:	2000      	movs	r0, #0
 80001bc:	f002 fa48 	bl	8002650 <chThdExit>

080001c0 <_port_switch_from_isr>:
 80001c0:	f002 fdfe 	bl	8002dc0 <_dbg_check_lock>
 80001c4:	f001 ffbc 	bl	8002140 <chSchDoReschedule>
 80001c8:	f002 fe12 	bl	8002df0 <_dbg_check_unlock>

080001cc <_port_exit_from_isr>:
 80001cc:	4a01      	ldr	r2, [pc, #4]	; (80001d4 <_port_exit_from_isr+0x8>)
 80001ce:	4b02      	ldr	r3, [pc, #8]	; (80001d8 <_port_exit_from_isr+0xc>)
 80001d0:	6013      	str	r3, [r2, #0]
 80001d2:	e7fe      	b.n	80001d2 <_port_exit_from_isr+0x6>
 80001d4:	e000ed04 	.word	0xe000ed04
 80001d8:	80000000 	.word	0x80000000
 80001dc:	00000000 	.word	0x00000000

080001e0 <spi_lld_start>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_start(SPIDriver *spip) {
 80001e0:	b510      	push	{r4, lr}
 80001e2:	b084      	sub	sp, #16
 80001e4:	9001      	str	r0, [sp, #4]
  uint32_t ds;

  /* If in stopped state then enables the SPI and DMA clocks.*/
  if (spip->state == SPI_STOP) {
 80001e6:	9b01      	ldr	r3, [sp, #4]
 80001e8:	781b      	ldrb	r3, [r3, #0]
 80001ea:	2b01      	cmp	r3, #1
 80001ec:	d140      	bne.n	8000270 <spi_lld_start+0x90>
#if STM32_SPI_USE_SPI1
    if (&SPID1 == spip) {
 80001ee:	9a01      	ldr	r2, [sp, #4]
 80001f0:	4b47      	ldr	r3, [pc, #284]	; (8000310 <spi_lld_start+0x130>)
 80001f2:	429a      	cmp	r2, r3
 80001f4:	d12e      	bne.n	8000254 <spi_lld_start+0x74>
      bool b;
      b = dmaStreamAllocate(spip->dmarx,
 80001f6:	9b01      	ldr	r3, [sp, #4]
 80001f8:	6a18      	ldr	r0, [r3, #32]
 80001fa:	240f      	movs	r4, #15
 80001fc:	446c      	add	r4, sp
 80001fe:	9b01      	ldr	r3, [sp, #4]
 8000200:	4a44      	ldr	r2, [pc, #272]	; (8000314 <spi_lld_start+0x134>)
 8000202:	2102      	movs	r1, #2
 8000204:	f000 feac 	bl	8000f60 <dmaStreamAllocate>
 8000208:	0003      	movs	r3, r0
 800020a:	7023      	strb	r3, [r4, #0]
                            STM32_SPI_SPI1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_rx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
 800020c:	230f      	movs	r3, #15
 800020e:	446b      	add	r3, sp
 8000210:	781b      	ldrb	r3, [r3, #0]
 8000212:	2b00      	cmp	r3, #0
 8000214:	d003      	beq.n	800021e <spi_lld_start+0x3e>
 8000216:	4b40      	ldr	r3, [pc, #256]	; (8000318 <spi_lld_start+0x138>)
 8000218:	0018      	movs	r0, r3
 800021a:	f002 fd81 	bl	8002d20 <chSysHalt>
      b = dmaStreamAllocate(spip->dmatx,
 800021e:	9b01      	ldr	r3, [sp, #4]
 8000220:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8000222:	240f      	movs	r4, #15
 8000224:	446c      	add	r4, sp
 8000226:	9b01      	ldr	r3, [sp, #4]
 8000228:	4a3c      	ldr	r2, [pc, #240]	; (800031c <spi_lld_start+0x13c>)
 800022a:	2102      	movs	r1, #2
 800022c:	f000 fe98 	bl	8000f60 <dmaStreamAllocate>
 8000230:	0003      	movs	r3, r0
 8000232:	7023      	strb	r3, [r4, #0]
                            STM32_SPI_SPI1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_tx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
 8000234:	230f      	movs	r3, #15
 8000236:	446b      	add	r3, sp
 8000238:	781b      	ldrb	r3, [r3, #0]
 800023a:	2b00      	cmp	r3, #0
 800023c:	d003      	beq.n	8000246 <spi_lld_start+0x66>
 800023e:	4b36      	ldr	r3, [pc, #216]	; (8000318 <spi_lld_start+0x138>)
 8000240:	0018      	movs	r0, r3
 8000242:	f002 fd6d 	bl	8002d20 <chSysHalt>
      rccEnableSPI1(FALSE);
 8000246:	4b36      	ldr	r3, [pc, #216]	; (8000320 <spi_lld_start+0x140>)
 8000248:	4a35      	ldr	r2, [pc, #212]	; (8000320 <spi_lld_start+0x140>)
 800024a:	6992      	ldr	r2, [r2, #24]
 800024c:	2180      	movs	r1, #128	; 0x80
 800024e:	0149      	lsls	r1, r1, #5
 8000250:	430a      	orrs	r2, r1
 8000252:	619a      	str	r2, [r3, #24]
      rccEnableSPI6(FALSE);
    }
#endif

    /* DMA setup.*/
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 8000254:	9b01      	ldr	r3, [sp, #4]
 8000256:	6a1b      	ldr	r3, [r3, #32]
 8000258:	685b      	ldr	r3, [r3, #4]
 800025a:	9a01      	ldr	r2, [sp, #4]
 800025c:	69d2      	ldr	r2, [r2, #28]
 800025e:	320c      	adds	r2, #12
 8000260:	609a      	str	r2, [r3, #8]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 8000262:	9b01      	ldr	r3, [sp, #4]
 8000264:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000266:	685b      	ldr	r3, [r3, #4]
 8000268:	9a01      	ldr	r2, [sp, #4]
 800026a:	69d2      	ldr	r2, [r2, #28]
 800026c:	320c      	adds	r2, #12
 800026e:	609a      	str	r2, [r3, #8]
  }

  /* Configuration-specific DMA setup.*/
  ds = spip->config->cr2 & SPI_CR2_DS;
 8000270:	9b01      	ldr	r3, [sp, #4]
 8000272:	685b      	ldr	r3, [r3, #4]
 8000274:	899b      	ldrh	r3, [r3, #12]
 8000276:	001a      	movs	r2, r3
 8000278:	23f0      	movs	r3, #240	; 0xf0
 800027a:	011b      	lsls	r3, r3, #4
 800027c:	4013      	ands	r3, r2
 800027e:	9302      	str	r3, [sp, #8]
  if (!ds || (ds <= (SPI_CR2_DS_2 | SPI_CR2_DS_1 | SPI_CR2_DS_0))) {
 8000280:	9b02      	ldr	r3, [sp, #8]
 8000282:	2b00      	cmp	r3, #0
 8000284:	d004      	beq.n	8000290 <spi_lld_start+0xb0>
 8000286:	9a02      	ldr	r2, [sp, #8]
 8000288:	23e0      	movs	r3, #224	; 0xe0
 800028a:	00db      	lsls	r3, r3, #3
 800028c:	429a      	cmp	r2, r3
 800028e:	d80c      	bhi.n	80002aa <spi_lld_start+0xca>
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 8000290:	9b01      	ldr	r3, [sp, #4]
 8000292:	6a9b      	ldr	r3, [r3, #40]	; 0x28
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 8000294:	4a23      	ldr	r2, [pc, #140]	; (8000324 <spi_lld_start+0x144>)
 8000296:	401a      	ands	r2, r3
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 8000298:	9b01      	ldr	r3, [sp, #4]
 800029a:	629a      	str	r2, [r3, #40]	; 0x28
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800029c:	9b01      	ldr	r3, [sp, #4]
 800029e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 80002a0:	4a20      	ldr	r2, [pc, #128]	; (8000324 <spi_lld_start+0x144>)
 80002a2:	401a      	ands	r2, r3
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 80002a4:	9b01      	ldr	r3, [sp, #4]
 80002a6:	62da      	str	r2, [r3, #44]	; 0x2c
 80002a8:	e011      	b.n	80002ce <spi_lld_start+0xee>
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 80002aa:	9b01      	ldr	r3, [sp, #4]
 80002ac:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80002ae:	4a1d      	ldr	r2, [pc, #116]	; (8000324 <spi_lld_start+0x144>)
 80002b0:	4013      	ands	r3, r2
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 80002b2:	22a0      	movs	r2, #160	; 0xa0
 80002b4:	00d2      	lsls	r2, r2, #3
 80002b6:	431a      	orrs	r2, r3
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 80002b8:	9b01      	ldr	r3, [sp, #4]
 80002ba:	629a      	str	r2, [r3, #40]	; 0x28
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 80002bc:	9b01      	ldr	r3, [sp, #4]
 80002be:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80002c0:	4a18      	ldr	r2, [pc, #96]	; (8000324 <spi_lld_start+0x144>)
 80002c2:	4013      	ands	r3, r2
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 80002c4:	22a0      	movs	r2, #160	; 0xa0
 80002c6:	00d2      	lsls	r2, r2, #3
 80002c8:	431a      	orrs	r2, r3
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 80002ca:	9b01      	ldr	r3, [sp, #4]
 80002cc:	62da      	str	r2, [r3, #44]	; 0x2c
  }

  /* SPI setup and enable.*/
  spip->spi->CR1  = 0;
 80002ce:	9b01      	ldr	r3, [sp, #4]
 80002d0:	69db      	ldr	r3, [r3, #28]
 80002d2:	2200      	movs	r2, #0
 80002d4:	601a      	str	r2, [r3, #0]
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR;
 80002d6:	9b01      	ldr	r3, [sp, #4]
 80002d8:	69db      	ldr	r3, [r3, #28]
 80002da:	9a01      	ldr	r2, [sp, #4]
 80002dc:	6852      	ldr	r2, [r2, #4]
 80002de:	8952      	ldrh	r2, [r2, #10]
 80002e0:	2104      	movs	r1, #4
 80002e2:	430a      	orrs	r2, r1
 80002e4:	b292      	uxth	r2, r2
 80002e6:	601a      	str	r2, [r3, #0]
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_FRXTH | SPI_CR2_SSOE |
 80002e8:	9b01      	ldr	r3, [sp, #4]
 80002ea:	69db      	ldr	r3, [r3, #28]
 80002ec:	9a01      	ldr	r2, [sp, #4]
 80002ee:	6852      	ldr	r2, [r2, #4]
 80002f0:	8992      	ldrh	r2, [r2, #12]
 80002f2:	490d      	ldr	r1, [pc, #52]	; (8000328 <spi_lld_start+0x148>)
 80002f4:	430a      	orrs	r2, r1
 80002f6:	b292      	uxth	r2, r2
 80002f8:	605a      	str	r2, [r3, #4]
                    SPI_CR2_RXDMAEN | SPI_CR2_TXDMAEN;
  spip->spi->CR1 |= SPI_CR1_SPE;
 80002fa:	9b01      	ldr	r3, [sp, #4]
 80002fc:	69db      	ldr	r3, [r3, #28]
 80002fe:	9a01      	ldr	r2, [sp, #4]
 8000300:	69d2      	ldr	r2, [r2, #28]
 8000302:	6812      	ldr	r2, [r2, #0]
 8000304:	2140      	movs	r1, #64	; 0x40
 8000306:	430a      	orrs	r2, r1
 8000308:	601a      	str	r2, [r3, #0]
}
 800030a:	b004      	add	sp, #16
 800030c:	bd10      	pop	{r4, pc}
 800030e:	46c0      	nop			; (mov r8, r8)
 8000310:	20000db4 	.word	0x20000db4
 8000314:	08001321 	.word	0x08001321
 8000318:	08003aac 	.word	0x08003aac
 800031c:	080013e1 	.word	0x080013e1
 8000320:	40021000 	.word	0x40021000
 8000324:	fffff0ff 	.word	0xfffff0ff
 8000328:	00001007 	.word	0x00001007
 800032c:	00000000 	.word	0x00000000

08000330 <spi_lld_select>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_select(SPIDriver *spip) {
 8000330:	b082      	sub	sp, #8
 8000332:	9001      	str	r0, [sp, #4]

  palClearPad(spip->config->ssport, spip->config->sspad);
 8000334:	9b01      	ldr	r3, [sp, #4]
 8000336:	685b      	ldr	r3, [r3, #4]
 8000338:	685a      	ldr	r2, [r3, #4]
 800033a:	9b01      	ldr	r3, [sp, #4]
 800033c:	685b      	ldr	r3, [r3, #4]
 800033e:	891b      	ldrh	r3, [r3, #8]
 8000340:	0019      	movs	r1, r3
 8000342:	2301      	movs	r3, #1
 8000344:	408b      	lsls	r3, r1
 8000346:	b29b      	uxth	r3, r3
 8000348:	8353      	strh	r3, [r2, #26]
}
 800034a:	b002      	add	sp, #8
 800034c:	4770      	bx	lr
 800034e:	46c0      	nop			; (mov r8, r8)

08000350 <spi_lld_unselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_unselect(SPIDriver *spip) {
 8000350:	b082      	sub	sp, #8
 8000352:	9001      	str	r0, [sp, #4]

  palSetPad(spip->config->ssport, spip->config->sspad);
 8000354:	9b01      	ldr	r3, [sp, #4]
 8000356:	685b      	ldr	r3, [r3, #4]
 8000358:	685a      	ldr	r2, [r3, #4]
 800035a:	9b01      	ldr	r3, [sp, #4]
 800035c:	685b      	ldr	r3, [r3, #4]
 800035e:	891b      	ldrh	r3, [r3, #8]
 8000360:	0019      	movs	r1, r3
 8000362:	2301      	movs	r3, #1
 8000364:	408b      	lsls	r3, r1
 8000366:	b29b      	uxth	r3, r3
 8000368:	8313      	strh	r3, [r2, #24]
}
 800036a:	b002      	add	sp, #8
 800036c:	4770      	bx	lr
 800036e:	46c0      	nop			; (mov r8, r8)

08000370 <spi_lld_exchange>:
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @notapi
 */
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {
 8000370:	b500      	push	{lr}
 8000372:	b085      	sub	sp, #20
 8000374:	9003      	str	r0, [sp, #12]
 8000376:	9102      	str	r1, [sp, #8]
 8000378:	9201      	str	r2, [sp, #4]
 800037a:	9300      	str	r3, [sp, #0]

  osalDbgAssert(n < 65536, "unsupported DMA transfer size");
 800037c:	9b02      	ldr	r3, [sp, #8]
 800037e:	4a20      	ldr	r2, [pc, #128]	; (8000400 <spi_lld_exchange+0x90>)
 8000380:	4293      	cmp	r3, r2
 8000382:	d903      	bls.n	800038c <spi_lld_exchange+0x1c>
 8000384:	4b1f      	ldr	r3, [pc, #124]	; (8000404 <spi_lld_exchange+0x94>)
 8000386:	0018      	movs	r0, r3
 8000388:	f002 fcca 	bl	8002d20 <chSysHalt>

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 800038c:	9b03      	ldr	r3, [sp, #12]
 800038e:	6a1b      	ldr	r3, [r3, #32]
 8000390:	685b      	ldr	r3, [r3, #4]
 8000392:	9a00      	ldr	r2, [sp, #0]
 8000394:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 8000396:	9b03      	ldr	r3, [sp, #12]
 8000398:	6a1b      	ldr	r3, [r3, #32]
 800039a:	685b      	ldr	r3, [r3, #4]
 800039c:	9a02      	ldr	r2, [sp, #8]
 800039e:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 80003a0:	9b03      	ldr	r3, [sp, #12]
 80003a2:	6a1b      	ldr	r3, [r3, #32]
 80003a4:	685b      	ldr	r3, [r3, #4]
 80003a6:	9a03      	ldr	r2, [sp, #12]
 80003a8:	6a92      	ldr	r2, [r2, #40]	; 0x28
 80003aa:	2180      	movs	r1, #128	; 0x80
 80003ac:	430a      	orrs	r2, r1
 80003ae:	601a      	str	r2, [r3, #0]

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 80003b0:	9b03      	ldr	r3, [sp, #12]
 80003b2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80003b4:	685b      	ldr	r3, [r3, #4]
 80003b6:	9a01      	ldr	r2, [sp, #4]
 80003b8:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 80003ba:	9b03      	ldr	r3, [sp, #12]
 80003bc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80003be:	685b      	ldr	r3, [r3, #4]
 80003c0:	9a02      	ldr	r2, [sp, #8]
 80003c2:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 80003c4:	9b03      	ldr	r3, [sp, #12]
 80003c6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80003c8:	685b      	ldr	r3, [r3, #4]
 80003ca:	9a03      	ldr	r2, [sp, #12]
 80003cc:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80003ce:	2180      	movs	r1, #128	; 0x80
 80003d0:	430a      	orrs	r2, r1
 80003d2:	601a      	str	r2, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 80003d4:	9b03      	ldr	r3, [sp, #12]
 80003d6:	6a1b      	ldr	r3, [r3, #32]
 80003d8:	685b      	ldr	r3, [r3, #4]
 80003da:	9a03      	ldr	r2, [sp, #12]
 80003dc:	6a12      	ldr	r2, [r2, #32]
 80003de:	6852      	ldr	r2, [r2, #4]
 80003e0:	6812      	ldr	r2, [r2, #0]
 80003e2:	2101      	movs	r1, #1
 80003e4:	430a      	orrs	r2, r1
 80003e6:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(spip->dmatx);
 80003e8:	9b03      	ldr	r3, [sp, #12]
 80003ea:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80003ec:	685b      	ldr	r3, [r3, #4]
 80003ee:	9a03      	ldr	r2, [sp, #12]
 80003f0:	6a52      	ldr	r2, [r2, #36]	; 0x24
 80003f2:	6852      	ldr	r2, [r2, #4]
 80003f4:	6812      	ldr	r2, [r2, #0]
 80003f6:	2101      	movs	r1, #1
 80003f8:	430a      	orrs	r2, r1
 80003fa:	601a      	str	r2, [r3, #0]
}
 80003fc:	b005      	add	sp, #20
 80003fe:	bd00      	pop	{pc}
 8000400:	0000ffff 	.word	0x0000ffff
 8000404:	08003abc 	.word	0x08003abc
	...

08000410 <port_lock>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000410:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8000412:	4770      	bx	lr
	...

08000420 <port_unlock>:
  __ASM volatile ("cpsie i" : : : "memory");
 8000420:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8000422:	4770      	bx	lr
	...

08000430 <port_lock_from_isr>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8000430:	b510      	push	{r4, lr}

  port_lock();
 8000432:	f7ff ffed 	bl	8000410 <port_lock>
}
 8000436:	bd10      	pop	{r4, pc}
	...

08000440 <port_unlock_from_isr>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8000440:	b510      	push	{r4, lr}

  port_unlock();
 8000442:	f7ff ffed 	bl	8000420 <port_unlock>
}
 8000446:	bd10      	pop	{r4, pc}
	...

08000450 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8000450:	b510      	push	{r4, lr}

  port_lock_from_isr();
 8000452:	f7ff ffed 	bl	8000430 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8000456:	f002 fce3 	bl	8002e20 <_dbg_check_lock_from_isr>
}
 800045a:	bd10      	pop	{r4, pc}
 800045c:	0000      	movs	r0, r0
	...

08000460 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8000460:	b510      	push	{r4, lr}

  _dbg_check_unlock_from_isr();
 8000462:	f002 fcf5 	bl	8002e50 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8000466:	f7ff ffeb 	bl	8000440 <port_unlock_from_isr>
}
 800046a:	bd10      	pop	{r4, pc}
 800046c:	0000      	movs	r0, r0
	...

08000470 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8000470:	b510      	push	{r4, lr}

  chSysLockFromISR();
 8000472:	f7ff ffed 	bl	8000450 <chSysLockFromISR>
}
 8000476:	bd10      	pop	{r4, pc}
	...

08000480 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8000480:	b510      	push	{r4, lr}

  chSysUnlockFromISR();
 8000482:	f7ff ffed 	bl	8000460 <chSysUnlockFromISR>
}
 8000486:	bd10      	pop	{r4, pc}
	...

08000490 <osalOsTimerHandlerI>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
 8000490:	b510      	push	{r4, lr}

  chSysTimerHandlerI();
 8000492:	f002 fc55 	bl	8002d40 <chSysTimerHandlerI>
}
 8000496:	bd10      	pop	{r4, pc}
	...

080004a0 <Vector7C>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 80004a0:	b500      	push	{lr}
 80004a2:	b083      	sub	sp, #12
 80004a4:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 80004a6:	9301      	str	r3, [sp, #4]
 80004a8:	4b10      	ldr	r3, [pc, #64]	; (80004ec <Vector7C+0x4c>)
 80004aa:	0018      	movs	r0, r3
 80004ac:	f002 fe18 	bl	80030e0 <_trace_isr_enter>
 80004b0:	f002 fce6 	bl	8002e80 <_dbg_check_enter_isr>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 80004b4:	2380      	movs	r3, #128	; 0x80
 80004b6:	05db      	lsls	r3, r3, #23
 80004b8:	691b      	ldr	r3, [r3, #16]
 80004ba:	2202      	movs	r2, #2
 80004bc:	4013      	ands	r3, r2
 80004be:	d009      	beq.n	80004d4 <Vector7C+0x34>
    STM32_ST_TIM->SR = 0U;
 80004c0:	2380      	movs	r3, #128	; 0x80
 80004c2:	05db      	lsls	r3, r3, #23
 80004c4:	2200      	movs	r2, #0
 80004c6:	611a      	str	r2, [r3, #16]

    osalSysLockFromISR();
 80004c8:	f7ff ffd2 	bl	8000470 <osalSysLockFromISR>
    osalOsTimerHandlerI();
 80004cc:	f7ff ffe0 	bl	8000490 <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
 80004d0:	f7ff ffd6 	bl	8000480 <osalSysUnlockFromISR>
  }

  OSAL_IRQ_EPILOGUE();
 80004d4:	f002 fcf4 	bl	8002ec0 <_dbg_check_leave_isr>
 80004d8:	4b04      	ldr	r3, [pc, #16]	; (80004ec <Vector7C+0x4c>)
 80004da:	0018      	movs	r0, r3
 80004dc:	f002 fe28 	bl	8003130 <_trace_isr_leave>
 80004e0:	9b01      	ldr	r3, [sp, #4]
 80004e2:	0018      	movs	r0, r3
 80004e4:	f001 fa44 	bl	8001970 <_port_irq_epilogue>
}
 80004e8:	b003      	add	sp, #12
 80004ea:	bd00      	pop	{pc}
 80004ec:	08003ad0 	.word	0x08003ad0

080004f0 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 80004f0:	b510      	push	{r4, lr}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80004f2:	4b19      	ldr	r3, [pc, #100]	; (8000558 <st_lld_init+0x68>)
 80004f4:	4a18      	ldr	r2, [pc, #96]	; (8000558 <st_lld_init+0x68>)
 80004f6:	69d2      	ldr	r2, [r2, #28]
 80004f8:	2101      	movs	r1, #1
 80004fa:	430a      	orrs	r2, r1
 80004fc:	61da      	str	r2, [r3, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80004fe:	4b17      	ldr	r3, [pc, #92]	; (800055c <st_lld_init+0x6c>)
 8000500:	4a16      	ldr	r2, [pc, #88]	; (800055c <st_lld_init+0x6c>)
 8000502:	6892      	ldr	r2, [r2, #8]
 8000504:	2101      	movs	r1, #1
 8000506:	430a      	orrs	r2, r1
 8000508:	609a      	str	r2, [r3, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 800050a:	2380      	movs	r3, #128	; 0x80
 800050c:	05db      	lsls	r3, r3, #23
 800050e:	4a14      	ldr	r2, [pc, #80]	; (8000560 <st_lld_init+0x70>)
 8000510:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8000512:	2380      	movs	r3, #128	; 0x80
 8000514:	05db      	lsls	r3, r3, #23
 8000516:	2201      	movs	r2, #1
 8000518:	4252      	negs	r2, r2
 800051a:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 800051c:	2380      	movs	r3, #128	; 0x80
 800051e:	05db      	lsls	r3, r3, #23
 8000520:	2200      	movs	r2, #0
 8000522:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8000524:	2380      	movs	r3, #128	; 0x80
 8000526:	05db      	lsls	r3, r3, #23
 8000528:	2200      	movs	r2, #0
 800052a:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 800052c:	2380      	movs	r3, #128	; 0x80
 800052e:	05db      	lsls	r3, r3, #23
 8000530:	2200      	movs	r2, #0
 8000532:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8000534:	2380      	movs	r3, #128	; 0x80
 8000536:	05db      	lsls	r3, r3, #23
 8000538:	2200      	movs	r2, #0
 800053a:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800053c:	2380      	movs	r3, #128	; 0x80
 800053e:	05db      	lsls	r3, r3, #23
 8000540:	2201      	movs	r2, #1
 8000542:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8000544:	2380      	movs	r3, #128	; 0x80
 8000546:	05db      	lsls	r3, r3, #23
 8000548:	2201      	movs	r2, #1
 800054a:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 800054c:	2102      	movs	r1, #2
 800054e:	200f      	movs	r0, #15
 8000550:	f000 fa7e 	bl	8000a50 <nvicEnableVector>
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8000554:	bd10      	pop	{r4, pc}
 8000556:	46c0      	nop			; (mov r8, r8)
 8000558:	40021000 	.word	0x40021000
 800055c:	40015800 	.word	0x40015800
 8000560:	000012bf 	.word	0x000012bf
	...

08000570 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
 8000570:	b510      	push	{r4, lr}

  stm32_clock_init();
 8000572:	f000 fc0d 	bl	8000d90 <stm32_clock_init>
}
 8000576:	bd10      	pop	{r4, pc}
	...

08000580 <boardInit>:
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
}
 8000580:	4770      	bx	lr
 8000582:	46c0      	nop			; (mov r8, r8)
	...

08000590 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8000590:	b082      	sub	sp, #8
 8000592:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 8000594:	4b02      	ldr	r3, [pc, #8]	; (80005a0 <chRegSetThreadName+0x10>)
 8000596:	699b      	ldr	r3, [r3, #24]
 8000598:	9a01      	ldr	r2, [sp, #4]
 800059a:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 800059c:	b002      	add	sp, #8
 800059e:	4770      	bx	lr
 80005a0:	200004d8 	.word	0x200004d8
	...

080005b0 <spi_thread_1>:

/*
 * SPI bus contender 1.
 */
static THD_WORKING_AREA(spi_thread_1_wa, 256);
static THD_FUNCTION(spi_thread_1, p) {
 80005b0:	b510      	push	{r4, lr}
 80005b2:	b082      	sub	sp, #8
 80005b4:	9001      	str	r0, [sp, #4]

  (void)p;
  chRegSetThreadName("SPI thread 1");
 80005b6:	4b13      	ldr	r3, [pc, #76]	; (8000604 <spi_thread_1+0x54>)
 80005b8:	0018      	movs	r0, r3
 80005ba:	f7ff ffe9 	bl	8000590 <chRegSetThreadName>
  while (true) {
    spiAcquireBus(&SPID1);              /* Acquire ownership of the bus.    */
 80005be:	4b12      	ldr	r3, [pc, #72]	; (8000608 <spi_thread_1+0x58>)
 80005c0:	0018      	movs	r0, r3
 80005c2:	f000 f9a5 	bl	8000910 <spiAcquireBus>
    palSetPad(GPIOC, GPIOC_PIN4);       /* LED ON.                          */
 80005c6:	4b11      	ldr	r3, [pc, #68]	; (800060c <spi_thread_1+0x5c>)
 80005c8:	2210      	movs	r2, #16
 80005ca:	831a      	strh	r2, [r3, #24]
    spiStart(&SPID1, &hs_spicfg);       /* Setup transfer parameters.       */
 80005cc:	4a10      	ldr	r2, [pc, #64]	; (8000610 <spi_thread_1+0x60>)
 80005ce:	4b0e      	ldr	r3, [pc, #56]	; (8000608 <spi_thread_1+0x58>)
 80005d0:	0011      	movs	r1, r2
 80005d2:	0018      	movs	r0, r3
 80005d4:	f000 f8ec 	bl	80007b0 <spiStart>
    spiSelect(&SPID1);                  /* Slave Select assertion.          */
 80005d8:	4b0b      	ldr	r3, [pc, #44]	; (8000608 <spi_thread_1+0x58>)
 80005da:	0018      	movs	r0, r3
 80005dc:	f000 f918 	bl	8000810 <spiSelect>
    spiExchange(&SPID1, 512,
 80005e0:	4c0c      	ldr	r4, [pc, #48]	; (8000614 <spi_thread_1+0x64>)
 80005e2:	4a0d      	ldr	r2, [pc, #52]	; (8000618 <spi_thread_1+0x68>)
 80005e4:	2380      	movs	r3, #128	; 0x80
 80005e6:	0099      	lsls	r1, r3, #2
 80005e8:	4807      	ldr	r0, [pc, #28]	; (8000608 <spi_thread_1+0x58>)
 80005ea:	0023      	movs	r3, r4
 80005ec:	f000 f950 	bl	8000890 <spiExchange>
                txbuf, rxbuf);          /* Atomic transfer operations.      */
    spiUnselect(&SPID1);                /* Slave Select de-assertion.       */
 80005f0:	4b05      	ldr	r3, [pc, #20]	; (8000608 <spi_thread_1+0x58>)
 80005f2:	0018      	movs	r0, r3
 80005f4:	f000 f92c 	bl	8000850 <spiUnselect>
    spiReleaseBus(&SPID1);              /* Ownership release.               */
 80005f8:	4b03      	ldr	r3, [pc, #12]	; (8000608 <spi_thread_1+0x58>)
 80005fa:	0018      	movs	r0, r3
 80005fc:	f000 f9a0 	bl	8000940 <spiReleaseBus>
 8000600:	e7dd      	b.n	80005be <spi_thread_1+0xe>
 8000602:	46c0      	nop			; (mov r8, r8)
 8000604:	080036cc 	.word	0x080036cc
 8000608:	20000db4 	.word	0x20000db4
 800060c:	48000800 	.word	0x48000800
 8000610:	08003b4c 	.word	0x08003b4c
 8000614:	20000fe4 	.word	0x20000fe4
 8000618:	20000de4 	.word	0x20000de4
 800061c:	00000000 	.word	0x00000000

08000620 <spi_thread_2>:

/*
 * SPI bus contender 2.
 */
static THD_WORKING_AREA(spi_thread_2_wa, 256);
static THD_FUNCTION(spi_thread_2, p) {
 8000620:	b510      	push	{r4, lr}
 8000622:	b082      	sub	sp, #8
 8000624:	9001      	str	r0, [sp, #4]

  (void)p;
  chRegSetThreadName("SPI thread 2");
 8000626:	4b13      	ldr	r3, [pc, #76]	; (8000674 <spi_thread_2+0x54>)
 8000628:	0018      	movs	r0, r3
 800062a:	f7ff ffb1 	bl	8000590 <chRegSetThreadName>
  while (true) {
    spiAcquireBus(&SPID1);              /* Acquire ownership of the bus.    */
 800062e:	4b12      	ldr	r3, [pc, #72]	; (8000678 <spi_thread_2+0x58>)
 8000630:	0018      	movs	r0, r3
 8000632:	f000 f96d 	bl	8000910 <spiAcquireBus>
    palClearPad(GPIOC, GPIOC_PIN4);     /* LED OFF.                         */
 8000636:	4b11      	ldr	r3, [pc, #68]	; (800067c <spi_thread_2+0x5c>)
 8000638:	2210      	movs	r2, #16
 800063a:	835a      	strh	r2, [r3, #26]
    spiStart(&SPID1, &ls_spicfg);       /* Setup transfer parameters.       */
 800063c:	4a10      	ldr	r2, [pc, #64]	; (8000680 <spi_thread_2+0x60>)
 800063e:	4b0e      	ldr	r3, [pc, #56]	; (8000678 <spi_thread_2+0x58>)
 8000640:	0011      	movs	r1, r2
 8000642:	0018      	movs	r0, r3
 8000644:	f000 f8b4 	bl	80007b0 <spiStart>
    spiSelect(&SPID1);                  /* Slave Select assertion.          */
 8000648:	4b0b      	ldr	r3, [pc, #44]	; (8000678 <spi_thread_2+0x58>)
 800064a:	0018      	movs	r0, r3
 800064c:	f000 f8e0 	bl	8000810 <spiSelect>
    spiExchange(&SPID1, 512,
 8000650:	4c0c      	ldr	r4, [pc, #48]	; (8000684 <spi_thread_2+0x64>)
 8000652:	4a0d      	ldr	r2, [pc, #52]	; (8000688 <spi_thread_2+0x68>)
 8000654:	2380      	movs	r3, #128	; 0x80
 8000656:	0099      	lsls	r1, r3, #2
 8000658:	4807      	ldr	r0, [pc, #28]	; (8000678 <spi_thread_2+0x58>)
 800065a:	0023      	movs	r3, r4
 800065c:	f000 f918 	bl	8000890 <spiExchange>
                txbuf, rxbuf);          /* Atomic transfer operations.      */
    spiUnselect(&SPID1);                /* Slave Select de-assertion.       */
 8000660:	4b05      	ldr	r3, [pc, #20]	; (8000678 <spi_thread_2+0x58>)
 8000662:	0018      	movs	r0, r3
 8000664:	f000 f8f4 	bl	8000850 <spiUnselect>
    spiReleaseBus(&SPID1);              /* Ownership release.               */
 8000668:	4b03      	ldr	r3, [pc, #12]	; (8000678 <spi_thread_2+0x58>)
 800066a:	0018      	movs	r0, r3
 800066c:	f000 f968 	bl	8000940 <spiReleaseBus>
 8000670:	e7dd      	b.n	800062e <spi_thread_2+0xe>
 8000672:	46c0      	nop			; (mov r8, r8)
 8000674:	080036dc 	.word	0x080036dc
 8000678:	20000db4 	.word	0x20000db4
 800067c:	48000800 	.word	0x48000800
 8000680:	08003b5c 	.word	0x08003b5c
 8000684:	20000fe4 	.word	0x20000fe4
 8000688:	20000de4 	.word	0x20000de4
 800068c:	00000000 	.word	0x00000000

08000690 <blinker>:
/*
 * This is a periodic thread that does absolutely nothing except flashing
 * a LED.
 */
static THD_WORKING_AREA(blinker_wa, 128);
static THD_FUNCTION(blinker, arg) {
 8000690:	b500      	push	{lr}
 8000692:	b083      	sub	sp, #12
 8000694:	9001      	str	r0, [sp, #4]

  (void)arg;
  chRegSetThreadName("blinker");
 8000696:	4b09      	ldr	r3, [pc, #36]	; (80006bc <blinker+0x2c>)
 8000698:	0018      	movs	r0, r3
 800069a:	f7ff ff79 	bl	8000590 <chRegSetThreadName>
  while (true) {
    palSetPad(GPIOC, GPIOC_PIN3);
 800069e:	4b08      	ldr	r3, [pc, #32]	; (80006c0 <blinker+0x30>)
 80006a0:	2208      	movs	r2, #8
 80006a2:	831a      	strh	r2, [r3, #24]
    chThdSleepMilliseconds(500);
 80006a4:	4b07      	ldr	r3, [pc, #28]	; (80006c4 <blinker+0x34>)
 80006a6:	0018      	movs	r0, r3
 80006a8:	f002 f822 	bl	80026f0 <chThdSleep>
    palClearPad(GPIOC, GPIOC_PIN3);
 80006ac:	4b04      	ldr	r3, [pc, #16]	; (80006c0 <blinker+0x30>)
 80006ae:	2208      	movs	r2, #8
 80006b0:	835a      	strh	r2, [r3, #26]
    chThdSleepMilliseconds(500);
 80006b2:	4b04      	ldr	r3, [pc, #16]	; (80006c4 <blinker+0x34>)
 80006b4:	0018      	movs	r0, r3
 80006b6:	f002 f81b 	bl	80026f0 <chThdSleep>
 80006ba:	e7f0      	b.n	800069e <blinker+0xe>
 80006bc:	080036ec 	.word	0x080036ec
 80006c0:	48000800 	.word	0x48000800
 80006c4:	00001388 	.word	0x00001388
	...

080006d0 <main>:
}

/*
 * Application entry point.
 */
int main(void) {
 80006d0:	b500      	push	{lr}
 80006d2:	b085      	sub	sp, #20
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 80006d4:	f001 f984 	bl	80019e0 <halInit>
  chSysInit();
 80006d8:	f002 faea 	bl	8002cb0 <chSysInit>

  /*
   * SPI2 I/O pins setup.
   */
  palSetPadMode(GPIOB, 13, PAL_MODE_ALTERNATE(0) |
 80006dc:	2380      	movs	r3, #128	; 0x80
 80006de:	019b      	lsls	r3, r3, #6
 80006e0:	4828      	ldr	r0, [pc, #160]	; (8000784 <main+0xb4>)
 80006e2:	221a      	movs	r2, #26
 80006e4:	0019      	movs	r1, r3
 80006e6:	f000 fd03 	bl	80010f0 <_pal_lld_setgroupmode>
                           PAL_STM32_OSPEED_HIGHEST);       /* New SCK.     */
  palSetPadMode(GPIOB, 14, PAL_MODE_ALTERNATE(0) |
 80006ea:	2380      	movs	r3, #128	; 0x80
 80006ec:	01db      	lsls	r3, r3, #7
 80006ee:	4825      	ldr	r0, [pc, #148]	; (8000784 <main+0xb4>)
 80006f0:	221a      	movs	r2, #26
 80006f2:	0019      	movs	r1, r3
 80006f4:	f000 fcfc 	bl	80010f0 <_pal_lld_setgroupmode>
                           PAL_STM32_OSPEED_HIGHEST);       /* New MISO.    */
  palSetPadMode(GPIOB, 15, PAL_MODE_ALTERNATE(0) |
 80006f8:	2380      	movs	r3, #128	; 0x80
 80006fa:	021b      	lsls	r3, r3, #8
 80006fc:	4821      	ldr	r0, [pc, #132]	; (8000784 <main+0xb4>)
 80006fe:	221a      	movs	r2, #26
 8000700:	0019      	movs	r1, r3
 8000702:	f000 fcf5 	bl	80010f0 <_pal_lld_setgroupmode>
                           PAL_STM32_OSPEED_HIGHEST);       /* New MOSI.    */
  palSetPad(GPIOB, 12);
 8000706:	4b1f      	ldr	r3, [pc, #124]	; (8000784 <main+0xb4>)
 8000708:	2280      	movs	r2, #128	; 0x80
 800070a:	0152      	lsls	r2, r2, #5
 800070c:	831a      	strh	r2, [r3, #24]
  palSetPadMode(GPIOB, 12, PAL_MODE_OUTPUT_PUSHPULL |
 800070e:	2380      	movs	r3, #128	; 0x80
 8000710:	015b      	lsls	r3, r3, #5
 8000712:	481c      	ldr	r0, [pc, #112]	; (8000784 <main+0xb4>)
 8000714:	2219      	movs	r2, #25
 8000716:	0019      	movs	r1, r3
 8000718:	f000 fcea 	bl	80010f0 <_pal_lld_setgroupmode>
                           PAL_STM32_OSPEED_HIGHEST);       /* New CS.      */

  /*
   * Prepare transmit pattern.
   */
  for (i = 0; i < sizeof(txbuf); i++)
 800071c:	2300      	movs	r3, #0
 800071e:	9303      	str	r3, [sp, #12]
 8000720:	e009      	b.n	8000736 <main+0x66>
    txbuf[i] = (uint8_t)i;
 8000722:	9b03      	ldr	r3, [sp, #12]
 8000724:	b2d9      	uxtb	r1, r3
 8000726:	4a18      	ldr	r2, [pc, #96]	; (8000788 <main+0xb8>)
 8000728:	9b03      	ldr	r3, [sp, #12]
 800072a:	18d3      	adds	r3, r2, r3
 800072c:	1c0a      	adds	r2, r1, #0
 800072e:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < sizeof(txbuf); i++)
 8000730:	9b03      	ldr	r3, [sp, #12]
 8000732:	3301      	adds	r3, #1
 8000734:	9303      	str	r3, [sp, #12]
 8000736:	9b03      	ldr	r3, [sp, #12]
 8000738:	4a14      	ldr	r2, [pc, #80]	; (800078c <main+0xbc>)
 800073a:	4293      	cmp	r3, r2
 800073c:	d9f1      	bls.n	8000722 <main+0x52>

  /*
   * Starting the transmitter and receiver threads.
   */
  chThdCreateStatic(spi_thread_1_wa, sizeof(spi_thread_1_wa),
 800073e:	4a14      	ldr	r2, [pc, #80]	; (8000790 <main+0xc0>)
 8000740:	23e4      	movs	r3, #228	; 0xe4
 8000742:	0059      	lsls	r1, r3, #1
 8000744:	4813      	ldr	r0, [pc, #76]	; (8000794 <main+0xc4>)
 8000746:	2300      	movs	r3, #0
 8000748:	9300      	str	r3, [sp, #0]
 800074a:	0013      	movs	r3, r2
 800074c:	2281      	movs	r2, #129	; 0x81
 800074e:	f001 febf 	bl	80024d0 <chThdCreateStatic>
                    NORMALPRIO + 1, spi_thread_1, NULL);
  chThdCreateStatic(spi_thread_2_wa, sizeof(spi_thread_2_wa),
 8000752:	4a11      	ldr	r2, [pc, #68]	; (8000798 <main+0xc8>)
 8000754:	23e4      	movs	r3, #228	; 0xe4
 8000756:	0059      	lsls	r1, r3, #1
 8000758:	4810      	ldr	r0, [pc, #64]	; (800079c <main+0xcc>)
 800075a:	2300      	movs	r3, #0
 800075c:	9300      	str	r3, [sp, #0]
 800075e:	0013      	movs	r3, r2
 8000760:	2281      	movs	r2, #129	; 0x81
 8000762:	f001 feb5 	bl	80024d0 <chThdCreateStatic>
                    NORMALPRIO + 1, spi_thread_2, NULL);

  /*
   * Starting the blinker thread.
   */
  chThdCreateStatic(blinker_wa, sizeof(blinker_wa),
 8000766:	4a0e      	ldr	r2, [pc, #56]	; (80007a0 <main+0xd0>)
 8000768:	23a4      	movs	r3, #164	; 0xa4
 800076a:	0059      	lsls	r1, r3, #1
 800076c:	480d      	ldr	r0, [pc, #52]	; (80007a4 <main+0xd4>)
 800076e:	2300      	movs	r3, #0
 8000770:	9300      	str	r3, [sp, #0]
 8000772:	0013      	movs	r3, r2
 8000774:	227f      	movs	r2, #127	; 0x7f
 8000776:	f001 feab 	bl	80024d0 <chThdCreateStatic>

  /*
   * Normal main() thread activity, in this demo it does nothing.
   */
  while (true) {
    chThdSleepMilliseconds(500);
 800077a:	4b0b      	ldr	r3, [pc, #44]	; (80007a8 <main+0xd8>)
 800077c:	0018      	movs	r0, r3
 800077e:	f001 ffb7 	bl	80026f0 <chThdSleep>
 8000782:	e7fa      	b.n	800077a <main+0xaa>
 8000784:	48000400 	.word	0x48000400
 8000788:	20000de4 	.word	0x20000de4
 800078c:	000001ff 	.word	0x000001ff
 8000790:	080005b1 	.word	0x080005b1
 8000794:	200011e8 	.word	0x200011e8
 8000798:	08000621 	.word	0x08000621
 800079c:	200013b0 	.word	0x200013b0
 80007a0:	08000691 	.word	0x08000691
 80007a4:	20001578 	.word	0x20001578
 80007a8:	00001388 	.word	0x00001388
 80007ac:	00000000 	.word	0x00000000

080007b0 <spiStart>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] config    pointer to the @p SPIConfig object
 *
 * @api
 */
void spiStart(SPIDriver *spip, const SPIConfig *config) {
 80007b0:	b500      	push	{lr}
 80007b2:	b083      	sub	sp, #12
 80007b4:	9001      	str	r0, [sp, #4]
 80007b6:	9100      	str	r1, [sp, #0]

  osalDbgCheck((spip != NULL) && (config != NULL));
 80007b8:	9b01      	ldr	r3, [sp, #4]
 80007ba:	2b00      	cmp	r3, #0
 80007bc:	d002      	beq.n	80007c4 <spiStart+0x14>
 80007be:	9b00      	ldr	r3, [sp, #0]
 80007c0:	2b00      	cmp	r3, #0
 80007c2:	d103      	bne.n	80007cc <spiStart+0x1c>
 80007c4:	4b0f      	ldr	r3, [pc, #60]	; (8000804 <spiStart+0x54>)
 80007c6:	0018      	movs	r0, r3
 80007c8:	f002 faaa 	bl	8002d20 <chSysHalt>

  osalSysLock();
 80007cc:	f000 fe78 	bl	80014c0 <osalSysLock.lto_priv.84>
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
 80007d0:	9b01      	ldr	r3, [sp, #4]
 80007d2:	781b      	ldrb	r3, [r3, #0]
 80007d4:	2b01      	cmp	r3, #1
 80007d6:	d007      	beq.n	80007e8 <spiStart+0x38>
 80007d8:	9b01      	ldr	r3, [sp, #4]
 80007da:	781b      	ldrb	r3, [r3, #0]
 80007dc:	2b02      	cmp	r3, #2
 80007de:	d003      	beq.n	80007e8 <spiStart+0x38>
 80007e0:	4b08      	ldr	r3, [pc, #32]	; (8000804 <spiStart+0x54>)
 80007e2:	0018      	movs	r0, r3
 80007e4:	f002 fa9c 	bl	8002d20 <chSysHalt>
                "invalid state");
  spip->config = config;
 80007e8:	9b01      	ldr	r3, [sp, #4]
 80007ea:	9a00      	ldr	r2, [sp, #0]
 80007ec:	605a      	str	r2, [r3, #4]
  spi_lld_start(spip);
 80007ee:	9b01      	ldr	r3, [sp, #4]
 80007f0:	0018      	movs	r0, r3
 80007f2:	f7ff fcf5 	bl	80001e0 <spi_lld_start>
  spip->state = SPI_READY;
 80007f6:	9b01      	ldr	r3, [sp, #4]
 80007f8:	2202      	movs	r2, #2
 80007fa:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 80007fc:	f000 fe68 	bl	80014d0 <osalSysUnlock.lto_priv.82>
}
 8000800:	b003      	add	sp, #12
 8000802:	bd00      	pop	{pc}
 8000804:	08003998 	.word	0x08003998
	...

08000810 <spiSelect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiSelect(SPIDriver *spip) {
 8000810:	b500      	push	{lr}
 8000812:	b083      	sub	sp, #12
 8000814:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);
 8000816:	9b01      	ldr	r3, [sp, #4]
 8000818:	2b00      	cmp	r3, #0
 800081a:	d103      	bne.n	8000824 <spiSelect+0x14>
 800081c:	4b0a      	ldr	r3, [pc, #40]	; (8000848 <spiSelect+0x38>)
 800081e:	0018      	movs	r0, r3
 8000820:	f002 fa7e 	bl	8002d20 <chSysHalt>

  osalSysLock();
 8000824:	f000 fe4c 	bl	80014c0 <osalSysLock.lto_priv.84>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 8000828:	9b01      	ldr	r3, [sp, #4]
 800082a:	781b      	ldrb	r3, [r3, #0]
 800082c:	2b02      	cmp	r3, #2
 800082e:	d003      	beq.n	8000838 <spiSelect+0x28>
 8000830:	4b05      	ldr	r3, [pc, #20]	; (8000848 <spiSelect+0x38>)
 8000832:	0018      	movs	r0, r3
 8000834:	f002 fa74 	bl	8002d20 <chSysHalt>
  spiSelectI(spip);
 8000838:	9b01      	ldr	r3, [sp, #4]
 800083a:	0018      	movs	r0, r3
 800083c:	f7ff fd78 	bl	8000330 <spi_lld_select>
  osalSysUnlock();
 8000840:	f000 fe46 	bl	80014d0 <osalSysUnlock.lto_priv.82>
}
 8000844:	b003      	add	sp, #12
 8000846:	bd00      	pop	{pc}
 8000848:	080039b0 	.word	0x080039b0
 800084c:	00000000 	.word	0x00000000

08000850 <spiUnselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiUnselect(SPIDriver *spip) {
 8000850:	b500      	push	{lr}
 8000852:	b083      	sub	sp, #12
 8000854:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);
 8000856:	9b01      	ldr	r3, [sp, #4]
 8000858:	2b00      	cmp	r3, #0
 800085a:	d103      	bne.n	8000864 <spiUnselect+0x14>
 800085c:	4b0a      	ldr	r3, [pc, #40]	; (8000888 <spiUnselect+0x38>)
 800085e:	0018      	movs	r0, r3
 8000860:	f002 fa5e 	bl	8002d20 <chSysHalt>

  osalSysLock();
 8000864:	f000 fe2c 	bl	80014c0 <osalSysLock.lto_priv.84>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 8000868:	9b01      	ldr	r3, [sp, #4]
 800086a:	781b      	ldrb	r3, [r3, #0]
 800086c:	2b02      	cmp	r3, #2
 800086e:	d003      	beq.n	8000878 <spiUnselect+0x28>
 8000870:	4b05      	ldr	r3, [pc, #20]	; (8000888 <spiUnselect+0x38>)
 8000872:	0018      	movs	r0, r3
 8000874:	f002 fa54 	bl	8002d20 <chSysHalt>
  spiUnselectI(spip);
 8000878:	9b01      	ldr	r3, [sp, #4]
 800087a:	0018      	movs	r0, r3
 800087c:	f7ff fd68 	bl	8000350 <spi_lld_unselect>
  osalSysUnlock();
 8000880:	f000 fe26 	bl	80014d0 <osalSysUnlock.lto_priv.82>
}
 8000884:	b003      	add	sp, #12
 8000886:	bd00      	pop	{pc}
 8000888:	080039bc 	.word	0x080039bc
 800088c:	00000000 	.word	0x00000000

08000890 <spiExchange>:
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiExchange(SPIDriver *spip, size_t n,
                 const void *txbuf, void *rxbuf) {
 8000890:	b500      	push	{lr}
 8000892:	b085      	sub	sp, #20
 8000894:	9003      	str	r0, [sp, #12]
 8000896:	9102      	str	r1, [sp, #8]
 8000898:	9201      	str	r2, [sp, #4]
 800089a:	9300      	str	r3, [sp, #0]

  osalDbgCheck((spip != NULL) && (n > 0U) &&
 800089c:	9b03      	ldr	r3, [sp, #12]
 800089e:	2b00      	cmp	r3, #0
 80008a0:	d008      	beq.n	80008b4 <spiExchange+0x24>
 80008a2:	9b02      	ldr	r3, [sp, #8]
 80008a4:	2b00      	cmp	r3, #0
 80008a6:	d005      	beq.n	80008b4 <spiExchange+0x24>
 80008a8:	9b00      	ldr	r3, [sp, #0]
 80008aa:	2b00      	cmp	r3, #0
 80008ac:	d002      	beq.n	80008b4 <spiExchange+0x24>
 80008ae:	9b01      	ldr	r3, [sp, #4]
 80008b0:	2b00      	cmp	r3, #0
 80008b2:	d103      	bne.n	80008bc <spiExchange+0x2c>
 80008b4:	4b14      	ldr	r3, [pc, #80]	; (8000908 <spiExchange+0x78>)
 80008b6:	0018      	movs	r0, r3
 80008b8:	f002 fa32 	bl	8002d20 <chSysHalt>
               (rxbuf != NULL) && (txbuf != NULL));

  osalSysLock();
 80008bc:	f000 fe00 	bl	80014c0 <osalSysLock.lto_priv.84>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 80008c0:	9b03      	ldr	r3, [sp, #12]
 80008c2:	781b      	ldrb	r3, [r3, #0]
 80008c4:	2b02      	cmp	r3, #2
 80008c6:	d003      	beq.n	80008d0 <spiExchange+0x40>
 80008c8:	4b0f      	ldr	r3, [pc, #60]	; (8000908 <spiExchange+0x78>)
 80008ca:	0018      	movs	r0, r3
 80008cc:	f002 fa28 	bl	8002d20 <chSysHalt>
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
 80008d0:	9b03      	ldr	r3, [sp, #12]
 80008d2:	685b      	ldr	r3, [r3, #4]
 80008d4:	681b      	ldr	r3, [r3, #0]
 80008d6:	2b00      	cmp	r3, #0
 80008d8:	d003      	beq.n	80008e2 <spiExchange+0x52>
 80008da:	4b0b      	ldr	r3, [pc, #44]	; (8000908 <spiExchange+0x78>)
 80008dc:	0018      	movs	r0, r3
 80008de:	f002 fa1f 	bl	8002d20 <chSysHalt>
  spiStartExchangeI(spip, n, txbuf, rxbuf);
 80008e2:	9b03      	ldr	r3, [sp, #12]
 80008e4:	2203      	movs	r2, #3
 80008e6:	701a      	strb	r2, [r3, #0]
 80008e8:	9b00      	ldr	r3, [sp, #0]
 80008ea:	9a01      	ldr	r2, [sp, #4]
 80008ec:	9902      	ldr	r1, [sp, #8]
 80008ee:	9803      	ldr	r0, [sp, #12]
 80008f0:	f7ff fd3e 	bl	8000370 <spi_lld_exchange>
  (void) osalThreadSuspendS(&spip->thread);
 80008f4:	9b03      	ldr	r3, [sp, #12]
 80008f6:	3308      	adds	r3, #8
 80008f8:	0018      	movs	r0, r3
 80008fa:	f000 fdf1 	bl	80014e0 <osalThreadSuspendS.lto_priv.83>
  osalSysUnlock();
 80008fe:	f000 fde7 	bl	80014d0 <osalSysUnlock.lto_priv.82>
}
 8000902:	b005      	add	sp, #20
 8000904:	bd00      	pop	{pc}
 8000906:	46c0      	nop			; (mov r8, r8)
 8000908:	080039c8 	.word	0x080039c8
 800090c:	00000000 	.word	0x00000000

08000910 <spiAcquireBus>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiAcquireBus(SPIDriver *spip) {
 8000910:	b500      	push	{lr}
 8000912:	b083      	sub	sp, #12
 8000914:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);
 8000916:	9b01      	ldr	r3, [sp, #4]
 8000918:	2b00      	cmp	r3, #0
 800091a:	d103      	bne.n	8000924 <spiAcquireBus+0x14>
 800091c:	4b05      	ldr	r3, [pc, #20]	; (8000934 <spiAcquireBus+0x24>)
 800091e:	0018      	movs	r0, r3
 8000920:	f002 f9fe 	bl	8002d20 <chSysHalt>

  osalMutexLock(&spip->mutex);
 8000924:	9b01      	ldr	r3, [sp, #4]
 8000926:	330c      	adds	r3, #12
 8000928:	0018      	movs	r0, r3
 800092a:	f000 fdf9 	bl	8001520 <osalMutexLock.lto_priv.81>
}
 800092e:	b003      	add	sp, #12
 8000930:	bd00      	pop	{pc}
 8000932:	46c0      	nop			; (mov r8, r8)
 8000934:	080039d4 	.word	0x080039d4
	...

08000940 <spiReleaseBus>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiReleaseBus(SPIDriver *spip) {
 8000940:	b500      	push	{lr}
 8000942:	b083      	sub	sp, #12
 8000944:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);
 8000946:	9b01      	ldr	r3, [sp, #4]
 8000948:	2b00      	cmp	r3, #0
 800094a:	d103      	bne.n	8000954 <spiReleaseBus+0x14>
 800094c:	4b05      	ldr	r3, [pc, #20]	; (8000964 <spiReleaseBus+0x24>)
 800094e:	0018      	movs	r0, r3
 8000950:	f002 f9e6 	bl	8002d20 <chSysHalt>

  osalMutexUnlock(&spip->mutex);
 8000954:	9b01      	ldr	r3, [sp, #4]
 8000956:	330c      	adds	r3, #12
 8000958:	0018      	movs	r0, r3
 800095a:	f000 fdf1 	bl	8001540 <osalMutexUnlock.lto_priv.80>
}
 800095e:	b003      	add	sp, #12
 8000960:	bd00      	pop	{pc}
 8000962:	46c0      	nop			; (mov r8, r8)
 8000964:	080039e4 	.word	0x080039e4
	...

08000970 <st_lld_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {
 8000970:	b082      	sub	sp, #8
 8000972:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000974:	2380      	movs	r3, #128	; 0x80
 8000976:	05db      	lsls	r3, r3, #23
 8000978:	9a01      	ldr	r2, [sp, #4]
 800097a:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 800097c:	2380      	movs	r3, #128	; 0x80
 800097e:	05db      	lsls	r3, r3, #23
 8000980:	2200      	movs	r2, #0
 8000982:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000984:	2380      	movs	r3, #128	; 0x80
 8000986:	05db      	lsls	r3, r3, #23
 8000988:	2202      	movs	r2, #2
 800098a:	60da      	str	r2, [r3, #12]
}
 800098c:	b002      	add	sp, #8
 800098e:	4770      	bx	lr

08000990 <st_lld_stop_alarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8000990:	2380      	movs	r3, #128	; 0x80
 8000992:	05db      	lsls	r3, r3, #23
 8000994:	2200      	movs	r2, #0
 8000996:	60da      	str	r2, [r3, #12]
}
 8000998:	4770      	bx	lr
 800099a:	46c0      	nop			; (mov r8, r8)
 800099c:	0000      	movs	r0, r0
	...

080009a0 <st_lld_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {
 80009a0:	b082      	sub	sp, #8
 80009a2:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80009a4:	2380      	movs	r3, #128	; 0x80
 80009a6:	05db      	lsls	r3, r3, #23
 80009a8:	9a01      	ldr	r2, [sp, #4]
 80009aa:	635a      	str	r2, [r3, #52]	; 0x34
}
 80009ac:	b002      	add	sp, #8
 80009ae:	4770      	bx	lr

080009b0 <st_lld_is_alarm_active>:
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 80009b0:	2380      	movs	r3, #128	; 0x80
 80009b2:	05db      	lsls	r3, r3, #23
 80009b4:	68db      	ldr	r3, [r3, #12]
 80009b6:	2202      	movs	r2, #2
 80009b8:	4013      	ands	r3, r2
 80009ba:	1e5a      	subs	r2, r3, #1
 80009bc:	4193      	sbcs	r3, r2
 80009be:	b2db      	uxtb	r3, r3
}
 80009c0:	0018      	movs	r0, r3
 80009c2:	4770      	bx	lr
	...

080009d0 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 80009d0:	b510      	push	{r4, lr}

  st_lld_init();
 80009d2:	f7ff fd8d 	bl	80004f0 <st_lld_init>
}
 80009d6:	bd10      	pop	{r4, pc}
	...

080009e0 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 80009e0:	b500      	push	{lr}
 80009e2:	b083      	sub	sp, #12
 80009e4:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 80009e6:	f7ff ffe3 	bl	80009b0 <st_lld_is_alarm_active>
 80009ea:	1e03      	subs	r3, r0, #0
 80009ec:	d003      	beq.n	80009f6 <stStartAlarm+0x16>
 80009ee:	4b05      	ldr	r3, [pc, #20]	; (8000a04 <stStartAlarm+0x24>)
 80009f0:	0018      	movs	r0, r3
 80009f2:	f002 f995 	bl	8002d20 <chSysHalt>

  st_lld_start_alarm(abstime);
 80009f6:	9b01      	ldr	r3, [sp, #4]
 80009f8:	0018      	movs	r0, r3
 80009fa:	f7ff ffb9 	bl	8000970 <st_lld_start_alarm>
}
 80009fe:	b003      	add	sp, #12
 8000a00:	bd00      	pop	{pc}
 8000a02:	46c0      	nop			; (mov r8, r8)
 8000a04:	080039f4 	.word	0x080039f4
	...

08000a10 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 8000a10:	b510      	push	{r4, lr}

  st_lld_stop_alarm();
 8000a12:	f7ff ffbd 	bl	8000990 <st_lld_stop_alarm>
}
 8000a16:	bd10      	pop	{r4, pc}
	...

08000a20 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8000a20:	b500      	push	{lr}
 8000a22:	b083      	sub	sp, #12
 8000a24:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8000a26:	f7ff ffc3 	bl	80009b0 <st_lld_is_alarm_active>
 8000a2a:	0003      	movs	r3, r0
 8000a2c:	001a      	movs	r2, r3
 8000a2e:	2301      	movs	r3, #1
 8000a30:	4053      	eors	r3, r2
 8000a32:	b2db      	uxtb	r3, r3
 8000a34:	2b00      	cmp	r3, #0
 8000a36:	d003      	beq.n	8000a40 <stSetAlarm+0x20>
 8000a38:	4b04      	ldr	r3, [pc, #16]	; (8000a4c <stSetAlarm+0x2c>)
 8000a3a:	0018      	movs	r0, r3
 8000a3c:	f002 f970 	bl	8002d20 <chSysHalt>

  st_lld_set_alarm(abstime);
 8000a40:	9b01      	ldr	r3, [sp, #4]
 8000a42:	0018      	movs	r0, r3
 8000a44:	f7ff ffac 	bl	80009a0 <st_lld_set_alarm>
}
 8000a48:	b003      	add	sp, #12
 8000a4a:	bd00      	pop	{pc}
 8000a4c:	08003a04 	.word	0x08003a04

08000a50 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8000a50:	b530      	push	{r4, r5, lr}
 8000a52:	b083      	sub	sp, #12
 8000a54:	9001      	str	r0, [sp, #4]
 8000a56:	9100      	str	r1, [sp, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8000a58:	4c1b      	ldr	r4, [pc, #108]	; (8000ac8 <nvicEnableVector+0x78>)
 8000a5a:	9b01      	ldr	r3, [sp, #4]
 8000a5c:	089b      	lsrs	r3, r3, #2
 8000a5e:	491a      	ldr	r1, [pc, #104]	; (8000ac8 <nvicEnableVector+0x78>)
 8000a60:	9a01      	ldr	r2, [sp, #4]
 8000a62:	0892      	lsrs	r2, r2, #2
 8000a64:	32c0      	adds	r2, #192	; 0xc0
 8000a66:	0092      	lsls	r2, r2, #2
 8000a68:	5852      	ldr	r2, [r2, r1]
 8000a6a:	9901      	ldr	r1, [sp, #4]
 8000a6c:	2003      	movs	r0, #3
 8000a6e:	4001      	ands	r1, r0
 8000a70:	00c9      	lsls	r1, r1, #3
 8000a72:	20ff      	movs	r0, #255	; 0xff
 8000a74:	4088      	lsls	r0, r1
 8000a76:	0001      	movs	r1, r0
 8000a78:	43c9      	mvns	r1, r1
 8000a7a:	4011      	ands	r1, r2
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
 8000a7c:	9a00      	ldr	r2, [sp, #0]
 8000a7e:	0190      	lsls	r0, r2, #6
 8000a80:	9a01      	ldr	r2, [sp, #4]
 8000a82:	2503      	movs	r5, #3
 8000a84:	402a      	ands	r2, r5
 8000a86:	00d2      	lsls	r2, r2, #3
 8000a88:	4090      	lsls	r0, r2
 8000a8a:	0002      	movs	r2, r0
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8000a8c:	430a      	orrs	r2, r1
 8000a8e:	33c0      	adds	r3, #192	; 0xc0
 8000a90:	009b      	lsls	r3, r3, #2
 8000a92:	511a      	str	r2, [r3, r4]
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000a94:	490c      	ldr	r1, [pc, #48]	; (8000ac8 <nvicEnableVector+0x78>)
 8000a96:	9b01      	ldr	r3, [sp, #4]
 8000a98:	095b      	lsrs	r3, r3, #5
 8000a9a:	9a01      	ldr	r2, [sp, #4]
 8000a9c:	201f      	movs	r0, #31
 8000a9e:	4002      	ands	r2, r0
 8000aa0:	2001      	movs	r0, #1
 8000aa2:	4090      	lsls	r0, r2
 8000aa4:	0002      	movs	r2, r0
 8000aa6:	3360      	adds	r3, #96	; 0x60
 8000aa8:	009b      	lsls	r3, r3, #2
 8000aaa:	505a      	str	r2, [r3, r1]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000aac:	4906      	ldr	r1, [pc, #24]	; (8000ac8 <nvicEnableVector+0x78>)
 8000aae:	9b01      	ldr	r3, [sp, #4]
 8000ab0:	095b      	lsrs	r3, r3, #5
 8000ab2:	9a01      	ldr	r2, [sp, #4]
 8000ab4:	201f      	movs	r0, #31
 8000ab6:	4002      	ands	r2, r0
 8000ab8:	2001      	movs	r0, #1
 8000aba:	4090      	lsls	r0, r2
 8000abc:	0002      	movs	r2, r0
 8000abe:	009b      	lsls	r3, r3, #2
 8000ac0:	505a      	str	r2, [r3, r1]
}
 8000ac2:	b003      	add	sp, #12
 8000ac4:	bd30      	pop	{r4, r5, pc}
 8000ac6:	46c0      	nop			; (mov r8, r8)
 8000ac8:	e000e100 	.word	0xe000e100
 8000acc:	00000000 	.word	0x00000000

08000ad0 <hal_lld_backup_domain_init>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8000ad0:	4b15      	ldr	r3, [pc, #84]	; (8000b28 <hal_lld_backup_domain_init+0x58>)
 8000ad2:	4a15      	ldr	r2, [pc, #84]	; (8000b28 <hal_lld_backup_domain_init+0x58>)
 8000ad4:	6812      	ldr	r2, [r2, #0]
 8000ad6:	2180      	movs	r1, #128	; 0x80
 8000ad8:	0049      	lsls	r1, r1, #1
 8000ada:	430a      	orrs	r2, r1
 8000adc:	601a      	str	r2, [r3, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 8000ade:	4b13      	ldr	r3, [pc, #76]	; (8000b2c <hal_lld_backup_domain_init+0x5c>)
 8000ae0:	6a1a      	ldr	r2, [r3, #32]
 8000ae2:	23c0      	movs	r3, #192	; 0xc0
 8000ae4:	009b      	lsls	r3, r3, #2
 8000ae6:	401a      	ands	r2, r3
 8000ae8:	2380      	movs	r3, #128	; 0x80
 8000aea:	009b      	lsls	r3, r3, #2
 8000aec:	429a      	cmp	r2, r3
 8000aee:	d006      	beq.n	8000afe <hal_lld_backup_domain_init+0x2e>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8000af0:	4b0e      	ldr	r3, [pc, #56]	; (8000b2c <hal_lld_backup_domain_init+0x5c>)
 8000af2:	2280      	movs	r2, #128	; 0x80
 8000af4:	0252      	lsls	r2, r2, #9
 8000af6:	621a      	str	r2, [r3, #32]
    RCC->BDCR = 0;
 8000af8:	4b0c      	ldr	r3, [pc, #48]	; (8000b2c <hal_lld_backup_domain_init+0x5c>)
 8000afa:	2200      	movs	r2, #0
 8000afc:	621a      	str	r2, [r3, #32]
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 8000afe:	4b0b      	ldr	r3, [pc, #44]	; (8000b2c <hal_lld_backup_domain_init+0x5c>)
 8000b00:	6a1a      	ldr	r2, [r3, #32]
 8000b02:	2380      	movs	r3, #128	; 0x80
 8000b04:	021b      	lsls	r3, r3, #8
 8000b06:	4013      	ands	r3, r2
 8000b08:	d10d      	bne.n	8000b26 <hal_lld_backup_domain_init+0x56>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 8000b0a:	4b08      	ldr	r3, [pc, #32]	; (8000b2c <hal_lld_backup_domain_init+0x5c>)
 8000b0c:	4a07      	ldr	r2, [pc, #28]	; (8000b2c <hal_lld_backup_domain_init+0x5c>)
 8000b0e:	6a12      	ldr	r2, [r2, #32]
 8000b10:	2180      	movs	r1, #128	; 0x80
 8000b12:	0089      	lsls	r1, r1, #2
 8000b14:	430a      	orrs	r2, r1
 8000b16:	621a      	str	r2, [r3, #32]

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 8000b18:	4b04      	ldr	r3, [pc, #16]	; (8000b2c <hal_lld_backup_domain_init+0x5c>)
 8000b1a:	4a04      	ldr	r2, [pc, #16]	; (8000b2c <hal_lld_backup_domain_init+0x5c>)
 8000b1c:	6a12      	ldr	r2, [r2, #32]
 8000b1e:	2180      	movs	r1, #128	; 0x80
 8000b20:	0209      	lsls	r1, r1, #8
 8000b22:	430a      	orrs	r2, r1
 8000b24:	621a      	str	r2, [r3, #32]
  }
#endif /* STM32_RTCSEL != STM32_RTCSEL_NOCLOCK */
}
 8000b26:	4770      	bx	lr
 8000b28:	40007000 	.word	0x40007000
 8000b2c:	40021000 	.word	0x40021000

08000b30 <Vector68>:
 * @note    It is declared here because this device has a non-standard
 *          DMA shared IRQ handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH23_HANDLER) {
 8000b30:	b500      	push	{lr}
 8000b32:	b087      	sub	sp, #28
 8000b34:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 8000b36:	9305      	str	r3, [sp, #20]
 8000b38:	4b38      	ldr	r3, [pc, #224]	; (8000c1c <Vector68+0xec>)
 8000b3a:	0018      	movs	r0, r3
 8000b3c:	f002 fad0 	bl	80030e0 <_trace_isr_enter>
 8000b40:	f002 f99e 	bl	8002e80 <_dbg_check_enter_isr>

  /* Check on channel 2.*/
  dmaServeInterrupt(STM32_DMA1_STREAM2);
 8000b44:	4b36      	ldr	r3, [pc, #216]	; (8000c20 <Vector68+0xf0>)
 8000b46:	2225      	movs	r2, #37	; 0x25
 8000b48:	5c9b      	ldrb	r3, [r3, r2]
 8000b4a:	9304      	str	r3, [sp, #16]
 8000b4c:	4b34      	ldr	r3, [pc, #208]	; (8000c20 <Vector68+0xf0>)
 8000b4e:	695b      	ldr	r3, [r3, #20]
 8000b50:	681b      	ldr	r3, [r3, #0]
 8000b52:	4a33      	ldr	r2, [pc, #204]	; (8000c20 <Vector68+0xf0>)
 8000b54:	2124      	movs	r1, #36	; 0x24
 8000b56:	5c52      	ldrb	r2, [r2, r1]
 8000b58:	40d3      	lsrs	r3, r2
 8000b5a:	220e      	movs	r2, #14
 8000b5c:	4013      	ands	r3, r2
 8000b5e:	9303      	str	r3, [sp, #12]
 8000b60:	4b2f      	ldr	r3, [pc, #188]	; (8000c20 <Vector68+0xf0>)
 8000b62:	699b      	ldr	r3, [r3, #24]
 8000b64:	681b      	ldr	r3, [r3, #0]
 8000b66:	9a03      	ldr	r2, [sp, #12]
 8000b68:	4013      	ands	r3, r2
 8000b6a:	d01b      	beq.n	8000ba4 <Vector68+0x74>
 8000b6c:	4b2c      	ldr	r3, [pc, #176]	; (8000c20 <Vector68+0xf0>)
 8000b6e:	695b      	ldr	r3, [r3, #20]
 8000b70:	4a2b      	ldr	r2, [pc, #172]	; (8000c20 <Vector68+0xf0>)
 8000b72:	2124      	movs	r1, #36	; 0x24
 8000b74:	5c52      	ldrb	r2, [r2, r1]
 8000b76:	0011      	movs	r1, r2
 8000b78:	9a03      	ldr	r2, [sp, #12]
 8000b7a:	408a      	lsls	r2, r1
 8000b7c:	605a      	str	r2, [r3, #4]
 8000b7e:	4b29      	ldr	r3, [pc, #164]	; (8000c24 <Vector68+0xf4>)
 8000b80:	9a04      	ldr	r2, [sp, #16]
 8000b82:	00d2      	lsls	r2, r2, #3
 8000b84:	58d3      	ldr	r3, [r2, r3]
 8000b86:	2b00      	cmp	r3, #0
 8000b88:	d00c      	beq.n	8000ba4 <Vector68+0x74>
 8000b8a:	4b26      	ldr	r3, [pc, #152]	; (8000c24 <Vector68+0xf4>)
 8000b8c:	9a04      	ldr	r2, [sp, #16]
 8000b8e:	00d2      	lsls	r2, r2, #3
 8000b90:	58d2      	ldr	r2, [r2, r3]
 8000b92:	4924      	ldr	r1, [pc, #144]	; (8000c24 <Vector68+0xf4>)
 8000b94:	9b04      	ldr	r3, [sp, #16]
 8000b96:	00db      	lsls	r3, r3, #3
 8000b98:	18cb      	adds	r3, r1, r3
 8000b9a:	3304      	adds	r3, #4
 8000b9c:	681b      	ldr	r3, [r3, #0]
 8000b9e:	9903      	ldr	r1, [sp, #12]
 8000ba0:	0018      	movs	r0, r3
 8000ba2:	4790      	blx	r2

  /* Check on channel 3.*/
  dmaServeInterrupt(STM32_DMA1_STREAM3);
 8000ba4:	4b1e      	ldr	r3, [pc, #120]	; (8000c20 <Vector68+0xf0>)
 8000ba6:	2239      	movs	r2, #57	; 0x39
 8000ba8:	5c9b      	ldrb	r3, [r3, r2]
 8000baa:	9302      	str	r3, [sp, #8]
 8000bac:	4b1c      	ldr	r3, [pc, #112]	; (8000c20 <Vector68+0xf0>)
 8000bae:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8000bb0:	681b      	ldr	r3, [r3, #0]
 8000bb2:	4a1b      	ldr	r2, [pc, #108]	; (8000c20 <Vector68+0xf0>)
 8000bb4:	2138      	movs	r1, #56	; 0x38
 8000bb6:	5c52      	ldrb	r2, [r2, r1]
 8000bb8:	40d3      	lsrs	r3, r2
 8000bba:	220e      	movs	r2, #14
 8000bbc:	4013      	ands	r3, r2
 8000bbe:	9301      	str	r3, [sp, #4]
 8000bc0:	4b17      	ldr	r3, [pc, #92]	; (8000c20 <Vector68+0xf0>)
 8000bc2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000bc4:	681b      	ldr	r3, [r3, #0]
 8000bc6:	9a01      	ldr	r2, [sp, #4]
 8000bc8:	4013      	ands	r3, r2
 8000bca:	d01b      	beq.n	8000c04 <Vector68+0xd4>
 8000bcc:	4b14      	ldr	r3, [pc, #80]	; (8000c20 <Vector68+0xf0>)
 8000bce:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8000bd0:	4a13      	ldr	r2, [pc, #76]	; (8000c20 <Vector68+0xf0>)
 8000bd2:	2138      	movs	r1, #56	; 0x38
 8000bd4:	5c52      	ldrb	r2, [r2, r1]
 8000bd6:	0011      	movs	r1, r2
 8000bd8:	9a01      	ldr	r2, [sp, #4]
 8000bda:	408a      	lsls	r2, r1
 8000bdc:	605a      	str	r2, [r3, #4]
 8000bde:	4b11      	ldr	r3, [pc, #68]	; (8000c24 <Vector68+0xf4>)
 8000be0:	9a02      	ldr	r2, [sp, #8]
 8000be2:	00d2      	lsls	r2, r2, #3
 8000be4:	58d3      	ldr	r3, [r2, r3]
 8000be6:	2b00      	cmp	r3, #0
 8000be8:	d00c      	beq.n	8000c04 <Vector68+0xd4>
 8000bea:	4b0e      	ldr	r3, [pc, #56]	; (8000c24 <Vector68+0xf4>)
 8000bec:	9a02      	ldr	r2, [sp, #8]
 8000bee:	00d2      	lsls	r2, r2, #3
 8000bf0:	58d2      	ldr	r2, [r2, r3]
 8000bf2:	490c      	ldr	r1, [pc, #48]	; (8000c24 <Vector68+0xf4>)
 8000bf4:	9b02      	ldr	r3, [sp, #8]
 8000bf6:	00db      	lsls	r3, r3, #3
 8000bf8:	18cb      	adds	r3, r1, r3
 8000bfa:	3304      	adds	r3, #4
 8000bfc:	681b      	ldr	r3, [r3, #0]
 8000bfe:	9901      	ldr	r1, [sp, #4]
 8000c00:	0018      	movs	r0, r3
 8000c02:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8000c04:	f002 f95c 	bl	8002ec0 <_dbg_check_leave_isr>
 8000c08:	4b04      	ldr	r3, [pc, #16]	; (8000c1c <Vector68+0xec>)
 8000c0a:	0018      	movs	r0, r3
 8000c0c:	f002 fa90 	bl	8003130 <_trace_isr_leave>
 8000c10:	9b05      	ldr	r3, [sp, #20]
 8000c12:	0018      	movs	r0, r3
 8000c14:	f000 feac 	bl	8001970 <_port_irq_epilogue>
}
 8000c18:	b007      	add	sp, #28
 8000c1a:	bd00      	pop	{pc}
 8000c1c:	08003a10 	.word	0x08003a10
 8000c20:	08003a28 	.word	0x08003a28
 8000c24:	20000d88 	.word	0x20000d88
	...

08000c30 <Vector6C>:
/**
 * @brief   DMA1 streams 4, 5, 6 and 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4567_HANDLER) {
 8000c30:	b500      	push	{lr}
 8000c32:	b087      	sub	sp, #28
 8000c34:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 8000c36:	9305      	str	r3, [sp, #20]
 8000c38:	4b38      	ldr	r3, [pc, #224]	; (8000d1c <Vector6C+0xec>)
 8000c3a:	0018      	movs	r0, r3
 8000c3c:	f002 fa50 	bl	80030e0 <_trace_isr_enter>
 8000c40:	f002 f91e 	bl	8002e80 <_dbg_check_enter_isr>

  /* Check on channel 4.*/
  dmaServeInterrupt(STM32_DMA1_STREAM4);
 8000c44:	4b36      	ldr	r3, [pc, #216]	; (8000d20 <Vector6C+0xf0>)
 8000c46:	224d      	movs	r2, #77	; 0x4d
 8000c48:	5c9b      	ldrb	r3, [r3, r2]
 8000c4a:	9304      	str	r3, [sp, #16]
 8000c4c:	4b34      	ldr	r3, [pc, #208]	; (8000d20 <Vector6C+0xf0>)
 8000c4e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8000c50:	681b      	ldr	r3, [r3, #0]
 8000c52:	4a33      	ldr	r2, [pc, #204]	; (8000d20 <Vector6C+0xf0>)
 8000c54:	214c      	movs	r1, #76	; 0x4c
 8000c56:	5c52      	ldrb	r2, [r2, r1]
 8000c58:	40d3      	lsrs	r3, r2
 8000c5a:	220e      	movs	r2, #14
 8000c5c:	4013      	ands	r3, r2
 8000c5e:	9303      	str	r3, [sp, #12]
 8000c60:	4b2f      	ldr	r3, [pc, #188]	; (8000d20 <Vector6C+0xf0>)
 8000c62:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000c64:	681b      	ldr	r3, [r3, #0]
 8000c66:	9a03      	ldr	r2, [sp, #12]
 8000c68:	4013      	ands	r3, r2
 8000c6a:	d01b      	beq.n	8000ca4 <Vector6C+0x74>
 8000c6c:	4b2c      	ldr	r3, [pc, #176]	; (8000d20 <Vector6C+0xf0>)
 8000c6e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8000c70:	4a2b      	ldr	r2, [pc, #172]	; (8000d20 <Vector6C+0xf0>)
 8000c72:	214c      	movs	r1, #76	; 0x4c
 8000c74:	5c52      	ldrb	r2, [r2, r1]
 8000c76:	0011      	movs	r1, r2
 8000c78:	9a03      	ldr	r2, [sp, #12]
 8000c7a:	408a      	lsls	r2, r1
 8000c7c:	605a      	str	r2, [r3, #4]
 8000c7e:	4b29      	ldr	r3, [pc, #164]	; (8000d24 <Vector6C+0xf4>)
 8000c80:	9a04      	ldr	r2, [sp, #16]
 8000c82:	00d2      	lsls	r2, r2, #3
 8000c84:	58d3      	ldr	r3, [r2, r3]
 8000c86:	2b00      	cmp	r3, #0
 8000c88:	d00c      	beq.n	8000ca4 <Vector6C+0x74>
 8000c8a:	4b26      	ldr	r3, [pc, #152]	; (8000d24 <Vector6C+0xf4>)
 8000c8c:	9a04      	ldr	r2, [sp, #16]
 8000c8e:	00d2      	lsls	r2, r2, #3
 8000c90:	58d2      	ldr	r2, [r2, r3]
 8000c92:	4924      	ldr	r1, [pc, #144]	; (8000d24 <Vector6C+0xf4>)
 8000c94:	9b04      	ldr	r3, [sp, #16]
 8000c96:	00db      	lsls	r3, r3, #3
 8000c98:	18cb      	adds	r3, r1, r3
 8000c9a:	3304      	adds	r3, #4
 8000c9c:	681b      	ldr	r3, [r3, #0]
 8000c9e:	9903      	ldr	r1, [sp, #12]
 8000ca0:	0018      	movs	r0, r3
 8000ca2:	4790      	blx	r2

  /* Check on channel 5.*/
  dmaServeInterrupt(STM32_DMA1_STREAM5);
 8000ca4:	4b1e      	ldr	r3, [pc, #120]	; (8000d20 <Vector6C+0xf0>)
 8000ca6:	2261      	movs	r2, #97	; 0x61
 8000ca8:	5c9b      	ldrb	r3, [r3, r2]
 8000caa:	9302      	str	r3, [sp, #8]
 8000cac:	4b1c      	ldr	r3, [pc, #112]	; (8000d20 <Vector6C+0xf0>)
 8000cae:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8000cb0:	681b      	ldr	r3, [r3, #0]
 8000cb2:	4a1b      	ldr	r2, [pc, #108]	; (8000d20 <Vector6C+0xf0>)
 8000cb4:	2160      	movs	r1, #96	; 0x60
 8000cb6:	5c52      	ldrb	r2, [r2, r1]
 8000cb8:	40d3      	lsrs	r3, r2
 8000cba:	220e      	movs	r2, #14
 8000cbc:	4013      	ands	r3, r2
 8000cbe:	9301      	str	r3, [sp, #4]
 8000cc0:	4b17      	ldr	r3, [pc, #92]	; (8000d20 <Vector6C+0xf0>)
 8000cc2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8000cc4:	681b      	ldr	r3, [r3, #0]
 8000cc6:	9a01      	ldr	r2, [sp, #4]
 8000cc8:	4013      	ands	r3, r2
 8000cca:	d01b      	beq.n	8000d04 <Vector6C+0xd4>
 8000ccc:	4b14      	ldr	r3, [pc, #80]	; (8000d20 <Vector6C+0xf0>)
 8000cce:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8000cd0:	4a13      	ldr	r2, [pc, #76]	; (8000d20 <Vector6C+0xf0>)
 8000cd2:	2160      	movs	r1, #96	; 0x60
 8000cd4:	5c52      	ldrb	r2, [r2, r1]
 8000cd6:	0011      	movs	r1, r2
 8000cd8:	9a01      	ldr	r2, [sp, #4]
 8000cda:	408a      	lsls	r2, r1
 8000cdc:	605a      	str	r2, [r3, #4]
 8000cde:	4b11      	ldr	r3, [pc, #68]	; (8000d24 <Vector6C+0xf4>)
 8000ce0:	9a02      	ldr	r2, [sp, #8]
 8000ce2:	00d2      	lsls	r2, r2, #3
 8000ce4:	58d3      	ldr	r3, [r2, r3]
 8000ce6:	2b00      	cmp	r3, #0
 8000ce8:	d00c      	beq.n	8000d04 <Vector6C+0xd4>
 8000cea:	4b0e      	ldr	r3, [pc, #56]	; (8000d24 <Vector6C+0xf4>)
 8000cec:	9a02      	ldr	r2, [sp, #8]
 8000cee:	00d2      	lsls	r2, r2, #3
 8000cf0:	58d2      	ldr	r2, [r2, r3]
 8000cf2:	490c      	ldr	r1, [pc, #48]	; (8000d24 <Vector6C+0xf4>)
 8000cf4:	9b02      	ldr	r3, [sp, #8]
 8000cf6:	00db      	lsls	r3, r3, #3
 8000cf8:	18cb      	adds	r3, r1, r3
 8000cfa:	3304      	adds	r3, #4
 8000cfc:	681b      	ldr	r3, [r3, #0]
 8000cfe:	9901      	ldr	r1, [sp, #4]
 8000d00:	0018      	movs	r0, r3
 8000d02:	4790      	blx	r2
#if STM32_DMA1_NUM_CHANNELS > 6
  /* Check on channel 7.*/
  dmaServeInterrupt(STM32_DMA1_STREAM7);
#endif

  OSAL_IRQ_EPILOGUE();
 8000d04:	f002 f8dc 	bl	8002ec0 <_dbg_check_leave_isr>
 8000d08:	4b04      	ldr	r3, [pc, #16]	; (8000d1c <Vector6C+0xec>)
 8000d0a:	0018      	movs	r0, r3
 8000d0c:	f002 fa10 	bl	8003130 <_trace_isr_leave>
 8000d10:	9b05      	ldr	r3, [sp, #20]
 8000d12:	0018      	movs	r0, r3
 8000d14:	f000 fe2c 	bl	8001970 <_port_irq_epilogue>
}
 8000d18:	b007      	add	sp, #28
 8000d1a:	bd00      	pop	{pc}
 8000d1c:	08003a1c 	.word	0x08003a1c
 8000d20:	08003a28 	.word	0x08003a28
 8000d24:	20000d88 	.word	0x20000d88
	...

08000d30 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 8000d30:	b510      	push	{r4, lr}

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 8000d32:	4b13      	ldr	r3, [pc, #76]	; (8000d80 <hal_lld_init+0x50>)
 8000d34:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8000d36:	4b12      	ldr	r3, [pc, #72]	; (8000d80 <hal_lld_init+0x50>)
 8000d38:	2201      	movs	r2, #1
 8000d3a:	4252      	negs	r2, r2
 8000d3c:	629a      	str	r2, [r3, #40]	; 0x28
 8000d3e:	4b10      	ldr	r3, [pc, #64]	; (8000d80 <hal_lld_init+0x50>)
 8000d40:	2200      	movs	r2, #0
 8000d42:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 8000d44:	4b0e      	ldr	r3, [pc, #56]	; (8000d80 <hal_lld_init+0x50>)
 8000d46:	691b      	ldr	r3, [r3, #16]
 8000d48:	4b0d      	ldr	r3, [pc, #52]	; (8000d80 <hal_lld_init+0x50>)
 8000d4a:	2201      	movs	r2, #1
 8000d4c:	4252      	negs	r2, r2
 8000d4e:	611a      	str	r2, [r3, #16]
 8000d50:	4b0b      	ldr	r3, [pc, #44]	; (8000d80 <hal_lld_init+0x50>)
 8000d52:	2200      	movs	r2, #0
 8000d54:	611a      	str	r2, [r3, #16]
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8000d56:	4b0a      	ldr	r3, [pc, #40]	; (8000d80 <hal_lld_init+0x50>)
 8000d58:	4a09      	ldr	r2, [pc, #36]	; (8000d80 <hal_lld_init+0x50>)
 8000d5a:	68d2      	ldr	r2, [r2, #12]
 8000d5c:	4909      	ldr	r1, [pc, #36]	; (8000d84 <hal_lld_init+0x54>)
 8000d5e:	430a      	orrs	r2, r1
 8000d60:	60da      	str	r2, [r3, #12]
 8000d62:	4b07      	ldr	r3, [pc, #28]	; (8000d80 <hal_lld_init+0x50>)
 8000d64:	2200      	movs	r2, #0
 8000d66:	60da      	str	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8000d68:	4b05      	ldr	r3, [pc, #20]	; (8000d80 <hal_lld_init+0x50>)
 8000d6a:	4a05      	ldr	r2, [pc, #20]	; (8000d80 <hal_lld_init+0x50>)
 8000d6c:	69d2      	ldr	r2, [r2, #28]
 8000d6e:	2180      	movs	r1, #128	; 0x80
 8000d70:	0549      	lsls	r1, r1, #21
 8000d72:	430a      	orrs	r2, r1
 8000d74:	61da      	str	r2, [r3, #28]

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 8000d76:	f7ff feab 	bl	8000ad0 <hal_lld_backup_domain_init>

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 8000d7a:	f000 f8c1 	bl	8000f00 <dmaInit>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 8000d7e:	bd10      	pop	{r4, pc}
 8000d80:	40021000 	.word	0x40021000
 8000d84:	ffbfffff 	.word	0xffbfffff
	...

08000d90 <stm32_clock_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8000d90:	4b32      	ldr	r3, [pc, #200]	; (8000e5c <stm32_clock_init+0xcc>)
 8000d92:	4a32      	ldr	r2, [pc, #200]	; (8000e5c <stm32_clock_init+0xcc>)
 8000d94:	6812      	ldr	r2, [r2, #0]
 8000d96:	2101      	movs	r1, #1
 8000d98:	430a      	orrs	r2, r1
 8000d9a:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8000d9c:	4b2f      	ldr	r3, [pc, #188]	; (8000e5c <stm32_clock_init+0xcc>)
 8000d9e:	681b      	ldr	r3, [r3, #0]
 8000da0:	2202      	movs	r2, #2
 8000da2:	4013      	ands	r3, r2
 8000da4:	d0fa      	beq.n	8000d9c <stm32_clock_init+0xc>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8000da6:	4b2d      	ldr	r3, [pc, #180]	; (8000e5c <stm32_clock_init+0xcc>)
 8000da8:	4a2c      	ldr	r2, [pc, #176]	; (8000e5c <stm32_clock_init+0xcc>)
 8000daa:	6852      	ldr	r2, [r2, #4]
 8000dac:	2103      	movs	r1, #3
 8000dae:	438a      	bics	r2, r1
 8000db0:	605a      	str	r2, [r3, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8000db2:	4b2a      	ldr	r3, [pc, #168]	; (8000e5c <stm32_clock_init+0xcc>)
 8000db4:	4a29      	ldr	r2, [pc, #164]	; (8000e5c <stm32_clock_init+0xcc>)
 8000db6:	6852      	ldr	r2, [r2, #4]
 8000db8:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8000dba:	4b28      	ldr	r3, [pc, #160]	; (8000e5c <stm32_clock_init+0xcc>)
 8000dbc:	685b      	ldr	r3, [r3, #4]
 8000dbe:	220c      	movs	r2, #12
 8000dc0:	4013      	ands	r3, r2
 8000dc2:	d1fa      	bne.n	8000dba <stm32_clock_init+0x2a>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8000dc4:	4b25      	ldr	r3, [pc, #148]	; (8000e5c <stm32_clock_init+0xcc>)
 8000dc6:	4a25      	ldr	r2, [pc, #148]	; (8000e5c <stm32_clock_init+0xcc>)
 8000dc8:	6812      	ldr	r2, [r2, #0]
 8000dca:	21f9      	movs	r1, #249	; 0xf9
 8000dcc:	400a      	ands	r2, r1
 8000dce:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8000dd0:	4b22      	ldr	r3, [pc, #136]	; (8000e5c <stm32_clock_init+0xcc>)
 8000dd2:	2200      	movs	r2, #0
 8000dd4:	605a      	str	r2, [r3, #4]
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_HSI14_ENABLED
  /* HSI14 activation.*/
  RCC->CR2 |= RCC_CR2_HSI14ON;
 8000dd6:	4b21      	ldr	r3, [pc, #132]	; (8000e5c <stm32_clock_init+0xcc>)
 8000dd8:	4a20      	ldr	r2, [pc, #128]	; (8000e5c <stm32_clock_init+0xcc>)
 8000dda:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8000ddc:	2101      	movs	r1, #1
 8000dde:	430a      	orrs	r2, r1
 8000de0:	635a      	str	r2, [r3, #52]	; 0x34
  while (!(RCC->CR2 & RCC_CR2_HSI14RDY))
 8000de2:	4b1e      	ldr	r3, [pc, #120]	; (8000e5c <stm32_clock_init+0xcc>)
 8000de4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8000de6:	2202      	movs	r2, #2
 8000de8:	4013      	ands	r3, r2
 8000dea:	d0fa      	beq.n	8000de2 <stm32_clock_init+0x52>
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8000dec:	4b1b      	ldr	r3, [pc, #108]	; (8000e5c <stm32_clock_init+0xcc>)
 8000dee:	4a1b      	ldr	r2, [pc, #108]	; (8000e5c <stm32_clock_init+0xcc>)
 8000df0:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8000df2:	2101      	movs	r1, #1
 8000df4:	430a      	orrs	r2, r1
 8000df6:	625a      	str	r2, [r3, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8000df8:	4b18      	ldr	r3, [pc, #96]	; (8000e5c <stm32_clock_init+0xcc>)
 8000dfa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000dfc:	2202      	movs	r2, #2
 8000dfe:	4013      	ands	r3, r2
 8000e00:	d0fa      	beq.n	8000df8 <stm32_clock_init+0x68>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  /* CFGR2 must be configured first since CFGR value could change CFGR2 */
  RCC->CFGR2 = STM32_PREDIV;
 8000e02:	4b16      	ldr	r3, [pc, #88]	; (8000e5c <stm32_clock_init+0xcc>)
 8000e04:	2200      	movs	r2, #0
 8000e06:	62da      	str	r2, [r3, #44]	; 0x2c
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 8000e08:	4b14      	ldr	r3, [pc, #80]	; (8000e5c <stm32_clock_init+0xcc>)
 8000e0a:	22a0      	movs	r2, #160	; 0xa0
 8000e0c:	0392      	lsls	r2, r2, #14
 8000e0e:	605a      	str	r2, [r3, #4]
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE |
               ((STM32_PREDIV & STM32_PLLXTPRE_MASK) << STM32_PLLXTPRE_OFFSET);
#if STM32_CECSW == STM32_CECSW_OFF
  RCC->CFGR3 = STM32_USBSW  | STM32_I2C1SW | STM32_USART1SW;
#else
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
 8000e10:	4b12      	ldr	r3, [pc, #72]	; (8000e5c <stm32_clock_init+0xcc>)
 8000e12:	2200      	movs	r2, #0
 8000e14:	631a      	str	r2, [r3, #48]	; 0x30
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8000e16:	4b11      	ldr	r3, [pc, #68]	; (8000e5c <stm32_clock_init+0xcc>)
 8000e18:	4a10      	ldr	r2, [pc, #64]	; (8000e5c <stm32_clock_init+0xcc>)
 8000e1a:	6812      	ldr	r2, [r2, #0]
 8000e1c:	2180      	movs	r1, #128	; 0x80
 8000e1e:	0449      	lsls	r1, r1, #17
 8000e20:	430a      	orrs	r2, r1
 8000e22:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8000e24:	4b0d      	ldr	r3, [pc, #52]	; (8000e5c <stm32_clock_init+0xcc>)
 8000e26:	681a      	ldr	r2, [r3, #0]
 8000e28:	2380      	movs	r3, #128	; 0x80
 8000e2a:	049b      	lsls	r3, r3, #18
 8000e2c:	4013      	ands	r3, r2
 8000e2e:	d0f9      	beq.n	8000e24 <stm32_clock_init+0x94>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8000e30:	4b0b      	ldr	r3, [pc, #44]	; (8000e60 <stm32_clock_init+0xd0>)
 8000e32:	2211      	movs	r2, #17
 8000e34:	601a      	str	r2, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8000e36:	4b09      	ldr	r3, [pc, #36]	; (8000e5c <stm32_clock_init+0xcc>)
 8000e38:	4a08      	ldr	r2, [pc, #32]	; (8000e5c <stm32_clock_init+0xcc>)
 8000e3a:	6852      	ldr	r2, [r2, #4]
 8000e3c:	2102      	movs	r1, #2
 8000e3e:	430a      	orrs	r2, r1
 8000e40:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8000e42:	4b06      	ldr	r3, [pc, #24]	; (8000e5c <stm32_clock_init+0xcc>)
 8000e44:	685b      	ldr	r3, [r3, #4]
 8000e46:	220c      	movs	r2, #12
 8000e48:	4013      	ands	r3, r2
 8000e4a:	2b08      	cmp	r3, #8
 8000e4c:	d1f9      	bne.n	8000e42 <stm32_clock_init+0xb2>
    ;                                       /* Waits selection complete.    */
#endif

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8000e4e:	4b03      	ldr	r3, [pc, #12]	; (8000e5c <stm32_clock_init+0xcc>)
 8000e50:	4a02      	ldr	r2, [pc, #8]	; (8000e5c <stm32_clock_init+0xcc>)
 8000e52:	6992      	ldr	r2, [r2, #24]
 8000e54:	2101      	movs	r1, #1
 8000e56:	430a      	orrs	r2, r1
 8000e58:	619a      	str	r2, [r3, #24]
#endif /* !STM32_NO_INIT */
}
 8000e5a:	4770      	bx	lr
 8000e5c:	40021000 	.word	0x40021000
 8000e60:	40022000 	.word	0x40022000
	...

08000e70 <Vector64>:
/**
 * @brief   DMA1 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8000e70:	b500      	push	{lr}
 8000e72:	b085      	sub	sp, #20
 8000e74:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 8000e76:	9303      	str	r3, [sp, #12]
 8000e78:	4b1c      	ldr	r3, [pc, #112]	; (8000eec <Vector64+0x7c>)
 8000e7a:	0018      	movs	r0, r3
 8000e7c:	f002 f930 	bl	80030e0 <_trace_isr_enter>
 8000e80:	f001 fffe 	bl	8002e80 <_dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM1);
 8000e84:	2300      	movs	r3, #0
 8000e86:	9302      	str	r3, [sp, #8]
 8000e88:	4b19      	ldr	r3, [pc, #100]	; (8000ef0 <Vector64+0x80>)
 8000e8a:	681b      	ldr	r3, [r3, #0]
 8000e8c:	2200      	movs	r2, #0
 8000e8e:	40d3      	lsrs	r3, r2
 8000e90:	220e      	movs	r2, #14
 8000e92:	4013      	ands	r3, r2
 8000e94:	9301      	str	r3, [sp, #4]
 8000e96:	4b17      	ldr	r3, [pc, #92]	; (8000ef4 <Vector64+0x84>)
 8000e98:	681b      	ldr	r3, [r3, #0]
 8000e9a:	9a01      	ldr	r2, [sp, #4]
 8000e9c:	4013      	ands	r3, r2
 8000e9e:	d018      	beq.n	8000ed2 <Vector64+0x62>
 8000ea0:	4b13      	ldr	r3, [pc, #76]	; (8000ef0 <Vector64+0x80>)
 8000ea2:	2200      	movs	r2, #0
 8000ea4:	0011      	movs	r1, r2
 8000ea6:	9a01      	ldr	r2, [sp, #4]
 8000ea8:	408a      	lsls	r2, r1
 8000eaa:	605a      	str	r2, [r3, #4]
 8000eac:	4b12      	ldr	r3, [pc, #72]	; (8000ef8 <Vector64+0x88>)
 8000eae:	9a02      	ldr	r2, [sp, #8]
 8000eb0:	00d2      	lsls	r2, r2, #3
 8000eb2:	58d3      	ldr	r3, [r2, r3]
 8000eb4:	2b00      	cmp	r3, #0
 8000eb6:	d00c      	beq.n	8000ed2 <Vector64+0x62>
 8000eb8:	4b0f      	ldr	r3, [pc, #60]	; (8000ef8 <Vector64+0x88>)
 8000eba:	9a02      	ldr	r2, [sp, #8]
 8000ebc:	00d2      	lsls	r2, r2, #3
 8000ebe:	58d2      	ldr	r2, [r2, r3]
 8000ec0:	490d      	ldr	r1, [pc, #52]	; (8000ef8 <Vector64+0x88>)
 8000ec2:	9b02      	ldr	r3, [sp, #8]
 8000ec4:	00db      	lsls	r3, r3, #3
 8000ec6:	18cb      	adds	r3, r1, r3
 8000ec8:	3304      	adds	r3, #4
 8000eca:	681b      	ldr	r3, [r3, #0]
 8000ecc:	9901      	ldr	r1, [sp, #4]
 8000ece:	0018      	movs	r0, r3
 8000ed0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8000ed2:	f001 fff5 	bl	8002ec0 <_dbg_check_leave_isr>
 8000ed6:	4b05      	ldr	r3, [pc, #20]	; (8000eec <Vector64+0x7c>)
 8000ed8:	0018      	movs	r0, r3
 8000eda:	f002 f929 	bl	8003130 <_trace_isr_leave>
 8000ede:	9b03      	ldr	r3, [sp, #12]
 8000ee0:	0018      	movs	r0, r3
 8000ee2:	f000 fd45 	bl	8001970 <_port_irq_epilogue>
}
 8000ee6:	b005      	add	sp, #20
 8000ee8:	bd00      	pop	{pc}
 8000eea:	46c0      	nop			; (mov r8, r8)
 8000eec:	08003a8c 	.word	0x08003a8c
 8000ef0:	40020000 	.word	0x40020000
 8000ef4:	40020008 	.word	0x40020008
 8000ef8:	20000d88 	.word	0x20000d88
 8000efc:	00000000 	.word	0x00000000

08000f00 <dmaInit>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 8000f00:	b082      	sub	sp, #8
  int i;

  dma_streams_mask = 0U;
 8000f02:	4b11      	ldr	r3, [pc, #68]	; (8000f48 <dmaInit+0x48>)
 8000f04:	2200      	movs	r2, #0
 8000f06:	601a      	str	r2, [r3, #0]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8000f08:	2300      	movs	r3, #0
 8000f0a:	9301      	str	r3, [sp, #4]
 8000f0c:	e012      	b.n	8000f34 <dmaInit+0x34>
    _stm32_dma_streams[i].channel->CCR = 0U;
 8000f0e:	490f      	ldr	r1, [pc, #60]	; (8000f4c <dmaInit+0x4c>)
 8000f10:	9a01      	ldr	r2, [sp, #4]
 8000f12:	0013      	movs	r3, r2
 8000f14:	009b      	lsls	r3, r3, #2
 8000f16:	189b      	adds	r3, r3, r2
 8000f18:	009b      	lsls	r3, r3, #2
 8000f1a:	18cb      	adds	r3, r1, r3
 8000f1c:	3304      	adds	r3, #4
 8000f1e:	681b      	ldr	r3, [r3, #0]
 8000f20:	2200      	movs	r2, #0
 8000f22:	601a      	str	r2, [r3, #0]
    _stm32_dma_isr_redir[i].dma_func = NULL;
 8000f24:	4b0a      	ldr	r3, [pc, #40]	; (8000f50 <dmaInit+0x50>)
 8000f26:	9a01      	ldr	r2, [sp, #4]
 8000f28:	00d2      	lsls	r2, r2, #3
 8000f2a:	2100      	movs	r1, #0
 8000f2c:	50d1      	str	r1, [r2, r3]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8000f2e:	9b01      	ldr	r3, [sp, #4]
 8000f30:	3301      	adds	r3, #1
 8000f32:	9301      	str	r3, [sp, #4]
 8000f34:	9b01      	ldr	r3, [sp, #4]
 8000f36:	2b04      	cmp	r3, #4
 8000f38:	dde9      	ble.n	8000f0e <dmaInit+0xe>
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 8000f3a:	4b06      	ldr	r3, [pc, #24]	; (8000f54 <dmaInit+0x54>)
 8000f3c:	2201      	movs	r2, #1
 8000f3e:	4252      	negs	r2, r2
 8000f40:	605a      	str	r2, [r3, #4]
#if STM32_DMA2_NUM_CHANNELS > 0
  DMA2->IFCR = 0xFFFFFFFFU;
#endif
}
 8000f42:	b002      	add	sp, #8
 8000f44:	4770      	bx	lr
 8000f46:	46c0      	nop			; (mov r8, r8)
 8000f48:	20000db0 	.word	0x20000db0
 8000f4c:	08003a28 	.word	0x08003a28
 8000f50:	20000d88 	.word	0x20000d88
 8000f54:	40020000 	.word	0x40020000
	...

08000f60 <dmaStreamAllocate>:
 * @special
 */
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
                       uint32_t priority,
                       stm32_dmaisr_t func,
                       void *param) {
 8000f60:	b500      	push	{lr}
 8000f62:	b085      	sub	sp, #20
 8000f64:	9003      	str	r0, [sp, #12]
 8000f66:	9102      	str	r1, [sp, #8]
 8000f68:	9201      	str	r2, [sp, #4]
 8000f6a:	9300      	str	r3, [sp, #0]

  osalDbgCheck(dmastp != NULL);
 8000f6c:	9b03      	ldr	r3, [sp, #12]
 8000f6e:	2b00      	cmp	r3, #0
 8000f70:	d103      	bne.n	8000f7a <dmaStreamAllocate+0x1a>
 8000f72:	4b2f      	ldr	r3, [pc, #188]	; (8001030 <dmaStreamAllocate+0xd0>)
 8000f74:	0018      	movs	r0, r3
 8000f76:	f001 fed3 	bl	8002d20 <chSysHalt>

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
 8000f7a:	9b03      	ldr	r3, [sp, #12]
 8000f7c:	7c5b      	ldrb	r3, [r3, #17]
 8000f7e:	001a      	movs	r2, r3
 8000f80:	2301      	movs	r3, #1
 8000f82:	4093      	lsls	r3, r2
 8000f84:	001a      	movs	r2, r3
 8000f86:	4b2b      	ldr	r3, [pc, #172]	; (8001034 <dmaStreamAllocate+0xd4>)
 8000f88:	681b      	ldr	r3, [r3, #0]
 8000f8a:	4013      	ands	r3, r2
 8000f8c:	d001      	beq.n	8000f92 <dmaStreamAllocate+0x32>
    return true;
 8000f8e:	2301      	movs	r3, #1
 8000f90:	e04a      	b.n	8001028 <dmaStreamAllocate+0xc8>

  /* Installs the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8000f92:	9b03      	ldr	r3, [sp, #12]
 8000f94:	7c5b      	ldrb	r3, [r3, #17]
 8000f96:	001a      	movs	r2, r3
 8000f98:	4b27      	ldr	r3, [pc, #156]	; (8001038 <dmaStreamAllocate+0xd8>)
 8000f9a:	00d2      	lsls	r2, r2, #3
 8000f9c:	9901      	ldr	r1, [sp, #4]
 8000f9e:	50d1      	str	r1, [r2, r3]
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;
 8000fa0:	9b03      	ldr	r3, [sp, #12]
 8000fa2:	7c5b      	ldrb	r3, [r3, #17]
 8000fa4:	4a24      	ldr	r2, [pc, #144]	; (8001038 <dmaStreamAllocate+0xd8>)
 8000fa6:	00db      	lsls	r3, r3, #3
 8000fa8:	18d3      	adds	r3, r2, r3
 8000faa:	3304      	adds	r3, #4
 8000fac:	9a00      	ldr	r2, [sp, #0]
 8000fae:	601a      	str	r2, [r3, #0]

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8000fb0:	4b20      	ldr	r3, [pc, #128]	; (8001034 <dmaStreamAllocate+0xd4>)
 8000fb2:	681b      	ldr	r3, [r3, #0]
 8000fb4:	221f      	movs	r2, #31
 8000fb6:	4013      	ands	r3, r2
 8000fb8:	d105      	bne.n	8000fc6 <dmaStreamAllocate+0x66>
    rccEnableDMA1(false);
 8000fba:	4b20      	ldr	r3, [pc, #128]	; (800103c <dmaStreamAllocate+0xdc>)
 8000fbc:	4a1f      	ldr	r2, [pc, #124]	; (800103c <dmaStreamAllocate+0xdc>)
 8000fbe:	6952      	ldr	r2, [r2, #20]
 8000fc0:	2101      	movs	r1, #1
 8000fc2:	430a      	orrs	r2, r1
 8000fc4:	615a      	str	r2, [r3, #20]
    rccEnableDMA2(false);
  }
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 8000fc6:	9b03      	ldr	r3, [sp, #12]
 8000fc8:	685b      	ldr	r3, [r3, #4]
 8000fca:	9a03      	ldr	r2, [sp, #12]
 8000fcc:	6852      	ldr	r2, [r2, #4]
 8000fce:	6812      	ldr	r2, [r2, #0]
 8000fd0:	210f      	movs	r1, #15
 8000fd2:	438a      	bics	r2, r1
 8000fd4:	601a      	str	r2, [r3, #0]
 8000fd6:	9b03      	ldr	r3, [sp, #12]
 8000fd8:	681b      	ldr	r3, [r3, #0]
 8000fda:	9a03      	ldr	r2, [sp, #12]
 8000fdc:	7c12      	ldrb	r2, [r2, #16]
 8000fde:	0011      	movs	r1, r2
 8000fe0:	220e      	movs	r2, #14
 8000fe2:	408a      	lsls	r2, r1
 8000fe4:	605a      	str	r2, [r3, #4]
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8000fe6:	9b03      	ldr	r3, [sp, #12]
 8000fe8:	685b      	ldr	r3, [r3, #4]
 8000fea:	2200      	movs	r2, #0
 8000fec:	601a      	str	r2, [r3, #0]

  /* Enables the associated IRQ vector if not alread enabled and if a
     callback is defined.*/
  if (((dma_streams_mask & dmastp->cmask) == 0U) &&
 8000fee:	9b03      	ldr	r3, [sp, #12]
 8000ff0:	689a      	ldr	r2, [r3, #8]
 8000ff2:	4b10      	ldr	r3, [pc, #64]	; (8001034 <dmaStreamAllocate+0xd4>)
 8000ff4:	681b      	ldr	r3, [r3, #0]
 8000ff6:	4013      	ands	r3, r2
 8000ff8:	d10a      	bne.n	8001010 <dmaStreamAllocate+0xb0>
 8000ffa:	9b01      	ldr	r3, [sp, #4]
 8000ffc:	2b00      	cmp	r3, #0
 8000ffe:	d007      	beq.n	8001010 <dmaStreamAllocate+0xb0>
      (func != NULL)) {
    nvicEnableVector(dmastp->vector, priority);
 8001000:	9b03      	ldr	r3, [sp, #12]
 8001002:	7c9b      	ldrb	r3, [r3, #18]
 8001004:	001a      	movs	r2, r3
 8001006:	9b02      	ldr	r3, [sp, #8]
 8001008:	0019      	movs	r1, r3
 800100a:	0010      	movs	r0, r2
 800100c:	f7ff fd20 	bl	8000a50 <nvicEnableVector>
  }

  /* Marks the stream as allocated.*/
  dma_streams_mask |= (1U << dmastp->selfindex);
 8001010:	9b03      	ldr	r3, [sp, #12]
 8001012:	7c5b      	ldrb	r3, [r3, #17]
 8001014:	001a      	movs	r2, r3
 8001016:	2301      	movs	r3, #1
 8001018:	4093      	lsls	r3, r2
 800101a:	001a      	movs	r2, r3
 800101c:	4b05      	ldr	r3, [pc, #20]	; (8001034 <dmaStreamAllocate+0xd4>)
 800101e:	681b      	ldr	r3, [r3, #0]
 8001020:	431a      	orrs	r2, r3
 8001022:	4b04      	ldr	r3, [pc, #16]	; (8001034 <dmaStreamAllocate+0xd4>)
 8001024:	601a      	str	r2, [r3, #0]

  return false;
 8001026:	2300      	movs	r3, #0
}
 8001028:	0018      	movs	r0, r3
 800102a:	b005      	add	sp, #20
 800102c:	bd00      	pop	{pc}
 800102e:	46c0      	nop			; (mov r8, r8)
 8001030:	08003a98 	.word	0x08003a98
 8001034:	20000db0 	.word	0x20000db0
 8001038:	20000d88 	.word	0x20000d88
 800103c:	40021000 	.word	0x40021000

08001040 <initgpio>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {
 8001040:	b082      	sub	sp, #8
 8001042:	9001      	str	r0, [sp, #4]
 8001044:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 8001046:	9b00      	ldr	r3, [sp, #0]
 8001048:	685a      	ldr	r2, [r3, #4]
 800104a:	9b01      	ldr	r3, [sp, #4]
 800104c:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800104e:	9b00      	ldr	r3, [sp, #0]
 8001050:	689a      	ldr	r2, [r3, #8]
 8001052:	9b01      	ldr	r3, [sp, #4]
 8001054:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8001056:	9b00      	ldr	r3, [sp, #0]
 8001058:	68da      	ldr	r2, [r3, #12]
 800105a:	9b01      	ldr	r3, [sp, #4]
 800105c:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 800105e:	9b00      	ldr	r3, [sp, #0]
 8001060:	691a      	ldr	r2, [r3, #16]
 8001062:	9b01      	ldr	r3, [sp, #4]
 8001064:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8001066:	9b00      	ldr	r3, [sp, #0]
 8001068:	695a      	ldr	r2, [r3, #20]
 800106a:	9b01      	ldr	r3, [sp, #4]
 800106c:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 800106e:	9b00      	ldr	r3, [sp, #0]
 8001070:	699a      	ldr	r2, [r3, #24]
 8001072:	9b01      	ldr	r3, [sp, #4]
 8001074:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001076:	9b00      	ldr	r3, [sp, #0]
 8001078:	681a      	ldr	r2, [r3, #0]
 800107a:	9b01      	ldr	r3, [sp, #4]
 800107c:	601a      	str	r2, [r3, #0]
}
 800107e:	b002      	add	sp, #8
 8001080:	4770      	bx	lr
 8001082:	46c0      	nop			; (mov r8, r8)
	...

08001090 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 8001090:	b500      	push	{lr}
 8001092:	b083      	sub	sp, #12
 8001094:	9001      	str	r0, [sp, #4]
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8001096:	4b12      	ldr	r3, [pc, #72]	; (80010e0 <_pal_lld_init+0x50>)
 8001098:	4a11      	ldr	r2, [pc, #68]	; (80010e0 <_pal_lld_init+0x50>)
 800109a:	6952      	ldr	r2, [r2, #20]
 800109c:	219c      	movs	r1, #156	; 0x9c
 800109e:	03c9      	lsls	r1, r1, #15
 80010a0:	430a      	orrs	r2, r1
 80010a2:	615a      	str	r2, [r3, #20]

  /*
   * Initial GPIO setup.
   */
#if STM32_HAS_GPIOA
  initgpio(GPIOA, &config->PAData);
 80010a4:	9a01      	ldr	r2, [sp, #4]
 80010a6:	2390      	movs	r3, #144	; 0x90
 80010a8:	05db      	lsls	r3, r3, #23
 80010aa:	0011      	movs	r1, r2
 80010ac:	0018      	movs	r0, r3
 80010ae:	f7ff ffc7 	bl	8001040 <initgpio>
#endif
#if STM32_HAS_GPIOB
  initgpio(GPIOB, &config->PBData);
 80010b2:	9b01      	ldr	r3, [sp, #4]
 80010b4:	331c      	adds	r3, #28
 80010b6:	4a0b      	ldr	r2, [pc, #44]	; (80010e4 <_pal_lld_init+0x54>)
 80010b8:	0019      	movs	r1, r3
 80010ba:	0010      	movs	r0, r2
 80010bc:	f7ff ffc0 	bl	8001040 <initgpio>
#endif
#if STM32_HAS_GPIOC
  initgpio(GPIOC, &config->PCData);
 80010c0:	9b01      	ldr	r3, [sp, #4]
 80010c2:	3338      	adds	r3, #56	; 0x38
 80010c4:	4a08      	ldr	r2, [pc, #32]	; (80010e8 <_pal_lld_init+0x58>)
 80010c6:	0019      	movs	r1, r3
 80010c8:	0010      	movs	r0, r2
 80010ca:	f7ff ffb9 	bl	8001040 <initgpio>
#endif
#if STM32_HAS_GPIOE
  initgpio(GPIOE, &config->PEData);
#endif
#if STM32_HAS_GPIOF
  initgpio(GPIOF, &config->PFData);
 80010ce:	9b01      	ldr	r3, [sp, #4]
 80010d0:	3354      	adds	r3, #84	; 0x54
 80010d2:	4a06      	ldr	r2, [pc, #24]	; (80010ec <_pal_lld_init+0x5c>)
 80010d4:	0019      	movs	r1, r3
 80010d6:	0010      	movs	r0, r2
 80010d8:	f7ff ffb2 	bl	8001040 <initgpio>
  initgpio(GPIOJ, &config->PJData);
#endif
#if STM32_HAS_GPIOK
  initgpio(GPIOK, &config->PKData);
#endif
}
 80010dc:	b003      	add	sp, #12
 80010de:	bd00      	pop	{pc}
 80010e0:	40021000 	.word	0x40021000
 80010e4:	48000400 	.word	0x48000400
 80010e8:	48000800 	.word	0x48000800
 80010ec:	48001400 	.word	0x48001400

080010f0 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 80010f0:	b08e      	sub	sp, #56	; 0x38
 80010f2:	9003      	str	r0, [sp, #12]
 80010f4:	9102      	str	r1, [sp, #8]
 80010f6:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 80010f8:	9b01      	ldr	r3, [sp, #4]
 80010fa:	2203      	movs	r2, #3
 80010fc:	4013      	ands	r3, r2
 80010fe:	930d      	str	r3, [sp, #52]	; 0x34
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8001100:	9b01      	ldr	r3, [sp, #4]
 8001102:	089b      	lsrs	r3, r3, #2
 8001104:	2201      	movs	r2, #1
 8001106:	4013      	ands	r3, r2
 8001108:	930c      	str	r3, [sp, #48]	; 0x30
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 800110a:	9b01      	ldr	r3, [sp, #4]
 800110c:	08db      	lsrs	r3, r3, #3
 800110e:	2203      	movs	r2, #3
 8001110:	4013      	ands	r3, r2
 8001112:	930b      	str	r3, [sp, #44]	; 0x2c
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 8001114:	9b01      	ldr	r3, [sp, #4]
 8001116:	095b      	lsrs	r3, r3, #5
 8001118:	2203      	movs	r2, #3
 800111a:	4013      	ands	r3, r2
 800111c:	930a      	str	r3, [sp, #40]	; 0x28
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 800111e:	9b01      	ldr	r3, [sp, #4]
 8001120:	09db      	lsrs	r3, r3, #7
 8001122:	220f      	movs	r2, #15
 8001124:	4013      	ands	r3, r2
 8001126:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
 8001128:	2300      	movs	r3, #0
 800112a:	9309      	str	r3, [sp, #36]	; 0x24
  while (true) {
    if ((mask & 1) != 0) {
 800112c:	9b02      	ldr	r3, [sp, #8]
 800112e:	2201      	movs	r2, #1
 8001130:	4013      	ands	r3, r2
 8001132:	d100      	bne.n	8001136 <_pal_lld_setgroupmode+0x46>
 8001134:	e079      	b.n	800122a <_pal_lld_setgroupmode+0x13a>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8001136:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8001138:	2207      	movs	r2, #7
 800113a:	4013      	ands	r3, r2
 800113c:	009b      	lsls	r3, r3, #2
 800113e:	9a08      	ldr	r2, [sp, #32]
 8001140:	409a      	lsls	r2, r3
 8001142:	0013      	movs	r3, r2
 8001144:	9307      	str	r3, [sp, #28]
      m1 = 1 << bit;
 8001146:	2201      	movs	r2, #1
 8001148:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800114a:	409a      	lsls	r2, r3
 800114c:	0013      	movs	r3, r2
 800114e:	9306      	str	r3, [sp, #24]
      m2 = 3 << (bit * 2);
 8001150:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8001152:	005b      	lsls	r3, r3, #1
 8001154:	2203      	movs	r2, #3
 8001156:	409a      	lsls	r2, r3
 8001158:	0013      	movs	r3, r2
 800115a:	9305      	str	r3, [sp, #20]
      m4 = 15 << ((bit & 7) * 4);
 800115c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800115e:	2207      	movs	r2, #7
 8001160:	4013      	ands	r3, r2
 8001162:	009b      	lsls	r3, r3, #2
 8001164:	220f      	movs	r2, #15
 8001166:	409a      	lsls	r2, r3
 8001168:	0013      	movs	r3, r2
 800116a:	9304      	str	r3, [sp, #16]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 800116c:	9b03      	ldr	r3, [sp, #12]
 800116e:	685b      	ldr	r3, [r3, #4]
 8001170:	9a06      	ldr	r2, [sp, #24]
 8001172:	43d2      	mvns	r2, r2
 8001174:	401a      	ands	r2, r3
 8001176:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8001178:	431a      	orrs	r2, r3
 800117a:	9b03      	ldr	r3, [sp, #12]
 800117c:	605a      	str	r2, [r3, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 800117e:	9b03      	ldr	r3, [sp, #12]
 8001180:	689b      	ldr	r3, [r3, #8]
 8001182:	9a05      	ldr	r2, [sp, #20]
 8001184:	43d2      	mvns	r2, r2
 8001186:	401a      	ands	r2, r3
 8001188:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800118a:	431a      	orrs	r2, r3
 800118c:	9b03      	ldr	r3, [sp, #12]
 800118e:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8001190:	9b03      	ldr	r3, [sp, #12]
 8001192:	68db      	ldr	r3, [r3, #12]
 8001194:	9a05      	ldr	r2, [sp, #20]
 8001196:	43d2      	mvns	r2, r2
 8001198:	401a      	ands	r2, r3
 800119a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800119c:	431a      	orrs	r2, r3
 800119e:	9b03      	ldr	r3, [sp, #12]
 80011a0:	60da      	str	r2, [r3, #12]
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 80011a2:	9b01      	ldr	r3, [sp, #4]
 80011a4:	2203      	movs	r2, #3
 80011a6:	4013      	ands	r3, r2
 80011a8:	2b02      	cmp	r3, #2
 80011aa:	d11f      	bne.n	80011ec <_pal_lld_setgroupmode+0xfc>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 80011ac:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80011ae:	2b07      	cmp	r3, #7
 80011b0:	d809      	bhi.n	80011c6 <_pal_lld_setgroupmode+0xd6>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 80011b2:	9b03      	ldr	r3, [sp, #12]
 80011b4:	6a1b      	ldr	r3, [r3, #32]
 80011b6:	9a04      	ldr	r2, [sp, #16]
 80011b8:	43d2      	mvns	r2, r2
 80011ba:	401a      	ands	r2, r3
 80011bc:	9b07      	ldr	r3, [sp, #28]
 80011be:	431a      	orrs	r2, r3
 80011c0:	9b03      	ldr	r3, [sp, #12]
 80011c2:	621a      	str	r2, [r3, #32]
 80011c4:	e008      	b.n	80011d8 <_pal_lld_setgroupmode+0xe8>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80011c6:	9b03      	ldr	r3, [sp, #12]
 80011c8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80011ca:	9a04      	ldr	r2, [sp, #16]
 80011cc:	43d2      	mvns	r2, r2
 80011ce:	401a      	ands	r2, r3
 80011d0:	9b07      	ldr	r3, [sp, #28]
 80011d2:	431a      	orrs	r2, r3
 80011d4:	9b03      	ldr	r3, [sp, #12]
 80011d6:	625a      	str	r2, [r3, #36]	; 0x24
        port->MODER   = (port->MODER & ~m2) | moder;
 80011d8:	9b03      	ldr	r3, [sp, #12]
 80011da:	681b      	ldr	r3, [r3, #0]
 80011dc:	9a05      	ldr	r2, [sp, #20]
 80011de:	43d2      	mvns	r2, r2
 80011e0:	401a      	ands	r2, r3
 80011e2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80011e4:	431a      	orrs	r2, r3
 80011e6:	9b03      	ldr	r3, [sp, #12]
 80011e8:	601a      	str	r2, [r3, #0]
 80011ea:	e01e      	b.n	800122a <_pal_lld_setgroupmode+0x13a>
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 80011ec:	9b03      	ldr	r3, [sp, #12]
 80011ee:	681b      	ldr	r3, [r3, #0]
 80011f0:	9a05      	ldr	r2, [sp, #20]
 80011f2:	43d2      	mvns	r2, r2
 80011f4:	401a      	ands	r2, r3
 80011f6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80011f8:	431a      	orrs	r2, r3
 80011fa:	9b03      	ldr	r3, [sp, #12]
 80011fc:	601a      	str	r2, [r3, #0]
        if (bit < 8)
 80011fe:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8001200:	2b07      	cmp	r3, #7
 8001202:	d809      	bhi.n	8001218 <_pal_lld_setgroupmode+0x128>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8001204:	9b03      	ldr	r3, [sp, #12]
 8001206:	6a1b      	ldr	r3, [r3, #32]
 8001208:	9a04      	ldr	r2, [sp, #16]
 800120a:	43d2      	mvns	r2, r2
 800120c:	401a      	ands	r2, r3
 800120e:	9b07      	ldr	r3, [sp, #28]
 8001210:	431a      	orrs	r2, r3
 8001212:	9b03      	ldr	r3, [sp, #12]
 8001214:	621a      	str	r2, [r3, #32]
 8001216:	e008      	b.n	800122a <_pal_lld_setgroupmode+0x13a>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8001218:	9b03      	ldr	r3, [sp, #12]
 800121a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800121c:	9a04      	ldr	r2, [sp, #16]
 800121e:	43d2      	mvns	r2, r2
 8001220:	401a      	ands	r2, r3
 8001222:	9b07      	ldr	r3, [sp, #28]
 8001224:	431a      	orrs	r2, r3
 8001226:	9b03      	ldr	r3, [sp, #12]
 8001228:	625a      	str	r2, [r3, #36]	; 0x24
      }
    }
    mask >>= 1;
 800122a:	9b02      	ldr	r3, [sp, #8]
 800122c:	085b      	lsrs	r3, r3, #1
 800122e:	9302      	str	r3, [sp, #8]
    if (!mask)
 8001230:	9b02      	ldr	r3, [sp, #8]
 8001232:	2b00      	cmp	r3, #0
 8001234:	d00f      	beq.n	8001256 <_pal_lld_setgroupmode+0x166>
      return;
    otyper <<= 1;
 8001236:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8001238:	005b      	lsls	r3, r3, #1
 800123a:	930c      	str	r3, [sp, #48]	; 0x30
    ospeedr <<= 2;
 800123c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800123e:	009b      	lsls	r3, r3, #2
 8001240:	930b      	str	r3, [sp, #44]	; 0x2c
    pupdr <<= 2;
 8001242:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8001244:	009b      	lsls	r3, r3, #2
 8001246:	930a      	str	r3, [sp, #40]	; 0x28
    moder <<= 2;
 8001248:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800124a:	009b      	lsls	r3, r3, #2
 800124c:	930d      	str	r3, [sp, #52]	; 0x34
    bit++;
 800124e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8001250:	3301      	adds	r3, #1
 8001252:	9309      	str	r3, [sp, #36]	; 0x24
 8001254:	e76a      	b.n	800112c <_pal_lld_setgroupmode+0x3c>
  }
}
 8001256:	b00e      	add	sp, #56	; 0x38
 8001258:	4770      	bx	lr
 800125a:	46c0      	nop			; (mov r8, r8)
 800125c:	0000      	movs	r0, r0
	...

08001260 <port_lock>:
  __ASM volatile ("cpsid i" : : : "memory");
 8001260:	b672      	cpsid	i
}
 8001262:	4770      	bx	lr
	...

08001270 <port_unlock>:
  __ASM volatile ("cpsie i" : : : "memory");
 8001270:	b662      	cpsie	i
}
 8001272:	4770      	bx	lr
	...

08001280 <port_lock_from_isr>:
static inline void port_lock_from_isr(void) {
 8001280:	b510      	push	{r4, lr}
  port_lock();
 8001282:	f7ff ffed 	bl	8001260 <port_lock>
}
 8001286:	bd10      	pop	{r4, pc}
	...

08001290 <port_unlock_from_isr>:
static inline void port_unlock_from_isr(void) {
 8001290:	b510      	push	{r4, lr}
  port_unlock();
 8001292:	f7ff ffed 	bl	8001270 <port_unlock>
}
 8001296:	bd10      	pop	{r4, pc}
	...

080012a0 <chSysLockFromISR>:
static inline void chSysLockFromISR(void) {
 80012a0:	b510      	push	{r4, lr}
  port_lock_from_isr();
 80012a2:	f7ff ffed 	bl	8001280 <port_lock_from_isr>
  _dbg_check_lock_from_isr();
 80012a6:	f001 fdbb 	bl	8002e20 <_dbg_check_lock_from_isr>
}
 80012aa:	bd10      	pop	{r4, pc}
 80012ac:	0000      	movs	r0, r0
	...

080012b0 <chSysUnlockFromISR>:
static inline void chSysUnlockFromISR(void) {
 80012b0:	b510      	push	{r4, lr}
  _dbg_check_unlock_from_isr();
 80012b2:	f001 fdcd 	bl	8002e50 <_dbg_check_unlock_from_isr>
  port_unlock_from_isr();
 80012b6:	f7ff ffeb 	bl	8001290 <port_unlock_from_isr>
}
 80012ba:	bd10      	pop	{r4, pc}
 80012bc:	0000      	movs	r0, r0
	...

080012c0 <osalSysHalt>:
static inline void osalSysHalt(const char *reason) {
 80012c0:	b500      	push	{lr}
 80012c2:	b083      	sub	sp, #12
 80012c4:	9001      	str	r0, [sp, #4]
  chSysHalt(reason);
 80012c6:	9b01      	ldr	r3, [sp, #4]
 80012c8:	0018      	movs	r0, r3
 80012ca:	f001 fd29 	bl	8002d20 <chSysHalt>
}
 80012ce:	b003      	add	sp, #12
 80012d0:	bd00      	pop	{pc}
 80012d2:	46c0      	nop			; (mov r8, r8)
	...

080012e0 <osalSysLockFromISR>:
static inline void osalSysLockFromISR(void) {
 80012e0:	b510      	push	{r4, lr}
  chSysLockFromISR();
 80012e2:	f7ff ffdd 	bl	80012a0 <chSysLockFromISR>
}
 80012e6:	bd10      	pop	{r4, pc}
	...

080012f0 <osalSysUnlockFromISR>:
static inline void osalSysUnlockFromISR(void) {
 80012f0:	b510      	push	{r4, lr}
  chSysUnlockFromISR();
 80012f2:	f7ff ffdd 	bl	80012b0 <chSysUnlockFromISR>
}
 80012f6:	bd10      	pop	{r4, pc}
	...

08001300 <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 8001300:	b500      	push	{lr}
 8001302:	b083      	sub	sp, #12
 8001304:	9001      	str	r0, [sp, #4]
 8001306:	9100      	str	r1, [sp, #0]

  chThdResumeI(trp, msg);
 8001308:	9a00      	ldr	r2, [sp, #0]
 800130a:	9b01      	ldr	r3, [sp, #4]
 800130c:	0011      	movs	r1, r2
 800130e:	0018      	movs	r0, r3
 8001310:	f001 fa26 	bl	8002760 <chThdResumeI>
}
 8001314:	b003      	add	sp, #12
 8001316:	bd00      	pop	{pc}
	...

08001320 <spi_lld_serve_rx_interrupt.lto_priv.4>:
static void spi_lld_serve_rx_interrupt(SPIDriver *spip, uint32_t flags) {
 8001320:	b500      	push	{lr}
 8001322:	b083      	sub	sp, #12
 8001324:	9001      	str	r0, [sp, #4]
 8001326:	9100      	str	r1, [sp, #0]
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8001328:	9b00      	ldr	r3, [sp, #0]
 800132a:	2208      	movs	r2, #8
 800132c:	4013      	ands	r3, r2
 800132e:	d003      	beq.n	8001338 <spi_lld_serve_rx_interrupt.lto_priv.4+0x18>
    STM32_SPI_DMA_ERROR_HOOK(spip);
 8001330:	4b28      	ldr	r3, [pc, #160]	; (80013d4 <spi_lld_serve_rx_interrupt.lto_priv.4+0xb4>)
 8001332:	0018      	movs	r0, r3
 8001334:	f7ff ffc4 	bl	80012c0 <osalSysHalt>
  dmaStreamDisable(spip->dmatx);
 8001338:	9b01      	ldr	r3, [sp, #4]
 800133a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800133c:	685b      	ldr	r3, [r3, #4]
 800133e:	9a01      	ldr	r2, [sp, #4]
 8001340:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8001342:	6852      	ldr	r2, [r2, #4]
 8001344:	6812      	ldr	r2, [r2, #0]
 8001346:	210f      	movs	r1, #15
 8001348:	438a      	bics	r2, r1
 800134a:	601a      	str	r2, [r3, #0]
 800134c:	9b01      	ldr	r3, [sp, #4]
 800134e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001350:	681b      	ldr	r3, [r3, #0]
 8001352:	9a01      	ldr	r2, [sp, #4]
 8001354:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8001356:	7c12      	ldrb	r2, [r2, #16]
 8001358:	0011      	movs	r1, r2
 800135a:	220e      	movs	r2, #14
 800135c:	408a      	lsls	r2, r1
 800135e:	605a      	str	r2, [r3, #4]
  dmaStreamDisable(spip->dmarx);
 8001360:	9b01      	ldr	r3, [sp, #4]
 8001362:	6a1b      	ldr	r3, [r3, #32]
 8001364:	685b      	ldr	r3, [r3, #4]
 8001366:	9a01      	ldr	r2, [sp, #4]
 8001368:	6a12      	ldr	r2, [r2, #32]
 800136a:	6852      	ldr	r2, [r2, #4]
 800136c:	6812      	ldr	r2, [r2, #0]
 800136e:	210f      	movs	r1, #15
 8001370:	438a      	bics	r2, r1
 8001372:	601a      	str	r2, [r3, #0]
 8001374:	9b01      	ldr	r3, [sp, #4]
 8001376:	6a1b      	ldr	r3, [r3, #32]
 8001378:	681b      	ldr	r3, [r3, #0]
 800137a:	9a01      	ldr	r2, [sp, #4]
 800137c:	6a12      	ldr	r2, [r2, #32]
 800137e:	7c12      	ldrb	r2, [r2, #16]
 8001380:	0011      	movs	r1, r2
 8001382:	220e      	movs	r2, #14
 8001384:	408a      	lsls	r2, r1
 8001386:	605a      	str	r2, [r3, #4]
  _spi_isr_code(spip);
 8001388:	9b01      	ldr	r3, [sp, #4]
 800138a:	685b      	ldr	r3, [r3, #4]
 800138c:	681b      	ldr	r3, [r3, #0]
 800138e:	2b00      	cmp	r3, #0
 8001390:	d010      	beq.n	80013b4 <spi_lld_serve_rx_interrupt.lto_priv.4+0x94>
 8001392:	9b01      	ldr	r3, [sp, #4]
 8001394:	2204      	movs	r2, #4
 8001396:	701a      	strb	r2, [r3, #0]
 8001398:	9b01      	ldr	r3, [sp, #4]
 800139a:	685b      	ldr	r3, [r3, #4]
 800139c:	681b      	ldr	r3, [r3, #0]
 800139e:	9a01      	ldr	r2, [sp, #4]
 80013a0:	0010      	movs	r0, r2
 80013a2:	4798      	blx	r3
 80013a4:	9b01      	ldr	r3, [sp, #4]
 80013a6:	781b      	ldrb	r3, [r3, #0]
 80013a8:	2b04      	cmp	r3, #4
 80013aa:	d106      	bne.n	80013ba <spi_lld_serve_rx_interrupt.lto_priv.4+0x9a>
 80013ac:	9b01      	ldr	r3, [sp, #4]
 80013ae:	2202      	movs	r2, #2
 80013b0:	701a      	strb	r2, [r3, #0]
 80013b2:	e002      	b.n	80013ba <spi_lld_serve_rx_interrupt.lto_priv.4+0x9a>
 80013b4:	9b01      	ldr	r3, [sp, #4]
 80013b6:	2202      	movs	r2, #2
 80013b8:	701a      	strb	r2, [r3, #0]
 80013ba:	f7ff ff91 	bl	80012e0 <osalSysLockFromISR>
 80013be:	9b01      	ldr	r3, [sp, #4]
 80013c0:	3308      	adds	r3, #8
 80013c2:	2100      	movs	r1, #0
 80013c4:	0018      	movs	r0, r3
 80013c6:	f7ff ff9b 	bl	8001300 <osalThreadResumeI>
 80013ca:	f7ff ff91 	bl	80012f0 <osalSysUnlockFromISR>
}
 80013ce:	b003      	add	sp, #12
 80013d0:	bd00      	pop	{pc}
 80013d2:	46c0      	nop			; (mov r8, r8)
 80013d4:	080036f4 	.word	0x080036f4
	...

080013e0 <spi_lld_serve_tx_interrupt.lto_priv.5>:
static void spi_lld_serve_tx_interrupt(SPIDriver *spip, uint32_t flags) {
 80013e0:	b500      	push	{lr}
 80013e2:	b083      	sub	sp, #12
 80013e4:	9001      	str	r0, [sp, #4]
 80013e6:	9100      	str	r1, [sp, #0]
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 80013e8:	9b00      	ldr	r3, [sp, #0]
 80013ea:	2208      	movs	r2, #8
 80013ec:	4013      	ands	r3, r2
 80013ee:	d003      	beq.n	80013f8 <spi_lld_serve_tx_interrupt.lto_priv.5+0x18>
    STM32_SPI_DMA_ERROR_HOOK(spip);
 80013f0:	4b02      	ldr	r3, [pc, #8]	; (80013fc <spi_lld_serve_tx_interrupt.lto_priv.5+0x1c>)
 80013f2:	0018      	movs	r0, r3
 80013f4:	f7ff ff64 	bl	80012c0 <osalSysHalt>
}
 80013f8:	b003      	add	sp, #12
 80013fa:	bd00      	pop	{pc}
 80013fc:	080036f4 	.word	0x080036f4

08001400 <spi_lld_init>:
void spi_lld_init(void) {
 8001400:	b510      	push	{r4, lr}
  spiObjectInit(&SPID1);
 8001402:	4b0a      	ldr	r3, [pc, #40]	; (800142c <spi_lld_init+0x2c>)
 8001404:	0018      	movs	r0, r3
 8001406:	f000 f8b3 	bl	8001570 <spiObjectInit>
  SPID1.spi       = SPI1;
 800140a:	4b08      	ldr	r3, [pc, #32]	; (800142c <spi_lld_init+0x2c>)
 800140c:	4a08      	ldr	r2, [pc, #32]	; (8001430 <spi_lld_init+0x30>)
 800140e:	61da      	str	r2, [r3, #28]
  SPID1.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI1_RX_DMA_STREAM);
 8001410:	4b06      	ldr	r3, [pc, #24]	; (800142c <spi_lld_init+0x2c>)
 8001412:	4a08      	ldr	r2, [pc, #32]	; (8001434 <spi_lld_init+0x34>)
 8001414:	621a      	str	r2, [r3, #32]
  SPID1.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI1_TX_DMA_STREAM);
 8001416:	4b05      	ldr	r3, [pc, #20]	; (800142c <spi_lld_init+0x2c>)
 8001418:	4a07      	ldr	r2, [pc, #28]	; (8001438 <spi_lld_init+0x38>)
 800141a:	625a      	str	r2, [r3, #36]	; 0x24
  SPID1.rxdmamode = STM32_DMA_CR_CHSEL(SPI1_RX_DMA_CHANNEL) |
 800141c:	4b03      	ldr	r3, [pc, #12]	; (800142c <spi_lld_init+0x2c>)
 800141e:	4a07      	ldr	r2, [pc, #28]	; (800143c <spi_lld_init+0x3c>)
 8001420:	629a      	str	r2, [r3, #40]	; 0x28
  SPID1.txdmamode = STM32_DMA_CR_CHSEL(SPI1_TX_DMA_CHANNEL) |
 8001422:	4b02      	ldr	r3, [pc, #8]	; (800142c <spi_lld_init+0x2c>)
 8001424:	4a06      	ldr	r2, [pc, #24]	; (8001440 <spi_lld_init+0x40>)
 8001426:	62da      	str	r2, [r3, #44]	; 0x2c
}
 8001428:	bd10      	pop	{r4, pc}
 800142a:	46c0      	nop			; (mov r8, r8)
 800142c:	20000db4 	.word	0x20000db4
 8001430:	40013000 	.word	0x40013000
 8001434:	08003a3c 	.word	0x08003a3c
 8001438:	08003a50 	.word	0x08003a50
 800143c:	0000100a 	.word	0x0000100a
 8001440:	00001018 	.word	0x00001018
	...

08001450 <port_lock.lto_priv.92>:
  __ASM volatile ("cpsid i" : : : "memory");
 8001450:	b672      	cpsid	i
}
 8001452:	4770      	bx	lr
	...

08001460 <port_unlock.lto_priv.90>:
  __ASM volatile ("cpsie i" : : : "memory");
 8001460:	b662      	cpsie	i
}
 8001462:	4770      	bx	lr
	...

08001470 <chSysLock.lto_priv.88>:
static inline void chSysLock(void) {
 8001470:	b510      	push	{r4, lr}
  port_lock();
 8001472:	f7ff ffed 	bl	8001450 <port_lock.lto_priv.92>
  _dbg_check_lock();
 8001476:	f001 fca3 	bl	8002dc0 <_dbg_check_lock>
}
 800147a:	bd10      	pop	{r4, pc}
 800147c:	0000      	movs	r0, r0
	...

08001480 <chSysUnlock.lto_priv.86>:
static inline void chSysUnlock(void) {
 8001480:	b510      	push	{r4, lr}
  _dbg_check_unlock();
 8001482:	f001 fcb5 	bl	8002df0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001486:	4b0a      	ldr	r3, [pc, #40]	; (80014b0 <chSysUnlock.lto_priv.86+0x30>)
 8001488:	681a      	ldr	r2, [r3, #0]
 800148a:	4b09      	ldr	r3, [pc, #36]	; (80014b0 <chSysUnlock.lto_priv.86+0x30>)
 800148c:	429a      	cmp	r2, r3
 800148e:	d00b      	beq.n	80014a8 <chSysUnlock.lto_priv.86+0x28>
 8001490:	4b07      	ldr	r3, [pc, #28]	; (80014b0 <chSysUnlock.lto_priv.86+0x30>)
 8001492:	699b      	ldr	r3, [r3, #24]
 8001494:	689a      	ldr	r2, [r3, #8]
 8001496:	4b06      	ldr	r3, [pc, #24]	; (80014b0 <chSysUnlock.lto_priv.86+0x30>)
 8001498:	681b      	ldr	r3, [r3, #0]
 800149a:	689b      	ldr	r3, [r3, #8]
 800149c:	429a      	cmp	r2, r3
 800149e:	d203      	bcs.n	80014a8 <chSysUnlock.lto_priv.86+0x28>
 80014a0:	4b04      	ldr	r3, [pc, #16]	; (80014b4 <chSysUnlock.lto_priv.86+0x34>)
 80014a2:	0018      	movs	r0, r3
 80014a4:	f001 fc3c 	bl	8002d20 <chSysHalt>
  port_unlock();
 80014a8:	f7ff ffda 	bl	8001460 <port_unlock.lto_priv.90>
}
 80014ac:	bd10      	pop	{r4, pc}
 80014ae:	46c0      	nop			; (mov r8, r8)
 80014b0:	200004d8 	.word	0x200004d8
 80014b4:	080039a4 	.word	0x080039a4
	...

080014c0 <osalSysLock.lto_priv.84>:
static inline void osalSysLock(void) {
 80014c0:	b510      	push	{r4, lr}
  chSysLock();
 80014c2:	f7ff ffd5 	bl	8001470 <chSysLock.lto_priv.88>
}
 80014c6:	bd10      	pop	{r4, pc}
	...

080014d0 <osalSysUnlock.lto_priv.82>:
static inline void osalSysUnlock(void) {
 80014d0:	b510      	push	{r4, lr}
  chSysUnlock();
 80014d2:	f7ff ffd5 	bl	8001480 <chSysUnlock.lto_priv.86>
}
 80014d6:	bd10      	pop	{r4, pc}
	...

080014e0 <osalThreadSuspendS.lto_priv.83>:
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 80014e0:	b500      	push	{lr}
 80014e2:	b083      	sub	sp, #12
 80014e4:	9001      	str	r0, [sp, #4]
  return chThdSuspendS(trp);
 80014e6:	9b01      	ldr	r3, [sp, #4]
 80014e8:	0018      	movs	r0, r3
 80014ea:	f001 f911 	bl	8002710 <chThdSuspendS>
 80014ee:	0003      	movs	r3, r0
}
 80014f0:	0018      	movs	r0, r3
 80014f2:	b003      	add	sp, #12
 80014f4:	bd00      	pop	{pc}
 80014f6:	46c0      	nop			; (mov r8, r8)
	...

08001500 <osalMutexObjectInit>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
 8001500:	b500      	push	{lr}
 8001502:	b083      	sub	sp, #12
 8001504:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 8001506:	9b01      	ldr	r3, [sp, #4]
 8001508:	0018      	movs	r0, r3
 800150a:	f000 fb39 	bl	8001b80 <chMtxObjectInit>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
 800150e:	b003      	add	sp, #12
 8001510:	bd00      	pop	{pc}
 8001512:	46c0      	nop			; (mov r8, r8)
	...

08001520 <osalMutexLock.lto_priv.81>:
 *
 * @param[in,out] mp    pointer to the @p mutex_t object
 *
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {
 8001520:	b500      	push	{lr}
 8001522:	b083      	sub	sp, #12
 8001524:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 8001526:	9b01      	ldr	r3, [sp, #4]
 8001528:	0018      	movs	r0, r3
 800152a:	f000 fb41 	bl	8001bb0 <chMtxLock>
#elif CH_CFG_USE_SEMAPHORES
  chSemWait((semaphore_t *)mp);
#else
  *mp = 1;
#endif
}
 800152e:	b003      	add	sp, #12
 8001530:	bd00      	pop	{pc}
 8001532:	46c0      	nop			; (mov r8, r8)
	...

08001540 <osalMutexUnlock.lto_priv.80>:
 *
 * @param[in,out] mp    pointer to the @p mutex_t object
 *
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {
 8001540:	b500      	push	{lr}
 8001542:	b083      	sub	sp, #12
 8001544:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 8001546:	9b01      	ldr	r3, [sp, #4]
 8001548:	0018      	movs	r0, r3
 800154a:	f000 fbc9 	bl	8001ce0 <chMtxUnlock>
#elif CH_CFG_USE_SEMAPHORES
  chSemSignal((semaphore_t *)mp);
#else
  *mp = 0;
#endif
}
 800154e:	b003      	add	sp, #12
 8001550:	bd00      	pop	{pc}
 8001552:	46c0      	nop			; (mov r8, r8)
	...

08001560 <spiInit>:
void spiInit(void) {
 8001560:	b510      	push	{r4, lr}
  spi_lld_init();
 8001562:	f7ff ff4d 	bl	8001400 <spi_lld_init>
}
 8001566:	bd10      	pop	{r4, pc}
	...

08001570 <spiObjectInit>:
void spiObjectInit(SPIDriver *spip) {
 8001570:	b500      	push	{lr}
 8001572:	b083      	sub	sp, #12
 8001574:	9001      	str	r0, [sp, #4]
  spip->state = SPI_STOP;
 8001576:	9b01      	ldr	r3, [sp, #4]
 8001578:	2201      	movs	r2, #1
 800157a:	701a      	strb	r2, [r3, #0]
  spip->config = NULL;
 800157c:	9b01      	ldr	r3, [sp, #4]
 800157e:	2200      	movs	r2, #0
 8001580:	605a      	str	r2, [r3, #4]
  spip->thread = NULL;
 8001582:	9b01      	ldr	r3, [sp, #4]
 8001584:	2200      	movs	r2, #0
 8001586:	609a      	str	r2, [r3, #8]
  osalMutexObjectInit(&spip->mutex);
 8001588:	9b01      	ldr	r3, [sp, #4]
 800158a:	330c      	adds	r3, #12
 800158c:	0018      	movs	r0, r3
 800158e:	f7ff ffb7 	bl	8001500 <osalMutexObjectInit>
}
 8001592:	b003      	add	sp, #12
 8001594:	bd00      	pop	{pc}
 8001596:	46c0      	nop			; (mov r8, r8)
	...

080015a0 <port_lock.lto_priv.145>:
  __ASM volatile ("cpsid i" : : : "memory");
 80015a0:	b672      	cpsid	i
}
 80015a2:	4770      	bx	lr
	...

080015b0 <port_unlock.lto_priv.139>:
  __ASM volatile ("cpsie i" : : : "memory");
 80015b0:	b662      	cpsie	i
}
 80015b2:	4770      	bx	lr
	...

080015c0 <chSysLock.lto_priv.131>:
static inline void chSysLock(void) {
 80015c0:	b510      	push	{r4, lr}
  port_lock();
 80015c2:	f7ff ffed 	bl	80015a0 <port_lock.lto_priv.145>
  _dbg_check_lock();
 80015c6:	f001 fbfb 	bl	8002dc0 <_dbg_check_lock>
}
 80015ca:	bd10      	pop	{r4, pc}
 80015cc:	0000      	movs	r0, r0
	...

080015d0 <chSysUnlock.lto_priv.125>:
static inline void chSysUnlock(void) {
 80015d0:	b510      	push	{r4, lr}
  _dbg_check_unlock();
 80015d2:	f001 fc0d 	bl	8002df0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80015d6:	4b0a      	ldr	r3, [pc, #40]	; (8001600 <chSysUnlock.lto_priv.125+0x30>)
 80015d8:	681a      	ldr	r2, [r3, #0]
 80015da:	4b09      	ldr	r3, [pc, #36]	; (8001600 <chSysUnlock.lto_priv.125+0x30>)
 80015dc:	429a      	cmp	r2, r3
 80015de:	d00b      	beq.n	80015f8 <chSysUnlock.lto_priv.125+0x28>
 80015e0:	4b07      	ldr	r3, [pc, #28]	; (8001600 <chSysUnlock.lto_priv.125+0x30>)
 80015e2:	699b      	ldr	r3, [r3, #24]
 80015e4:	689a      	ldr	r2, [r3, #8]
 80015e6:	4b06      	ldr	r3, [pc, #24]	; (8001600 <chSysUnlock.lto_priv.125+0x30>)
 80015e8:	681b      	ldr	r3, [r3, #0]
 80015ea:	689b      	ldr	r3, [r3, #8]
 80015ec:	429a      	cmp	r2, r3
 80015ee:	d203      	bcs.n	80015f8 <chSysUnlock.lto_priv.125+0x28>
 80015f0:	4b04      	ldr	r3, [pc, #16]	; (8001604 <chSysUnlock.lto_priv.125+0x34>)
 80015f2:	0018      	movs	r0, r3
 80015f4:	f001 fb94 	bl	8002d20 <chSysHalt>
  port_unlock();
 80015f8:	f7ff ffda 	bl	80015b0 <port_unlock.lto_priv.139>
}
 80015fc:	bd10      	pop	{r4, pc}
 80015fe:	46c0      	nop			; (mov r8, r8)
 8001600:	200004d8 	.word	0x200004d8
 8001604:	08003968 	.word	0x08003968
	...

08001610 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = __heap_base__;
 8001610:	4b03      	ldr	r3, [pc, #12]	; (8001620 <_core_init+0x10>)
 8001612:	4a04      	ldr	r2, [pc, #16]	; (8001624 <_core_init+0x14>)
 8001614:	601a      	str	r2, [r3, #0]
  endmem  = __heap_end__;
 8001616:	4b04      	ldr	r3, [pc, #16]	; (8001628 <_core_init+0x18>)
 8001618:	4a04      	ldr	r2, [pc, #16]	; (800162c <_core_init+0x1c>)
 800161a:	601a      	str	r2, [r3, #0]
  static uint8_t static_heap[CH_CFG_MEMCORE_SIZE];

  nextmem = &static_heap[0];
  endmem  = &static_heap[CH_CFG_MEMCORE_SIZE];
#endif
}
 800161c:	4770      	bx	lr
 800161e:	46c0      	nop			; (mov r8, r8)
 8001620:	20000d5c 	.word	0x20000d5c
 8001624:	200016c0 	.word	0x200016c0
 8001628:	20000d60 	.word	0x20000d60
 800162c:	20001800 	.word	0x20001800

08001630 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocAlignedI(size_t size, unsigned align) {
 8001630:	b500      	push	{lr}
 8001632:	b085      	sub	sp, #20
 8001634:	9001      	str	r0, [sp, #4]
 8001636:	9100      	str	r1, [sp, #0]
  uint8_t *p;

  chDbgCheckClassI();
 8001638:	f001 fc62 	bl	8002f00 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 800163c:	9b00      	ldr	r3, [sp, #0]
 800163e:	2b00      	cmp	r3, #0
 8001640:	d004      	beq.n	800164c <chCoreAllocAlignedI+0x1c>
 8001642:	9b00      	ldr	r3, [sp, #0]
 8001644:	3b01      	subs	r3, #1
 8001646:	9a00      	ldr	r2, [sp, #0]
 8001648:	4013      	ands	r3, r2
 800164a:	d003      	beq.n	8001654 <chCoreAllocAlignedI+0x24>
 800164c:	4b14      	ldr	r3, [pc, #80]	; (80016a0 <chCoreAllocAlignedI+0x70>)
 800164e:	0018      	movs	r0, r3
 8001650:	f001 fb66 	bl	8002d20 <chSysHalt>

  size = MEM_ALIGN_NEXT(size, align);
 8001654:	9a00      	ldr	r2, [sp, #0]
 8001656:	9b01      	ldr	r3, [sp, #4]
 8001658:	18d3      	adds	r3, r2, r3
 800165a:	3b01      	subs	r3, #1
 800165c:	9a00      	ldr	r2, [sp, #0]
 800165e:	4252      	negs	r2, r2
 8001660:	4013      	ands	r3, r2
 8001662:	9301      	str	r3, [sp, #4]
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 8001664:	4b0f      	ldr	r3, [pc, #60]	; (80016a4 <chCoreAllocAlignedI+0x74>)
 8001666:	681b      	ldr	r3, [r3, #0]
 8001668:	001a      	movs	r2, r3
 800166a:	9b00      	ldr	r3, [sp, #0]
 800166c:	18d3      	adds	r3, r2, r3
 800166e:	3b01      	subs	r3, #1
 8001670:	9a00      	ldr	r2, [sp, #0]
 8001672:	4252      	negs	r2, r2
 8001674:	4013      	ands	r3, r2
 8001676:	9303      	str	r3, [sp, #12]

  if (((size_t)endmem - (size_t)p) < size) {
 8001678:	4b0b      	ldr	r3, [pc, #44]	; (80016a8 <chCoreAllocAlignedI+0x78>)
 800167a:	681b      	ldr	r3, [r3, #0]
 800167c:	001a      	movs	r2, r3
 800167e:	9b03      	ldr	r3, [sp, #12]
 8001680:	1ad2      	subs	r2, r2, r3
 8001682:	9b01      	ldr	r3, [sp, #4]
 8001684:	429a      	cmp	r2, r3
 8001686:	d201      	bcs.n	800168c <chCoreAllocAlignedI+0x5c>
    return NULL;
 8001688:	2300      	movs	r3, #0
 800168a:	e005      	b.n	8001698 <chCoreAllocAlignedI+0x68>
  }
  nextmem = p + size;
 800168c:	9a03      	ldr	r2, [sp, #12]
 800168e:	9b01      	ldr	r3, [sp, #4]
 8001690:	18d2      	adds	r2, r2, r3
 8001692:	4b04      	ldr	r3, [pc, #16]	; (80016a4 <chCoreAllocAlignedI+0x74>)
 8001694:	601a      	str	r2, [r3, #0]

  return p;
 8001696:	9b03      	ldr	r3, [sp, #12]
}
 8001698:	0018      	movs	r0, r3
 800169a:	b005      	add	sp, #20
 800169c:	bd00      	pop	{pc}
 800169e:	46c0      	nop			; (mov r8, r8)
 80016a0:	08003954 	.word	0x08003954
 80016a4:	20000d5c 	.word	0x20000d5c
 80016a8:	20000d60 	.word	0x20000d60
 80016ac:	00000000 	.word	0x00000000

080016b0 <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
 80016b0:	b500      	push	{lr}
 80016b2:	b085      	sub	sp, #20
 80016b4:	9001      	str	r0, [sp, #4]
 80016b6:	9100      	str	r1, [sp, #0]
  void *p;

  chSysLock();
 80016b8:	f7ff ff82 	bl	80015c0 <chSysLock.lto_priv.131>
  p = chCoreAllocAlignedI(size, align);
 80016bc:	9a00      	ldr	r2, [sp, #0]
 80016be:	9b01      	ldr	r3, [sp, #4]
 80016c0:	0011      	movs	r1, r2
 80016c2:	0018      	movs	r0, r3
 80016c4:	f7ff ffb4 	bl	8001630 <chCoreAllocAlignedI>
 80016c8:	0003      	movs	r3, r0
 80016ca:	9303      	str	r3, [sp, #12]
  chSysUnlock();
 80016cc:	f7ff ff80 	bl	80015d0 <chSysUnlock.lto_priv.125>

  return p;
 80016d0:	9b03      	ldr	r3, [sp, #12]
}
 80016d2:	0018      	movs	r0, r3
 80016d4:	b005      	add	sp, #20
 80016d6:	bd00      	pop	{pc}
	...

080016e0 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
 80016e0:	b510      	push	{r4, lr}

  default_heap.provider = chCoreAllocAligned;
 80016e2:	4b07      	ldr	r3, [pc, #28]	; (8001700 <_heap_init+0x20>)
 80016e4:	4a07      	ldr	r2, [pc, #28]	; (8001704 <_heap_init+0x24>)
 80016e6:	601a      	str	r2, [r3, #0]
  H_NEXT(&default_heap.header) = NULL;
 80016e8:	4b05      	ldr	r3, [pc, #20]	; (8001700 <_heap_init+0x20>)
 80016ea:	2200      	movs	r2, #0
 80016ec:	609a      	str	r2, [r3, #8]
  H_PAGES(&default_heap.header) = 0;
 80016ee:	4b04      	ldr	r3, [pc, #16]	; (8001700 <_heap_init+0x20>)
 80016f0:	2200      	movs	r2, #0
 80016f2:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
 80016f4:	4b04      	ldr	r3, [pc, #16]	; (8001708 <_heap_init+0x28>)
 80016f6:	0018      	movs	r0, r3
 80016f8:	f000 fa42 	bl	8001b80 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
#endif
}
 80016fc:	bd10      	pop	{r4, pc}
 80016fe:	46c0      	nop			; (mov r8, r8)
 8001700:	20000d68 	.word	0x20000d68
 8001704:	080016b1 	.word	0x080016b1
 8001708:	20000d78 	.word	0x20000d78
 800170c:	00000000 	.word	0x00000000

08001710 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8001710:	b500      	push	{lr}
 8001712:	b087      	sub	sp, #28
 8001714:	9001      	str	r0, [sp, #4]
  heap_header_t *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
 8001716:	9b01      	ldr	r3, [sp, #4]
 8001718:	2b00      	cmp	r3, #0
 800171a:	d003      	beq.n	8001724 <chHeapFree+0x14>
 800171c:	9b01      	ldr	r3, [sp, #4]
 800171e:	2207      	movs	r2, #7
 8001720:	4013      	ands	r3, r2
 8001722:	d003      	beq.n	800172c <chHeapFree+0x1c>
 8001724:	4b3e      	ldr	r3, [pc, #248]	; (8001820 <chHeapFree+0x110>)
 8001726:	0018      	movs	r0, r3
 8001728:	f001 fafa 	bl	8002d20 <chSysHalt>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
 800172c:	9b01      	ldr	r3, [sp, #4]
 800172e:	3b08      	subs	r3, #8
 8001730:	9304      	str	r3, [sp, #16]
  /*lint -restore*/
  heapp = H_HEAP(hp);
 8001732:	9b04      	ldr	r3, [sp, #16]
 8001734:	681b      	ldr	r3, [r3, #0]
 8001736:	9303      	str	r3, [sp, #12]
  qp = &heapp->header;
 8001738:	9b03      	ldr	r3, [sp, #12]
 800173a:	3308      	adds	r3, #8
 800173c:	9305      	str	r3, [sp, #20]

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 800173e:	9b04      	ldr	r3, [sp, #16]
 8001740:	685b      	ldr	r3, [r3, #4]
 8001742:	3307      	adds	r3, #7
 8001744:	2207      	movs	r2, #7
 8001746:	4393      	bics	r3, r2
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8001748:	08da      	lsrs	r2, r3, #3
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 800174a:	9b04      	ldr	r3, [sp, #16]
 800174c:	605a      	str	r2, [r3, #4]

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 800174e:	9b03      	ldr	r3, [sp, #12]
 8001750:	3310      	adds	r3, #16
 8001752:	0018      	movs	r0, r3
 8001754:	f000 fa2c 	bl	8001bb0 <chMtxLock>

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 8001758:	9a04      	ldr	r2, [sp, #16]
 800175a:	9b05      	ldr	r3, [sp, #20]
 800175c:	429a      	cmp	r2, r3
 800175e:	d30c      	bcc.n	800177a <chHeapFree+0x6a>
 8001760:	9b05      	ldr	r3, [sp, #20]
 8001762:	685b      	ldr	r3, [r3, #4]
 8001764:	3301      	adds	r3, #1
 8001766:	00db      	lsls	r3, r3, #3
 8001768:	9a05      	ldr	r2, [sp, #20]
 800176a:	18d2      	adds	r2, r2, r3
 800176c:	9b04      	ldr	r3, [sp, #16]
 800176e:	429a      	cmp	r2, r3
 8001770:	d903      	bls.n	800177a <chHeapFree+0x6a>
 8001772:	4b2b      	ldr	r3, [pc, #172]	; (8001820 <chHeapFree+0x110>)
 8001774:	0018      	movs	r0, r3
 8001776:	f001 fad3 	bl	8002d20 <chSysHalt>

    if (((qp == &heapp->header) || (hp > qp)) &&
 800177a:	9b03      	ldr	r3, [sp, #12]
 800177c:	3308      	adds	r3, #8
 800177e:	001a      	movs	r2, r3
 8001780:	9b05      	ldr	r3, [sp, #20]
 8001782:	429a      	cmp	r2, r3
 8001784:	d003      	beq.n	800178e <chHeapFree+0x7e>
 8001786:	9a04      	ldr	r2, [sp, #16]
 8001788:	9b05      	ldr	r3, [sp, #20]
 800178a:	429a      	cmp	r2, r3
 800178c:	d942      	bls.n	8001814 <chHeapFree+0x104>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 800178e:	9b05      	ldr	r3, [sp, #20]
 8001790:	681b      	ldr	r3, [r3, #0]
    if (((qp == &heapp->header) || (hp > qp)) &&
 8001792:	2b00      	cmp	r3, #0
 8001794:	d004      	beq.n	80017a0 <chHeapFree+0x90>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8001796:	9b05      	ldr	r3, [sp, #20]
 8001798:	681a      	ldr	r2, [r3, #0]
 800179a:	9b04      	ldr	r3, [sp, #16]
 800179c:	429a      	cmp	r2, r3
 800179e:	d939      	bls.n	8001814 <chHeapFree+0x104>
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
 80017a0:	9b05      	ldr	r3, [sp, #20]
 80017a2:	681a      	ldr	r2, [r3, #0]
 80017a4:	9b04      	ldr	r3, [sp, #16]
 80017a6:	601a      	str	r2, [r3, #0]
      H_NEXT(qp) = hp;
 80017a8:	9b05      	ldr	r3, [sp, #20]
 80017aa:	9a04      	ldr	r2, [sp, #16]
 80017ac:	601a      	str	r2, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 80017ae:	9b04      	ldr	r3, [sp, #16]
 80017b0:	685b      	ldr	r3, [r3, #4]
 80017b2:	3301      	adds	r3, #1
 80017b4:	00db      	lsls	r3, r3, #3
 80017b6:	9a04      	ldr	r2, [sp, #16]
 80017b8:	18d2      	adds	r2, r2, r3
 80017ba:	9b04      	ldr	r3, [sp, #16]
 80017bc:	681b      	ldr	r3, [r3, #0]
 80017be:	429a      	cmp	r2, r3
 80017c0:	d10d      	bne.n	80017de <chHeapFree+0xce>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 80017c2:	9b04      	ldr	r3, [sp, #16]
 80017c4:	685a      	ldr	r2, [r3, #4]
 80017c6:	9b04      	ldr	r3, [sp, #16]
 80017c8:	681b      	ldr	r3, [r3, #0]
 80017ca:	685b      	ldr	r3, [r3, #4]
 80017cc:	18d3      	adds	r3, r2, r3
 80017ce:	1c5a      	adds	r2, r3, #1
 80017d0:	9b04      	ldr	r3, [sp, #16]
 80017d2:	605a      	str	r2, [r3, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 80017d4:	9b04      	ldr	r3, [sp, #16]
 80017d6:	681b      	ldr	r3, [r3, #0]
 80017d8:	681a      	ldr	r2, [r3, #0]
 80017da:	9b04      	ldr	r3, [sp, #16]
 80017dc:	601a      	str	r2, [r3, #0]
      }
      if ((H_LIMIT(qp) == hp)) {
 80017de:	9b05      	ldr	r3, [sp, #20]
 80017e0:	685b      	ldr	r3, [r3, #4]
 80017e2:	3301      	adds	r3, #1
 80017e4:	00db      	lsls	r3, r3, #3
 80017e6:	9a05      	ldr	r2, [sp, #20]
 80017e8:	18d2      	adds	r2, r2, r3
 80017ea:	9b04      	ldr	r3, [sp, #16]
 80017ec:	429a      	cmp	r2, r3
 80017ee:	d10b      	bne.n	8001808 <chHeapFree+0xf8>
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 80017f0:	9b05      	ldr	r3, [sp, #20]
 80017f2:	685a      	ldr	r2, [r3, #4]
 80017f4:	9b04      	ldr	r3, [sp, #16]
 80017f6:	685b      	ldr	r3, [r3, #4]
 80017f8:	18d3      	adds	r3, r2, r3
 80017fa:	1c5a      	adds	r2, r3, #1
 80017fc:	9b05      	ldr	r3, [sp, #20]
 80017fe:	605a      	str	r2, [r3, #4]
        H_NEXT(qp) = H_NEXT(hp);
 8001800:	9b04      	ldr	r3, [sp, #16]
 8001802:	681a      	ldr	r2, [r3, #0]
 8001804:	9b05      	ldr	r3, [sp, #20]
 8001806:	601a      	str	r2, [r3, #0]
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 8001808:	9b03      	ldr	r3, [sp, #12]
 800180a:	3310      	adds	r3, #16
 800180c:	0018      	movs	r0, r3
 800180e:	f000 fa67 	bl	8001ce0 <chMtxUnlock>
 8001812:	e003      	b.n	800181c <chHeapFree+0x10c>
    qp = H_NEXT(qp);
 8001814:	9b05      	ldr	r3, [sp, #20]
 8001816:	681b      	ldr	r3, [r3, #0]
 8001818:	9305      	str	r3, [sp, #20]
 800181a:	e79d      	b.n	8001758 <chHeapFree+0x48>

  return;
}
 800181c:	b007      	add	sp, #28
 800181e:	bd00      	pop	{pc}
 8001820:	08003974 	.word	0x08003974
	...

08001830 <port_lock.lto_priv.146>:
  __ASM volatile ("cpsid i" : : : "memory");
 8001830:	b672      	cpsid	i
}
 8001832:	4770      	bx	lr
	...

08001840 <port_unlock.lto_priv.140>:
  __ASM volatile ("cpsie i" : : : "memory");
 8001840:	b662      	cpsie	i
}
 8001842:	4770      	bx	lr
	...

08001850 <chSysLock.lto_priv.132>:
static inline void chSysLock(void) {
 8001850:	b510      	push	{r4, lr}
  port_lock();
 8001852:	f7ff ffed 	bl	8001830 <port_lock.lto_priv.146>
  _dbg_check_lock();
 8001856:	f001 fab3 	bl	8002dc0 <_dbg_check_lock>
}
 800185a:	bd10      	pop	{r4, pc}
 800185c:	0000      	movs	r0, r0
	...

08001860 <chSysUnlock.lto_priv.126>:
static inline void chSysUnlock(void) {
 8001860:	b510      	push	{r4, lr}
  _dbg_check_unlock();
 8001862:	f001 fac5 	bl	8002df0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001866:	4b0a      	ldr	r3, [pc, #40]	; (8001890 <chSysUnlock.lto_priv.126+0x30>)
 8001868:	681a      	ldr	r2, [r3, #0]
 800186a:	4b09      	ldr	r3, [pc, #36]	; (8001890 <chSysUnlock.lto_priv.126+0x30>)
 800186c:	429a      	cmp	r2, r3
 800186e:	d00b      	beq.n	8001888 <chSysUnlock.lto_priv.126+0x28>
 8001870:	4b07      	ldr	r3, [pc, #28]	; (8001890 <chSysUnlock.lto_priv.126+0x30>)
 8001872:	699b      	ldr	r3, [r3, #24]
 8001874:	689a      	ldr	r2, [r3, #8]
 8001876:	4b06      	ldr	r3, [pc, #24]	; (8001890 <chSysUnlock.lto_priv.126+0x30>)
 8001878:	681b      	ldr	r3, [r3, #0]
 800187a:	689b      	ldr	r3, [r3, #8]
 800187c:	429a      	cmp	r2, r3
 800187e:	d203      	bcs.n	8001888 <chSysUnlock.lto_priv.126+0x28>
 8001880:	4b04      	ldr	r3, [pc, #16]	; (8001894 <chSysUnlock.lto_priv.126+0x34>)
 8001882:	0018      	movs	r0, r3
 8001884:	f001 fa4c 	bl	8002d20 <chSysHalt>
  port_unlock();
 8001888:	f7ff ffda 	bl	8001840 <port_unlock.lto_priv.140>
}
 800188c:	bd10      	pop	{r4, pc}
 800188e:	46c0      	nop			; (mov r8, r8)
 8001890:	200004d8 	.word	0x200004d8
 8001894:	08003980 	.word	0x08003980
	...

080018a0 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
 80018a0:	b500      	push	{lr}
 80018a2:	b085      	sub	sp, #20
 80018a4:	9001      	str	r0, [sp, #4]
 80018a6:	9100      	str	r1, [sp, #0]
  struct pool_header *php = objp;
 80018a8:	9b00      	ldr	r3, [sp, #0]
 80018aa:	9303      	str	r3, [sp, #12]

  chDbgCheckClassI();
 80018ac:	f001 fb28 	bl	8002f00 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) && (objp != NULL));
 80018b0:	9b01      	ldr	r3, [sp, #4]
 80018b2:	2b00      	cmp	r3, #0
 80018b4:	d002      	beq.n	80018bc <chPoolFreeI+0x1c>
 80018b6:	9b00      	ldr	r3, [sp, #0]
 80018b8:	2b00      	cmp	r3, #0
 80018ba:	d103      	bne.n	80018c4 <chPoolFreeI+0x24>
 80018bc:	4b06      	ldr	r3, [pc, #24]	; (80018d8 <chPoolFreeI+0x38>)
 80018be:	0018      	movs	r0, r3
 80018c0:	f001 fa2e 	bl	8002d20 <chSysHalt>

  php->next = mp->next;
 80018c4:	9b01      	ldr	r3, [sp, #4]
 80018c6:	681a      	ldr	r2, [r3, #0]
 80018c8:	9b03      	ldr	r3, [sp, #12]
 80018ca:	601a      	str	r2, [r3, #0]
  mp->next = php;
 80018cc:	9b01      	ldr	r3, [sp, #4]
 80018ce:	9a03      	ldr	r2, [sp, #12]
 80018d0:	601a      	str	r2, [r3, #0]
}
 80018d2:	b005      	add	sp, #20
 80018d4:	bd00      	pop	{pc}
 80018d6:	46c0      	nop			; (mov r8, r8)
 80018d8:	0800398c 	.word	0x0800398c
 80018dc:	00000000 	.word	0x00000000

080018e0 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
 80018e0:	b500      	push	{lr}
 80018e2:	b083      	sub	sp, #12
 80018e4:	9001      	str	r0, [sp, #4]
 80018e6:	9100      	str	r1, [sp, #0]

  chSysLock();
 80018e8:	f7ff ffb2 	bl	8001850 <chSysLock.lto_priv.132>
  chPoolFreeI(mp, objp);
 80018ec:	9a00      	ldr	r2, [sp, #0]
 80018ee:	9b01      	ldr	r3, [sp, #4]
 80018f0:	0011      	movs	r1, r2
 80018f2:	0018      	movs	r0, r3
 80018f4:	f7ff ffd4 	bl	80018a0 <chPoolFreeI>
  chSysUnlock();
 80018f8:	f7ff ffb2 	bl	8001860 <chSysUnlock.lto_priv.126>
}
 80018fc:	b003      	add	sp, #12
 80018fe:	bd00      	pop	{pc}

08001900 <port_lock.lto_priv.147>:
  __ASM volatile ("cpsid i" : : : "memory");
 8001900:	b672      	cpsid	i
}
 8001902:	4770      	bx	lr
	...

08001910 <port_unlock.lto_priv.141>:
  __ASM volatile ("cpsie i" : : : "memory");
 8001910:	b662      	cpsie	i
}
 8001912:	4770      	bx	lr
	...

08001920 <port_lock_from_isr>:
static inline void port_lock_from_isr(void) {
 8001920:	b510      	push	{r4, lr}
  port_lock();
 8001922:	f7ff ffed 	bl	8001900 <port_lock.lto_priv.147>
}
 8001926:	bd10      	pop	{r4, pc}
	...

08001930 <port_unlock_from_isr>:
static inline void port_unlock_from_isr(void) {
 8001930:	b510      	push	{r4, lr}
  port_unlock();
 8001932:	f7ff ffed 	bl	8001910 <port_unlock.lto_priv.141>
}
 8001936:	bd10      	pop	{r4, pc}
	...

08001940 <NMI_Handler>:
 * @brief   NMI vector.
 * @details The NMI vector is used for exception mode re-entering after a
 *          context switch.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void NMI_Handler(void) {
 8001940:	b510      	push	{r4, lr}
 8001942:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8001944:	f3ef 8309 	mrs	r3, PSP
 8001948:	001c      	movs	r4, r3
  return(result);
 800194a:	0023      	movs	r3, r4
/*lint -restore*/

  /* The port_extctx structure is pointed by the PSP register.*/
  struct port_extctx *ctxp = (struct port_extctx *)__get_PSP();
 800194c:	9301      	str	r3, [sp, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 800194e:	9b01      	ldr	r3, [sp, #4]
 8001950:	3320      	adds	r3, #32
 8001952:	9301      	str	r3, [sp, #4]

  /* Writing back the modified PSP value.*/
  __set_PSP((uint32_t)ctxp);
 8001954:	9b01      	ldr	r3, [sp, #4]
 8001956:	9300      	str	r3, [sp, #0]
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8001958:	9b00      	ldr	r3, [sp, #0]
 800195a:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 800195e:	f7ff ffe7 	bl	8001930 <port_unlock_from_isr>
}
 8001962:	b002      	add	sp, #8
 8001964:	bd10      	pop	{r4, pc}
 8001966:	46c0      	nop			; (mov r8, r8)
	...

08001970 <_port_irq_epilogue>:
/**
 * @brief   IRQ epilogue code.
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {
 8001970:	b510      	push	{r4, lr}
 8001972:	b084      	sub	sp, #16
 8001974:	9001      	str	r0, [sp, #4]

  if (lr != (regarm_t)0xFFFFFFF1U) {
 8001976:	9b01      	ldr	r3, [sp, #4]
 8001978:	330f      	adds	r3, #15
 800197a:	d01d      	beq.n	80019b8 <_port_irq_epilogue+0x48>
    struct port_extctx *ctxp;

    port_lock_from_isr();
 800197c:	f7ff ffd0 	bl	8001920 <port_lock_from_isr>
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8001980:	f3ef 8309 	mrs	r3, PSP
 8001984:	001c      	movs	r4, r3
  return(result);
 8001986:	0023      	movs	r3, r4

    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
 8001988:	9303      	str	r3, [sp, #12]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 800198a:	9b03      	ldr	r3, [sp, #12]
 800198c:	3b20      	subs	r3, #32
 800198e:	9303      	str	r3, [sp, #12]

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
 8001990:	9b03      	ldr	r3, [sp, #12]
 8001992:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8001994:	9b02      	ldr	r3, [sp, #8]
 8001996:	f383 8809 	msr	PSP, r3

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 800199a:	9b03      	ldr	r3, [sp, #12]
 800199c:	2280      	movs	r2, #128	; 0x80
 800199e:	0452      	lsls	r2, r2, #17
 80019a0:	61da      	str	r2, [r3, #28]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 80019a2:	f000 fb75 	bl	8002090 <chSchIsPreemptionRequired>
 80019a6:	1e03      	subs	r3, r0, #0
 80019a8:	d003      	beq.n	80019b2 <_port_irq_epilogue+0x42>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80019aa:	9b03      	ldr	r3, [sp, #12]
 80019ac:	4a03      	ldr	r2, [pc, #12]	; (80019bc <_port_irq_epilogue+0x4c>)
 80019ae:	619a      	str	r2, [r3, #24]
 80019b0:	e002      	b.n	80019b8 <_port_irq_epilogue+0x48>
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 80019b2:	9b03      	ldr	r3, [sp, #12]
 80019b4:	4a02      	ldr	r2, [pc, #8]	; (80019c0 <_port_irq_epilogue+0x50>)
 80019b6:	619a      	str	r2, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
  }
}
 80019b8:	b004      	add	sp, #16
 80019ba:	bd10      	pop	{r4, pc}
 80019bc:	080001c1 	.word	0x080001c1
 80019c0:	080001cc 	.word	0x080001cc
	...

080019d0 <osalInit>:
}
 80019d0:	4770      	bx	lr
 80019d2:	46c0      	nop			; (mov r8, r8)
	...

080019e0 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 80019e0:	b510      	push	{r4, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 80019e2:	f7ff fff5 	bl	80019d0 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 80019e6:	f7ff f9a3 	bl	8000d30 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 80019ea:	4b05      	ldr	r3, [pc, #20]	; (8001a00 <halInit+0x20>)
 80019ec:	0018      	movs	r0, r3
 80019ee:	f7ff fb4f 	bl	8001090 <_pal_lld_init>
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
 80019f2:	f7ff fdb5 	bl	8001560 <spiInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 80019f6:	f7fe fdc3 	bl	8000580 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 80019fa:	f7fe ffe9 	bl	80009d0 <stInit>
#endif
}
 80019fe:	bd10      	pop	{r4, pc}
 8001a00:	08003adc 	.word	0x08003adc
	...

08001a10 <port_lock.lto_priv.161>:
  __ASM volatile ("cpsid i" : : : "memory");
 8001a10:	b672      	cpsid	i
}
 8001a12:	4770      	bx	lr
	...

08001a20 <port_unlock.lto_priv.176>:
  __ASM volatile ("cpsie i" : : : "memory");
 8001a20:	b662      	cpsie	i
}
 8001a22:	4770      	bx	lr
	...

08001a30 <queue_init.lto_priv.188>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8001a30:	b082      	sub	sp, #8
 8001a32:	9001      	str	r0, [sp, #4]

  tqp->next = (thread_t *)tqp;
 8001a34:	9b01      	ldr	r3, [sp, #4]
 8001a36:	9a01      	ldr	r2, [sp, #4]
 8001a38:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8001a3a:	9b01      	ldr	r3, [sp, #4]
 8001a3c:	9a01      	ldr	r2, [sp, #4]
 8001a3e:	605a      	str	r2, [r3, #4]
}
 8001a40:	b002      	add	sp, #8
 8001a42:	4770      	bx	lr
	...

08001a50 <queue_notempty.lto_priv.186>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8001a50:	b082      	sub	sp, #8
 8001a52:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->next != (const thread_t *)tqp);
 8001a54:	9b01      	ldr	r3, [sp, #4]
 8001a56:	681a      	ldr	r2, [r3, #0]
 8001a58:	9b01      	ldr	r3, [sp, #4]
 8001a5a:	1ad3      	subs	r3, r2, r3
 8001a5c:	1e5a      	subs	r2, r3, #1
 8001a5e:	4193      	sbcs	r3, r2
 8001a60:	b2db      	uxtb	r3, r3
}
 8001a62:	0018      	movs	r0, r3
 8001a64:	b002      	add	sp, #8
 8001a66:	4770      	bx	lr
	...

08001a70 <queue_prio_insert.lto_priv.183>:
  tlp->next = tp->queue.next;

  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {
 8001a70:	b084      	sub	sp, #16
 8001a72:	9001      	str	r0, [sp, #4]
 8001a74:	9100      	str	r1, [sp, #0]

  thread_t *cp = (thread_t *)tqp;
 8001a76:	9b00      	ldr	r3, [sp, #0]
 8001a78:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->queue.next;
 8001a7a:	9b03      	ldr	r3, [sp, #12]
 8001a7c:	681b      	ldr	r3, [r3, #0]
 8001a7e:	9303      	str	r3, [sp, #12]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8001a80:	9a03      	ldr	r2, [sp, #12]
 8001a82:	9b00      	ldr	r3, [sp, #0]
 8001a84:	429a      	cmp	r2, r3
 8001a86:	d005      	beq.n	8001a94 <queue_prio_insert.lto_priv.183+0x24>
 8001a88:	9b03      	ldr	r3, [sp, #12]
 8001a8a:	689a      	ldr	r2, [r3, #8]
 8001a8c:	9b01      	ldr	r3, [sp, #4]
 8001a8e:	689b      	ldr	r3, [r3, #8]
 8001a90:	429a      	cmp	r2, r3
 8001a92:	d2f2      	bcs.n	8001a7a <queue_prio_insert.lto_priv.183+0xa>
  tp->queue.next             = cp;
 8001a94:	9b01      	ldr	r3, [sp, #4]
 8001a96:	9a03      	ldr	r2, [sp, #12]
 8001a98:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 8001a9a:	9b03      	ldr	r3, [sp, #12]
 8001a9c:	685a      	ldr	r2, [r3, #4]
 8001a9e:	9b01      	ldr	r3, [sp, #4]
 8001aa0:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8001aa2:	9b01      	ldr	r3, [sp, #4]
 8001aa4:	685b      	ldr	r3, [r3, #4]
 8001aa6:	9a01      	ldr	r2, [sp, #4]
 8001aa8:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 8001aaa:	9b03      	ldr	r3, [sp, #12]
 8001aac:	9a01      	ldr	r2, [sp, #4]
 8001aae:	605a      	str	r2, [r3, #4]
}
 8001ab0:	b004      	add	sp, #16
 8001ab2:	4770      	bx	lr
	...

08001ac0 <queue_fifo_remove.lto_priv.181>:
  tp->queue.prev             = tqp->prev;
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8001ac0:	b084      	sub	sp, #16
 8001ac2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
 8001ac4:	9b01      	ldr	r3, [sp, #4]
 8001ac6:	681b      	ldr	r3, [r3, #0]
 8001ac8:	9303      	str	r3, [sp, #12]

  tqp->next             = tp->queue.next;
 8001aca:	9b03      	ldr	r3, [sp, #12]
 8001acc:	681a      	ldr	r2, [r3, #0]
 8001ace:	9b01      	ldr	r3, [sp, #4]
 8001ad0:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8001ad2:	9b01      	ldr	r3, [sp, #4]
 8001ad4:	681b      	ldr	r3, [r3, #0]
 8001ad6:	9a01      	ldr	r2, [sp, #4]
 8001ad8:	605a      	str	r2, [r3, #4]

  return tp;
 8001ada:	9b03      	ldr	r3, [sp, #12]
}
 8001adc:	0018      	movs	r0, r3
 8001ade:	b004      	add	sp, #16
 8001ae0:	4770      	bx	lr
 8001ae2:	46c0      	nop			; (mov r8, r8)
	...

08001af0 <queue_dequeue>:
  tqp->prev->queue.next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
 8001af0:	b082      	sub	sp, #8
 8001af2:	9001      	str	r0, [sp, #4]

  tp->queue.prev->queue.next = tp->queue.next;
 8001af4:	9b01      	ldr	r3, [sp, #4]
 8001af6:	685b      	ldr	r3, [r3, #4]
 8001af8:	9a01      	ldr	r2, [sp, #4]
 8001afa:	6812      	ldr	r2, [r2, #0]
 8001afc:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8001afe:	9b01      	ldr	r3, [sp, #4]
 8001b00:	681b      	ldr	r3, [r3, #0]
 8001b02:	9a01      	ldr	r2, [sp, #4]
 8001b04:	6852      	ldr	r2, [r2, #4]
 8001b06:	605a      	str	r2, [r3, #4]

  return tp;
 8001b08:	9b01      	ldr	r3, [sp, #4]
}
 8001b0a:	0018      	movs	r0, r3
 8001b0c:	b002      	add	sp, #8
 8001b0e:	4770      	bx	lr

08001b10 <chSysLock.lto_priv.173>:
static inline void chSysLock(void) {
 8001b10:	b510      	push	{r4, lr}
  port_lock();
 8001b12:	f7ff ff7d 	bl	8001a10 <port_lock.lto_priv.161>
  _dbg_check_lock();
 8001b16:	f001 f953 	bl	8002dc0 <_dbg_check_lock>
}
 8001b1a:	bd10      	pop	{r4, pc}
 8001b1c:	0000      	movs	r0, r0
	...

08001b20 <chSysUnlock.lto_priv.169>:
static inline void chSysUnlock(void) {
 8001b20:	b510      	push	{r4, lr}
  _dbg_check_unlock();
 8001b22:	f001 f965 	bl	8002df0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001b26:	4b0a      	ldr	r3, [pc, #40]	; (8001b50 <chSysUnlock.lto_priv.169+0x30>)
 8001b28:	681a      	ldr	r2, [r3, #0]
 8001b2a:	4b09      	ldr	r3, [pc, #36]	; (8001b50 <chSysUnlock.lto_priv.169+0x30>)
 8001b2c:	429a      	cmp	r2, r3
 8001b2e:	d00b      	beq.n	8001b48 <chSysUnlock.lto_priv.169+0x28>
 8001b30:	4b07      	ldr	r3, [pc, #28]	; (8001b50 <chSysUnlock.lto_priv.169+0x30>)
 8001b32:	699b      	ldr	r3, [r3, #24]
 8001b34:	689a      	ldr	r2, [r3, #8]
 8001b36:	4b06      	ldr	r3, [pc, #24]	; (8001b50 <chSysUnlock.lto_priv.169+0x30>)
 8001b38:	681b      	ldr	r3, [r3, #0]
 8001b3a:	689b      	ldr	r3, [r3, #8]
 8001b3c:	429a      	cmp	r2, r3
 8001b3e:	d203      	bcs.n	8001b48 <chSysUnlock.lto_priv.169+0x28>
 8001b40:	4b04      	ldr	r3, [pc, #16]	; (8001b54 <chSysUnlock.lto_priv.169+0x34>)
 8001b42:	0018      	movs	r0, r3
 8001b44:	f001 f8ec 	bl	8002d20 <chSysHalt>
  port_unlock();
 8001b48:	f7ff ff6a 	bl	8001a20 <port_unlock.lto_priv.176>
}
 8001b4c:	bd10      	pop	{r4, pc}
 8001b4e:	46c0      	nop			; (mov r8, r8)
 8001b50:	200004d8 	.word	0x200004d8
 8001b54:	08003930 	.word	0x08003930
	...

08001b60 <chMtxQueueNotEmptyS>:
 * @return              The mutex queue status.
 *
 * @deprecated
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {
 8001b60:	b500      	push	{lr}
 8001b62:	b083      	sub	sp, #12
 8001b64:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();
 8001b66:	f001 f9e3 	bl	8002f30 <chDbgCheckClassS>

  return queue_notempty(&mp->queue);
 8001b6a:	9b01      	ldr	r3, [sp, #4]
 8001b6c:	0018      	movs	r0, r3
 8001b6e:	f7ff ff6f 	bl	8001a50 <queue_notempty.lto_priv.186>
 8001b72:	0003      	movs	r3, r0
}
 8001b74:	0018      	movs	r0, r3
 8001b76:	b003      	add	sp, #12
 8001b78:	bd00      	pop	{pc}
 8001b7a:	46c0      	nop			; (mov r8, r8)
 8001b7c:	0000      	movs	r0, r0
	...

08001b80 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 8001b80:	b500      	push	{lr}
 8001b82:	b083      	sub	sp, #12
 8001b84:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);
 8001b86:	9b01      	ldr	r3, [sp, #4]
 8001b88:	2b00      	cmp	r3, #0
 8001b8a:	d103      	bne.n	8001b94 <chMtxObjectInit+0x14>
 8001b8c:	4b06      	ldr	r3, [pc, #24]	; (8001ba8 <chMtxObjectInit+0x28>)
 8001b8e:	0018      	movs	r0, r3
 8001b90:	f001 f8c6 	bl	8002d20 <chSysHalt>

  queue_init(&mp->queue);
 8001b94:	9b01      	ldr	r3, [sp, #4]
 8001b96:	0018      	movs	r0, r3
 8001b98:	f7ff ff4a 	bl	8001a30 <queue_init.lto_priv.188>
  mp->owner = NULL;
 8001b9c:	9b01      	ldr	r3, [sp, #4]
 8001b9e:	2200      	movs	r2, #0
 8001ba0:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
#endif
}
 8001ba2:	b003      	add	sp, #12
 8001ba4:	bd00      	pop	{pc}
 8001ba6:	46c0      	nop			; (mov r8, r8)
 8001ba8:	08003920 	.word	0x08003920
 8001bac:	00000000 	.word	0x00000000

08001bb0 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 8001bb0:	b500      	push	{lr}
 8001bb2:	b083      	sub	sp, #12
 8001bb4:	9001      	str	r0, [sp, #4]

  chSysLock();
 8001bb6:	f7ff ffab 	bl	8001b10 <chSysLock.lto_priv.173>
  chMtxLockS(mp);
 8001bba:	9b01      	ldr	r3, [sp, #4]
 8001bbc:	0018      	movs	r0, r3
 8001bbe:	f000 f807 	bl	8001bd0 <chMtxLockS>
  chSysUnlock();
 8001bc2:	f7ff ffad 	bl	8001b20 <chSysUnlock.lto_priv.169>
}
 8001bc6:	b003      	add	sp, #12
 8001bc8:	bd00      	pop	{pc}
 8001bca:	46c0      	nop			; (mov r8, r8)
 8001bcc:	0000      	movs	r0, r0
	...

08001bd0 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8001bd0:	b500      	push	{lr}
 8001bd2:	b085      	sub	sp, #20
 8001bd4:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8001bd6:	4b3e      	ldr	r3, [pc, #248]	; (8001cd0 <chMtxLockS+0x100>)
 8001bd8:	699b      	ldr	r3, [r3, #24]
 8001bda:	9302      	str	r3, [sp, #8]

  chDbgCheckClassS();
 8001bdc:	f001 f9a8 	bl	8002f30 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 8001be0:	9b01      	ldr	r3, [sp, #4]
 8001be2:	2b00      	cmp	r3, #0
 8001be4:	d103      	bne.n	8001bee <chMtxLockS+0x1e>
 8001be6:	4b3b      	ldr	r3, [pc, #236]	; (8001cd4 <chMtxLockS+0x104>)
 8001be8:	0018      	movs	r0, r3
 8001bea:	f001 f899 	bl	8002d20 <chSysHalt>

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8001bee:	9b01      	ldr	r3, [sp, #4]
 8001bf0:	689b      	ldr	r3, [r3, #8]
 8001bf2:	2b00      	cmp	r3, #0
 8001bf4:	d05f      	beq.n	8001cb6 <chMtxLockS+0xe6>
    else {
#endif
      /* Priority inheritance protocol; explores the thread-mutex dependencies
         boosting the priority of all the affected threads to equal the
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;
 8001bf6:	9b01      	ldr	r3, [sp, #4]
 8001bf8:	689b      	ldr	r3, [r3, #8]
 8001bfa:	9303      	str	r3, [sp, #12]
 8001bfc:	e036      	b.n	8001c6c <chMtxLockS+0x9c>

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;
 8001bfe:	9b02      	ldr	r3, [sp, #8]
 8001c00:	689a      	ldr	r2, [r3, #8]
 8001c02:	9b03      	ldr	r3, [sp, #12]
 8001c04:	609a      	str	r2, [r3, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8001c06:	9b03      	ldr	r3, [sp, #12]
 8001c08:	2220      	movs	r2, #32
 8001c0a:	5c9b      	ldrb	r3, [r3, r2]
 8001c0c:	2b06      	cmp	r3, #6
 8001c0e:	d004      	beq.n	8001c1a <chMtxLockS+0x4a>
 8001c10:	2b07      	cmp	r3, #7
 8001c12:	d012      	beq.n	8001c3a <chMtxLockS+0x6a>
 8001c14:	2b00      	cmp	r3, #0
 8001c16:	d01c      	beq.n	8001c52 <chMtxLockS+0x82>
 8001c18:	e02e      	b.n	8001c78 <chMtxLockS+0xa8>
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8001c1a:	9b03      	ldr	r3, [sp, #12]
 8001c1c:	0018      	movs	r0, r3
 8001c1e:	f7ff ff67 	bl	8001af0 <queue_dequeue>
 8001c22:	0002      	movs	r2, r0
 8001c24:	9b03      	ldr	r3, [sp, #12]
 8001c26:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001c28:	0019      	movs	r1, r3
 8001c2a:	0010      	movs	r0, r2
 8001c2c:	f7ff ff20 	bl	8001a70 <queue_prio_insert.lto_priv.183>
          tp = tp->u.wtmtxp->owner;
 8001c30:	9b03      	ldr	r3, [sp, #12]
 8001c32:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001c34:	689b      	ldr	r3, [r3, #8]
 8001c36:	9303      	str	r3, [sp, #12]
 8001c38:	e018      	b.n	8001c6c <chMtxLockS+0x9c>
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8001c3a:	9b03      	ldr	r3, [sp, #12]
 8001c3c:	0018      	movs	r0, r3
 8001c3e:	f7ff ff57 	bl	8001af0 <queue_dequeue>
 8001c42:	0002      	movs	r2, r0
 8001c44:	9b03      	ldr	r3, [sp, #12]
 8001c46:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001c48:	0019      	movs	r1, r3
 8001c4a:	0010      	movs	r0, r2
 8001c4c:	f7ff ff10 	bl	8001a70 <queue_prio_insert.lto_priv.183>
 8001c50:	e012      	b.n	8001c78 <chMtxLockS+0xa8>
          break;
#endif
        case CH_STATE_READY:
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
 8001c52:	9b03      	ldr	r3, [sp, #12]
 8001c54:	2220      	movs	r2, #32
 8001c56:	2101      	movs	r1, #1
 8001c58:	5499      	strb	r1, [r3, r2]
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 8001c5a:	9b03      	ldr	r3, [sp, #12]
 8001c5c:	0018      	movs	r0, r3
 8001c5e:	f7ff ff47 	bl	8001af0 <queue_dequeue>
 8001c62:	0003      	movs	r3, r0
 8001c64:	0018      	movs	r0, r3
 8001c66:	f001 fce3 	bl	8003630 <chSchReadyI>
 8001c6a:	e005      	b.n	8001c78 <chMtxLockS+0xa8>
      while (tp->prio < ctp->prio) {
 8001c6c:	9b03      	ldr	r3, [sp, #12]
 8001c6e:	689a      	ldr	r2, [r3, #8]
 8001c70:	9b02      	ldr	r3, [sp, #8]
 8001c72:	689b      	ldr	r3, [r3, #8]
 8001c74:	429a      	cmp	r2, r3
 8001c76:	d3c2      	bcc.n	8001bfe <chMtxLockS+0x2e>
        }
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
 8001c78:	9a01      	ldr	r2, [sp, #4]
 8001c7a:	9b02      	ldr	r3, [sp, #8]
 8001c7c:	0011      	movs	r1, r2
 8001c7e:	0018      	movs	r0, r3
 8001c80:	f7ff fef6 	bl	8001a70 <queue_prio_insert.lto_priv.183>
      ctp->u.wtmtxp = mp;
 8001c84:	9b02      	ldr	r3, [sp, #8]
 8001c86:	9a01      	ldr	r2, [sp, #4]
 8001c88:	625a      	str	r2, [r3, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 8001c8a:	2006      	movs	r0, #6
 8001c8c:	f000 f8e0 	bl	8001e50 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == ctp, "not owner");
 8001c90:	9b01      	ldr	r3, [sp, #4]
 8001c92:	689a      	ldr	r2, [r3, #8]
 8001c94:	9b02      	ldr	r3, [sp, #8]
 8001c96:	429a      	cmp	r2, r3
 8001c98:	d003      	beq.n	8001ca2 <chMtxLockS+0xd2>
 8001c9a:	4b0e      	ldr	r3, [pc, #56]	; (8001cd4 <chMtxLockS+0x104>)
 8001c9c:	0018      	movs	r0, r3
 8001c9e:	f001 f83f 	bl	8002d20 <chSysHalt>
      chDbgAssert(ctp->mtxlist == mp, "not owned");
 8001ca2:	9b02      	ldr	r3, [sp, #8]
 8001ca4:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8001ca6:	9b01      	ldr	r3, [sp, #4]
 8001ca8:	429a      	cmp	r2, r3
 8001caa:	d00e      	beq.n	8001cca <chMtxLockS+0xfa>
 8001cac:	4b09      	ldr	r3, [pc, #36]	; (8001cd4 <chMtxLockS+0x104>)
 8001cae:	0018      	movs	r0, r3
 8001cb0:	f001 f836 	bl	8002d20 <chSysHalt>
 8001cb4:	e009      	b.n	8001cca <chMtxLockS+0xfa>
    chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
 8001cb6:	9b01      	ldr	r3, [sp, #4]
 8001cb8:	9a02      	ldr	r2, [sp, #8]
 8001cba:	609a      	str	r2, [r3, #8]
    mp->next = ctp->mtxlist;
 8001cbc:	9b02      	ldr	r3, [sp, #8]
 8001cbe:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8001cc0:	9b01      	ldr	r3, [sp, #4]
 8001cc2:	60da      	str	r2, [r3, #12]
    ctp->mtxlist = mp;
 8001cc4:	9b02      	ldr	r3, [sp, #8]
 8001cc6:	9a01      	ldr	r2, [sp, #4]
 8001cc8:	639a      	str	r2, [r3, #56]	; 0x38
  }
}
 8001cca:	b005      	add	sp, #20
 8001ccc:	bd00      	pop	{pc}
 8001cce:	46c0      	nop			; (mov r8, r8)
 8001cd0:	200004d8 	.word	0x200004d8
 8001cd4:	0800393c 	.word	0x0800393c
	...

08001ce0 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8001ce0:	b500      	push	{lr}
 8001ce2:	b087      	sub	sp, #28
 8001ce4:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8001ce6:	4b37      	ldr	r3, [pc, #220]	; (8001dc4 <chMtxUnlock+0xe4>)
 8001ce8:	699b      	ldr	r3, [r3, #24]
 8001cea:	9303      	str	r3, [sp, #12]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 8001cec:	9b01      	ldr	r3, [sp, #4]
 8001cee:	2b00      	cmp	r3, #0
 8001cf0:	d103      	bne.n	8001cfa <chMtxUnlock+0x1a>
 8001cf2:	4b35      	ldr	r3, [pc, #212]	; (8001dc8 <chMtxUnlock+0xe8>)
 8001cf4:	0018      	movs	r0, r3
 8001cf6:	f001 f813 	bl	8002d20 <chSysHalt>

  chSysLock();
 8001cfa:	f7ff ff09 	bl	8001b10 <chSysLock.lto_priv.173>

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 8001cfe:	9b03      	ldr	r3, [sp, #12]
 8001d00:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8001d02:	2b00      	cmp	r3, #0
 8001d04:	d103      	bne.n	8001d0e <chMtxUnlock+0x2e>
 8001d06:	4b30      	ldr	r3, [pc, #192]	; (8001dc8 <chMtxUnlock+0xe8>)
 8001d08:	0018      	movs	r0, r3
 8001d0a:	f001 f809 	bl	8002d20 <chSysHalt>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
 8001d0e:	9b03      	ldr	r3, [sp, #12]
 8001d10:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8001d12:	689a      	ldr	r2, [r3, #8]
 8001d14:	9b03      	ldr	r3, [sp, #12]
 8001d16:	429a      	cmp	r2, r3
 8001d18:	d003      	beq.n	8001d22 <chMtxUnlock+0x42>
 8001d1a:	4b2b      	ldr	r3, [pc, #172]	; (8001dc8 <chMtxUnlock+0xe8>)
 8001d1c:	0018      	movs	r0, r3
 8001d1e:	f000 ffff 	bl	8002d20 <chSysHalt>
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
#endif

    chDbgAssert(ctp->mtxlist == mp, "not next in list");
 8001d22:	9b03      	ldr	r3, [sp, #12]
 8001d24:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8001d26:	9b01      	ldr	r3, [sp, #4]
 8001d28:	429a      	cmp	r2, r3
 8001d2a:	d003      	beq.n	8001d34 <chMtxUnlock+0x54>
 8001d2c:	4b26      	ldr	r3, [pc, #152]	; (8001dc8 <chMtxUnlock+0xe8>)
 8001d2e:	0018      	movs	r0, r3
 8001d30:	f000 fff6 	bl	8002d20 <chSysHalt>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 8001d34:	9b01      	ldr	r3, [sp, #4]
 8001d36:	68da      	ldr	r2, [r3, #12]
 8001d38:	9b03      	ldr	r3, [sp, #12]
 8001d3a:	639a      	str	r2, [r3, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8001d3c:	9b01      	ldr	r3, [sp, #4]
 8001d3e:	0018      	movs	r0, r3
 8001d40:	f7ff ff0e 	bl	8001b60 <chMtxQueueNotEmptyS>
 8001d44:	1e03      	subs	r3, r0, #0
 8001d46:	d036      	beq.n	8001db6 <chMtxUnlock+0xd6>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 8001d48:	9b03      	ldr	r3, [sp, #12]
 8001d4a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001d4c:	9304      	str	r3, [sp, #16]
      lmp = ctp->mtxlist;
 8001d4e:	9b03      	ldr	r3, [sp, #12]
 8001d50:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8001d52:	9305      	str	r3, [sp, #20]
 8001d54:	e012      	b.n	8001d7c <chMtxUnlock+0x9c>
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8001d56:	9b05      	ldr	r3, [sp, #20]
 8001d58:	0018      	movs	r0, r3
 8001d5a:	f7ff ff01 	bl	8001b60 <chMtxQueueNotEmptyS>
 8001d5e:	1e03      	subs	r3, r0, #0
 8001d60:	d009      	beq.n	8001d76 <chMtxUnlock+0x96>
            (lmp->queue.next->prio > newprio)) {
 8001d62:	9b05      	ldr	r3, [sp, #20]
 8001d64:	681b      	ldr	r3, [r3, #0]
 8001d66:	689a      	ldr	r2, [r3, #8]
        if (chMtxQueueNotEmptyS(lmp) &&
 8001d68:	9b04      	ldr	r3, [sp, #16]
 8001d6a:	429a      	cmp	r2, r3
 8001d6c:	d903      	bls.n	8001d76 <chMtxUnlock+0x96>
          newprio = lmp->queue.next->prio;
 8001d6e:	9b05      	ldr	r3, [sp, #20]
 8001d70:	681b      	ldr	r3, [r3, #0]
 8001d72:	689b      	ldr	r3, [r3, #8]
 8001d74:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->next;
 8001d76:	9b05      	ldr	r3, [sp, #20]
 8001d78:	68db      	ldr	r3, [r3, #12]
 8001d7a:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
 8001d7c:	9b05      	ldr	r3, [sp, #20]
 8001d7e:	2b00      	cmp	r3, #0
 8001d80:	d1e9      	bne.n	8001d56 <chMtxUnlock+0x76>
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 8001d82:	9b03      	ldr	r3, [sp, #12]
 8001d84:	9a04      	ldr	r2, [sp, #16]
 8001d86:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
 8001d88:	9b01      	ldr	r3, [sp, #4]
 8001d8a:	0018      	movs	r0, r3
 8001d8c:	f7ff fe98 	bl	8001ac0 <queue_fifo_remove.lto_priv.181>
 8001d90:	0003      	movs	r3, r0
 8001d92:	9302      	str	r3, [sp, #8]
      mp->owner = tp;
 8001d94:	9b01      	ldr	r3, [sp, #4]
 8001d96:	9a02      	ldr	r2, [sp, #8]
 8001d98:	609a      	str	r2, [r3, #8]
      mp->next = tp->mtxlist;
 8001d9a:	9b02      	ldr	r3, [sp, #8]
 8001d9c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8001d9e:	9b01      	ldr	r3, [sp, #4]
 8001da0:	60da      	str	r2, [r3, #12]
      tp->mtxlist = mp;
 8001da2:	9b02      	ldr	r3, [sp, #8]
 8001da4:	9a01      	ldr	r2, [sp, #4]
 8001da6:	639a      	str	r2, [r3, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8001da8:	9b02      	ldr	r3, [sp, #8]
 8001daa:	0018      	movs	r0, r3
 8001dac:	f001 fc40 	bl	8003630 <chSchReadyI>
      chSchRescheduleS();
 8001db0:	f000 f95e 	bl	8002070 <chSchRescheduleS>
 8001db4:	e002      	b.n	8001dbc <chMtxUnlock+0xdc>
    }
    else {
      mp->owner = NULL;
 8001db6:	9b01      	ldr	r3, [sp, #4]
 8001db8:	2200      	movs	r2, #0
 8001dba:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
 8001dbc:	f7ff feb0 	bl	8001b20 <chSysUnlock.lto_priv.169>
}
 8001dc0:	b007      	add	sp, #28
 8001dc2:	bd00      	pop	{pc}
 8001dc4:	200004d8 	.word	0x200004d8
 8001dc8:	08003948 	.word	0x08003948
 8001dcc:	00000000 	.word	0x00000000

08001dd0 <chSchReadyAheadI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyAheadI(thread_t *tp) {
 8001dd0:	b500      	push	{lr}
 8001dd2:	b085      	sub	sp, #20
 8001dd4:	9001      	str	r0, [sp, #4]
  thread_t *cp;

  chDbgCheckClassI();
 8001dd6:	f001 f893 	bl	8002f00 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8001dda:	9b01      	ldr	r3, [sp, #4]
 8001ddc:	2b00      	cmp	r3, #0
 8001dde:	d103      	bne.n	8001de8 <chSchReadyAheadI+0x18>
 8001de0:	4b19      	ldr	r3, [pc, #100]	; (8001e48 <chSchReadyAheadI+0x78>)
 8001de2:	0018      	movs	r0, r3
 8001de4:	f000 ff9c 	bl	8002d20 <chSysHalt>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8001de8:	9b01      	ldr	r3, [sp, #4]
 8001dea:	2220      	movs	r2, #32
 8001dec:	5c9b      	ldrb	r3, [r3, r2]
 8001dee:	2b00      	cmp	r3, #0
 8001df0:	d004      	beq.n	8001dfc <chSchReadyAheadI+0x2c>
 8001df2:	9b01      	ldr	r3, [sp, #4]
 8001df4:	2220      	movs	r2, #32
 8001df6:	5c9b      	ldrb	r3, [r3, r2]
 8001df8:	2b0f      	cmp	r3, #15
 8001dfa:	d103      	bne.n	8001e04 <chSchReadyAheadI+0x34>
 8001dfc:	4b12      	ldr	r3, [pc, #72]	; (8001e48 <chSchReadyAheadI+0x78>)
 8001dfe:	0018      	movs	r0, r3
 8001e00:	f000 ff8e 	bl	8002d20 <chSysHalt>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8001e04:	9b01      	ldr	r3, [sp, #4]
 8001e06:	2220      	movs	r2, #32
 8001e08:	2100      	movs	r1, #0
 8001e0a:	5499      	strb	r1, [r3, r2]
  cp = (thread_t *)&ch.rlist.queue;
 8001e0c:	4b0f      	ldr	r3, [pc, #60]	; (8001e4c <chSchReadyAheadI+0x7c>)
 8001e0e:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->queue.next;
 8001e10:	9b03      	ldr	r3, [sp, #12]
 8001e12:	681b      	ldr	r3, [r3, #0]
 8001e14:	9303      	str	r3, [sp, #12]
  } while (cp->prio > tp->prio);
 8001e16:	9b03      	ldr	r3, [sp, #12]
 8001e18:	689a      	ldr	r2, [r3, #8]
 8001e1a:	9b01      	ldr	r3, [sp, #4]
 8001e1c:	689b      	ldr	r3, [r3, #8]
 8001e1e:	429a      	cmp	r2, r3
 8001e20:	d8f6      	bhi.n	8001e10 <chSchReadyAheadI+0x40>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8001e22:	9b01      	ldr	r3, [sp, #4]
 8001e24:	9a03      	ldr	r2, [sp, #12]
 8001e26:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 8001e28:	9b03      	ldr	r3, [sp, #12]
 8001e2a:	685a      	ldr	r2, [r3, #4]
 8001e2c:	9b01      	ldr	r3, [sp, #4]
 8001e2e:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8001e30:	9b01      	ldr	r3, [sp, #4]
 8001e32:	685b      	ldr	r3, [r3, #4]
 8001e34:	9a01      	ldr	r2, [sp, #4]
 8001e36:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 8001e38:	9b03      	ldr	r3, [sp, #12]
 8001e3a:	9a01      	ldr	r2, [sp, #4]
 8001e3c:	605a      	str	r2, [r3, #4]

  return tp;
 8001e3e:	9b01      	ldr	r3, [sp, #4]
}
 8001e40:	0018      	movs	r0, r3
 8001e42:	b005      	add	sp, #20
 8001e44:	bd00      	pop	{pc}
 8001e46:	46c0      	nop			; (mov r8, r8)
 8001e48:	0800383c 	.word	0x0800383c
 8001e4c:	200004d8 	.word	0x200004d8

08001e50 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8001e50:	b510      	push	{r4, lr}
 8001e52:	b084      	sub	sp, #16
 8001e54:	0002      	movs	r2, r0
 8001e56:	466b      	mov	r3, sp
 8001e58:	3307      	adds	r3, #7
 8001e5a:	701a      	strb	r2, [r3, #0]
  thread_t *otp = currp;
 8001e5c:	4b1b      	ldr	r3, [pc, #108]	; (8001ecc <chSchGoSleepS+0x7c>)
 8001e5e:	699b      	ldr	r3, [r3, #24]
 8001e60:	9303      	str	r3, [sp, #12]

  chDbgCheckClassS();
 8001e62:	f001 f865 	bl	8002f30 <chDbgCheckClassS>

  /* New state.*/
  otp->state = newstate;
 8001e66:	9b03      	ldr	r3, [sp, #12]
 8001e68:	466a      	mov	r2, sp
 8001e6a:	3207      	adds	r2, #7
 8001e6c:	2120      	movs	r1, #32
 8001e6e:	7812      	ldrb	r2, [r2, #0]
 8001e70:	545a      	strb	r2, [r3, r1]
     time quantum when it will wakeup.*/
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8001e72:	4b16      	ldr	r3, [pc, #88]	; (8001ecc <chSchGoSleepS+0x7c>)
 8001e74:	0018      	movs	r0, r3
 8001e76:	f001 fb53 	bl	8003520 <queue_fifo_remove.lto_priv.226>
 8001e7a:	0002      	movs	r2, r0
 8001e7c:	4b13      	ldr	r3, [pc, #76]	; (8001ecc <chSchGoSleepS+0x7c>)
 8001e7e:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 8001e80:	4b12      	ldr	r3, [pc, #72]	; (8001ecc <chSchGoSleepS+0x7c>)
 8001e82:	699b      	ldr	r3, [r3, #24]
 8001e84:	2220      	movs	r2, #32
 8001e86:	2101      	movs	r1, #1
 8001e88:	5499      	strb	r1, [r3, r2]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8001e8a:	4b10      	ldr	r3, [pc, #64]	; (8001ecc <chSchGoSleepS+0x7c>)
 8001e8c:	699b      	ldr	r3, [r3, #24]
 8001e8e:	9a03      	ldr	r2, [sp, #12]
 8001e90:	0011      	movs	r1, r2
 8001e92:	0018      	movs	r0, r3
 8001e94:	f001 f8ec 	bl	8003070 <_trace_switch>
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8001e98:	f3ef 8309 	mrs	r3, PSP
 8001e9c:	001c      	movs	r4, r3
  return(result);
 8001e9e:	0023      	movs	r3, r4
 8001ea0:	9302      	str	r3, [sp, #8]
 8001ea2:	9b02      	ldr	r3, [sp, #8]
 8001ea4:	3b24      	subs	r3, #36	; 0x24
 8001ea6:	001a      	movs	r2, r3
 8001ea8:	9b03      	ldr	r3, [sp, #12]
 8001eaa:	69db      	ldr	r3, [r3, #28]
 8001eac:	429a      	cmp	r2, r3
 8001eae:	d203      	bcs.n	8001eb8 <chSchGoSleepS+0x68>
 8001eb0:	4b07      	ldr	r3, [pc, #28]	; (8001ed0 <chSchGoSleepS+0x80>)
 8001eb2:	0018      	movs	r0, r3
 8001eb4:	f000 ff34 	bl	8002d20 <chSysHalt>
 8001eb8:	4b04      	ldr	r3, [pc, #16]	; (8001ecc <chSchGoSleepS+0x7c>)
 8001eba:	699b      	ldr	r3, [r3, #24]
 8001ebc:	9a03      	ldr	r2, [sp, #12]
 8001ebe:	0011      	movs	r1, r2
 8001ec0:	0018      	movs	r0, r3
 8001ec2:	f7fe f965 	bl	8000190 <_port_switch>
}
 8001ec6:	b004      	add	sp, #16
 8001ec8:	bd10      	pop	{r4, pc}
 8001eca:	46c0      	nop			; (mov r8, r8)
 8001ecc:	200004d8 	.word	0x200004d8
 8001ed0:	08003700 	.word	0x08003700
	...

08001ee0 <wakeup>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8001ee0:	b500      	push	{lr}
 8001ee2:	b085      	sub	sp, #20
 8001ee4:	9001      	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
 8001ee6:	9b01      	ldr	r3, [sp, #4]
 8001ee8:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
 8001eea:	f001 fb59 	bl	80035a0 <chSysLockFromISR.lto_priv.235>
  switch (tp->state) {
 8001eee:	9b03      	ldr	r3, [sp, #12]
 8001ef0:	2220      	movs	r2, #32
 8001ef2:	5c9b      	ldrb	r3, [r3, r2]
 8001ef4:	2b07      	cmp	r3, #7
 8001ef6:	d815      	bhi.n	8001f24 <wakeup+0x44>
 8001ef8:	009a      	lsls	r2, r3, #2
 8001efa:	4b10      	ldr	r3, [pc, #64]	; (8001f3c <wakeup+0x5c>)
 8001efc:	18d3      	adds	r3, r2, r3
 8001efe:	681b      	ldr	r3, [r3, #0]
 8001f00:	469f      	mov	pc, r3
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 8001f02:	f001 fb55 	bl	80035b0 <chSysUnlockFromISR.lto_priv.232>
 8001f06:	e017      	b.n	8001f38 <wakeup+0x58>
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 8001f08:	9b03      	ldr	r3, [sp, #12]
 8001f0a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001f0c:	2200      	movs	r2, #0
 8001f0e:	601a      	str	r2, [r3, #0]
 8001f10:	e008      	b.n	8001f24 <wakeup+0x44>
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 8001f12:	9b03      	ldr	r3, [sp, #12]
 8001f14:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001f16:	0018      	movs	r0, r3
 8001f18:	f001 fb62 	bl	80035e0 <chSemFastSignalI.lto_priv.234>
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
 8001f1c:	9b03      	ldr	r3, [sp, #12]
 8001f1e:	0018      	movs	r0, r3
 8001f20:	f001 fb16 	bl	8003550 <queue_dequeue.lto_priv.233>
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 8001f24:	9b03      	ldr	r3, [sp, #12]
 8001f26:	2201      	movs	r2, #1
 8001f28:	4252      	negs	r2, r2
 8001f2a:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 8001f2c:	9b03      	ldr	r3, [sp, #12]
 8001f2e:	0018      	movs	r0, r3
 8001f30:	f001 fb7e 	bl	8003630 <chSchReadyI>
  chSysUnlockFromISR();
 8001f34:	f001 fb3c 	bl	80035b0 <chSysUnlockFromISR.lto_priv.232>
}
 8001f38:	b005      	add	sp, #20
 8001f3a:	bd00      	pop	{pc}
 8001f3c:	08003b6c 	.word	0x08003b6c

08001f40 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8001f40:	b500      	push	{lr}
 8001f42:	b089      	sub	sp, #36	; 0x24
 8001f44:	0002      	movs	r2, r0
 8001f46:	9100      	str	r1, [sp, #0]
 8001f48:	466b      	mov	r3, sp
 8001f4a:	3307      	adds	r3, #7
 8001f4c:	701a      	strb	r2, [r3, #0]

  chDbgCheckClassS();
 8001f4e:	f000 ffef 	bl	8002f30 <chDbgCheckClassS>

  if (TIME_INFINITE != time) {
 8001f52:	9b00      	ldr	r3, [sp, #0]
 8001f54:	3301      	adds	r3, #1
 8001f56:	d017      	beq.n	8001f88 <chSchGoSleepTimeoutS+0x48>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8001f58:	4b11      	ldr	r3, [pc, #68]	; (8001fa0 <chSchGoSleepTimeoutS+0x60>)
 8001f5a:	699b      	ldr	r3, [r3, #24]
 8001f5c:	4a11      	ldr	r2, [pc, #68]	; (8001fa4 <chSchGoSleepTimeoutS+0x64>)
 8001f5e:	9900      	ldr	r1, [sp, #0]
 8001f60:	a803      	add	r0, sp, #12
 8001f62:	f001 f98d 	bl	8003280 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8001f66:	466b      	mov	r3, sp
 8001f68:	3307      	adds	r3, #7
 8001f6a:	781b      	ldrb	r3, [r3, #0]
 8001f6c:	0018      	movs	r0, r3
 8001f6e:	f7ff ff6f 	bl	8001e50 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8001f72:	ab03      	add	r3, sp, #12
 8001f74:	0018      	movs	r0, r3
 8001f76:	f001 fb23 	bl	80035c0 <chVTIsArmedI.lto_priv.231>
 8001f7a:	1e03      	subs	r3, r0, #0
 8001f7c:	d00a      	beq.n	8001f94 <chSchGoSleepTimeoutS+0x54>
      chVTDoResetI(&vt);
 8001f7e:	ab03      	add	r3, sp, #12
 8001f80:	0018      	movs	r0, r3
 8001f82:	f001 fa1d 	bl	80033c0 <chVTDoResetI>
 8001f86:	e005      	b.n	8001f94 <chSchGoSleepTimeoutS+0x54>
    }
  }
  else {
    chSchGoSleepS(newstate);
 8001f88:	466b      	mov	r3, sp
 8001f8a:	3307      	adds	r3, #7
 8001f8c:	781b      	ldrb	r3, [r3, #0]
 8001f8e:	0018      	movs	r0, r3
 8001f90:	f7ff ff5e 	bl	8001e50 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
 8001f94:	4b02      	ldr	r3, [pc, #8]	; (8001fa0 <chSchGoSleepTimeoutS+0x60>)
 8001f96:	699b      	ldr	r3, [r3, #24]
 8001f98:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8001f9a:	0018      	movs	r0, r3
 8001f9c:	b009      	add	sp, #36	; 0x24
 8001f9e:	bd00      	pop	{pc}
 8001fa0:	200004d8 	.word	0x200004d8
 8001fa4:	08001ee1 	.word	0x08001ee1
	...

08001fb0 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8001fb0:	b510      	push	{r4, lr}
 8001fb2:	b084      	sub	sp, #16
 8001fb4:	9001      	str	r0, [sp, #4]
 8001fb6:	9100      	str	r1, [sp, #0]
  thread_t *otp = currp;
 8001fb8:	4b27      	ldr	r3, [pc, #156]	; (8002058 <chSchWakeupS+0xa8>)
 8001fba:	699b      	ldr	r3, [r3, #24]
 8001fbc:	9303      	str	r3, [sp, #12]

  chDbgCheckClassS();
 8001fbe:	f000 ffb7 	bl	8002f30 <chDbgCheckClassS>

  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001fc2:	4b25      	ldr	r3, [pc, #148]	; (8002058 <chSchWakeupS+0xa8>)
 8001fc4:	681a      	ldr	r2, [r3, #0]
 8001fc6:	4b24      	ldr	r3, [pc, #144]	; (8002058 <chSchWakeupS+0xa8>)
 8001fc8:	429a      	cmp	r2, r3
 8001fca:	d00b      	beq.n	8001fe4 <chSchWakeupS+0x34>
 8001fcc:	4b22      	ldr	r3, [pc, #136]	; (8002058 <chSchWakeupS+0xa8>)
 8001fce:	699b      	ldr	r3, [r3, #24]
 8001fd0:	689a      	ldr	r2, [r3, #8]
 8001fd2:	4b21      	ldr	r3, [pc, #132]	; (8002058 <chSchWakeupS+0xa8>)
 8001fd4:	681b      	ldr	r3, [r3, #0]
 8001fd6:	689b      	ldr	r3, [r3, #8]
 8001fd8:	429a      	cmp	r2, r3
 8001fda:	d203      	bcs.n	8001fe4 <chSchWakeupS+0x34>
 8001fdc:	4b1f      	ldr	r3, [pc, #124]	; (800205c <chSchWakeupS+0xac>)
 8001fde:	0018      	movs	r0, r3
 8001fe0:	f000 fe9e 	bl	8002d20 <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 8001fe4:	9b01      	ldr	r3, [sp, #4]
 8001fe6:	9a00      	ldr	r2, [sp, #0]
 8001fe8:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 8001fea:	9b01      	ldr	r3, [sp, #4]
 8001fec:	689a      	ldr	r2, [r3, #8]
 8001fee:	9b03      	ldr	r3, [sp, #12]
 8001ff0:	689b      	ldr	r3, [r3, #8]
 8001ff2:	429a      	cmp	r2, r3
 8001ff4:	d804      	bhi.n	8002000 <chSchWakeupS+0x50>
    (void) chSchReadyI(ntp);
 8001ff6:	9b01      	ldr	r3, [sp, #4]
 8001ff8:	0018      	movs	r0, r3
 8001ffa:	f001 fb19 	bl	8003630 <chSchReadyI>
 8001ffe:	e028      	b.n	8002052 <chSchWakeupS+0xa2>
  }
  else {
    otp = chSchReadyI(otp);
 8002000:	9b03      	ldr	r3, [sp, #12]
 8002002:	0018      	movs	r0, r3
 8002004:	f001 fb14 	bl	8003630 <chSchReadyI>
 8002008:	0003      	movs	r3, r0
 800200a:	9303      	str	r3, [sp, #12]
    if (otp->prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
 800200c:	4b12      	ldr	r3, [pc, #72]	; (8002058 <chSchWakeupS+0xa8>)
 800200e:	9a01      	ldr	r2, [sp, #4]
 8002010:	619a      	str	r2, [r3, #24]
    ntp->state = CH_STATE_CURRENT;
 8002012:	9b01      	ldr	r3, [sp, #4]
 8002014:	2220      	movs	r2, #32
 8002016:	2101      	movs	r1, #1
 8002018:	5499      	strb	r1, [r3, r2]

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 800201a:	9a03      	ldr	r2, [sp, #12]
 800201c:	9b01      	ldr	r3, [sp, #4]
 800201e:	0011      	movs	r1, r2
 8002020:	0018      	movs	r0, r3
 8002022:	f001 f825 	bl	8003070 <_trace_switch>
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8002026:	f3ef 8309 	mrs	r3, PSP
 800202a:	001c      	movs	r4, r3
  return(result);
 800202c:	0023      	movs	r3, r4
 800202e:	9302      	str	r3, [sp, #8]
 8002030:	9b02      	ldr	r3, [sp, #8]
 8002032:	3b24      	subs	r3, #36	; 0x24
 8002034:	001a      	movs	r2, r3
 8002036:	9b03      	ldr	r3, [sp, #12]
 8002038:	69db      	ldr	r3, [r3, #28]
 800203a:	429a      	cmp	r2, r3
 800203c:	d203      	bcs.n	8002046 <chSchWakeupS+0x96>
 800203e:	4b08      	ldr	r3, [pc, #32]	; (8002060 <chSchWakeupS+0xb0>)
 8002040:	0018      	movs	r0, r3
 8002042:	f000 fe6d 	bl	8002d20 <chSysHalt>
 8002046:	9a03      	ldr	r2, [sp, #12]
 8002048:	9b01      	ldr	r3, [sp, #4]
 800204a:	0011      	movs	r1, r2
 800204c:	0018      	movs	r0, r3
 800204e:	f7fe f89f 	bl	8000190 <_port_switch>
  }
}
 8002052:	b004      	add	sp, #16
 8002054:	bd10      	pop	{r4, pc}
 8002056:	46c0      	nop			; (mov r8, r8)
 8002058:	200004d8 	.word	0x200004d8
 800205c:	08003850 	.word	0x08003850
 8002060:	08003700 	.word	0x08003700
	...

08002070 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 8002070:	b510      	push	{r4, lr}

  chDbgCheckClassS();
 8002072:	f000 ff5d 	bl	8002f30 <chDbgCheckClassS>

  if (chSchIsRescRequiredI()) {
 8002076:	f001 fa7b 	bl	8003570 <chSchIsRescRequiredI.lto_priv.230>
 800207a:	1e03      	subs	r3, r0, #0
 800207c:	d001      	beq.n	8002082 <chSchRescheduleS+0x12>
    chSchDoRescheduleAhead();
 800207e:	f000 f81f 	bl	80020c0 <chSchDoRescheduleAhead>
  }
}
 8002082:	bd10      	pop	{r4, pc}
	...

08002090 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 8002090:	b082      	sub	sp, #8
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8002092:	4b08      	ldr	r3, [pc, #32]	; (80020b4 <chSchIsPreemptionRequired+0x24>)
 8002094:	681b      	ldr	r3, [r3, #0]
 8002096:	689b      	ldr	r3, [r3, #8]
 8002098:	9301      	str	r3, [sp, #4]
  tprio_t p2 = currp->prio;
 800209a:	4b06      	ldr	r3, [pc, #24]	; (80020b4 <chSchIsPreemptionRequired+0x24>)
 800209c:	699b      	ldr	r3, [r3, #24]
 800209e:	689b      	ldr	r3, [r3, #8]
 80020a0:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 80020a2:	9b01      	ldr	r3, [sp, #4]
 80020a4:	9a00      	ldr	r2, [sp, #0]
 80020a6:	429a      	cmp	r2, r3
 80020a8:	419b      	sbcs	r3, r3
 80020aa:	425b      	negs	r3, r3
 80020ac:	b2db      	uxtb	r3, r3
#endif
}
 80020ae:	0018      	movs	r0, r3
 80020b0:	b002      	add	sp, #8
 80020b2:	4770      	bx	lr
 80020b4:	200004d8 	.word	0x200004d8
	...

080020c0 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 80020c0:	b510      	push	{r4, lr}
 80020c2:	b082      	sub	sp, #8
  thread_t *otp = currp;
 80020c4:	4b1a      	ldr	r3, [pc, #104]	; (8002130 <chSchDoRescheduleAhead+0x70>)
 80020c6:	699b      	ldr	r3, [r3, #24]
 80020c8:	9301      	str	r3, [sp, #4]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 80020ca:	4b19      	ldr	r3, [pc, #100]	; (8002130 <chSchDoRescheduleAhead+0x70>)
 80020cc:	0018      	movs	r0, r3
 80020ce:	f001 fa27 	bl	8003520 <queue_fifo_remove.lto_priv.226>
 80020d2:	0002      	movs	r2, r0
 80020d4:	4b16      	ldr	r3, [pc, #88]	; (8002130 <chSchDoRescheduleAhead+0x70>)
 80020d6:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 80020d8:	4b15      	ldr	r3, [pc, #84]	; (8002130 <chSchDoRescheduleAhead+0x70>)
 80020da:	699b      	ldr	r3, [r3, #24]
 80020dc:	2220      	movs	r2, #32
 80020de:	2101      	movs	r1, #1
 80020e0:	5499      	strb	r1, [r3, r2]
  if (otp->prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);
 80020e2:	9b01      	ldr	r3, [sp, #4]
 80020e4:	0018      	movs	r0, r3
 80020e6:	f7ff fe73 	bl	8001dd0 <chSchReadyAheadI>
 80020ea:	0003      	movs	r3, r0
 80020ec:	9301      	str	r3, [sp, #4]

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 80020ee:	4b10      	ldr	r3, [pc, #64]	; (8002130 <chSchDoRescheduleAhead+0x70>)
 80020f0:	699b      	ldr	r3, [r3, #24]
 80020f2:	9a01      	ldr	r2, [sp, #4]
 80020f4:	0011      	movs	r1, r2
 80020f6:	0018      	movs	r0, r3
 80020f8:	f000 ffba 	bl	8003070 <_trace_switch>
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80020fc:	f3ef 8309 	mrs	r3, PSP
 8002100:	001c      	movs	r4, r3
  return(result);
 8002102:	0023      	movs	r3, r4
 8002104:	9300      	str	r3, [sp, #0]
 8002106:	9b00      	ldr	r3, [sp, #0]
 8002108:	3b24      	subs	r3, #36	; 0x24
 800210a:	001a      	movs	r2, r3
 800210c:	9b01      	ldr	r3, [sp, #4]
 800210e:	69db      	ldr	r3, [r3, #28]
 8002110:	429a      	cmp	r2, r3
 8002112:	d203      	bcs.n	800211c <chSchDoRescheduleAhead+0x5c>
 8002114:	4b07      	ldr	r3, [pc, #28]	; (8002134 <chSchDoRescheduleAhead+0x74>)
 8002116:	0018      	movs	r0, r3
 8002118:	f000 fe02 	bl	8002d20 <chSysHalt>
 800211c:	4b04      	ldr	r3, [pc, #16]	; (8002130 <chSchDoRescheduleAhead+0x70>)
 800211e:	699b      	ldr	r3, [r3, #24]
 8002120:	9a01      	ldr	r2, [sp, #4]
 8002122:	0011      	movs	r1, r2
 8002124:	0018      	movs	r0, r3
 8002126:	f7fe f833 	bl	8000190 <_port_switch>
}
 800212a:	b002      	add	sp, #8
 800212c:	bd10      	pop	{r4, pc}
 800212e:	46c0      	nop			; (mov r8, r8)
 8002130:	200004d8 	.word	0x200004d8
 8002134:	08003700 	.word	0x08003700
	...

08002140 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8002140:	b510      	push	{r4, lr}
 8002142:	b082      	sub	sp, #8
  thread_t *otp = currp;
 8002144:	4b1a      	ldr	r3, [pc, #104]	; (80021b0 <chSchDoReschedule+0x70>)
 8002146:	699b      	ldr	r3, [r3, #24]
 8002148:	9301      	str	r3, [sp, #4]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800214a:	4b19      	ldr	r3, [pc, #100]	; (80021b0 <chSchDoReschedule+0x70>)
 800214c:	0018      	movs	r0, r3
 800214e:	f001 f9e7 	bl	8003520 <queue_fifo_remove.lto_priv.226>
 8002152:	0002      	movs	r2, r0
 8002154:	4b16      	ldr	r3, [pc, #88]	; (80021b0 <chSchDoReschedule+0x70>)
 8002156:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 8002158:	4b15      	ldr	r3, [pc, #84]	; (80021b0 <chSchDoReschedule+0x70>)
 800215a:	699b      	ldr	r3, [r3, #24]
 800215c:	2220      	movs	r2, #32
 800215e:	2101      	movs	r1, #1
 8002160:	5499      	strb	r1, [r3, r2]
    otp = chSchReadyAheadI(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
 8002162:	9b01      	ldr	r3, [sp, #4]
 8002164:	0018      	movs	r0, r3
 8002166:	f7ff fe33 	bl	8001dd0 <chSchReadyAheadI>
 800216a:	0003      	movs	r3, r0
 800216c:	9301      	str	r3, [sp, #4]
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800216e:	4b10      	ldr	r3, [pc, #64]	; (80021b0 <chSchDoReschedule+0x70>)
 8002170:	699b      	ldr	r3, [r3, #24]
 8002172:	9a01      	ldr	r2, [sp, #4]
 8002174:	0011      	movs	r1, r2
 8002176:	0018      	movs	r0, r3
 8002178:	f000 ff7a 	bl	8003070 <_trace_switch>
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800217c:	f3ef 8309 	mrs	r3, PSP
 8002180:	001c      	movs	r4, r3
  return(result);
 8002182:	0023      	movs	r3, r4
 8002184:	9300      	str	r3, [sp, #0]
 8002186:	9b00      	ldr	r3, [sp, #0]
 8002188:	3b24      	subs	r3, #36	; 0x24
 800218a:	001a      	movs	r2, r3
 800218c:	9b01      	ldr	r3, [sp, #4]
 800218e:	69db      	ldr	r3, [r3, #28]
 8002190:	429a      	cmp	r2, r3
 8002192:	d203      	bcs.n	800219c <chSchDoReschedule+0x5c>
 8002194:	4b07      	ldr	r3, [pc, #28]	; (80021b4 <chSchDoReschedule+0x74>)
 8002196:	0018      	movs	r0, r3
 8002198:	f000 fdc2 	bl	8002d20 <chSysHalt>
 800219c:	4b04      	ldr	r3, [pc, #16]	; (80021b0 <chSchDoReschedule+0x70>)
 800219e:	699b      	ldr	r3, [r3, #24]
 80021a0:	9a01      	ldr	r2, [sp, #4]
 80021a2:	0011      	movs	r1, r2
 80021a4:	0018      	movs	r0, r3
 80021a6:	f7fd fff3 	bl	8000190 <_port_switch>
}
 80021aa:	b002      	add	sp, #8
 80021ac:	bd10      	pop	{r4, pc}
 80021ae:	46c0      	nop			; (mov r8, r8)
 80021b0:	200004d8 	.word	0x200004d8
 80021b4:	08003700 	.word	0x08003700
	...

080021c0 <port_lock.lto_priv.202>:
  __ASM volatile ("cpsid i" : : : "memory");
 80021c0:	b672      	cpsid	i
}
 80021c2:	4770      	bx	lr
	...

080021d0 <port_unlock.lto_priv.199>:
  __ASM volatile ("cpsie i" : : : "memory");
 80021d0:	b662      	cpsie	i
}
 80021d2:	4770      	bx	lr
	...

080021e0 <list_init>:
static inline void list_init(threads_list_t *tlp) {
 80021e0:	b082      	sub	sp, #8
 80021e2:	9001      	str	r0, [sp, #4]
  tlp->next = (thread_t *)tlp;
 80021e4:	9b01      	ldr	r3, [sp, #4]
 80021e6:	9a01      	ldr	r2, [sp, #4]
 80021e8:	601a      	str	r2, [r3, #0]
}
 80021ea:	b002      	add	sp, #8
 80021ec:	4770      	bx	lr
 80021ee:	46c0      	nop			; (mov r8, r8)

080021f0 <list_notempty>:
static inline bool list_notempty(threads_list_t *tlp) {
 80021f0:	b082      	sub	sp, #8
 80021f2:	9001      	str	r0, [sp, #4]
  return (bool)(tlp->next != (thread_t *)tlp);
 80021f4:	9b01      	ldr	r3, [sp, #4]
 80021f6:	681a      	ldr	r2, [r3, #0]
 80021f8:	9b01      	ldr	r3, [sp, #4]
 80021fa:	1ad3      	subs	r3, r2, r3
 80021fc:	1e5a      	subs	r2, r3, #1
 80021fe:	4193      	sbcs	r3, r2
 8002200:	b2db      	uxtb	r3, r3
}
 8002202:	0018      	movs	r0, r3
 8002204:	b002      	add	sp, #8
 8002206:	4770      	bx	lr
	...

08002210 <queue_init.lto_priv.197>:
static inline void queue_init(threads_queue_t *tqp) {
 8002210:	b082      	sub	sp, #8
 8002212:	9001      	str	r0, [sp, #4]
  tqp->next = (thread_t *)tqp;
 8002214:	9b01      	ldr	r3, [sp, #4]
 8002216:	9a01      	ldr	r2, [sp, #4]
 8002218:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800221a:	9b01      	ldr	r3, [sp, #4]
 800221c:	9a01      	ldr	r2, [sp, #4]
 800221e:	605a      	str	r2, [r3, #4]
}
 8002220:	b002      	add	sp, #8
 8002222:	4770      	bx	lr
	...

08002230 <list_remove>:
static inline thread_t *list_remove(threads_list_t *tlp) {
 8002230:	b084      	sub	sp, #16
 8002232:	9001      	str	r0, [sp, #4]
  thread_t *tp = tlp->next;
 8002234:	9b01      	ldr	r3, [sp, #4]
 8002236:	681b      	ldr	r3, [r3, #0]
 8002238:	9303      	str	r3, [sp, #12]
  tlp->next = tp->queue.next;
 800223a:	9b03      	ldr	r3, [sp, #12]
 800223c:	681a      	ldr	r2, [r3, #0]
 800223e:	9b01      	ldr	r3, [sp, #4]
 8002240:	601a      	str	r2, [r3, #0]
  return tp;
 8002242:	9b03      	ldr	r3, [sp, #12]
}
 8002244:	0018      	movs	r0, r3
 8002246:	b004      	add	sp, #16
 8002248:	4770      	bx	lr
 800224a:	46c0      	nop			; (mov r8, r8)
 800224c:	0000      	movs	r0, r0
	...

08002250 <chSysLock.lto_priv.210>:
static inline void chSysLock(void) {
 8002250:	b510      	push	{r4, lr}
  port_lock();
 8002252:	f7ff ffb5 	bl	80021c0 <port_lock.lto_priv.202>
  _dbg_check_lock();
 8002256:	f000 fdb3 	bl	8002dc0 <_dbg_check_lock>
}
 800225a:	bd10      	pop	{r4, pc}
 800225c:	0000      	movs	r0, r0
	...

08002260 <chSysUnlock.lto_priv.208>:
static inline void chSysUnlock(void) {
 8002260:	b510      	push	{r4, lr}
  _dbg_check_unlock();
 8002262:	f000 fdc5 	bl	8002df0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002266:	4b0a      	ldr	r3, [pc, #40]	; (8002290 <chSysUnlock.lto_priv.208+0x30>)
 8002268:	681a      	ldr	r2, [r3, #0]
 800226a:	4b09      	ldr	r3, [pc, #36]	; (8002290 <chSysUnlock.lto_priv.208+0x30>)
 800226c:	429a      	cmp	r2, r3
 800226e:	d00b      	beq.n	8002288 <chSysUnlock.lto_priv.208+0x28>
 8002270:	4b07      	ldr	r3, [pc, #28]	; (8002290 <chSysUnlock.lto_priv.208+0x30>)
 8002272:	699b      	ldr	r3, [r3, #24]
 8002274:	689a      	ldr	r2, [r3, #8]
 8002276:	4b06      	ldr	r3, [pc, #24]	; (8002290 <chSysUnlock.lto_priv.208+0x30>)
 8002278:	681b      	ldr	r3, [r3, #0]
 800227a:	689b      	ldr	r3, [r3, #8]
 800227c:	429a      	cmp	r2, r3
 800227e:	d203      	bcs.n	8002288 <chSysUnlock.lto_priv.208+0x28>
 8002280:	4b04      	ldr	r3, [pc, #16]	; (8002294 <chSysUnlock.lto_priv.208+0x34>)
 8002282:	0018      	movs	r0, r3
 8002284:	f000 fd4c 	bl	8002d20 <chSysHalt>
  port_unlock();
 8002288:	f7ff ffa2 	bl	80021d0 <port_unlock.lto_priv.199>
}
 800228c:	bd10      	pop	{r4, pc}
 800228e:	46c0      	nop			; (mov r8, r8)
 8002290:	200004d8 	.word	0x200004d8
 8002294:	08003878 	.word	0x08003878
	...

080022a0 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80022a0:	4b01      	ldr	r3, [pc, #4]	; (80022a8 <chThdGetSelfX+0x8>)
 80022a2:	699b      	ldr	r3, [r3, #24]
}
 80022a4:	0018      	movs	r0, r3
 80022a6:	4770      	bx	lr
 80022a8:	200004d8 	.word	0x200004d8
 80022ac:	00000000 	.word	0x00000000

080022b0 <chThdGetWorkingAreaX.lto_priv.206>:
 * @param[in] tp        pointer to the thread
 * @return              The working area base pointer.
 *
 * @xclass
 */
static inline stkalign_t *chThdGetWorkingAreaX(thread_t *tp) {
 80022b0:	b082      	sub	sp, #8
 80022b2:	9001      	str	r0, [sp, #4]

  return tp->wabase;
 80022b4:	9b01      	ldr	r3, [sp, #4]
 80022b6:	69db      	ldr	r3, [r3, #28]
}
 80022b8:	0018      	movs	r0, r3
 80022ba:	b002      	add	sp, #8
 80022bc:	4770      	bx	lr
 80022be:	46c0      	nop			; (mov r8, r8)

080022c0 <chThdSleepS>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {
 80022c0:	b500      	push	{lr}
 80022c2:	b083      	sub	sp, #12
 80022c4:	9001      	str	r0, [sp, #4]

  chDbgCheck(time != TIME_IMMEDIATE);
 80022c6:	9b01      	ldr	r3, [sp, #4]
 80022c8:	2b00      	cmp	r3, #0
 80022ca:	d103      	bne.n	80022d4 <chThdSleepS+0x14>
 80022cc:	4b05      	ldr	r3, [pc, #20]	; (80022e4 <chThdSleepS+0x24>)
 80022ce:	0018      	movs	r0, r3
 80022d0:	f000 fd26 	bl	8002d20 <chSysHalt>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 80022d4:	9b01      	ldr	r3, [sp, #4]
 80022d6:	0019      	movs	r1, r3
 80022d8:	2008      	movs	r0, #8
 80022da:	f7ff fe31 	bl	8001f40 <chSchGoSleepTimeoutS>
}
 80022de:	b003      	add	sp, #12
 80022e0:	bd00      	pop	{pc}
 80022e2:	46c0      	nop			; (mov r8, r8)
 80022e4:	080038c0 	.word	0x080038c0
	...

080022f0 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {
 80022f0:	b500      	push	{lr}
 80022f2:	b085      	sub	sp, #20
 80022f4:	9003      	str	r0, [sp, #12]
 80022f6:	9102      	str	r1, [sp, #8]
 80022f8:	9201      	str	r2, [sp, #4]

  tp->prio      = prio;
 80022fa:	9b03      	ldr	r3, [sp, #12]
 80022fc:	9a01      	ldr	r2, [sp, #4]
 80022fe:	609a      	str	r2, [r3, #8]
  tp->state     = CH_STATE_WTSTART;
 8002300:	9b03      	ldr	r3, [sp, #12]
 8002302:	2220      	movs	r2, #32
 8002304:	2102      	movs	r1, #2
 8002306:	5499      	strb	r1, [r3, r2]
  tp->flags     = CH_FLAG_MODE_STATIC;
 8002308:	9b03      	ldr	r3, [sp, #12]
 800230a:	2221      	movs	r2, #33	; 0x21
 800230c:	2100      	movs	r1, #0
 800230e:	5499      	strb	r1, [r3, r2]
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8002310:	9b03      	ldr	r3, [sp, #12]
 8002312:	9a01      	ldr	r2, [sp, #4]
 8002314:	63da      	str	r2, [r3, #60]	; 0x3c
  tp->mtxlist   = NULL;
 8002316:	9b03      	ldr	r3, [sp, #12]
 8002318:	2200      	movs	r2, #0
 800231a:	639a      	str	r2, [r3, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 800231c:	9b03      	ldr	r3, [sp, #12]
 800231e:	2200      	movs	r2, #0
 8002320:	635a      	str	r2, [r3, #52]	; 0x34
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8002322:	9b03      	ldr	r3, [sp, #12]
 8002324:	2222      	movs	r2, #34	; 0x22
 8002326:	2101      	movs	r1, #1
 8002328:	5499      	strb	r1, [r3, r2]
  tp->name      = name;
 800232a:	9b03      	ldr	r3, [sp, #12]
 800232c:	9a02      	ldr	r2, [sp, #8]
 800232e:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
 8002330:	9b03      	ldr	r3, [sp, #12]
 8002332:	4a0d      	ldr	r2, [pc, #52]	; (8002368 <_thread_init+0x78>)
 8002334:	611a      	str	r2, [r3, #16]
 8002336:	4b0c      	ldr	r3, [pc, #48]	; (8002368 <_thread_init+0x78>)
 8002338:	695a      	ldr	r2, [r3, #20]
 800233a:	9b03      	ldr	r3, [sp, #12]
 800233c:	615a      	str	r2, [r3, #20]
 800233e:	9b03      	ldr	r3, [sp, #12]
 8002340:	695b      	ldr	r3, [r3, #20]
 8002342:	9a03      	ldr	r2, [sp, #12]
 8002344:	611a      	str	r2, [r3, #16]
 8002346:	4b08      	ldr	r3, [pc, #32]	; (8002368 <_thread_init+0x78>)
 8002348:	9a03      	ldr	r2, [sp, #12]
 800234a:	615a      	str	r2, [r3, #20]
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
 800234c:	9b03      	ldr	r3, [sp, #12]
 800234e:	3328      	adds	r3, #40	; 0x28
 8002350:	0018      	movs	r0, r3
 8002352:	f7ff ff45 	bl	80021e0 <list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
 8002356:	9b03      	ldr	r3, [sp, #12]
 8002358:	332c      	adds	r3, #44	; 0x2c
 800235a:	0018      	movs	r0, r3
 800235c:	f7ff ff58 	bl	8002210 <queue_init.lto_priv.197>
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
 8002360:	9b03      	ldr	r3, [sp, #12]
}
 8002362:	0018      	movs	r0, r3
 8002364:	b005      	add	sp, #20
 8002366:	bd00      	pop	{pc}
 8002368:	200004d8 	.word	0x200004d8
 800236c:	00000000 	.word	0x00000000

08002370 <_thread_memfill>:
 * @param[in] endp      last address to fill +1
 * @param[in] v         filler value
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {
 8002370:	b084      	sub	sp, #16
 8002372:	9003      	str	r0, [sp, #12]
 8002374:	9102      	str	r1, [sp, #8]
 8002376:	466b      	mov	r3, sp
 8002378:	3307      	adds	r3, #7
 800237a:	701a      	strb	r2, [r3, #0]
 800237c:	e006      	b.n	800238c <_thread_memfill+0x1c>

  while (startp < endp) {
    *startp++ = v;
 800237e:	9b03      	ldr	r3, [sp, #12]
 8002380:	1c5a      	adds	r2, r3, #1
 8002382:	9203      	str	r2, [sp, #12]
 8002384:	466a      	mov	r2, sp
 8002386:	3207      	adds	r2, #7
 8002388:	7812      	ldrb	r2, [r2, #0]
 800238a:	701a      	strb	r2, [r3, #0]
  while (startp < endp) {
 800238c:	9a03      	ldr	r2, [sp, #12]
 800238e:	9b02      	ldr	r3, [sp, #8]
 8002390:	429a      	cmp	r2, r3
 8002392:	d3f4      	bcc.n	800237e <_thread_memfill+0xe>
  }
}
 8002394:	b004      	add	sp, #16
 8002396:	4770      	bx	lr
	...

080023a0 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 80023a0:	b500      	push	{lr}
 80023a2:	b085      	sub	sp, #20
 80023a4:	9001      	str	r0, [sp, #4]
  thread_t *tp;

  chDbgCheckClassI();
 80023a6:	f000 fdab 	bl	8002f00 <chDbgCheckClassI>
  chDbgCheck(tdp != NULL);
 80023aa:	9b01      	ldr	r3, [sp, #4]
 80023ac:	2b00      	cmp	r3, #0
 80023ae:	d103      	bne.n	80023b8 <chThdCreateSuspendedI+0x18>
 80023b0:	4b2a      	ldr	r3, [pc, #168]	; (800245c <chThdCreateSuspendedI+0xbc>)
 80023b2:	0018      	movs	r0, r3
 80023b4:	f000 fcb4 	bl	8002d20 <chSysHalt>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
 80023b8:	9b01      	ldr	r3, [sp, #4]
 80023ba:	685b      	ldr	r3, [r3, #4]
 80023bc:	001a      	movs	r2, r3
 80023be:	2307      	movs	r3, #7
 80023c0:	4013      	ands	r3, r2
 80023c2:	d113      	bne.n	80023ec <chThdCreateSuspendedI+0x4c>
 80023c4:	9b01      	ldr	r3, [sp, #4]
 80023c6:	689b      	ldr	r3, [r3, #8]
 80023c8:	001a      	movs	r2, r3
 80023ca:	2307      	movs	r3, #7
 80023cc:	4013      	ands	r3, r2
 80023ce:	d10d      	bne.n	80023ec <chThdCreateSuspendedI+0x4c>
 80023d0:	9b01      	ldr	r3, [sp, #4]
 80023d2:	689a      	ldr	r2, [r3, #8]
 80023d4:	9b01      	ldr	r3, [sp, #4]
 80023d6:	685b      	ldr	r3, [r3, #4]
 80023d8:	429a      	cmp	r2, r3
 80023da:	d907      	bls.n	80023ec <chThdCreateSuspendedI+0x4c>
 80023dc:	9b01      	ldr	r3, [sp, #4]
 80023de:	689b      	ldr	r3, [r3, #8]
 80023e0:	001a      	movs	r2, r3
 80023e2:	9b01      	ldr	r3, [sp, #4]
 80023e4:	685b      	ldr	r3, [r3, #4]
 80023e6:	1ad3      	subs	r3, r2, r3
 80023e8:	2bc7      	cmp	r3, #199	; 0xc7
 80023ea:	d803      	bhi.n	80023f4 <chThdCreateSuspendedI+0x54>
 80023ec:	4b1b      	ldr	r3, [pc, #108]	; (800245c <chThdCreateSuspendedI+0xbc>)
 80023ee:	0018      	movs	r0, r3
 80023f0:	f000 fc96 	bl	8002d20 <chSysHalt>
             MEM_IS_ALIGNED(tdp->wend, PORT_STACK_ALIGN) &&
             (tdp->wend > tdp->wbase) &&
             (((size_t)tdp->wend - (size_t)tdp->wbase) >= THD_WORKING_AREA_SIZE(0)));
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));
 80023f4:	9b01      	ldr	r3, [sp, #4]
 80023f6:	68db      	ldr	r3, [r3, #12]
 80023f8:	2bff      	cmp	r3, #255	; 0xff
 80023fa:	d803      	bhi.n	8002404 <chThdCreateSuspendedI+0x64>
 80023fc:	9b01      	ldr	r3, [sp, #4]
 80023fe:	691b      	ldr	r3, [r3, #16]
 8002400:	2b00      	cmp	r3, #0
 8002402:	d103      	bne.n	800240c <chThdCreateSuspendedI+0x6c>
 8002404:	4b15      	ldr	r3, [pc, #84]	; (800245c <chThdCreateSuspendedI+0xbc>)
 8002406:	0018      	movs	r0, r3
 8002408:	f000 fc8a 	bl	8002d20 <chSysHalt>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
 800240c:	9b01      	ldr	r3, [sp, #4]
 800240e:	689b      	ldr	r3, [r3, #8]
 8002410:	3b48      	subs	r3, #72	; 0x48
 8002412:	9303      	str	r3, [sp, #12]
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8002414:	9b01      	ldr	r3, [sp, #4]
 8002416:	685a      	ldr	r2, [r3, #4]
 8002418:	9b03      	ldr	r3, [sp, #12]
 800241a:	61da      	str	r2, [r3, #28]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800241c:	9b03      	ldr	r3, [sp, #12]
 800241e:	3b24      	subs	r3, #36	; 0x24
 8002420:	001a      	movs	r2, r3
 8002422:	9b03      	ldr	r3, [sp, #12]
 8002424:	60da      	str	r2, [r3, #12]
 8002426:	9b03      	ldr	r3, [sp, #12]
 8002428:	68db      	ldr	r3, [r3, #12]
 800242a:	9a01      	ldr	r2, [sp, #4]
 800242c:	6912      	ldr	r2, [r2, #16]
 800242e:	611a      	str	r2, [r3, #16]
 8002430:	9b03      	ldr	r3, [sp, #12]
 8002432:	68db      	ldr	r3, [r3, #12]
 8002434:	9a01      	ldr	r2, [sp, #4]
 8002436:	6952      	ldr	r2, [r2, #20]
 8002438:	615a      	str	r2, [r3, #20]
 800243a:	9b03      	ldr	r3, [sp, #12]
 800243c:	68db      	ldr	r3, [r3, #12]
 800243e:	4a08      	ldr	r2, [pc, #32]	; (8002460 <chThdCreateSuspendedI+0xc0>)
 8002440:	621a      	str	r2, [r3, #32]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 8002442:	9b01      	ldr	r3, [sp, #4]
 8002444:	6819      	ldr	r1, [r3, #0]
 8002446:	9b01      	ldr	r3, [sp, #4]
 8002448:	68da      	ldr	r2, [r3, #12]
 800244a:	9b03      	ldr	r3, [sp, #12]
 800244c:	0018      	movs	r0, r3
 800244e:	f7ff ff4f 	bl	80022f0 <_thread_init>
 8002452:	0003      	movs	r3, r0
}
 8002454:	0018      	movs	r0, r3
 8002456:	b005      	add	sp, #20
 8002458:	bd00      	pop	{pc}
 800245a:	46c0      	nop			; (mov r8, r8)
 800245c:	08003860 	.word	0x08003860
 8002460:	080001b1 	.word	0x080001b1
	...

08002470 <chThdCreate>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
 8002470:	b500      	push	{lr}
 8002472:	b085      	sub	sp, #20
 8002474:	9001      	str	r0, [sp, #4]
  thread_t *tp;

#if CH_CFG_USE_REGISTRY == TRUE
  chDbgAssert(chRegFindThreadByWorkingArea(tdp->wbase) == NULL,
 8002476:	9b01      	ldr	r3, [sp, #4]
 8002478:	685b      	ldr	r3, [r3, #4]
 800247a:	0018      	movs	r0, r3
 800247c:	f000 fa20 	bl	80028c0 <chRegFindThreadByWorkingArea>
 8002480:	1e03      	subs	r3, r0, #0
 8002482:	d003      	beq.n	800248c <chThdCreate+0x1c>
 8002484:	4b0f      	ldr	r3, [pc, #60]	; (80024c4 <chThdCreate+0x54>)
 8002486:	0018      	movs	r0, r3
 8002488:	f000 fc4a 	bl	8002d20 <chSysHalt>
              "working area in use");
#endif

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)tdp->wbase,
 800248c:	9b01      	ldr	r3, [sp, #4]
 800248e:	6858      	ldr	r0, [r3, #4]
                  (uint8_t *)tdp->wend,
 8002490:	9b01      	ldr	r3, [sp, #4]
 8002492:	689b      	ldr	r3, [r3, #8]
  _thread_memfill((uint8_t *)tdp->wbase,
 8002494:	2255      	movs	r2, #85	; 0x55
 8002496:	0019      	movs	r1, r3
 8002498:	f7ff ff6a 	bl	8002370 <_thread_memfill>
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 800249c:	f7ff fed8 	bl	8002250 <chSysLock.lto_priv.210>
  tp = chThdCreateSuspendedI(tdp);
 80024a0:	9b01      	ldr	r3, [sp, #4]
 80024a2:	0018      	movs	r0, r3
 80024a4:	f7ff ff7c 	bl	80023a0 <chThdCreateSuspendedI>
 80024a8:	0003      	movs	r3, r0
 80024aa:	9303      	str	r3, [sp, #12]
  chSchWakeupS(tp, MSG_OK);
 80024ac:	9b03      	ldr	r3, [sp, #12]
 80024ae:	2100      	movs	r1, #0
 80024b0:	0018      	movs	r0, r3
 80024b2:	f7ff fd7d 	bl	8001fb0 <chSchWakeupS>
  chSysUnlock();
 80024b6:	f7ff fed3 	bl	8002260 <chSysUnlock.lto_priv.208>

  return tp;
 80024ba:	9b03      	ldr	r3, [sp, #12]
}
 80024bc:	0018      	movs	r0, r3
 80024be:	b005      	add	sp, #20
 80024c0:	bd00      	pop	{pc}
 80024c2:	46c0      	nop			; (mov r8, r8)
 80024c4:	08003884 	.word	0x08003884
	...

080024d0 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 80024d0:	b500      	push	{lr}
 80024d2:	b087      	sub	sp, #28
 80024d4:	9003      	str	r0, [sp, #12]
 80024d6:	9102      	str	r1, [sp, #8]
 80024d8:	9201      	str	r2, [sp, #4]
 80024da:	9300      	str	r3, [sp, #0]
  thread_t *tp;

  chDbgCheck((wsp != NULL) &&
 80024dc:	9b03      	ldr	r3, [sp, #12]
 80024de:	2b00      	cmp	r3, #0
 80024e0:	d010      	beq.n	8002504 <chThdCreateStatic+0x34>
 80024e2:	9b03      	ldr	r3, [sp, #12]
 80024e4:	2207      	movs	r2, #7
 80024e6:	4013      	ands	r3, r2
 80024e8:	d10c      	bne.n	8002504 <chThdCreateStatic+0x34>
 80024ea:	9b02      	ldr	r3, [sp, #8]
 80024ec:	2bc7      	cmp	r3, #199	; 0xc7
 80024ee:	d909      	bls.n	8002504 <chThdCreateStatic+0x34>
 80024f0:	9b02      	ldr	r3, [sp, #8]
 80024f2:	2207      	movs	r2, #7
 80024f4:	4013      	ands	r3, r2
 80024f6:	d105      	bne.n	8002504 <chThdCreateStatic+0x34>
 80024f8:	9b01      	ldr	r3, [sp, #4]
 80024fa:	2bff      	cmp	r3, #255	; 0xff
 80024fc:	d802      	bhi.n	8002504 <chThdCreateStatic+0x34>
 80024fe:	9b00      	ldr	r3, [sp, #0]
 8002500:	2b00      	cmp	r3, #0
 8002502:	d103      	bne.n	800250c <chThdCreateStatic+0x3c>
 8002504:	4b21      	ldr	r3, [pc, #132]	; (800258c <chThdCreateStatic+0xbc>)
 8002506:	0018      	movs	r0, r3
 8002508:	f000 fc0a 	bl	8002d20 <chSysHalt>
             (size >= THD_WORKING_AREA_SIZE(0)) &&
             MEM_IS_ALIGNED(size, PORT_STACK_ALIGN) &&
             (prio <= HIGHPRIO) && (pf != NULL));

#if CH_CFG_USE_REGISTRY == TRUE
  chDbgAssert(chRegFindThreadByWorkingArea(wsp) == NULL,
 800250c:	9b03      	ldr	r3, [sp, #12]
 800250e:	0018      	movs	r0, r3
 8002510:	f000 f9d6 	bl	80028c0 <chRegFindThreadByWorkingArea>
 8002514:	1e03      	subs	r3, r0, #0
 8002516:	d003      	beq.n	8002520 <chThdCreateStatic+0x50>
 8002518:	4b1c      	ldr	r3, [pc, #112]	; (800258c <chThdCreateStatic+0xbc>)
 800251a:	0018      	movs	r0, r3
 800251c:	f000 fc00 	bl	8002d20 <chSysHalt>
              "working area in use");
#endif

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
 8002520:	9a03      	ldr	r2, [sp, #12]
 8002522:	9b02      	ldr	r3, [sp, #8]
 8002524:	18d1      	adds	r1, r2, r3
 8002526:	9b03      	ldr	r3, [sp, #12]
 8002528:	2255      	movs	r2, #85	; 0x55
 800252a:	0018      	movs	r0, r3
 800252c:	f7ff ff20 	bl	8002370 <_thread_memfill>
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 8002530:	f7ff fe8e 	bl	8002250 <chSysLock.lto_priv.210>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)wsp + size -
 8002534:	9b02      	ldr	r3, [sp, #8]
 8002536:	3b48      	subs	r3, #72	; 0x48
 8002538:	9a03      	ldr	r2, [sp, #12]
 800253a:	18d3      	adds	r3, r2, r3
 800253c:	9305      	str	r3, [sp, #20]
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 800253e:	9b05      	ldr	r3, [sp, #20]
 8002540:	9a03      	ldr	r2, [sp, #12]
 8002542:	61da      	str	r2, [r3, #28]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8002544:	9b05      	ldr	r3, [sp, #20]
 8002546:	3b24      	subs	r3, #36	; 0x24
 8002548:	001a      	movs	r2, r3
 800254a:	9b05      	ldr	r3, [sp, #20]
 800254c:	60da      	str	r2, [r3, #12]
 800254e:	9b05      	ldr	r3, [sp, #20]
 8002550:	68db      	ldr	r3, [r3, #12]
 8002552:	9a00      	ldr	r2, [sp, #0]
 8002554:	611a      	str	r2, [r3, #16]
 8002556:	9b05      	ldr	r3, [sp, #20]
 8002558:	68db      	ldr	r3, [r3, #12]
 800255a:	9a08      	ldr	r2, [sp, #32]
 800255c:	615a      	str	r2, [r3, #20]
 800255e:	9b05      	ldr	r3, [sp, #20]
 8002560:	68db      	ldr	r3, [r3, #12]
 8002562:	4a0b      	ldr	r2, [pc, #44]	; (8002590 <chThdCreateStatic+0xc0>)
 8002564:	621a      	str	r2, [r3, #32]

  tp = _thread_init(tp, "noname", prio);
 8002566:	9a01      	ldr	r2, [sp, #4]
 8002568:	490a      	ldr	r1, [pc, #40]	; (8002594 <chThdCreateStatic+0xc4>)
 800256a:	9b05      	ldr	r3, [sp, #20]
 800256c:	0018      	movs	r0, r3
 800256e:	f7ff febf 	bl	80022f0 <_thread_init>
 8002572:	0003      	movs	r3, r0
 8002574:	9305      	str	r3, [sp, #20]

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8002576:	9b05      	ldr	r3, [sp, #20]
 8002578:	2100      	movs	r1, #0
 800257a:	0018      	movs	r0, r3
 800257c:	f7ff fd18 	bl	8001fb0 <chSchWakeupS>
  chSysUnlock();
 8002580:	f7ff fe6e 	bl	8002260 <chSysUnlock.lto_priv.208>

  return tp;
 8002584:	9b05      	ldr	r3, [sp, #20]
}
 8002586:	0018      	movs	r0, r3
 8002588:	b007      	add	sp, #28
 800258a:	bd00      	pop	{pc}
 800258c:	08003890 	.word	0x08003890
 8002590:	080001b1 	.word	0x080001b1
 8002594:	08003710 	.word	0x08003710
	...

080025a0 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 80025a0:	b510      	push	{r4, lr}
 80025a2:	b082      	sub	sp, #8
 80025a4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80025a6:	f7ff fe53 	bl	8002250 <chSysLock.lto_priv.210>
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 80025aa:	9b01      	ldr	r3, [sp, #4]
 80025ac:	2222      	movs	r2, #34	; 0x22
 80025ae:	5c9b      	ldrb	r3, [r3, r2]
 80025b0:	2b00      	cmp	r3, #0
 80025b2:	d103      	bne.n	80025bc <chThdRelease+0x1c>
 80025b4:	4b22      	ldr	r3, [pc, #136]	; (8002640 <chThdRelease+0xa0>)
 80025b6:	0018      	movs	r0, r3
 80025b8:	f000 fbb2 	bl	8002d20 <chSysHalt>
  tp->refs--;
 80025bc:	9b01      	ldr	r3, [sp, #4]
 80025be:	2222      	movs	r2, #34	; 0x22
 80025c0:	5c9b      	ldrb	r3, [r3, r2]
 80025c2:	3b01      	subs	r3, #1
 80025c4:	b2d9      	uxtb	r1, r3
 80025c6:	9b01      	ldr	r3, [sp, #4]
 80025c8:	2222      	movs	r2, #34	; 0x22
 80025ca:	5499      	strb	r1, [r3, r2]

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 80025cc:	9b01      	ldr	r3, [sp, #4]
 80025ce:	2222      	movs	r2, #34	; 0x22
 80025d0:	5c9b      	ldrb	r3, [r3, r2]
 80025d2:	2b00      	cmp	r3, #0
 80025d4:	d130      	bne.n	8002638 <chThdRelease+0x98>
 80025d6:	9b01      	ldr	r3, [sp, #4]
 80025d8:	2220      	movs	r2, #32
 80025da:	5c9b      	ldrb	r3, [r3, r2]
 80025dc:	2b0f      	cmp	r3, #15
 80025de:	d12b      	bne.n	8002638 <chThdRelease+0x98>
    REG_REMOVE(tp);
 80025e0:	9b01      	ldr	r3, [sp, #4]
 80025e2:	695b      	ldr	r3, [r3, #20]
 80025e4:	9a01      	ldr	r2, [sp, #4]
 80025e6:	6912      	ldr	r2, [r2, #16]
 80025e8:	611a      	str	r2, [r3, #16]
 80025ea:	9b01      	ldr	r3, [sp, #4]
 80025ec:	691b      	ldr	r3, [r3, #16]
 80025ee:	9a01      	ldr	r2, [sp, #4]
 80025f0:	6952      	ldr	r2, [r2, #20]
 80025f2:	615a      	str	r2, [r3, #20]
    chSysUnlock();
 80025f4:	f7ff fe34 	bl	8002260 <chSysUnlock.lto_priv.208>

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 80025f8:	9b01      	ldr	r3, [sp, #4]
 80025fa:	2221      	movs	r2, #33	; 0x21
 80025fc:	5c9b      	ldrb	r3, [r3, r2]
 80025fe:	001a      	movs	r2, r3
 8002600:	2303      	movs	r3, #3
 8002602:	4013      	ands	r3, r2
 8002604:	2b01      	cmp	r3, #1
 8002606:	d002      	beq.n	800260e <chThdRelease+0x6e>
 8002608:	2b02      	cmp	r3, #2
 800260a:	d009      	beq.n	8002620 <chThdRelease+0x80>
 800260c:	e016      	b.n	800263c <chThdRelease+0x9c>
#if CH_CFG_USE_HEAP == TRUE
    case CH_FLAG_MODE_HEAP:
      chHeapFree(chThdGetWorkingAreaX(tp));
 800260e:	9b01      	ldr	r3, [sp, #4]
 8002610:	0018      	movs	r0, r3
 8002612:	f7ff fe4d 	bl	80022b0 <chThdGetWorkingAreaX.lto_priv.206>
 8002616:	0003      	movs	r3, r0
 8002618:	0018      	movs	r0, r3
 800261a:	f7ff f879 	bl	8001710 <chHeapFree>
 800261e:	e00d      	b.n	800263c <chThdRelease+0x9c>
      break;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 8002620:	9b01      	ldr	r3, [sp, #4]
 8002622:	6c1c      	ldr	r4, [r3, #64]	; 0x40
 8002624:	9b01      	ldr	r3, [sp, #4]
 8002626:	0018      	movs	r0, r3
 8002628:	f7ff fe42 	bl	80022b0 <chThdGetWorkingAreaX.lto_priv.206>
 800262c:	0003      	movs	r3, r0
 800262e:	0019      	movs	r1, r3
 8002630:	0020      	movs	r0, r4
 8002632:	f7ff f955 	bl	80018e0 <chPoolFree>
 8002636:	e001      	b.n	800263c <chThdRelease+0x9c>
      break;
    }
#endif /* CH_CFG_USE_DYNAMIC == TRUE */
    return;
  }
  chSysUnlock();
 8002638:	f7ff fe12 	bl	8002260 <chSysUnlock.lto_priv.208>
}
 800263c:	b002      	add	sp, #8
 800263e:	bd10      	pop	{r4, pc}
 8002640:	080038a4 	.word	0x080038a4
	...

08002650 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8002650:	b500      	push	{lr}
 8002652:	b083      	sub	sp, #12
 8002654:	9001      	str	r0, [sp, #4]

  chSysLock();
 8002656:	f7ff fdfb 	bl	8002250 <chSysLock.lto_priv.210>
  chThdExitS(msg);
 800265a:	9b01      	ldr	r3, [sp, #4]
 800265c:	0018      	movs	r0, r3
 800265e:	f000 f807 	bl	8002670 <chThdExitS>
  /* The thread never returns here.*/
}
 8002662:	b003      	add	sp, #12
 8002664:	bd00      	pop	{pc}
 8002666:	46c0      	nop			; (mov r8, r8)
	...

08002670 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8002670:	b500      	push	{lr}
 8002672:	b085      	sub	sp, #20
 8002674:	9001      	str	r0, [sp, #4]
  thread_t *tp = currp;
 8002676:	4b1b      	ldr	r3, [pc, #108]	; (80026e4 <chThdExitS+0x74>)
 8002678:	699b      	ldr	r3, [r3, #24]
 800267a:	9303      	str	r3, [sp, #12]

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 800267c:	9b03      	ldr	r3, [sp, #12]
 800267e:	9a01      	ldr	r2, [sp, #4]
 8002680:	625a      	str	r2, [r3, #36]	; 0x24
 8002682:	e008      	b.n	8002696 <chThdExitS+0x26>
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
    (void) chSchReadyI(list_remove(&tp->waiting));
 8002684:	9b03      	ldr	r3, [sp, #12]
 8002686:	3328      	adds	r3, #40	; 0x28
 8002688:	0018      	movs	r0, r3
 800268a:	f7ff fdd1 	bl	8002230 <list_remove>
 800268e:	0003      	movs	r3, r0
 8002690:	0018      	movs	r0, r3
 8002692:	f000 ffcd 	bl	8003630 <chSchReadyI>
  while (list_notempty(&tp->waiting)) {
 8002696:	9b03      	ldr	r3, [sp, #12]
 8002698:	3328      	adds	r3, #40	; 0x28
 800269a:	0018      	movs	r0, r3
 800269c:	f7ff fda8 	bl	80021f0 <list_notempty>
 80026a0:	1e03      	subs	r3, r0, #0
 80026a2:	d1ef      	bne.n	8002684 <chThdExitS+0x14>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 80026a4:	9b03      	ldr	r3, [sp, #12]
 80026a6:	2222      	movs	r2, #34	; 0x22
 80026a8:	5c9b      	ldrb	r3, [r3, r2]
 80026aa:	2b00      	cmp	r3, #0
 80026ac:	d110      	bne.n	80026d0 <chThdExitS+0x60>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
 80026ae:	9b03      	ldr	r3, [sp, #12]
 80026b0:	2221      	movs	r2, #33	; 0x21
 80026b2:	5c9b      	ldrb	r3, [r3, r2]
 80026b4:	001a      	movs	r2, r3
 80026b6:	2303      	movs	r3, #3
 80026b8:	4013      	ands	r3, r2
  if ((tp->refs == (trefs_t)0) &&
 80026ba:	d109      	bne.n	80026d0 <chThdExitS+0x60>
    REG_REMOVE(tp);
 80026bc:	9b03      	ldr	r3, [sp, #12]
 80026be:	695b      	ldr	r3, [r3, #20]
 80026c0:	9a03      	ldr	r2, [sp, #12]
 80026c2:	6912      	ldr	r2, [r2, #16]
 80026c4:	611a      	str	r2, [r3, #16]
 80026c6:	9b03      	ldr	r3, [sp, #12]
 80026c8:	691b      	ldr	r3, [r3, #16]
 80026ca:	9a03      	ldr	r2, [sp, #12]
 80026cc:	6952      	ldr	r2, [r2, #20]
 80026ce:	615a      	str	r2, [r3, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 80026d0:	200f      	movs	r0, #15
 80026d2:	f7ff fbbd 	bl	8001e50 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 80026d6:	4b04      	ldr	r3, [pc, #16]	; (80026e8 <chThdExitS+0x78>)
 80026d8:	0018      	movs	r0, r3
 80026da:	f000 fb21 	bl	8002d20 <chSysHalt>
}
 80026de:	b005      	add	sp, #20
 80026e0:	bd00      	pop	{pc}
 80026e2:	46c0      	nop			; (mov r8, r8)
 80026e4:	200004d8 	.word	0x200004d8
 80026e8:	080038b4 	.word	0x080038b4
 80026ec:	00000000 	.word	0x00000000

080026f0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 80026f0:	b500      	push	{lr}
 80026f2:	b083      	sub	sp, #12
 80026f4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80026f6:	f7ff fdab 	bl	8002250 <chSysLock.lto_priv.210>
  chThdSleepS(time);
 80026fa:	9b01      	ldr	r3, [sp, #4]
 80026fc:	0018      	movs	r0, r3
 80026fe:	f7ff fddf 	bl	80022c0 <chThdSleepS>
  chSysUnlock();
 8002702:	f7ff fdad 	bl	8002260 <chSysUnlock.lto_priv.208>
}
 8002706:	b003      	add	sp, #12
 8002708:	bd00      	pop	{pc}
 800270a:	46c0      	nop			; (mov r8, r8)
 800270c:	0000      	movs	r0, r0
	...

08002710 <chThdSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
msg_t chThdSuspendS(thread_reference_t *trp) {
 8002710:	b500      	push	{lr}
 8002712:	b085      	sub	sp, #20
 8002714:	9001      	str	r0, [sp, #4]
  thread_t *tp = chThdGetSelfX();
 8002716:	f7ff fdc3 	bl	80022a0 <chThdGetSelfX>
 800271a:	0003      	movs	r3, r0
 800271c:	9303      	str	r3, [sp, #12]

  chDbgAssert(*trp == NULL, "not NULL");
 800271e:	9b01      	ldr	r3, [sp, #4]
 8002720:	681b      	ldr	r3, [r3, #0]
 8002722:	2b00      	cmp	r3, #0
 8002724:	d003      	beq.n	800272e <chThdSuspendS+0x1e>
 8002726:	4b0a      	ldr	r3, [pc, #40]	; (8002750 <chThdSuspendS+0x40>)
 8002728:	0018      	movs	r0, r3
 800272a:	f000 faf9 	bl	8002d20 <chSysHalt>

  *trp = tp;
 800272e:	9b01      	ldr	r3, [sp, #4]
 8002730:	9a03      	ldr	r2, [sp, #12]
 8002732:	601a      	str	r2, [r3, #0]
  tp->u.wttrp = trp;
 8002734:	9b03      	ldr	r3, [sp, #12]
 8002736:	9a01      	ldr	r2, [sp, #4]
 8002738:	625a      	str	r2, [r3, #36]	; 0x24
  chSchGoSleepS(CH_STATE_SUSPENDED);
 800273a:	2003      	movs	r0, #3
 800273c:	f7ff fb88 	bl	8001e50 <chSchGoSleepS>

  return chThdGetSelfX()->u.rdymsg;
 8002740:	f7ff fdae 	bl	80022a0 <chThdGetSelfX>
 8002744:	0003      	movs	r3, r0
 8002746:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8002748:	0018      	movs	r0, r3
 800274a:	b005      	add	sp, #20
 800274c:	bd00      	pop	{pc}
 800274e:	46c0      	nop			; (mov r8, r8)
 8002750:	080038cc 	.word	0x080038cc
	...

08002760 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 8002760:	b500      	push	{lr}
 8002762:	b085      	sub	sp, #20
 8002764:	9001      	str	r0, [sp, #4]
 8002766:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 8002768:	9b01      	ldr	r3, [sp, #4]
 800276a:	681b      	ldr	r3, [r3, #0]
 800276c:	2b00      	cmp	r3, #0
 800276e:	d015      	beq.n	800279c <chThdResumeI+0x3c>
    thread_t *tp = *trp;
 8002770:	9b01      	ldr	r3, [sp, #4]
 8002772:	681b      	ldr	r3, [r3, #0]
 8002774:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8002776:	9b03      	ldr	r3, [sp, #12]
 8002778:	2220      	movs	r2, #32
 800277a:	5c9b      	ldrb	r3, [r3, r2]
 800277c:	2b03      	cmp	r3, #3
 800277e:	d003      	beq.n	8002788 <chThdResumeI+0x28>
 8002780:	4b07      	ldr	r3, [pc, #28]	; (80027a0 <chThdResumeI+0x40>)
 8002782:	0018      	movs	r0, r3
 8002784:	f000 facc 	bl	8002d20 <chSysHalt>

    *trp = NULL;
 8002788:	9b01      	ldr	r3, [sp, #4]
 800278a:	2200      	movs	r2, #0
 800278c:	601a      	str	r2, [r3, #0]
    tp->u.rdymsg = msg;
 800278e:	9b03      	ldr	r3, [sp, #12]
 8002790:	9a00      	ldr	r2, [sp, #0]
 8002792:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 8002794:	9b03      	ldr	r3, [sp, #12]
 8002796:	0018      	movs	r0, r3
 8002798:	f000 ff4a 	bl	8003630 <chSchReadyI>
  }
}
 800279c:	b005      	add	sp, #20
 800279e:	bd00      	pop	{pc}
 80027a0:	080038dc 	.word	0x080038dc
	...

080027b0 <port_lock.lto_priv.203>:
  __ASM volatile ("cpsid i" : : : "memory");
 80027b0:	b672      	cpsid	i
}
 80027b2:	4770      	bx	lr
	...

080027c0 <port_unlock.lto_priv.200>:
  __ASM volatile ("cpsie i" : : : "memory");
 80027c0:	b662      	cpsie	i
}
 80027c2:	4770      	bx	lr
	...

080027d0 <chSysLock.lto_priv.211>:
static inline void chSysLock(void) {
 80027d0:	b510      	push	{r4, lr}
  port_lock();
 80027d2:	f7ff ffed 	bl	80027b0 <port_lock.lto_priv.203>
  _dbg_check_lock();
 80027d6:	f000 faf3 	bl	8002dc0 <_dbg_check_lock>
}
 80027da:	bd10      	pop	{r4, pc}
 80027dc:	0000      	movs	r0, r0
	...

080027e0 <chSysUnlock.lto_priv.209>:
static inline void chSysUnlock(void) {
 80027e0:	b510      	push	{r4, lr}
  _dbg_check_unlock();
 80027e2:	f000 fb05 	bl	8002df0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80027e6:	4b0a      	ldr	r3, [pc, #40]	; (8002810 <chSysUnlock.lto_priv.209+0x30>)
 80027e8:	681a      	ldr	r2, [r3, #0]
 80027ea:	4b09      	ldr	r3, [pc, #36]	; (8002810 <chSysUnlock.lto_priv.209+0x30>)
 80027ec:	429a      	cmp	r2, r3
 80027ee:	d00b      	beq.n	8002808 <chSysUnlock.lto_priv.209+0x28>
 80027f0:	4b07      	ldr	r3, [pc, #28]	; (8002810 <chSysUnlock.lto_priv.209+0x30>)
 80027f2:	699b      	ldr	r3, [r3, #24]
 80027f4:	689a      	ldr	r2, [r3, #8]
 80027f6:	4b06      	ldr	r3, [pc, #24]	; (8002810 <chSysUnlock.lto_priv.209+0x30>)
 80027f8:	681b      	ldr	r3, [r3, #0]
 80027fa:	689b      	ldr	r3, [r3, #8]
 80027fc:	429a      	cmp	r2, r3
 80027fe:	d203      	bcs.n	8002808 <chSysUnlock.lto_priv.209+0x28>
 8002800:	4b04      	ldr	r3, [pc, #16]	; (8002814 <chSysUnlock.lto_priv.209+0x34>)
 8002802:	0018      	movs	r0, r3
 8002804:	f000 fa8c 	bl	8002d20 <chSysHalt>
  port_unlock();
 8002808:	f7ff ffda 	bl	80027c0 <port_unlock.lto_priv.200>
}
 800280c:	bd10      	pop	{r4, pc}
 800280e:	46c0      	nop			; (mov r8, r8)
 8002810:	200004d8 	.word	0x200004d8
 8002814:	08003904 	.word	0x08003904
	...

08002820 <chThdGetWorkingAreaX.lto_priv.207>:
static inline stkalign_t *chThdGetWorkingAreaX(thread_t *tp) {
 8002820:	b082      	sub	sp, #8
 8002822:	9001      	str	r0, [sp, #4]
  return tp->wabase;
 8002824:	9b01      	ldr	r3, [sp, #4]
 8002826:	69db      	ldr	r3, [r3, #28]
}
 8002828:	0018      	movs	r0, r3
 800282a:	b002      	add	sp, #8
 800282c:	4770      	bx	lr
 800282e:	46c0      	nop			; (mov r8, r8)

08002830 <chRegFirstThread>:
 *
 * @return              A reference to the most ancient thread.
 *
 * @api
 */
thread_t *chRegFirstThread(void) {
 8002830:	b500      	push	{lr}
 8002832:	b083      	sub	sp, #12
  thread_t *tp;

  chSysLock();
 8002834:	f7ff ffcc 	bl	80027d0 <chSysLock.lto_priv.211>
  tp = ch.rlist.newer;
 8002838:	4b08      	ldr	r3, [pc, #32]	; (800285c <chRegFirstThread+0x2c>)
 800283a:	691b      	ldr	r3, [r3, #16]
 800283c:	9301      	str	r3, [sp, #4]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 800283e:	9b01      	ldr	r3, [sp, #4]
 8002840:	2222      	movs	r2, #34	; 0x22
 8002842:	5c9b      	ldrb	r3, [r3, r2]
 8002844:	3301      	adds	r3, #1
 8002846:	b2d9      	uxtb	r1, r3
 8002848:	9b01      	ldr	r3, [sp, #4]
 800284a:	2222      	movs	r2, #34	; 0x22
 800284c:	5499      	strb	r1, [r3, r2]
#endif
  chSysUnlock();
 800284e:	f7ff ffc7 	bl	80027e0 <chSysUnlock.lto_priv.209>

  return tp;
 8002852:	9b01      	ldr	r3, [sp, #4]
}
 8002854:	0018      	movs	r0, r3
 8002856:	b003      	add	sp, #12
 8002858:	bd00      	pop	{pc}
 800285a:	46c0      	nop			; (mov r8, r8)
 800285c:	200004d8 	.word	0x200004d8

08002860 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
 8002860:	b500      	push	{lr}
 8002862:	b085      	sub	sp, #20
 8002864:	9001      	str	r0, [sp, #4]
  thread_t *ntp;

  chSysLock();
 8002866:	f7ff ffb3 	bl	80027d0 <chSysLock.lto_priv.211>
  ntp = tp->newer;
 800286a:	9b01      	ldr	r3, [sp, #4]
 800286c:	691b      	ldr	r3, [r3, #16]
 800286e:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 8002870:	9a03      	ldr	r2, [sp, #12]
 8002872:	4b10      	ldr	r3, [pc, #64]	; (80028b4 <chRegNextThread+0x54>)
 8002874:	429a      	cmp	r2, r3
 8002876:	d102      	bne.n	800287e <chRegNextThread+0x1e>
  /*lint -restore*/
    ntp = NULL;
 8002878:	2300      	movs	r3, #0
 800287a:	9303      	str	r3, [sp, #12]
 800287c:	e010      	b.n	80028a0 <chRegNextThread+0x40>
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 800287e:	9b03      	ldr	r3, [sp, #12]
 8002880:	2222      	movs	r2, #34	; 0x22
 8002882:	5c9b      	ldrb	r3, [r3, r2]
 8002884:	2bff      	cmp	r3, #255	; 0xff
 8002886:	d103      	bne.n	8002890 <chRegNextThread+0x30>
 8002888:	4b0b      	ldr	r3, [pc, #44]	; (80028b8 <chRegNextThread+0x58>)
 800288a:	0018      	movs	r0, r3
 800288c:	f000 fa48 	bl	8002d20 <chSysHalt>
    ntp->refs++;
 8002890:	9b03      	ldr	r3, [sp, #12]
 8002892:	2222      	movs	r2, #34	; 0x22
 8002894:	5c9b      	ldrb	r3, [r3, r2]
 8002896:	3301      	adds	r3, #1
 8002898:	b2d9      	uxtb	r1, r3
 800289a:	9b03      	ldr	r3, [sp, #12]
 800289c:	2222      	movs	r2, #34	; 0x22
 800289e:	5499      	strb	r1, [r3, r2]
  }
#endif
  chSysUnlock();
 80028a0:	f7ff ff9e 	bl	80027e0 <chSysUnlock.lto_priv.209>
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 80028a4:	9b01      	ldr	r3, [sp, #4]
 80028a6:	0018      	movs	r0, r3
 80028a8:	f7ff fe7a 	bl	80025a0 <chThdRelease>
#endif

  return ntp;
 80028ac:	9b03      	ldr	r3, [sp, #12]
}
 80028ae:	0018      	movs	r0, r3
 80028b0:	b005      	add	sp, #20
 80028b2:	bd00      	pop	{pc}
 80028b4:	200004d8 	.word	0x200004d8
 80028b8:	08003910 	.word	0x08003910
 80028bc:	00000000 	.word	0x00000000

080028c0 <chRegFindThreadByWorkingArea>:
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByWorkingArea(stkalign_t *wa) {
 80028c0:	b500      	push	{lr}
 80028c2:	b085      	sub	sp, #20
 80028c4:	9001      	str	r0, [sp, #4]
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
 80028c6:	f7ff ffb3 	bl	8002830 <chRegFirstThread>
 80028ca:	0003      	movs	r3, r0
 80028cc:	9303      	str	r3, [sp, #12]
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 80028ce:	9b03      	ldr	r3, [sp, #12]
 80028d0:	0018      	movs	r0, r3
 80028d2:	f7ff ffa5 	bl	8002820 <chThdGetWorkingAreaX.lto_priv.207>
 80028d6:	0002      	movs	r2, r0
 80028d8:	9b01      	ldr	r3, [sp, #4]
 80028da:	429a      	cmp	r2, r3
 80028dc:	d101      	bne.n	80028e2 <chRegFindThreadByWorkingArea+0x22>
      return ctp;
 80028de:	9b03      	ldr	r3, [sp, #12]
 80028e0:	e009      	b.n	80028f6 <chRegFindThreadByWorkingArea+0x36>
    }
    ctp = chRegNextThread(ctp);
 80028e2:	9b03      	ldr	r3, [sp, #12]
 80028e4:	0018      	movs	r0, r3
 80028e6:	f7ff ffbb 	bl	8002860 <chRegNextThread>
 80028ea:	0003      	movs	r3, r0
 80028ec:	9303      	str	r3, [sp, #12]
  } while (ctp != NULL);
 80028ee:	9b03      	ldr	r3, [sp, #12]
 80028f0:	2b00      	cmp	r3, #0
 80028f2:	d1ec      	bne.n	80028ce <chRegFindThreadByWorkingArea+0xe>

  return NULL;
 80028f4:	2300      	movs	r3, #0
}
 80028f6:	0018      	movs	r0, r3
 80028f8:	b005      	add	sp, #20
 80028fa:	bd00      	pop	{pc}
 80028fc:	0000      	movs	r0, r0
	...

08002900 <__core_init>:

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8002900:	4770      	bx	lr
 8002902:	46c0      	nop			; (mov r8, r8)
	...

08002910 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8002910:	4770      	bx	lr
 8002912:	46c0      	nop			; (mov r8, r8)
	...

08002920 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8002920:	e7fe      	b.n	8002920 <__default_exit>
 8002922:	46c0      	nop			; (mov r8, r8)
	...

08002930 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8002930:	b084      	sub	sp, #16
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8002932:	4b16      	ldr	r3, [pc, #88]	; (800298c <__init_ram_areas+0x5c>)
 8002934:	9303      	str	r3, [sp, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 8002936:	9b03      	ldr	r3, [sp, #12]
 8002938:	681b      	ldr	r3, [r3, #0]
 800293a:	9302      	str	r3, [sp, #8]
    uint32_t *p = rap->init_area;
 800293c:	9b03      	ldr	r3, [sp, #12]
 800293e:	685b      	ldr	r3, [r3, #4]
 8002940:	9301      	str	r3, [sp, #4]
 8002942:	e009      	b.n	8002958 <__init_ram_areas+0x28>

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
      *p = *tp;
 8002944:	9b02      	ldr	r3, [sp, #8]
 8002946:	681a      	ldr	r2, [r3, #0]
 8002948:	9b01      	ldr	r3, [sp, #4]
 800294a:	601a      	str	r2, [r3, #0]
      p++;
 800294c:	9b01      	ldr	r3, [sp, #4]
 800294e:	3304      	adds	r3, #4
 8002950:	9301      	str	r3, [sp, #4]
      tp++;
 8002952:	9b02      	ldr	r3, [sp, #8]
 8002954:	3304      	adds	r3, #4
 8002956:	9302      	str	r3, [sp, #8]
    while (p < rap->clear_area) {
 8002958:	9b03      	ldr	r3, [sp, #12]
 800295a:	689a      	ldr	r2, [r3, #8]
 800295c:	9b01      	ldr	r3, [sp, #4]
 800295e:	429a      	cmp	r2, r3
 8002960:	d8f0      	bhi.n	8002944 <__init_ram_areas+0x14>
 8002962:	e005      	b.n	8002970 <__init_ram_areas+0x40>
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8002964:	9b01      	ldr	r3, [sp, #4]
 8002966:	2200      	movs	r2, #0
 8002968:	601a      	str	r2, [r3, #0]
      p++;
 800296a:	9b01      	ldr	r3, [sp, #4]
 800296c:	3304      	adds	r3, #4
 800296e:	9301      	str	r3, [sp, #4]
    while (p < rap->no_init_area) {
 8002970:	9b03      	ldr	r3, [sp, #12]
 8002972:	68da      	ldr	r2, [r3, #12]
 8002974:	9b01      	ldr	r3, [sp, #4]
 8002976:	429a      	cmp	r2, r3
 8002978:	d8f4      	bhi.n	8002964 <__init_ram_areas+0x34>
    }
    rap++;
 800297a:	9b03      	ldr	r3, [sp, #12]
 800297c:	3310      	adds	r3, #16
 800297e:	9303      	str	r3, [sp, #12]
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8002980:	9a03      	ldr	r2, [sp, #12]
 8002982:	4b03      	ldr	r3, [pc, #12]	; (8002990 <__init_ram_areas+0x60>)
 8002984:	429a      	cmp	r2, r3
 8002986:	d3d6      	bcc.n	8002936 <__init_ram_areas+0x6>
#endif
}
 8002988:	b004      	add	sp, #16
 800298a:	4770      	bx	lr
 800298c:	08003770 	.word	0x08003770
 8002990:	080037f0 	.word	0x080037f0
	...

080029a0 <BusFault_Handler>:
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
__attribute__((weak))
void _unhandled_exception(void) {
 80029a0:	e7fe      	b.n	80029a0 <BusFault_Handler>
 80029a2:	46c0      	nop			; (mov r8, r8)
	...

080029b0 <NVIC_SetPriority>:
  \note    The priority cannot be set for every core interrupt.
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 80029b0:	b530      	push	{r4, r5, lr}
 80029b2:	b083      	sub	sp, #12
 80029b4:	0002      	movs	r2, r0
 80029b6:	9100      	str	r1, [sp, #0]
 80029b8:	466b      	mov	r3, sp
 80029ba:	3307      	adds	r3, #7
 80029bc:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) < 0)
 80029be:	466b      	mov	r3, sp
 80029c0:	3307      	adds	r3, #7
 80029c2:	781b      	ldrb	r3, [r3, #0]
 80029c4:	2b7f      	cmp	r3, #127	; 0x7f
 80029c6:	d936      	bls.n	8002a36 <NVIC_SetPriority+0x86>
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80029c8:	4c32      	ldr	r4, [pc, #200]	; (8002a94 <NVIC_SetPriority+0xe4>)
 80029ca:	466b      	mov	r3, sp
 80029cc:	3307      	adds	r3, #7
 80029ce:	781b      	ldrb	r3, [r3, #0]
 80029d0:	001a      	movs	r2, r3
 80029d2:	230f      	movs	r3, #15
 80029d4:	4013      	ands	r3, r2
 80029d6:	3b08      	subs	r3, #8
 80029d8:	0899      	lsrs	r1, r3, #2
 80029da:	4a2e      	ldr	r2, [pc, #184]	; (8002a94 <NVIC_SetPriority+0xe4>)
 80029dc:	466b      	mov	r3, sp
 80029de:	3307      	adds	r3, #7
 80029e0:	781b      	ldrb	r3, [r3, #0]
 80029e2:	0018      	movs	r0, r3
 80029e4:	230f      	movs	r3, #15
 80029e6:	4003      	ands	r3, r0
 80029e8:	3b08      	subs	r3, #8
 80029ea:	089b      	lsrs	r3, r3, #2
 80029ec:	3306      	adds	r3, #6
 80029ee:	009b      	lsls	r3, r3, #2
 80029f0:	18d3      	adds	r3, r2, r3
 80029f2:	3304      	adds	r3, #4
 80029f4:	681b      	ldr	r3, [r3, #0]
 80029f6:	466a      	mov	r2, sp
 80029f8:	3207      	adds	r2, #7
 80029fa:	7812      	ldrb	r2, [r2, #0]
 80029fc:	0010      	movs	r0, r2
 80029fe:	2203      	movs	r2, #3
 8002a00:	4002      	ands	r2, r0
 8002a02:	00d2      	lsls	r2, r2, #3
 8002a04:	20ff      	movs	r0, #255	; 0xff
 8002a06:	4090      	lsls	r0, r2
 8002a08:	0002      	movs	r2, r0
 8002a0a:	43d2      	mvns	r2, r2
 8002a0c:	401a      	ands	r2, r3
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 8002a0e:	9b00      	ldr	r3, [sp, #0]
 8002a10:	019b      	lsls	r3, r3, #6
 8002a12:	20ff      	movs	r0, #255	; 0xff
 8002a14:	4018      	ands	r0, r3
 8002a16:	466b      	mov	r3, sp
 8002a18:	3307      	adds	r3, #7
 8002a1a:	781b      	ldrb	r3, [r3, #0]
 8002a1c:	001d      	movs	r5, r3
 8002a1e:	2303      	movs	r3, #3
 8002a20:	402b      	ands	r3, r5
 8002a22:	00db      	lsls	r3, r3, #3
 8002a24:	4098      	lsls	r0, r3
 8002a26:	0003      	movs	r3, r0
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8002a28:	431a      	orrs	r2, r3
 8002a2a:	1d8b      	adds	r3, r1, #6
 8002a2c:	009b      	lsls	r3, r3, #2
 8002a2e:	18e3      	adds	r3, r4, r3
 8002a30:	3304      	adds	r3, #4
 8002a32:	601a      	str	r2, [r3, #0]
 8002a34:	e02b      	b.n	8002a8e <NVIC_SetPriority+0xde>
  }
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8002a36:	4c18      	ldr	r4, [pc, #96]	; (8002a98 <NVIC_SetPriority+0xe8>)
 8002a38:	466b      	mov	r3, sp
 8002a3a:	3307      	adds	r3, #7
 8002a3c:	781b      	ldrb	r3, [r3, #0]
 8002a3e:	b25b      	sxtb	r3, r3
 8002a40:	089b      	lsrs	r3, r3, #2
 8002a42:	4915      	ldr	r1, [pc, #84]	; (8002a98 <NVIC_SetPriority+0xe8>)
 8002a44:	466a      	mov	r2, sp
 8002a46:	3207      	adds	r2, #7
 8002a48:	7812      	ldrb	r2, [r2, #0]
 8002a4a:	b252      	sxtb	r2, r2
 8002a4c:	0892      	lsrs	r2, r2, #2
 8002a4e:	32c0      	adds	r2, #192	; 0xc0
 8002a50:	0092      	lsls	r2, r2, #2
 8002a52:	5852      	ldr	r2, [r2, r1]
 8002a54:	4669      	mov	r1, sp
 8002a56:	3107      	adds	r1, #7
 8002a58:	7809      	ldrb	r1, [r1, #0]
 8002a5a:	0008      	movs	r0, r1
 8002a5c:	2103      	movs	r1, #3
 8002a5e:	4001      	ands	r1, r0
 8002a60:	00c9      	lsls	r1, r1, #3
 8002a62:	20ff      	movs	r0, #255	; 0xff
 8002a64:	4088      	lsls	r0, r1
 8002a66:	0001      	movs	r1, r0
 8002a68:	43c9      	mvns	r1, r1
 8002a6a:	4011      	ands	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 8002a6c:	9a00      	ldr	r2, [sp, #0]
 8002a6e:	0192      	lsls	r2, r2, #6
 8002a70:	20ff      	movs	r0, #255	; 0xff
 8002a72:	4010      	ands	r0, r2
 8002a74:	466a      	mov	r2, sp
 8002a76:	3207      	adds	r2, #7
 8002a78:	7812      	ldrb	r2, [r2, #0]
 8002a7a:	0015      	movs	r5, r2
 8002a7c:	2203      	movs	r2, #3
 8002a7e:	402a      	ands	r2, r5
 8002a80:	00d2      	lsls	r2, r2, #3
 8002a82:	4090      	lsls	r0, r2
 8002a84:	0002      	movs	r2, r0
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8002a86:	430a      	orrs	r2, r1
 8002a88:	33c0      	adds	r3, #192	; 0xc0
 8002a8a:	009b      	lsls	r3, r3, #2
 8002a8c:	511a      	str	r2, [r3, r4]
  }
}
 8002a8e:	b003      	add	sp, #12
 8002a90:	bd30      	pop	{r4, r5, pc}
 8002a92:	46c0      	nop			; (mov r8, r8)
 8002a94:	e000ed00 	.word	0xe000ed00
 8002a98:	e000e100 	.word	0xe000e100
 8002a9c:	00000000 	.word	0x00000000

08002aa0 <port_init>:
static inline void port_init(void) {
 8002aa0:	b510      	push	{r4, lr}
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 8002aa2:	2302      	movs	r3, #2
 8002aa4:	425b      	negs	r3, r3
 8002aa6:	2100      	movs	r1, #0
 8002aa8:	0018      	movs	r0, r3
 8002aaa:	f7ff ff81 	bl	80029b0 <NVIC_SetPriority>
}
 8002aae:	bd10      	pop	{r4, pc}

08002ab0 <port_lock.lto_priv.249>:
  __ASM volatile ("cpsid i" : : : "memory");
 8002ab0:	b672      	cpsid	i
}
 8002ab2:	4770      	bx	lr
	...

08002ac0 <port_unlock.lto_priv.245>:
  __ASM volatile ("cpsie i" : : : "memory");
 8002ac0:	b662      	cpsie	i
}
 8002ac2:	4770      	bx	lr
	...

08002ad0 <port_lock_from_isr.lto_priv.241>:
static inline void port_lock_from_isr(void) {
 8002ad0:	b510      	push	{r4, lr}
  port_lock();
 8002ad2:	f7ff ffed 	bl	8002ab0 <port_lock.lto_priv.249>
}
 8002ad6:	bd10      	pop	{r4, pc}
	...

08002ae0 <port_unlock_from_isr.lto_priv.237>:
static inline void port_unlock_from_isr(void) {
 8002ae0:	b510      	push	{r4, lr}
  port_unlock();
 8002ae2:	f7ff ffed 	bl	8002ac0 <port_unlock.lto_priv.245>
}
 8002ae6:	bd10      	pop	{r4, pc}
	...

08002af0 <port_disable>:
  __ASM volatile ("cpsid i" : : : "memory");
 8002af0:	b672      	cpsid	i
 * @brief   Disables all the interrupt sources.
 */
static inline void port_disable(void) {

  __disable_irq();
}
 8002af2:	4770      	bx	lr
	...

08002b00 <port_enable>:
  __ASM volatile ("cpsie i" : : : "memory");
 8002b00:	b662      	cpsie	i
 * @brief   Enables all the interrupt sources.
 */
static inline void port_enable(void) {

  __enable_irq();
}
 8002b02:	4770      	bx	lr
	...

08002b10 <port_wait_for_interrupt>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 8002b10:	4770      	bx	lr
 8002b12:	46c0      	nop			; (mov r8, r8)
	...

08002b20 <st_lld_get_counter.lto_priv.263>:
  return (systime_t)STM32_ST_TIM->CNT;
 8002b20:	2380      	movs	r3, #128	; 0x80
 8002b22:	05db      	lsls	r3, r3, #23
 8002b24:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8002b26:	0018      	movs	r0, r3
 8002b28:	4770      	bx	lr
 8002b2a:	46c0      	nop			; (mov r8, r8)
 8002b2c:	0000      	movs	r0, r0
	...

08002b30 <port_timer_stop_alarm.lto_priv.261>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 8002b30:	b510      	push	{r4, lr}

  stStopAlarm();
 8002b32:	f7fd ff6d 	bl	8000a10 <stStopAlarm>
}
 8002b36:	bd10      	pop	{r4, pc}
	...

08002b40 <port_timer_set_alarm.lto_priv.259>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 8002b40:	b500      	push	{lr}
 8002b42:	b083      	sub	sp, #12
 8002b44:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
 8002b46:	9b01      	ldr	r3, [sp, #4]
 8002b48:	0018      	movs	r0, r3
 8002b4a:	f7fd ff69 	bl	8000a20 <stSetAlarm>
}
 8002b4e:	b003      	add	sp, #12
 8002b50:	bd00      	pop	{pc}
 8002b52:	46c0      	nop			; (mov r8, r8)
	...

08002b60 <port_timer_get_time.lto_priv.256>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8002b60:	b510      	push	{r4, lr}

  return stGetCounter();
 8002b62:	f7ff ffdd 	bl	8002b20 <st_lld_get_counter.lto_priv.263>
 8002b66:	0003      	movs	r3, r0
}
 8002b68:	0018      	movs	r0, r3
 8002b6a:	bd10      	pop	{r4, pc}
 8002b6c:	0000      	movs	r0, r0
	...

08002b70 <chSysEnable>:
static inline void chSysEnable(void) {
 8002b70:	b510      	push	{r4, lr}
  _dbg_check_enable();
 8002b72:	f000 f90d 	bl	8002d90 <_dbg_check_enable>
  port_enable();
 8002b76:	f7ff ffc3 	bl	8002b00 <port_enable>
}
 8002b7a:	bd10      	pop	{r4, pc}
 8002b7c:	0000      	movs	r0, r0
	...

08002b80 <chSysLockFromISR>:
static inline void chSysLockFromISR(void) {
 8002b80:	b510      	push	{r4, lr}
  port_lock_from_isr();
 8002b82:	f7ff ffa5 	bl	8002ad0 <port_lock_from_isr.lto_priv.241>
  _dbg_check_lock_from_isr();
 8002b86:	f000 f94b 	bl	8002e20 <_dbg_check_lock_from_isr>
}
 8002b8a:	bd10      	pop	{r4, pc}
 8002b8c:	0000      	movs	r0, r0
	...

08002b90 <chSysUnlockFromISR>:
static inline void chSysUnlockFromISR(void) {
 8002b90:	b510      	push	{r4, lr}
  _dbg_check_unlock_from_isr();
 8002b92:	f000 f95d 	bl	8002e50 <_dbg_check_unlock_from_isr>
  port_unlock_from_isr();
 8002b96:	f7ff ffa3 	bl	8002ae0 <port_unlock_from_isr.lto_priv.237>
}
 8002b9a:	bd10      	pop	{r4, pc}
 8002b9c:	0000      	movs	r0, r0
	...

08002ba0 <chVTGetSystemTimeX.lto_priv.253>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8002ba0:	b510      	push	{r4, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8002ba2:	f7ff ffdd 	bl	8002b60 <port_timer_get_time.lto_priv.256>
 8002ba6:	0003      	movs	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8002ba8:	0018      	movs	r0, r3
 8002baa:	bd10      	pop	{r4, pc}
 8002bac:	0000      	movs	r0, r0
	...

08002bb0 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
 8002bb0:	b500      	push	{lr}
 8002bb2:	b085      	sub	sp, #20

  chDbgCheckClassI();
 8002bb4:	f000 f9a4 	bl	8002f00 <chDbgCheckClassI>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.next;
 8002bb8:	4b33      	ldr	r3, [pc, #204]	; (8002c88 <chVTDoTickI+0xd8>)
 8002bba:	69db      	ldr	r3, [r3, #28]
 8002bbc:	9303      	str	r3, [sp, #12]
  now = chVTGetSystemTimeX();
 8002bbe:	f7ff ffef 	bl	8002ba0 <chVTGetSystemTimeX.lto_priv.253>
 8002bc2:	0003      	movs	r3, r0
 8002bc4:	9302      	str	r3, [sp, #8]
 8002bc6:	e02b      	b.n	8002c20 <chVTDoTickI+0x70>
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;
 8002bc8:	4b2f      	ldr	r3, [pc, #188]	; (8002c88 <chVTDoTickI+0xd8>)
 8002bca:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8002bcc:	9b03      	ldr	r3, [sp, #12]
 8002bce:	689b      	ldr	r3, [r3, #8]
 8002bd0:	18d2      	adds	r2, r2, r3
 8002bd2:	4b2d      	ldr	r3, [pc, #180]	; (8002c88 <chVTDoTickI+0xd8>)
 8002bd4:	629a      	str	r2, [r3, #40]	; 0x28

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8002bd6:	9b03      	ldr	r3, [sp, #12]
 8002bd8:	681b      	ldr	r3, [r3, #0]
 8002bda:	4a2c      	ldr	r2, [pc, #176]	; (8002c8c <chVTDoTickI+0xdc>)
 8002bdc:	605a      	str	r2, [r3, #4]
    ch.vtlist.next = vtp->next;
 8002bde:	9b03      	ldr	r3, [sp, #12]
 8002be0:	681a      	ldr	r2, [r3, #0]
 8002be2:	4b29      	ldr	r3, [pc, #164]	; (8002c88 <chVTDoTickI+0xd8>)
 8002be4:	61da      	str	r2, [r3, #28]
    fn = vtp->func;
 8002be6:	9b03      	ldr	r3, [sp, #12]
 8002be8:	68db      	ldr	r3, [r3, #12]
 8002bea:	9300      	str	r3, [sp, #0]
    vtp->func = NULL;
 8002bec:	9b03      	ldr	r3, [sp, #12]
 8002bee:	2200      	movs	r2, #0
 8002bf0:	60da      	str	r2, [r3, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8002bf2:	4b25      	ldr	r3, [pc, #148]	; (8002c88 <chVTDoTickI+0xd8>)
 8002bf4:	69da      	ldr	r2, [r3, #28]
 8002bf6:	4b25      	ldr	r3, [pc, #148]	; (8002c8c <chVTDoTickI+0xdc>)
 8002bf8:	429a      	cmp	r2, r3
 8002bfa:	d101      	bne.n	8002c00 <chVTDoTickI+0x50>
      port_timer_stop_alarm();
 8002bfc:	f7ff ff98 	bl	8002b30 <port_timer_stop_alarm.lto_priv.261>
    }

    /* Leaving the system critical zone in order to execute the callback
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();
 8002c00:	f7ff ffc6 	bl	8002b90 <chSysUnlockFromISR>

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->par);
 8002c04:	9b03      	ldr	r3, [sp, #12]
 8002c06:	691a      	ldr	r2, [r3, #16]
 8002c08:	9b00      	ldr	r3, [sp, #0]
 8002c0a:	0010      	movs	r0, r2
 8002c0c:	4798      	blx	r3

    /* Re-entering the critical zone in order to continue the exploration
       of the list.*/
    chSysLockFromISR();
 8002c0e:	f7ff ffb7 	bl	8002b80 <chSysLockFromISR>

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.next;
 8002c12:	4b1d      	ldr	r3, [pc, #116]	; (8002c88 <chVTDoTickI+0xd8>)
 8002c14:	69db      	ldr	r3, [r3, #28]
 8002c16:	9303      	str	r3, [sp, #12]
    now = chVTGetSystemTimeX();
 8002c18:	f7ff ffc2 	bl	8002ba0 <chVTGetSystemTimeX.lto_priv.253>
 8002c1c:	0003      	movs	r3, r0
 8002c1e:	9302      	str	r3, [sp, #8]
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8002c20:	9b03      	ldr	r3, [sp, #12]
 8002c22:	689a      	ldr	r2, [r3, #8]
 8002c24:	4b18      	ldr	r3, [pc, #96]	; (8002c88 <chVTDoTickI+0xd8>)
 8002c26:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002c28:	9902      	ldr	r1, [sp, #8]
 8002c2a:	1acb      	subs	r3, r1, r3
 8002c2c:	429a      	cmp	r2, r3
 8002c2e:	d9cb      	bls.n	8002bc8 <chVTDoTickI+0x18>
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8002c30:	4b15      	ldr	r3, [pc, #84]	; (8002c88 <chVTDoTickI+0xd8>)
 8002c32:	69da      	ldr	r2, [r3, #28]
 8002c34:	4b15      	ldr	r3, [pc, #84]	; (8002c8c <chVTDoTickI+0xdc>)
 8002c36:	429a      	cmp	r2, r3
 8002c38:	d024      	beq.n	8002c84 <chVTDoTickI+0xd4>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.lasttime + vtp->delta - now;
 8002c3a:	4b13      	ldr	r3, [pc, #76]	; (8002c88 <chVTDoTickI+0xd8>)
 8002c3c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8002c3e:	9b03      	ldr	r3, [sp, #12]
 8002c40:	689b      	ldr	r3, [r3, #8]
 8002c42:	18d2      	adds	r2, r2, r3
 8002c44:	9b02      	ldr	r3, [sp, #8]
 8002c46:	1ad3      	subs	r3, r2, r3
 8002c48:	9301      	str	r3, [sp, #4]
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8002c4a:	9b01      	ldr	r3, [sp, #4]
 8002c4c:	2b01      	cmp	r3, #1
 8002c4e:	d801      	bhi.n	8002c54 <chVTDoTickI+0xa4>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8002c50:	2302      	movs	r3, #2
 8002c52:	9301      	str	r3, [sp, #4]
  }
  port_timer_set_alarm(now + delta);
 8002c54:	9a02      	ldr	r2, [sp, #8]
 8002c56:	9b01      	ldr	r3, [sp, #4]
 8002c58:	18d3      	adds	r3, r2, r3
 8002c5a:	0018      	movs	r0, r3
 8002c5c:	f7ff ff70 	bl	8002b40 <port_timer_set_alarm.lto_priv.259>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.lasttime) <=
 8002c60:	f7ff ff9e 	bl	8002ba0 <chVTGetSystemTimeX.lto_priv.253>
 8002c64:	0002      	movs	r2, r0
 8002c66:	4b08      	ldr	r3, [pc, #32]	; (8002c88 <chVTDoTickI+0xd8>)
 8002c68:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002c6a:	1ad2      	subs	r2, r2, r3
 8002c6c:	9902      	ldr	r1, [sp, #8]
 8002c6e:	9b01      	ldr	r3, [sp, #4]
 8002c70:	18c9      	adds	r1, r1, r3
 8002c72:	4b05      	ldr	r3, [pc, #20]	; (8002c88 <chVTDoTickI+0xd8>)
 8002c74:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002c76:	1acb      	subs	r3, r1, r3
 8002c78:	429a      	cmp	r2, r3
 8002c7a:	d903      	bls.n	8002c84 <chVTDoTickI+0xd4>
 8002c7c:	4b04      	ldr	r3, [pc, #16]	; (8002c90 <chVTDoTickI+0xe0>)
 8002c7e:	0018      	movs	r0, r3
 8002c80:	f000 f84e 	bl	8002d20 <chSysHalt>
              (now + delta - ch.vtlist.lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8002c84:	b005      	add	sp, #20
 8002c86:	bd00      	pop	{pc}
 8002c88:	200004d8 	.word	0x200004d8
 8002c8c:	200004f4 	.word	0x200004f4
 8002c90:	08003808 	.word	0x08003808
	...

08002ca0 <_idle_thread.lto_priv.63>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8002ca0:	b500      	push	{lr}
 8002ca2:	b083      	sub	sp, #12
 8002ca4:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 8002ca6:	f7ff ff33 	bl	8002b10 <port_wait_for_interrupt>
 8002caa:	e7fc      	b.n	8002ca6 <_idle_thread.lto_priv.63+0x6>
 8002cac:	0000      	movs	r0, r0
	...

08002cb0 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 8002cb0:	b510      	push	{r4, lr}

  _scheduler_init();
 8002cb2:	f000 fca5 	bl	8003600 <_scheduler_init>
  _vt_init();
 8002cb6:	f000 facb 	bl	8003250 <_vt_init>
  _trace_init();
 8002cba:	f000 f9b1 	bl	8003020 <_trace_init>

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  ch.dbg.isr_cnt  = (cnt_t)0;
 8002cbe:	4b12      	ldr	r3, [pc, #72]	; (8002d08 <chSysInit+0x58>)
 8002cc0:	2200      	movs	r2, #0
 8002cc2:	631a      	str	r2, [r3, #48]	; 0x30
  ch.dbg.lock_cnt = (cnt_t)0;
 8002cc4:	4b10      	ldr	r3, [pc, #64]	; (8002d08 <chSysInit+0x58>)
 8002cc6:	2200      	movs	r2, #0
 8002cc8:	635a      	str	r2, [r3, #52]	; 0x34
#endif
#if CH_CFG_USE_TM == TRUE
  _tm_init();
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 8002cca:	f7fe fca1 	bl	8001610 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 8002cce:	f7fe fd07 	bl	80016e0 <_heap_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 8002cd2:	490e      	ldr	r1, [pc, #56]	; (8002d0c <chSysInit+0x5c>)
 8002cd4:	4b0e      	ldr	r3, [pc, #56]	; (8002d10 <chSysInit+0x60>)
 8002cd6:	2280      	movs	r2, #128	; 0x80
 8002cd8:	0018      	movs	r0, r3
 8002cda:	f7ff fb09 	bl	80022f0 <_thread_init>
 8002cde:	0002      	movs	r2, r0
 8002ce0:	4b09      	ldr	r3, [pc, #36]	; (8002d08 <chSysInit+0x58>)
 8002ce2:	619a      	str	r2, [r3, #24]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  {
    /* Setting up the base address of the static main thread stack, the
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
 8002ce4:	4b08      	ldr	r3, [pc, #32]	; (8002d08 <chSysInit+0x58>)
 8002ce6:	699b      	ldr	r3, [r3, #24]
 8002ce8:	4a0a      	ldr	r2, [pc, #40]	; (8002d14 <chSysInit+0x64>)
 8002cea:	61da      	str	r2, [r3, #28]
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 8002cec:	4b06      	ldr	r3, [pc, #24]	; (8002d08 <chSysInit+0x58>)
 8002cee:	699b      	ldr	r3, [r3, #24]
 8002cf0:	2220      	movs	r2, #32
 8002cf2:	2101      	movs	r1, #1
 8002cf4:	5499      	strb	r1, [r3, r2]

  /* Port layer initialization last because it depend on some of the
     initializations performed before.*/
  port_init();
 8002cf6:	f7ff fed3 	bl	8002aa0 <port_init>
  /* Starting measurement for this thread.*/
  chTMStartMeasurementX(&currp->stats);
#endif

  /* It is alive now.*/
  chSysEnable();
 8002cfa:	f7ff ff39 	bl	8002b70 <chSysEnable>
    };

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreate(&idle_descriptor);
 8002cfe:	4b06      	ldr	r3, [pc, #24]	; (8002d18 <chSysInit+0x68>)
 8002d00:	0018      	movs	r0, r3
 8002d02:	f7ff fbb5 	bl	8002470 <chThdCreate>
  }
#endif
}
 8002d06:	bd10      	pop	{r4, pc}
 8002d08:	200004d8 	.word	0x200004d8
 8002d0c:	080038ec 	.word	0x080038ec
 8002d10:	20000d18 	.word	0x20000d18
 8002d14:	20000200 	.word	0x20000200
 8002d18:	080037f0 	.word	0x080037f0
 8002d1c:	00000000 	.word	0x00000000

08002d20 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 8002d20:	b500      	push	{lr}
 8002d22:	b083      	sub	sp, #12
 8002d24:	9001      	str	r0, [sp, #4]

  port_disable();
 8002d26:	f7ff fee3 	bl	8002af0 <port_disable>

  /* Logging the event.*/
  _trace_halt(reason);
 8002d2a:	9b01      	ldr	r3, [sp, #4]
 8002d2c:	0018      	movs	r0, r3
 8002d2e:	f000 fa27 	bl	8003180 <_trace_halt>

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8002d32:	4b02      	ldr	r3, [pc, #8]	; (8002d3c <chSysHalt+0x1c>)
 8002d34:	9a01      	ldr	r2, [sp, #4]
 8002d36:	62da      	str	r2, [r3, #44]	; 0x2c
 8002d38:	e7fe      	b.n	8002d38 <chSysHalt+0x18>
 8002d3a:	46c0      	nop			; (mov r8, r8)
 8002d3c:	200004d8 	.word	0x200004d8

08002d40 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8002d40:	b510      	push	{r4, lr}

  chDbgCheckClassI();
 8002d42:	f000 f8dd 	bl	8002f00 <chDbgCheckClassI>
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->time++;
#endif
  chVTDoTickI();
 8002d46:	f7ff ff33 	bl	8002bb0 <chVTDoTickI>
  CH_CFG_SYSTEM_TICK_HOOK();
}
 8002d4a:	bd10      	pop	{r4, pc}
 8002d4c:	0000      	movs	r0, r0
	...

08002d50 <port_lock.lto_priv.250>:
  __ASM volatile ("cpsid i" : : : "memory");
 8002d50:	b672      	cpsid	i
}
 8002d52:	4770      	bx	lr
	...

08002d60 <port_unlock.lto_priv.246>:
  __ASM volatile ("cpsie i" : : : "memory");
 8002d60:	b662      	cpsie	i
}
 8002d62:	4770      	bx	lr
	...

08002d70 <port_lock_from_isr.lto_priv.242>:
static inline void port_lock_from_isr(void) {
 8002d70:	b510      	push	{r4, lr}
  port_lock();
 8002d72:	f7ff ffed 	bl	8002d50 <port_lock.lto_priv.250>
}
 8002d76:	bd10      	pop	{r4, pc}
	...

08002d80 <port_unlock_from_isr.lto_priv.238>:
static inline void port_unlock_from_isr(void) {
 8002d80:	b510      	push	{r4, lr}
  port_unlock();
 8002d82:	f7ff ffed 	bl	8002d60 <port_unlock.lto_priv.246>
}
 8002d86:	bd10      	pop	{r4, pc}
	...

08002d90 <_dbg_check_enable>:
/**
 * @brief   Guard code for @p chSysEnable().
 *
 * @notapi
 */
void _dbg_check_enable(void) {
 8002d90:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002d92:	4b06      	ldr	r3, [pc, #24]	; (8002dac <_dbg_check_enable+0x1c>)
 8002d94:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002d96:	2b00      	cmp	r3, #0
 8002d98:	d103      	bne.n	8002da2 <_dbg_check_enable+0x12>
 8002d9a:	4b04      	ldr	r3, [pc, #16]	; (8002dac <_dbg_check_enable+0x1c>)
 8002d9c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002d9e:	2b00      	cmp	r3, #0
 8002da0:	d003      	beq.n	8002daa <_dbg_check_enable+0x1a>
    chSysHalt("SV#3");
 8002da2:	4b03      	ldr	r3, [pc, #12]	; (8002db0 <_dbg_check_enable+0x20>)
 8002da4:	0018      	movs	r0, r3
 8002da6:	f7ff ffbb 	bl	8002d20 <chSysHalt>
  }
}
 8002daa:	bd10      	pop	{r4, pc}
 8002dac:	200004d8 	.word	0x200004d8
 8002db0:	08003728 	.word	0x08003728
	...

08002dc0 <_dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void _dbg_check_lock(void) {
 8002dc0:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002dc2:	4b08      	ldr	r3, [pc, #32]	; (8002de4 <_dbg_check_lock+0x24>)
 8002dc4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002dc6:	2b00      	cmp	r3, #0
 8002dc8:	d103      	bne.n	8002dd2 <_dbg_check_lock+0x12>
 8002dca:	4b06      	ldr	r3, [pc, #24]	; (8002de4 <_dbg_check_lock+0x24>)
 8002dcc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002dce:	2b00      	cmp	r3, #0
 8002dd0:	d003      	beq.n	8002dda <_dbg_check_lock+0x1a>
    chSysHalt("SV#4");
 8002dd2:	4b05      	ldr	r3, [pc, #20]	; (8002de8 <_dbg_check_lock+0x28>)
 8002dd4:	0018      	movs	r0, r3
 8002dd6:	f7ff ffa3 	bl	8002d20 <chSysHalt>
  }
  _dbg_enter_lock();
 8002dda:	4b02      	ldr	r3, [pc, #8]	; (8002de4 <_dbg_check_lock+0x24>)
 8002ddc:	2201      	movs	r2, #1
 8002dde:	635a      	str	r2, [r3, #52]	; 0x34
}
 8002de0:	bd10      	pop	{r4, pc}
 8002de2:	46c0      	nop			; (mov r8, r8)
 8002de4:	200004d8 	.word	0x200004d8
 8002de8:	08003730 	.word	0x08003730
 8002dec:	00000000 	.word	0x00000000

08002df0 <_dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void _dbg_check_unlock(void) {
 8002df0:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002df2:	4b08      	ldr	r3, [pc, #32]	; (8002e14 <_dbg_check_unlock+0x24>)
 8002df4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002df6:	2b00      	cmp	r3, #0
 8002df8:	d103      	bne.n	8002e02 <_dbg_check_unlock+0x12>
 8002dfa:	4b06      	ldr	r3, [pc, #24]	; (8002e14 <_dbg_check_unlock+0x24>)
 8002dfc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002dfe:	2b00      	cmp	r3, #0
 8002e00:	dc03      	bgt.n	8002e0a <_dbg_check_unlock+0x1a>
    chSysHalt("SV#5");
 8002e02:	4b05      	ldr	r3, [pc, #20]	; (8002e18 <_dbg_check_unlock+0x28>)
 8002e04:	0018      	movs	r0, r3
 8002e06:	f7ff ff8b 	bl	8002d20 <chSysHalt>
  }
  _dbg_leave_lock();
 8002e0a:	4b02      	ldr	r3, [pc, #8]	; (8002e14 <_dbg_check_unlock+0x24>)
 8002e0c:	2200      	movs	r2, #0
 8002e0e:	635a      	str	r2, [r3, #52]	; 0x34
}
 8002e10:	bd10      	pop	{r4, pc}
 8002e12:	46c0      	nop			; (mov r8, r8)
 8002e14:	200004d8 	.word	0x200004d8
 8002e18:	08003738 	.word	0x08003738
 8002e1c:	00000000 	.word	0x00000000

08002e20 <_dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {
 8002e20:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002e22:	4b08      	ldr	r3, [pc, #32]	; (8002e44 <_dbg_check_lock_from_isr+0x24>)
 8002e24:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002e26:	2b00      	cmp	r3, #0
 8002e28:	dd03      	ble.n	8002e32 <_dbg_check_lock_from_isr+0x12>
 8002e2a:	4b06      	ldr	r3, [pc, #24]	; (8002e44 <_dbg_check_lock_from_isr+0x24>)
 8002e2c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002e2e:	2b00      	cmp	r3, #0
 8002e30:	d003      	beq.n	8002e3a <_dbg_check_lock_from_isr+0x1a>
    chSysHalt("SV#6");
 8002e32:	4b05      	ldr	r3, [pc, #20]	; (8002e48 <_dbg_check_lock_from_isr+0x28>)
 8002e34:	0018      	movs	r0, r3
 8002e36:	f7ff ff73 	bl	8002d20 <chSysHalt>
  }
  _dbg_enter_lock();
 8002e3a:	4b02      	ldr	r3, [pc, #8]	; (8002e44 <_dbg_check_lock_from_isr+0x24>)
 8002e3c:	2201      	movs	r2, #1
 8002e3e:	635a      	str	r2, [r3, #52]	; 0x34
}
 8002e40:	bd10      	pop	{r4, pc}
 8002e42:	46c0      	nop			; (mov r8, r8)
 8002e44:	200004d8 	.word	0x200004d8
 8002e48:	08003740 	.word	0x08003740
 8002e4c:	00000000 	.word	0x00000000

08002e50 <_dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {
 8002e50:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002e52:	4b08      	ldr	r3, [pc, #32]	; (8002e74 <_dbg_check_unlock_from_isr+0x24>)
 8002e54:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002e56:	2b00      	cmp	r3, #0
 8002e58:	dd03      	ble.n	8002e62 <_dbg_check_unlock_from_isr+0x12>
 8002e5a:	4b06      	ldr	r3, [pc, #24]	; (8002e74 <_dbg_check_unlock_from_isr+0x24>)
 8002e5c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002e5e:	2b00      	cmp	r3, #0
 8002e60:	dc03      	bgt.n	8002e6a <_dbg_check_unlock_from_isr+0x1a>
    chSysHalt("SV#7");
 8002e62:	4b05      	ldr	r3, [pc, #20]	; (8002e78 <_dbg_check_unlock_from_isr+0x28>)
 8002e64:	0018      	movs	r0, r3
 8002e66:	f7ff ff5b 	bl	8002d20 <chSysHalt>
  }
  _dbg_leave_lock();
 8002e6a:	4b02      	ldr	r3, [pc, #8]	; (8002e74 <_dbg_check_unlock_from_isr+0x24>)
 8002e6c:	2200      	movs	r2, #0
 8002e6e:	635a      	str	r2, [r3, #52]	; 0x34
}
 8002e70:	bd10      	pop	{r4, pc}
 8002e72:	46c0      	nop			; (mov r8, r8)
 8002e74:	200004d8 	.word	0x200004d8
 8002e78:	08003748 	.word	0x08003748
 8002e7c:	00000000 	.word	0x00000000

08002e80 <_dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {
 8002e80:	b510      	push	{r4, lr}

  port_lock_from_isr();
 8002e82:	f7ff ff75 	bl	8002d70 <port_lock_from_isr.lto_priv.242>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002e86:	4b0a      	ldr	r3, [pc, #40]	; (8002eb0 <_dbg_check_enter_isr+0x30>)
 8002e88:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002e8a:	2b00      	cmp	r3, #0
 8002e8c:	db03      	blt.n	8002e96 <_dbg_check_enter_isr+0x16>
 8002e8e:	4b08      	ldr	r3, [pc, #32]	; (8002eb0 <_dbg_check_enter_isr+0x30>)
 8002e90:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002e92:	2b00      	cmp	r3, #0
 8002e94:	d003      	beq.n	8002e9e <_dbg_check_enter_isr+0x1e>
    chSysHalt("SV#8");
 8002e96:	4b07      	ldr	r3, [pc, #28]	; (8002eb4 <_dbg_check_enter_isr+0x34>)
 8002e98:	0018      	movs	r0, r3
 8002e9a:	f7ff ff41 	bl	8002d20 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
 8002e9e:	4b04      	ldr	r3, [pc, #16]	; (8002eb0 <_dbg_check_enter_isr+0x30>)
 8002ea0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002ea2:	1c5a      	adds	r2, r3, #1
 8002ea4:	4b02      	ldr	r3, [pc, #8]	; (8002eb0 <_dbg_check_enter_isr+0x30>)
 8002ea6:	631a      	str	r2, [r3, #48]	; 0x30
  port_unlock_from_isr();
 8002ea8:	f7ff ff6a 	bl	8002d80 <port_unlock_from_isr.lto_priv.238>
}
 8002eac:	bd10      	pop	{r4, pc}
 8002eae:	46c0      	nop			; (mov r8, r8)
 8002eb0:	200004d8 	.word	0x200004d8
 8002eb4:	08003750 	.word	0x08003750
	...

08002ec0 <_dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {
 8002ec0:	b510      	push	{r4, lr}

  port_lock_from_isr();
 8002ec2:	f7ff ff55 	bl	8002d70 <port_lock_from_isr.lto_priv.242>
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002ec6:	4b0a      	ldr	r3, [pc, #40]	; (8002ef0 <_dbg_check_leave_isr+0x30>)
 8002ec8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002eca:	2b00      	cmp	r3, #0
 8002ecc:	dd03      	ble.n	8002ed6 <_dbg_check_leave_isr+0x16>
 8002ece:	4b08      	ldr	r3, [pc, #32]	; (8002ef0 <_dbg_check_leave_isr+0x30>)
 8002ed0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002ed2:	2b00      	cmp	r3, #0
 8002ed4:	d003      	beq.n	8002ede <_dbg_check_leave_isr+0x1e>
    chSysHalt("SV#9");
 8002ed6:	4b07      	ldr	r3, [pc, #28]	; (8002ef4 <_dbg_check_leave_isr+0x34>)
 8002ed8:	0018      	movs	r0, r3
 8002eda:	f7ff ff21 	bl	8002d20 <chSysHalt>
  }
  ch.dbg.isr_cnt--;
 8002ede:	4b04      	ldr	r3, [pc, #16]	; (8002ef0 <_dbg_check_leave_isr+0x30>)
 8002ee0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002ee2:	1e5a      	subs	r2, r3, #1
 8002ee4:	4b02      	ldr	r3, [pc, #8]	; (8002ef0 <_dbg_check_leave_isr+0x30>)
 8002ee6:	631a      	str	r2, [r3, #48]	; 0x30
  port_unlock_from_isr();
 8002ee8:	f7ff ff4a 	bl	8002d80 <port_unlock_from_isr.lto_priv.238>
}
 8002eec:	bd10      	pop	{r4, pc}
 8002eee:	46c0      	nop			; (mov r8, r8)
 8002ef0:	200004d8 	.word	0x200004d8
 8002ef4:	08003758 	.word	0x08003758
	...

08002f00 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
 8002f00:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002f02:	4b06      	ldr	r3, [pc, #24]	; (8002f1c <chDbgCheckClassI+0x1c>)
 8002f04:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002f06:	2b00      	cmp	r3, #0
 8002f08:	db03      	blt.n	8002f12 <chDbgCheckClassI+0x12>
 8002f0a:	4b04      	ldr	r3, [pc, #16]	; (8002f1c <chDbgCheckClassI+0x1c>)
 8002f0c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002f0e:	2b00      	cmp	r3, #0
 8002f10:	dc03      	bgt.n	8002f1a <chDbgCheckClassI+0x1a>
    chSysHalt("SV#10");
 8002f12:	4b03      	ldr	r3, [pc, #12]	; (8002f20 <chDbgCheckClassI+0x20>)
 8002f14:	0018      	movs	r0, r3
 8002f16:	f7ff ff03 	bl	8002d20 <chSysHalt>
  }
}
 8002f1a:	bd10      	pop	{r4, pc}
 8002f1c:	200004d8 	.word	0x200004d8
 8002f20:	08003760 	.word	0x08003760
	...

08002f30 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 8002f30:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002f32:	4b06      	ldr	r3, [pc, #24]	; (8002f4c <chDbgCheckClassS+0x1c>)
 8002f34:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002f36:	2b00      	cmp	r3, #0
 8002f38:	d103      	bne.n	8002f42 <chDbgCheckClassS+0x12>
 8002f3a:	4b04      	ldr	r3, [pc, #16]	; (8002f4c <chDbgCheckClassS+0x1c>)
 8002f3c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002f3e:	2b00      	cmp	r3, #0
 8002f40:	dc03      	bgt.n	8002f4a <chDbgCheckClassS+0x1a>
    chSysHalt("SV#11");
 8002f42:	4b03      	ldr	r3, [pc, #12]	; (8002f50 <chDbgCheckClassS+0x20>)
 8002f44:	0018      	movs	r0, r3
 8002f46:	f7ff feeb 	bl	8002d20 <chSysHalt>
  }
}
 8002f4a:	bd10      	pop	{r4, pc}
 8002f4c:	200004d8 	.word	0x200004d8
 8002f50:	08003768 	.word	0x08003768
	...

08002f60 <port_lock.lto_priv.251>:
  __ASM volatile ("cpsid i" : : : "memory");
 8002f60:	b672      	cpsid	i
}
 8002f62:	4770      	bx	lr
	...

08002f70 <port_unlock.lto_priv.247>:
  __ASM volatile ("cpsie i" : : : "memory");
 8002f70:	b662      	cpsie	i
}
 8002f72:	4770      	bx	lr
	...

08002f80 <port_lock_from_isr.lto_priv.243>:
static inline void port_lock_from_isr(void) {
 8002f80:	b510      	push	{r4, lr}
  port_lock();
 8002f82:	f7ff ffed 	bl	8002f60 <port_lock.lto_priv.251>
}
 8002f86:	bd10      	pop	{r4, pc}
	...

08002f90 <port_unlock_from_isr.lto_priv.239>:
static inline void port_unlock_from_isr(void) {
 8002f90:	b510      	push	{r4, lr}
  port_unlock();
 8002f92:	f7ff ffed 	bl	8002f70 <port_unlock.lto_priv.247>
}
 8002f96:	bd10      	pop	{r4, pc}
	...

08002fa0 <st_lld_get_counter.lto_priv.264>:
  return (systime_t)STM32_ST_TIM->CNT;
 8002fa0:	2380      	movs	r3, #128	; 0x80
 8002fa2:	05db      	lsls	r3, r3, #23
 8002fa4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8002fa6:	0018      	movs	r0, r3
 8002fa8:	4770      	bx	lr
 8002faa:	46c0      	nop			; (mov r8, r8)
 8002fac:	0000      	movs	r0, r0
	...

08002fb0 <port_timer_get_time.lto_priv.257>:
static inline systime_t port_timer_get_time(void) {
 8002fb0:	b510      	push	{r4, lr}
  return stGetCounter();
 8002fb2:	f7ff fff5 	bl	8002fa0 <st_lld_get_counter.lto_priv.264>
 8002fb6:	0003      	movs	r3, r0
}
 8002fb8:	0018      	movs	r0, r3
 8002fba:	bd10      	pop	{r4, pc}
 8002fbc:	0000      	movs	r0, r0
	...

08002fc0 <chVTGetSystemTimeX.lto_priv.254>:
static inline systime_t chVTGetSystemTimeX(void) {
 8002fc0:	b510      	push	{r4, lr}
  return port_timer_get_time();
 8002fc2:	f7ff fff5 	bl	8002fb0 <port_timer_get_time.lto_priv.257>
 8002fc6:	0003      	movs	r3, r0
}
 8002fc8:	0018      	movs	r0, r3
 8002fca:	bd10      	pop	{r4, pc}
 8002fcc:	0000      	movs	r0, r0
	...

08002fd0 <trace_next>:
/**
 * @brief   Writes a time stamp and increases the trace buffer pointer.
 *
 * @notapi
 */
static NOINLINE void trace_next(void) {
 8002fd0:	b510      	push	{r4, lr}

  ch.dbg.trace_buffer.ptr->time    = chVTGetSystemTimeX();
 8002fd2:	4b0d      	ldr	r3, [pc, #52]	; (8003008 <trace_next+0x38>)
 8002fd4:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
 8002fd6:	f7ff fff3 	bl	8002fc0 <chVTGetSystemTimeX.lto_priv.254>
 8002fda:	0003      	movs	r3, r0
 8002fdc:	6063      	str	r3, [r4, #4]
#if PORT_SUPPORTS_RT == TRUE
  ch.dbg.trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
#else
  ch.dbg.trace_buffer.ptr->rtstamp = (rtcnt_t)0;
 8002fde:	4b0a      	ldr	r3, [pc, #40]	; (8003008 <trace_next+0x38>)
 8002fe0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002fe2:	681a      	ldr	r2, [r3, #0]
 8002fe4:	21ff      	movs	r1, #255	; 0xff
 8002fe6:	400a      	ands	r2, r1
 8002fe8:	601a      	str	r2, [r3, #0]
#endif

  /* Trace hook, useful in order to interface debug tools.*/
  CH_CFG_TRACE_HOOK(ch.dbg.trace_buffer.ptr);

  if (++ch.dbg.trace_buffer.ptr >=
 8002fea:	4b07      	ldr	r3, [pc, #28]	; (8003008 <trace_next+0x38>)
 8002fec:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002fee:	3310      	adds	r3, #16
 8002ff0:	001a      	movs	r2, r3
 8002ff2:	4b05      	ldr	r3, [pc, #20]	; (8003008 <trace_next+0x38>)
 8002ff4:	63da      	str	r2, [r3, #60]	; 0x3c
 8002ff6:	4b04      	ldr	r3, [pc, #16]	; (8003008 <trace_next+0x38>)
 8002ff8:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8002ffa:	4b04      	ldr	r3, [pc, #16]	; (800300c <trace_next+0x3c>)
 8002ffc:	429a      	cmp	r2, r3
 8002ffe:	d302      	bcc.n	8003006 <trace_next+0x36>
      &ch.dbg.trace_buffer.buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.ptr = &ch.dbg.trace_buffer.buffer[0];
 8003000:	4b01      	ldr	r3, [pc, #4]	; (8003008 <trace_next+0x38>)
 8003002:	4a03      	ldr	r2, [pc, #12]	; (8003010 <trace_next+0x40>)
 8003004:	63da      	str	r2, [r3, #60]	; 0x3c
  }
}
 8003006:	bd10      	pop	{r4, pc}
 8003008:	200004d8 	.word	0x200004d8
 800300c:	20000d18 	.word	0x20000d18
 8003010:	20000518 	.word	0x20000518
	...

08003020 <_trace_init>:
#if (CH_DBG_TRACE_MASK != CH_DBG_TRACE_MASK_DISABLED) || defined(__DOXYGEN__)
/**
 * @brief   Trace circular buffer subsystem initialization.
 * @note    Internal use only.
 */
void _trace_init(void) {
 8003020:	b082      	sub	sp, #8
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)CH_DBG_TRACE_MASK;
 8003022:	4b0f      	ldr	r3, [pc, #60]	; (8003060 <_trace_init+0x40>)
 8003024:	220f      	movs	r2, #15
 8003026:	871a      	strh	r2, [r3, #56]	; 0x38
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
 8003028:	4b0d      	ldr	r3, [pc, #52]	; (8003060 <_trace_init+0x40>)
 800302a:	2280      	movs	r2, #128	; 0x80
 800302c:	875a      	strh	r2, [r3, #58]	; 0x3a
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
 800302e:	4b0c      	ldr	r3, [pc, #48]	; (8003060 <_trace_init+0x40>)
 8003030:	4a0c      	ldr	r2, [pc, #48]	; (8003064 <_trace_init+0x44>)
 8003032:	63da      	str	r2, [r3, #60]	; 0x3c
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8003034:	2300      	movs	r3, #0
 8003036:	9301      	str	r3, [sp, #4]
 8003038:	e00d      	b.n	8003056 <_trace_init+0x36>
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
 800303a:	4a09      	ldr	r2, [pc, #36]	; (8003060 <_trace_init+0x40>)
 800303c:	9b01      	ldr	r3, [sp, #4]
 800303e:	3301      	adds	r3, #1
 8003040:	2128      	movs	r1, #40	; 0x28
 8003042:	011b      	lsls	r3, r3, #4
 8003044:	18d3      	adds	r3, r2, r3
 8003046:	185b      	adds	r3, r3, r1
 8003048:	7a1a      	ldrb	r2, [r3, #8]
 800304a:	2107      	movs	r1, #7
 800304c:	438a      	bics	r2, r1
 800304e:	721a      	strb	r2, [r3, #8]
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8003050:	9b01      	ldr	r3, [sp, #4]
 8003052:	3301      	adds	r3, #1
 8003054:	9301      	str	r3, [sp, #4]
 8003056:	9b01      	ldr	r3, [sp, #4]
 8003058:	2b7f      	cmp	r3, #127	; 0x7f
 800305a:	d9ee      	bls.n	800303a <_trace_init+0x1a>
  }
}
 800305c:	b002      	add	sp, #8
 800305e:	4770      	bx	lr
 8003060:	200004d8 	.word	0x200004d8
 8003064:	20000518 	.word	0x20000518
	...

08003070 <_trace_switch>:
 * @param[in] ntp       the thread being switched in
 * @param[in] otp       the thread being switched out
 *
 * @notapi
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {
 8003070:	b500      	push	{lr}
 8003072:	b083      	sub	sp, #12
 8003074:	9001      	str	r0, [sp, #4]
 8003076:	9100      	str	r1, [sp, #0]

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8003078:	4b16      	ldr	r3, [pc, #88]	; (80030d4 <_trace_switch+0x64>)
 800307a:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800307c:	001a      	movs	r2, r3
 800307e:	2301      	movs	r3, #1
 8003080:	4013      	ands	r3, r2
 8003082:	d125      	bne.n	80030d0 <_trace_switch+0x60>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8003084:	4b13      	ldr	r3, [pc, #76]	; (80030d4 <_trace_switch+0x64>)
 8003086:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8003088:	781a      	ldrb	r2, [r3, #0]
 800308a:	2107      	movs	r1, #7
 800308c:	438a      	bics	r2, r1
 800308e:	1c11      	adds	r1, r2, #0
 8003090:	2201      	movs	r2, #1
 8003092:	430a      	orrs	r2, r1
 8003094:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8003096:	4b0f      	ldr	r3, [pc, #60]	; (80030d4 <_trace_switch+0x64>)
 8003098:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800309a:	9a00      	ldr	r2, [sp, #0]
 800309c:	2120      	movs	r1, #32
 800309e:	5c52      	ldrb	r2, [r2, r1]
 80030a0:	1c11      	adds	r1, r2, #0
 80030a2:	221f      	movs	r2, #31
 80030a4:	400a      	ands	r2, r1
 80030a6:	b2d2      	uxtb	r2, r2
 80030a8:	00d0      	lsls	r0, r2, #3
 80030aa:	781a      	ldrb	r2, [r3, #0]
 80030ac:	2107      	movs	r1, #7
 80030ae:	400a      	ands	r2, r1
 80030b0:	1c11      	adds	r1, r2, #0
 80030b2:	1c02      	adds	r2, r0, #0
 80030b4:	430a      	orrs	r2, r1
 80030b6:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 80030b8:	4b06      	ldr	r3, [pc, #24]	; (80030d4 <_trace_switch+0x64>)
 80030ba:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80030bc:	4a05      	ldr	r2, [pc, #20]	; (80030d4 <_trace_switch+0x64>)
 80030be:	6992      	ldr	r2, [r2, #24]
 80030c0:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 80030c2:	4b04      	ldr	r3, [pc, #16]	; (80030d4 <_trace_switch+0x64>)
 80030c4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80030c6:	9a00      	ldr	r2, [sp, #0]
 80030c8:	6a52      	ldr	r2, [r2, #36]	; 0x24
 80030ca:	60da      	str	r2, [r3, #12]
    trace_next();
 80030cc:	f7ff ff80 	bl	8002fd0 <trace_next>
  }
}
 80030d0:	b003      	add	sp, #12
 80030d2:	bd00      	pop	{pc}
 80030d4:	200004d8 	.word	0x200004d8
	...

080030e0 <_trace_isr_enter>:
 *
 * @param[in] isr       name of the isr
 *
 * @notapi
 */
void _trace_isr_enter(const char *isr) {
 80030e0:	b500      	push	{lr}
 80030e2:	b083      	sub	sp, #12
 80030e4:	9001      	str	r0, [sp, #4]

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80030e6:	4b10      	ldr	r3, [pc, #64]	; (8003128 <_trace_isr_enter+0x48>)
 80030e8:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 80030ea:	001a      	movs	r2, r3
 80030ec:	2302      	movs	r3, #2
 80030ee:	4013      	ands	r3, r2
 80030f0:	d118      	bne.n	8003124 <_trace_isr_enter+0x44>
    port_lock_from_isr();
 80030f2:	f7ff ff45 	bl	8002f80 <port_lock_from_isr.lto_priv.243>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80030f6:	4b0c      	ldr	r3, [pc, #48]	; (8003128 <_trace_isr_enter+0x48>)
 80030f8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80030fa:	781a      	ldrb	r2, [r3, #0]
 80030fc:	2107      	movs	r1, #7
 80030fe:	438a      	bics	r2, r1
 8003100:	1c11      	adds	r1, r2, #0
 8003102:	2202      	movs	r2, #2
 8003104:	430a      	orrs	r2, r1
 8003106:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->state       = 0U;
 8003108:	4b07      	ldr	r3, [pc, #28]	; (8003128 <_trace_isr_enter+0x48>)
 800310a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800310c:	781a      	ldrb	r2, [r3, #0]
 800310e:	2107      	movs	r1, #7
 8003110:	400a      	ands	r2, r1
 8003112:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8003114:	4b04      	ldr	r3, [pc, #16]	; (8003128 <_trace_isr_enter+0x48>)
 8003116:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8003118:	9a01      	ldr	r2, [sp, #4]
 800311a:	609a      	str	r2, [r3, #8]
    trace_next();
 800311c:	f7ff ff58 	bl	8002fd0 <trace_next>
    port_unlock_from_isr();
 8003120:	f7ff ff36 	bl	8002f90 <port_unlock_from_isr.lto_priv.239>
  }
}
 8003124:	b003      	add	sp, #12
 8003126:	bd00      	pop	{pc}
 8003128:	200004d8 	.word	0x200004d8
 800312c:	00000000 	.word	0x00000000

08003130 <_trace_isr_leave>:
 *
 * @param[in] isr       name of the isr
 *
 * @notapi
 */
void _trace_isr_leave(const char *isr) {
 8003130:	b500      	push	{lr}
 8003132:	b083      	sub	sp, #12
 8003134:	9001      	str	r0, [sp, #4]

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003136:	4b10      	ldr	r3, [pc, #64]	; (8003178 <_trace_isr_leave+0x48>)
 8003138:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800313a:	001a      	movs	r2, r3
 800313c:	2302      	movs	r3, #2
 800313e:	4013      	ands	r3, r2
 8003140:	d118      	bne.n	8003174 <_trace_isr_leave+0x44>
    port_lock_from_isr();
 8003142:	f7ff ff1d 	bl	8002f80 <port_lock_from_isr.lto_priv.243>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003146:	4b0c      	ldr	r3, [pc, #48]	; (8003178 <_trace_isr_leave+0x48>)
 8003148:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800314a:	781a      	ldrb	r2, [r3, #0]
 800314c:	2107      	movs	r1, #7
 800314e:	438a      	bics	r2, r1
 8003150:	1c11      	adds	r1, r2, #0
 8003152:	2203      	movs	r2, #3
 8003154:	430a      	orrs	r2, r1
 8003156:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->state       = 0U;
 8003158:	4b07      	ldr	r3, [pc, #28]	; (8003178 <_trace_isr_leave+0x48>)
 800315a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800315c:	781a      	ldrb	r2, [r3, #0]
 800315e:	2107      	movs	r1, #7
 8003160:	400a      	ands	r2, r1
 8003162:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8003164:	4b04      	ldr	r3, [pc, #16]	; (8003178 <_trace_isr_leave+0x48>)
 8003166:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8003168:	9a01      	ldr	r2, [sp, #4]
 800316a:	609a      	str	r2, [r3, #8]
    trace_next();
 800316c:	f7ff ff30 	bl	8002fd0 <trace_next>
    port_unlock_from_isr();
 8003170:	f7ff ff0e 	bl	8002f90 <port_unlock_from_isr.lto_priv.239>
  }
}
 8003174:	b003      	add	sp, #12
 8003176:	bd00      	pop	{pc}
 8003178:	200004d8 	.word	0x200004d8
 800317c:	00000000 	.word	0x00000000

08003180 <_trace_halt>:
 *
 * @param[in] reason    the halt error string
 *
 * @notapi
 */
void _trace_halt(const char *reason) {
 8003180:	b500      	push	{lr}
 8003182:	b083      	sub	sp, #12
 8003184:	9001      	str	r0, [sp, #4]

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
 8003186:	4b0e      	ldr	r3, [pc, #56]	; (80031c0 <_trace_halt+0x40>)
 8003188:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800318a:	001a      	movs	r2, r3
 800318c:	2304      	movs	r3, #4
 800318e:	4013      	ands	r3, r2
 8003190:	d114      	bne.n	80031bc <_trace_halt+0x3c>
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 8003192:	4b0b      	ldr	r3, [pc, #44]	; (80031c0 <_trace_halt+0x40>)
 8003194:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8003196:	781a      	ldrb	r2, [r3, #0]
 8003198:	2107      	movs	r1, #7
 800319a:	438a      	bics	r2, r1
 800319c:	1c11      	adds	r1, r2, #0
 800319e:	2204      	movs	r2, #4
 80031a0:	430a      	orrs	r2, r1
 80031a2:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->state         = 0;
 80031a4:	4b06      	ldr	r3, [pc, #24]	; (80031c0 <_trace_halt+0x40>)
 80031a6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80031a8:	781a      	ldrb	r2, [r3, #0]
 80031aa:	2107      	movs	r1, #7
 80031ac:	400a      	ands	r2, r1
 80031ae:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->u.halt.reason = reason;
 80031b0:	4b03      	ldr	r3, [pc, #12]	; (80031c0 <_trace_halt+0x40>)
 80031b2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80031b4:	9a01      	ldr	r2, [sp, #4]
 80031b6:	609a      	str	r2, [r3, #8]
    trace_next();
 80031b8:	f7ff ff0a 	bl	8002fd0 <trace_next>
  }
}
 80031bc:	b003      	add	sp, #12
 80031be:	bd00      	pop	{pc}
 80031c0:	200004d8 	.word	0x200004d8
	...

080031d0 <st_lld_get_counter.lto_priv.265>:
  return (systime_t)STM32_ST_TIM->CNT;
 80031d0:	2380      	movs	r3, #128	; 0x80
 80031d2:	05db      	lsls	r3, r3, #23
 80031d4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 80031d6:	0018      	movs	r0, r3
 80031d8:	4770      	bx	lr
 80031da:	46c0      	nop			; (mov r8, r8)
 80031dc:	0000      	movs	r0, r0
	...

080031e0 <port_timer_start_alarm>:
static inline void port_timer_start_alarm(systime_t time) {
 80031e0:	b500      	push	{lr}
 80031e2:	b083      	sub	sp, #12
 80031e4:	9001      	str	r0, [sp, #4]
  stStartAlarm(time);
 80031e6:	9b01      	ldr	r3, [sp, #4]
 80031e8:	0018      	movs	r0, r3
 80031ea:	f7fd fbf9 	bl	80009e0 <stStartAlarm>
}
 80031ee:	b003      	add	sp, #12
 80031f0:	bd00      	pop	{pc}
 80031f2:	46c0      	nop			; (mov r8, r8)
	...

08003200 <port_timer_stop_alarm.lto_priv.262>:
static inline void port_timer_stop_alarm(void) {
 8003200:	b510      	push	{r4, lr}
  stStopAlarm();
 8003202:	f7fd fc05 	bl	8000a10 <stStopAlarm>
}
 8003206:	bd10      	pop	{r4, pc}
	...

08003210 <port_timer_set_alarm.lto_priv.260>:
static inline void port_timer_set_alarm(systime_t time) {
 8003210:	b500      	push	{lr}
 8003212:	b083      	sub	sp, #12
 8003214:	9001      	str	r0, [sp, #4]
  stSetAlarm(time);
 8003216:	9b01      	ldr	r3, [sp, #4]
 8003218:	0018      	movs	r0, r3
 800321a:	f7fd fc01 	bl	8000a20 <stSetAlarm>
}
 800321e:	b003      	add	sp, #12
 8003220:	bd00      	pop	{pc}
 8003222:	46c0      	nop			; (mov r8, r8)
	...

08003230 <port_timer_get_time.lto_priv.258>:
static inline systime_t port_timer_get_time(void) {
 8003230:	b510      	push	{r4, lr}
  return stGetCounter();
 8003232:	f7ff ffcd 	bl	80031d0 <st_lld_get_counter.lto_priv.265>
 8003236:	0003      	movs	r3, r0
}
 8003238:	0018      	movs	r0, r3
 800323a:	bd10      	pop	{r4, pc}
 800323c:	0000      	movs	r0, r0
	...

08003240 <chVTGetSystemTimeX.lto_priv.255>:
static inline systime_t chVTGetSystemTimeX(void) {
 8003240:	b510      	push	{r4, lr}
  return port_timer_get_time();
 8003242:	f7ff fff5 	bl	8003230 <port_timer_get_time.lto_priv.258>
 8003246:	0003      	movs	r3, r0
}
 8003248:	0018      	movs	r0, r3
 800324a:	bd10      	pop	{r4, pc}
 800324c:	0000      	movs	r0, r0
	...

08003250 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8003250:	4b06      	ldr	r3, [pc, #24]	; (800326c <_vt_init+0x1c>)
 8003252:	4a07      	ldr	r2, [pc, #28]	; (8003270 <_vt_init+0x20>)
 8003254:	61da      	str	r2, [r3, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8003256:	4b05      	ldr	r3, [pc, #20]	; (800326c <_vt_init+0x1c>)
 8003258:	4a05      	ldr	r2, [pc, #20]	; (8003270 <_vt_init+0x20>)
 800325a:	621a      	str	r2, [r3, #32]
  ch.vtlist.delta = (systime_t)-1;
 800325c:	4b03      	ldr	r3, [pc, #12]	; (800326c <_vt_init+0x1c>)
 800325e:	2201      	movs	r2, #1
 8003260:	4252      	negs	r2, r2
 8003262:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 8003264:	4b01      	ldr	r3, [pc, #4]	; (800326c <_vt_init+0x1c>)
 8003266:	2200      	movs	r2, #0
 8003268:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800326a:	4770      	bx	lr
 800326c:	200004d8 	.word	0x200004d8
 8003270:	200004f4 	.word	0x200004f4
	...

08003280 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8003280:	b500      	push	{lr}
 8003282:	b089      	sub	sp, #36	; 0x24
 8003284:	9003      	str	r0, [sp, #12]
 8003286:	9102      	str	r1, [sp, #8]
 8003288:	9201      	str	r2, [sp, #4]
 800328a:	9300      	str	r3, [sp, #0]
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
 800328c:	f7ff fe38 	bl	8002f00 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8003290:	9b03      	ldr	r3, [sp, #12]
 8003292:	2b00      	cmp	r3, #0
 8003294:	d005      	beq.n	80032a2 <chVTDoSetI+0x22>
 8003296:	9b01      	ldr	r3, [sp, #4]
 8003298:	2b00      	cmp	r3, #0
 800329a:	d002      	beq.n	80032a2 <chVTDoSetI+0x22>
 800329c:	9b02      	ldr	r3, [sp, #8]
 800329e:	2b00      	cmp	r3, #0
 80032a0:	d103      	bne.n	80032aa <chVTDoSetI+0x2a>
 80032a2:	4b42      	ldr	r3, [pc, #264]	; (80033ac <chVTDoSetI+0x12c>)
 80032a4:	0018      	movs	r0, r3
 80032a6:	f7ff fd3b 	bl	8002d20 <chSysHalt>

  vtp->par = par;
 80032aa:	9b03      	ldr	r3, [sp, #12]
 80032ac:	9a00      	ldr	r2, [sp, #0]
 80032ae:	611a      	str	r2, [r3, #16]
  vtp->func = vtfunc;
 80032b0:	9b03      	ldr	r3, [sp, #12]
 80032b2:	9a01      	ldr	r2, [sp, #4]
 80032b4:	60da      	str	r2, [r3, #12]

#if CH_CFG_ST_TIMEDELTA > 0
  {
    systime_t now = chVTGetSystemTimeX();
 80032b6:	f7ff ffc3 	bl	8003240 <chVTGetSystemTimeX.lto_priv.255>
 80032ba:	0003      	movs	r3, r0
 80032bc:	9305      	str	r3, [sp, #20]

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
 80032be:	9b02      	ldr	r3, [sp, #8]
 80032c0:	2b01      	cmp	r3, #1
 80032c2:	d801      	bhi.n	80032c8 <chVTDoSetI+0x48>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 80032c4:	2302      	movs	r3, #2
 80032c6:	9302      	str	r3, [sp, #8]
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80032c8:	4b39      	ldr	r3, [pc, #228]	; (80033b0 <chVTDoSetI+0x130>)
 80032ca:	69da      	ldr	r2, [r3, #28]
 80032cc:	4b39      	ldr	r3, [pc, #228]	; (80033b4 <chVTDoSetI+0x134>)
 80032ce:	429a      	cmp	r2, r3
 80032d0:	d119      	bne.n	8003306 <chVTDoSetI+0x86>

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
 80032d2:	4b37      	ldr	r3, [pc, #220]	; (80033b0 <chVTDoSetI+0x130>)
 80032d4:	9a05      	ldr	r2, [sp, #20]
 80032d6:	629a      	str	r2, [r3, #40]	; 0x28
      ch.vtlist.next = vtp;
 80032d8:	4b35      	ldr	r3, [pc, #212]	; (80033b0 <chVTDoSetI+0x130>)
 80032da:	9a03      	ldr	r2, [sp, #12]
 80032dc:	61da      	str	r2, [r3, #28]
      ch.vtlist.prev = vtp;
 80032de:	4b34      	ldr	r3, [pc, #208]	; (80033b0 <chVTDoSetI+0x130>)
 80032e0:	9a03      	ldr	r2, [sp, #12]
 80032e2:	621a      	str	r2, [r3, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 80032e4:	9b03      	ldr	r3, [sp, #12]
 80032e6:	4a33      	ldr	r2, [pc, #204]	; (80033b4 <chVTDoSetI+0x134>)
 80032e8:	601a      	str	r2, [r3, #0]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 80032ea:	9b03      	ldr	r3, [sp, #12]
 80032ec:	4a31      	ldr	r2, [pc, #196]	; (80033b4 <chVTDoSetI+0x134>)
 80032ee:	605a      	str	r2, [r3, #4]
      vtp->delta = delay;
 80032f0:	9b03      	ldr	r3, [sp, #12]
 80032f2:	9a02      	ldr	r2, [sp, #8]
 80032f4:	609a      	str	r2, [r3, #8]

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.lasttime + delay);
 80032f6:	4b2e      	ldr	r3, [pc, #184]	; (80033b0 <chVTDoSetI+0x130>)
 80032f8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80032fa:	9b02      	ldr	r3, [sp, #8]
 80032fc:	18d3      	adds	r3, r2, r3
 80032fe:	0018      	movs	r0, r3
 8003300:	f7ff ff6e 	bl	80031e0 <port_timer_start_alarm>
 8003304:	e04f      	b.n	80033a6 <chVTDoSetI+0x126>

      return;
    }

    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;
 8003306:	4b2a      	ldr	r3, [pc, #168]	; (80033b0 <chVTDoSetI+0x130>)
 8003308:	69db      	ldr	r3, [r3, #28]
 800330a:	9307      	str	r3, [sp, #28]

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = now - ch.vtlist.lasttime + delay;
 800330c:	4b28      	ldr	r3, [pc, #160]	; (80033b0 <chVTDoSetI+0x130>)
 800330e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003310:	9a05      	ldr	r2, [sp, #20]
 8003312:	1ad2      	subs	r2, r2, r3
 8003314:	9b02      	ldr	r3, [sp, #8]
 8003316:	18d3      	adds	r3, r2, r3
 8003318:	9306      	str	r3, [sp, #24]

    if (delta < now - ch.vtlist.lasttime) {
 800331a:	4b25      	ldr	r3, [pc, #148]	; (80033b0 <chVTDoSetI+0x130>)
 800331c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800331e:	9a05      	ldr	r2, [sp, #20]
 8003320:	1ad2      	subs	r2, r2, r3
 8003322:	9b06      	ldr	r3, [sp, #24]
 8003324:	429a      	cmp	r2, r3
 8003326:	d908      	bls.n	800333a <chVTDoSetI+0xba>
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 8003328:	9b07      	ldr	r3, [sp, #28]
 800332a:	689b      	ldr	r3, [r3, #8]
 800332c:	9a06      	ldr	r2, [sp, #24]
 800332e:	1ad3      	subs	r3, r2, r3
 8003330:	9306      	str	r3, [sp, #24]
      p = p->next;
 8003332:	9b07      	ldr	r3, [sp, #28]
 8003334:	681b      	ldr	r3, [r3, #0]
 8003336:	9307      	str	r3, [sp, #28]
 8003338:	e014      	b.n	8003364 <chVTDoSetI+0xe4>
    }
    else if (delta < p->delta) {
 800333a:	9b07      	ldr	r3, [sp, #28]
 800333c:	689a      	ldr	r2, [r3, #8]
 800333e:	9b06      	ldr	r3, [sp, #24]
 8003340:	429a      	cmp	r2, r3
 8003342:	d90f      	bls.n	8003364 <chVTDoSetI+0xe4>
     /* A small delay that will become the first element in the delta list
        and next deadline.*/
      port_timer_set_alarm(ch.vtlist.lasttime + delta);
 8003344:	4b1a      	ldr	r3, [pc, #104]	; (80033b0 <chVTDoSetI+0x130>)
 8003346:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8003348:	9b06      	ldr	r3, [sp, #24]
 800334a:	18d3      	adds	r3, r2, r3
 800334c:	0018      	movs	r0, r3
 800334e:	f7ff ff5f 	bl	8003210 <port_timer_set_alarm.lto_priv.260>
 8003352:	e007      	b.n	8003364 <chVTDoSetI+0xe4>
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    delta -= p->delta;
 8003354:	9b07      	ldr	r3, [sp, #28]
 8003356:	689b      	ldr	r3, [r3, #8]
 8003358:	9a06      	ldr	r2, [sp, #24]
 800335a:	1ad3      	subs	r3, r2, r3
 800335c:	9306      	str	r3, [sp, #24]
    p = p->next;
 800335e:	9b07      	ldr	r3, [sp, #28]
 8003360:	681b      	ldr	r3, [r3, #0]
 8003362:	9307      	str	r3, [sp, #28]
  while (p->delta < delta) {
 8003364:	9b07      	ldr	r3, [sp, #28]
 8003366:	689a      	ldr	r2, [r3, #8]
 8003368:	9b06      	ldr	r3, [sp, #24]
 800336a:	429a      	cmp	r2, r3
 800336c:	d3f2      	bcc.n	8003354 <chVTDoSetI+0xd4>
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
 800336e:	9b03      	ldr	r3, [sp, #12]
 8003370:	9a07      	ldr	r2, [sp, #28]
 8003372:	601a      	str	r2, [r3, #0]
  vtp->prev = vtp->next->prev;
 8003374:	9b03      	ldr	r3, [sp, #12]
 8003376:	681b      	ldr	r3, [r3, #0]
 8003378:	685a      	ldr	r2, [r3, #4]
 800337a:	9b03      	ldr	r3, [sp, #12]
 800337c:	605a      	str	r2, [r3, #4]
  vtp->prev->next = vtp;
 800337e:	9b03      	ldr	r3, [sp, #12]
 8003380:	685b      	ldr	r3, [r3, #4]
 8003382:	9a03      	ldr	r2, [sp, #12]
 8003384:	601a      	str	r2, [r3, #0]
  p->prev = vtp;
 8003386:	9b07      	ldr	r3, [sp, #28]
 8003388:	9a03      	ldr	r2, [sp, #12]
 800338a:	605a      	str	r2, [r3, #4]
  vtp->delta = delta
 800338c:	9b03      	ldr	r3, [sp, #12]
 800338e:	9a06      	ldr	r2, [sp, #24]
 8003390:	609a      	str	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 8003392:	9b07      	ldr	r3, [sp, #28]
 8003394:	689a      	ldr	r2, [r3, #8]
 8003396:	9b06      	ldr	r3, [sp, #24]
 8003398:	1ad2      	subs	r2, r2, r3
 800339a:	9b07      	ldr	r3, [sp, #28]
 800339c:	609a      	str	r2, [r3, #8]
  ch.vtlist.delta = (systime_t)-1;
 800339e:	4b04      	ldr	r3, [pc, #16]	; (80033b0 <chVTDoSetI+0x130>)
 80033a0:	2201      	movs	r2, #1
 80033a2:	4252      	negs	r2, r2
 80033a4:	625a      	str	r2, [r3, #36]	; 0x24
}
 80033a6:	b009      	add	sp, #36	; 0x24
 80033a8:	bd00      	pop	{pc}
 80033aa:	46c0      	nop			; (mov r8, r8)
 80033ac:	08003814 	.word	0x08003814
 80033b0:	200004d8 	.word	0x200004d8
 80033b4:	200004f4 	.word	0x200004f4
	...

080033c0 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 80033c0:	b500      	push	{lr}
 80033c2:	b085      	sub	sp, #20
 80033c4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 80033c6:	f7ff fd9b 	bl	8002f00 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
 80033ca:	9b01      	ldr	r3, [sp, #4]
 80033cc:	2b00      	cmp	r3, #0
 80033ce:	d103      	bne.n	80033d8 <chVTDoResetI+0x18>
 80033d0:	4b36      	ldr	r3, [pc, #216]	; (80034ac <chVTDoResetI+0xec>)
 80033d2:	0018      	movs	r0, r3
 80033d4:	f7ff fca4 	bl	8002d20 <chSysHalt>
  chDbgAssert(vtp->func != NULL, "timer not set or already triggered");
 80033d8:	9b01      	ldr	r3, [sp, #4]
 80033da:	68db      	ldr	r3, [r3, #12]
 80033dc:	2b00      	cmp	r3, #0
 80033de:	d103      	bne.n	80033e8 <chVTDoResetI+0x28>
 80033e0:	4b32      	ldr	r3, [pc, #200]	; (80034ac <chVTDoResetI+0xec>)
 80033e2:	0018      	movs	r0, r3
 80033e4:	f7ff fc9c 	bl	8002d20 <chSysHalt>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 80033e8:	4b31      	ldr	r3, [pc, #196]	; (80034b0 <chVTDoResetI+0xf0>)
 80033ea:	69da      	ldr	r2, [r3, #28]
 80033ec:	9b01      	ldr	r3, [sp, #4]
 80033ee:	429a      	cmp	r2, r3
 80033f0:	d01b      	beq.n	800342a <chVTDoResetI+0x6a>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 80033f2:	9b01      	ldr	r3, [sp, #4]
 80033f4:	685b      	ldr	r3, [r3, #4]
 80033f6:	9a01      	ldr	r2, [sp, #4]
 80033f8:	6812      	ldr	r2, [r2, #0]
 80033fa:	601a      	str	r2, [r3, #0]
    vtp->next->prev = vtp->prev;
 80033fc:	9b01      	ldr	r3, [sp, #4]
 80033fe:	681b      	ldr	r3, [r3, #0]
 8003400:	9a01      	ldr	r2, [sp, #4]
 8003402:	6852      	ldr	r2, [r2, #4]
 8003404:	605a      	str	r2, [r3, #4]
    vtp->func = NULL;
 8003406:	9b01      	ldr	r3, [sp, #4]
 8003408:	2200      	movs	r2, #0
 800340a:	60da      	str	r2, [r3, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 800340c:	9b01      	ldr	r3, [sp, #4]
 800340e:	681a      	ldr	r2, [r3, #0]
 8003410:	4b28      	ldr	r3, [pc, #160]	; (80034b4 <chVTDoResetI+0xf4>)
 8003412:	429a      	cmp	r2, r3
 8003414:	d047      	beq.n	80034a6 <chVTDoResetI+0xe6>
      vtp->next->delta += vtp->delta;
 8003416:	9b01      	ldr	r3, [sp, #4]
 8003418:	681b      	ldr	r3, [r3, #0]
 800341a:	9a01      	ldr	r2, [sp, #4]
 800341c:	6812      	ldr	r2, [r2, #0]
 800341e:	6891      	ldr	r1, [r2, #8]
 8003420:	9a01      	ldr	r2, [sp, #4]
 8003422:	6892      	ldr	r2, [r2, #8]
 8003424:	188a      	adds	r2, r1, r2
 8003426:	609a      	str	r2, [r3, #8]
 8003428:	e03e      	b.n	80034a8 <chVTDoResetI+0xe8>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 800342a:	9b01      	ldr	r3, [sp, #4]
 800342c:	681a      	ldr	r2, [r3, #0]
 800342e:	4b20      	ldr	r3, [pc, #128]	; (80034b0 <chVTDoResetI+0xf0>)
 8003430:	61da      	str	r2, [r3, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8003432:	4b1f      	ldr	r3, [pc, #124]	; (80034b0 <chVTDoResetI+0xf0>)
 8003434:	69db      	ldr	r3, [r3, #28]
 8003436:	4a1f      	ldr	r2, [pc, #124]	; (80034b4 <chVTDoResetI+0xf4>)
 8003438:	605a      	str	r2, [r3, #4]
  vtp->func = NULL;
 800343a:	9b01      	ldr	r3, [sp, #4]
 800343c:	2200      	movs	r2, #0
 800343e:	60da      	str	r2, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8003440:	4b1b      	ldr	r3, [pc, #108]	; (80034b0 <chVTDoResetI+0xf0>)
 8003442:	69da      	ldr	r2, [r3, #28]
 8003444:	4b1b      	ldr	r3, [pc, #108]	; (80034b4 <chVTDoResetI+0xf4>)
 8003446:	429a      	cmp	r2, r3
 8003448:	d102      	bne.n	8003450 <chVTDoResetI+0x90>
    port_timer_stop_alarm();
 800344a:	f7ff fed9 	bl	8003200 <port_timer_stop_alarm.lto_priv.262>
 800344e:	e02b      	b.n	80034a8 <chVTDoResetI+0xe8>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 8003450:	4b17      	ldr	r3, [pc, #92]	; (80034b0 <chVTDoResetI+0xf0>)
 8003452:	69db      	ldr	r3, [r3, #28]
 8003454:	4a16      	ldr	r2, [pc, #88]	; (80034b0 <chVTDoResetI+0xf0>)
 8003456:	69d2      	ldr	r2, [r2, #28]
 8003458:	6891      	ldr	r1, [r2, #8]
 800345a:	9a01      	ldr	r2, [sp, #4]
 800345c:	6892      	ldr	r2, [r2, #8]
 800345e:	188a      	adds	r2, r1, r2
 8003460:	609a      	str	r2, [r3, #8]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 8003462:	f7ff feed 	bl	8003240 <chVTGetSystemTimeX.lto_priv.255>
 8003466:	0002      	movs	r2, r0
 8003468:	4b11      	ldr	r3, [pc, #68]	; (80034b0 <chVTDoResetI+0xf0>)
 800346a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800346c:	1ad3      	subs	r3, r2, r3
 800346e:	9302      	str	r3, [sp, #8]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 8003470:	4b0f      	ldr	r3, [pc, #60]	; (80034b0 <chVTDoResetI+0xf0>)
 8003472:	69db      	ldr	r3, [r3, #28]
 8003474:	689a      	ldr	r2, [r3, #8]
 8003476:	9b02      	ldr	r3, [sp, #8]
 8003478:	429a      	cmp	r2, r3
 800347a:	d915      	bls.n	80034a8 <chVTDoResetI+0xe8>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 800347c:	4b0c      	ldr	r3, [pc, #48]	; (80034b0 <chVTDoResetI+0xf0>)
 800347e:	69db      	ldr	r3, [r3, #28]
 8003480:	689a      	ldr	r2, [r3, #8]
 8003482:	9b02      	ldr	r3, [sp, #8]
 8003484:	1ad3      	subs	r3, r2, r3
 8003486:	9303      	str	r3, [sp, #12]

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8003488:	9b03      	ldr	r3, [sp, #12]
 800348a:	2b01      	cmp	r3, #1
 800348c:	d801      	bhi.n	8003492 <chVTDoResetI+0xd2>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800348e:	2302      	movs	r3, #2
 8003490:	9303      	str	r3, [sp, #12]
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
 8003492:	4b07      	ldr	r3, [pc, #28]	; (80034b0 <chVTDoResetI+0xf0>)
 8003494:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8003496:	9b02      	ldr	r3, [sp, #8]
 8003498:	18d2      	adds	r2, r2, r3
 800349a:	9b03      	ldr	r3, [sp, #12]
 800349c:	18d3      	adds	r3, r2, r3
 800349e:	0018      	movs	r0, r3
 80034a0:	f7ff feb6 	bl	8003210 <port_timer_set_alarm.lto_priv.260>
 80034a4:	e000      	b.n	80034a8 <chVTDoResetI+0xe8>
      vtp->next->delta += vtp->delta;
 80034a6:	46c0      	nop			; (mov r8, r8)
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80034a8:	b005      	add	sp, #20
 80034aa:	bd00      	pop	{pc}
 80034ac:	08003820 	.word	0x08003820
 80034b0:	200004d8 	.word	0x200004d8
 80034b4:	200004f4 	.word	0x200004f4
	...

080034c0 <port_lock.lto_priv.252>:
  __ASM volatile ("cpsid i" : : : "memory");
 80034c0:	b672      	cpsid	i
}
 80034c2:	4770      	bx	lr
	...

080034d0 <port_unlock.lto_priv.248>:
  __ASM volatile ("cpsie i" : : : "memory");
 80034d0:	b662      	cpsie	i
}
 80034d2:	4770      	bx	lr
	...

080034e0 <port_lock_from_isr.lto_priv.244>:
static inline void port_lock_from_isr(void) {
 80034e0:	b510      	push	{r4, lr}
  port_lock();
 80034e2:	f7ff ffed 	bl	80034c0 <port_lock.lto_priv.252>
}
 80034e6:	bd10      	pop	{r4, pc}
	...

080034f0 <port_unlock_from_isr.lto_priv.240>:
static inline void port_unlock_from_isr(void) {
 80034f0:	b510      	push	{r4, lr}
  port_unlock();
 80034f2:	f7ff ffed 	bl	80034d0 <port_unlock.lto_priv.248>
}
 80034f6:	bd10      	pop	{r4, pc}
	...

08003500 <queue_init>:
static inline void queue_init(threads_queue_t *tqp) {
 8003500:	b082      	sub	sp, #8
 8003502:	9001      	str	r0, [sp, #4]
  tqp->next = (thread_t *)tqp;
 8003504:	9b01      	ldr	r3, [sp, #4]
 8003506:	9a01      	ldr	r2, [sp, #4]
 8003508:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800350a:	9b01      	ldr	r3, [sp, #4]
 800350c:	9a01      	ldr	r2, [sp, #4]
 800350e:	605a      	str	r2, [r3, #4]
}
 8003510:	b002      	add	sp, #8
 8003512:	4770      	bx	lr
	...

08003520 <queue_fifo_remove.lto_priv.226>:
static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8003520:	b084      	sub	sp, #16
 8003522:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
 8003524:	9b01      	ldr	r3, [sp, #4]
 8003526:	681b      	ldr	r3, [r3, #0]
 8003528:	9303      	str	r3, [sp, #12]
  tqp->next             = tp->queue.next;
 800352a:	9b03      	ldr	r3, [sp, #12]
 800352c:	681a      	ldr	r2, [r3, #0]
 800352e:	9b01      	ldr	r3, [sp, #4]
 8003530:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8003532:	9b01      	ldr	r3, [sp, #4]
 8003534:	681b      	ldr	r3, [r3, #0]
 8003536:	9a01      	ldr	r2, [sp, #4]
 8003538:	605a      	str	r2, [r3, #4]
  return tp;
 800353a:	9b03      	ldr	r3, [sp, #12]
}
 800353c:	0018      	movs	r0, r3
 800353e:	b004      	add	sp, #16
 8003540:	4770      	bx	lr
 8003542:	46c0      	nop			; (mov r8, r8)
	...

08003550 <queue_dequeue.lto_priv.233>:
static inline thread_t *queue_dequeue(thread_t *tp) {
 8003550:	b082      	sub	sp, #8
 8003552:	9001      	str	r0, [sp, #4]
  tp->queue.prev->queue.next = tp->queue.next;
 8003554:	9b01      	ldr	r3, [sp, #4]
 8003556:	685b      	ldr	r3, [r3, #4]
 8003558:	9a01      	ldr	r2, [sp, #4]
 800355a:	6812      	ldr	r2, [r2, #0]
 800355c:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800355e:	9b01      	ldr	r3, [sp, #4]
 8003560:	681b      	ldr	r3, [r3, #0]
 8003562:	9a01      	ldr	r2, [sp, #4]
 8003564:	6852      	ldr	r2, [r2, #4]
 8003566:	605a      	str	r2, [r3, #4]
  return tp;
 8003568:	9b01      	ldr	r3, [sp, #4]
}
 800356a:	0018      	movs	r0, r3
 800356c:	b002      	add	sp, #8
 800356e:	4770      	bx	lr

08003570 <chSchIsRescRequiredI.lto_priv.230>:
 * @retval false        if rescheduling is not necessary.
 * @retval true         if there is a ready thread at higher priority.
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {
 8003570:	b510      	push	{r4, lr}

  chDbgCheckClassI();
 8003572:	f7ff fcc5 	bl	8002f00 <chDbgCheckClassI>

  return firstprio(&ch.rlist.queue) > currp->prio;
 8003576:	4b06      	ldr	r3, [pc, #24]	; (8003590 <chSchIsRescRequiredI.lto_priv.230+0x20>)
 8003578:	681b      	ldr	r3, [r3, #0]
 800357a:	689a      	ldr	r2, [r3, #8]
 800357c:	4b04      	ldr	r3, [pc, #16]	; (8003590 <chSchIsRescRequiredI.lto_priv.230+0x20>)
 800357e:	699b      	ldr	r3, [r3, #24]
 8003580:	689b      	ldr	r3, [r3, #8]
 8003582:	4293      	cmp	r3, r2
 8003584:	419b      	sbcs	r3, r3
 8003586:	425b      	negs	r3, r3
 8003588:	b2db      	uxtb	r3, r3
}
 800358a:	0018      	movs	r0, r3
 800358c:	bd10      	pop	{r4, pc}
 800358e:	46c0      	nop			; (mov r8, r8)
 8003590:	200004d8 	.word	0x200004d8
	...

080035a0 <chSysLockFromISR.lto_priv.235>:
static inline void chSysLockFromISR(void) {
 80035a0:	b510      	push	{r4, lr}
  port_lock_from_isr();
 80035a2:	f7ff ff9d 	bl	80034e0 <port_lock_from_isr.lto_priv.244>
  _dbg_check_lock_from_isr();
 80035a6:	f7ff fc3b 	bl	8002e20 <_dbg_check_lock_from_isr>
}
 80035aa:	bd10      	pop	{r4, pc}
 80035ac:	0000      	movs	r0, r0
	...

080035b0 <chSysUnlockFromISR.lto_priv.232>:
static inline void chSysUnlockFromISR(void) {
 80035b0:	b510      	push	{r4, lr}
  _dbg_check_unlock_from_isr();
 80035b2:	f7ff fc4d 	bl	8002e50 <_dbg_check_unlock_from_isr>
  port_unlock_from_isr();
 80035b6:	f7ff ff9b 	bl	80034f0 <port_unlock_from_isr.lto_priv.240>
}
 80035ba:	bd10      	pop	{r4, pc}
 80035bc:	0000      	movs	r0, r0
	...

080035c0 <chVTIsArmedI.lto_priv.231>:
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 80035c0:	b500      	push	{lr}
 80035c2:	b083      	sub	sp, #12
 80035c4:	9001      	str	r0, [sp, #4]
  chDbgCheckClassI();
 80035c6:	f7ff fc9b 	bl	8002f00 <chDbgCheckClassI>
  return (bool)(vtp->func != NULL);
 80035ca:	9b01      	ldr	r3, [sp, #4]
 80035cc:	68db      	ldr	r3, [r3, #12]
 80035ce:	1e5a      	subs	r2, r3, #1
 80035d0:	4193      	sbcs	r3, r2
 80035d2:	b2db      	uxtb	r3, r3
}
 80035d4:	0018      	movs	r0, r3
 80035d6:	b003      	add	sp, #12
 80035d8:	bd00      	pop	{pc}
 80035da:	46c0      	nop			; (mov r8, r8)
 80035dc:	0000      	movs	r0, r0
	...

080035e0 <chSemFastSignalI.lto_priv.234>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 80035e0:	b500      	push	{lr}
 80035e2:	b083      	sub	sp, #12
 80035e4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 80035e6:	f7ff fc8b 	bl	8002f00 <chDbgCheckClassI>

  sp->cnt++;
 80035ea:	9b01      	ldr	r3, [sp, #4]
 80035ec:	689b      	ldr	r3, [r3, #8]
 80035ee:	1c5a      	adds	r2, r3, #1
 80035f0:	9b01      	ldr	r3, [sp, #4]
 80035f2:	609a      	str	r2, [r3, #8]
}
 80035f4:	b003      	add	sp, #12
 80035f6:	bd00      	pop	{pc}
	...

08003600 <_scheduler_init>:
void _scheduler_init(void) {
 8003600:	b510      	push	{r4, lr}
  queue_init(&ch.rlist.queue);
 8003602:	4b07      	ldr	r3, [pc, #28]	; (8003620 <_scheduler_init+0x20>)
 8003604:	0018      	movs	r0, r3
 8003606:	f7ff ff7b 	bl	8003500 <queue_init>
  ch.rlist.prio = NOPRIO;
 800360a:	4b05      	ldr	r3, [pc, #20]	; (8003620 <_scheduler_init+0x20>)
 800360c:	2200      	movs	r2, #0
 800360e:	609a      	str	r2, [r3, #8]
  ch.rlist.newer = (thread_t *)&ch.rlist;
 8003610:	4b03      	ldr	r3, [pc, #12]	; (8003620 <_scheduler_init+0x20>)
 8003612:	4a03      	ldr	r2, [pc, #12]	; (8003620 <_scheduler_init+0x20>)
 8003614:	611a      	str	r2, [r3, #16]
  ch.rlist.older = (thread_t *)&ch.rlist;
 8003616:	4b02      	ldr	r3, [pc, #8]	; (8003620 <_scheduler_init+0x20>)
 8003618:	4a01      	ldr	r2, [pc, #4]	; (8003620 <_scheduler_init+0x20>)
 800361a:	615a      	str	r2, [r3, #20]
}
 800361c:	bd10      	pop	{r4, pc}
 800361e:	46c0      	nop			; (mov r8, r8)
 8003620:	200004d8 	.word	0x200004d8
	...

08003630 <chSchReadyI>:
thread_t *chSchReadyI(thread_t *tp) {
 8003630:	b500      	push	{lr}
 8003632:	b085      	sub	sp, #20
 8003634:	9001      	str	r0, [sp, #4]
  chDbgCheckClassI();
 8003636:	f7ff fc63 	bl	8002f00 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800363a:	9b01      	ldr	r3, [sp, #4]
 800363c:	2b00      	cmp	r3, #0
 800363e:	d103      	bne.n	8003648 <chSchReadyI+0x18>
 8003640:	4b19      	ldr	r3, [pc, #100]	; (80036a8 <chSchReadyI+0x78>)
 8003642:	0018      	movs	r0, r3
 8003644:	f7ff fb6c 	bl	8002d20 <chSysHalt>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8003648:	9b01      	ldr	r3, [sp, #4]
 800364a:	2220      	movs	r2, #32
 800364c:	5c9b      	ldrb	r3, [r3, r2]
 800364e:	2b00      	cmp	r3, #0
 8003650:	d004      	beq.n	800365c <chSchReadyI+0x2c>
 8003652:	9b01      	ldr	r3, [sp, #4]
 8003654:	2220      	movs	r2, #32
 8003656:	5c9b      	ldrb	r3, [r3, r2]
 8003658:	2b0f      	cmp	r3, #15
 800365a:	d103      	bne.n	8003664 <chSchReadyI+0x34>
 800365c:	4b12      	ldr	r3, [pc, #72]	; (80036a8 <chSchReadyI+0x78>)
 800365e:	0018      	movs	r0, r3
 8003660:	f7ff fb5e 	bl	8002d20 <chSysHalt>
  tp->state = CH_STATE_READY;
 8003664:	9b01      	ldr	r3, [sp, #4]
 8003666:	2220      	movs	r2, #32
 8003668:	2100      	movs	r1, #0
 800366a:	5499      	strb	r1, [r3, r2]
  cp = (thread_t *)&ch.rlist.queue;
 800366c:	4b0f      	ldr	r3, [pc, #60]	; (80036ac <chSchReadyI+0x7c>)
 800366e:	9303      	str	r3, [sp, #12]
    cp = cp->queue.next;
 8003670:	9b03      	ldr	r3, [sp, #12]
 8003672:	681b      	ldr	r3, [r3, #0]
 8003674:	9303      	str	r3, [sp, #12]
  } while (cp->prio >= tp->prio);
 8003676:	9b03      	ldr	r3, [sp, #12]
 8003678:	689a      	ldr	r2, [r3, #8]
 800367a:	9b01      	ldr	r3, [sp, #4]
 800367c:	689b      	ldr	r3, [r3, #8]
 800367e:	429a      	cmp	r2, r3
 8003680:	d2f6      	bcs.n	8003670 <chSchReadyI+0x40>
  tp->queue.next             = cp;
 8003682:	9b01      	ldr	r3, [sp, #4]
 8003684:	9a03      	ldr	r2, [sp, #12]
 8003686:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 8003688:	9b03      	ldr	r3, [sp, #12]
 800368a:	685a      	ldr	r2, [r3, #4]
 800368c:	9b01      	ldr	r3, [sp, #4]
 800368e:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8003690:	9b01      	ldr	r3, [sp, #4]
 8003692:	685b      	ldr	r3, [r3, #4]
 8003694:	9a01      	ldr	r2, [sp, #4]
 8003696:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 8003698:	9b03      	ldr	r3, [sp, #12]
 800369a:	9a01      	ldr	r2, [sp, #4]
 800369c:	605a      	str	r2, [r3, #4]
  return tp;
 800369e:	9b01      	ldr	r3, [sp, #4]
}
 80036a0:	0018      	movs	r0, r3
 80036a2:	b005      	add	sp, #20
 80036a4:	bd00      	pop	{pc}
 80036a6:	46c0      	nop			; (mov r8, r8)
 80036a8:	08003830 	.word	0x08003830
 80036ac:	200004d8 	.word	0x200004d8
