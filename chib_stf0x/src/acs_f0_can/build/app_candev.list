
build/app_candev.elf:     file format elf32-littlearm


Disassembly of section .text:

080000c0 <Reset_Handler>:
 80000c0:	b672      	cpsid	i
 80000c2:	4824      	ldr	r0, [pc, #144]	; (8000154 <endfiniloop+0x6>)
 80000c4:	f380 8808 	msr	MSP, r0
 80000c8:	4823      	ldr	r0, [pc, #140]	; (8000158 <endfiniloop+0xa>)
 80000ca:	f380 8809 	msr	PSP, r0
 80000ce:	2002      	movs	r0, #2
 80000d0:	f380 8814 	msr	CONTROL, r0
 80000d4:	f3bf 8f6f 	isb	sy
 80000d8:	f002 f8a2 	bl	8002220 <__core_init>
 80000dc:	f000 fcd8 	bl	8000a90 <__early_init>
 80000e0:	481e      	ldr	r0, [pc, #120]	; (800015c <endfiniloop+0xe>)
 80000e2:	491f      	ldr	r1, [pc, #124]	; (8000160 <endfiniloop+0x12>)
 80000e4:	4a1b      	ldr	r2, [pc, #108]	; (8000154 <endfiniloop+0x6>)

080000e6 <msloop>:
 80000e6:	4291      	cmp	r1, r2
 80000e8:	da02      	bge.n	80000f0 <endmsloop>
 80000ea:	6008      	str	r0, [r1, #0]
 80000ec:	3104      	adds	r1, #4
 80000ee:	e7fa      	b.n	80000e6 <msloop>

080000f0 <endmsloop>:
 80000f0:	491c      	ldr	r1, [pc, #112]	; (8000164 <endfiniloop+0x16>)
 80000f2:	4a19      	ldr	r2, [pc, #100]	; (8000158 <endfiniloop+0xa>)

080000f4 <psloop>:
 80000f4:	4291      	cmp	r1, r2
 80000f6:	da02      	bge.n	80000fe <endpsloop>
 80000f8:	6008      	str	r0, [r1, #0]
 80000fa:	3104      	adds	r1, #4
 80000fc:	e7fa      	b.n	80000f4 <psloop>

080000fe <endpsloop>:
 80000fe:	491a      	ldr	r1, [pc, #104]	; (8000168 <endfiniloop+0x1a>)
 8000100:	4a1a      	ldr	r2, [pc, #104]	; (800016c <endfiniloop+0x1e>)
 8000102:	4b1b      	ldr	r3, [pc, #108]	; (8000170 <endfiniloop+0x22>)

08000104 <dloop>:
 8000104:	429a      	cmp	r2, r3
 8000106:	da04      	bge.n	8000112 <enddloop>
 8000108:	6808      	ldr	r0, [r1, #0]
 800010a:	6010      	str	r0, [r2, #0]
 800010c:	3104      	adds	r1, #4
 800010e:	3204      	adds	r2, #4
 8000110:	e7f8      	b.n	8000104 <dloop>

08000112 <enddloop>:
 8000112:	2000      	movs	r0, #0
 8000114:	4917      	ldr	r1, [pc, #92]	; (8000174 <endfiniloop+0x26>)
 8000116:	4a18      	ldr	r2, [pc, #96]	; (8000178 <endfiniloop+0x2a>)

08000118 <bloop>:
 8000118:	4291      	cmp	r1, r2
 800011a:	da02      	bge.n	8000122 <endbloop>
 800011c:	6008      	str	r0, [r1, #0]
 800011e:	3104      	adds	r1, #4
 8000120:	e7fa      	b.n	8000118 <bloop>

08000122 <endbloop>:
 8000122:	f002 f895 	bl	8002250 <__init_ram_areas>
 8000126:	f002 f883 	bl	8002230 <__late_init>
 800012a:	4c14      	ldr	r4, [pc, #80]	; (800017c <endfiniloop+0x2e>)
 800012c:	4d14      	ldr	r5, [pc, #80]	; (8000180 <endfiniloop+0x32>)

0800012e <initloop>:
 800012e:	42ac      	cmp	r4, r5
 8000130:	da03      	bge.n	800013a <endinitloop>
 8000132:	6821      	ldr	r1, [r4, #0]
 8000134:	4788      	blx	r1
 8000136:	3404      	adds	r4, #4
 8000138:	e7f9      	b.n	800012e <initloop>

0800013a <endinitloop>:
 800013a:	f000 fd59 	bl	8000bf0 <main>
 800013e:	4c11      	ldr	r4, [pc, #68]	; (8000184 <endfiniloop+0x36>)
 8000140:	4d11      	ldr	r5, [pc, #68]	; (8000188 <endfiniloop+0x3a>)

08000142 <finiloop>:
 8000142:	42ac      	cmp	r4, r5
 8000144:	da03      	bge.n	800014e <endfiniloop>
 8000146:	6821      	ldr	r1, [r4, #0]
 8000148:	4788      	blx	r1
 800014a:	3404      	adds	r4, #4
 800014c:	e7f9      	b.n	8000142 <finiloop>

0800014e <endfiniloop>:
 800014e:	490f      	ldr	r1, [pc, #60]	; (800018c <endfiniloop+0x3e>)
 8000150:	4708      	bx	r1
 8000152:	0000      	.short	0x0000
 8000154:	20000200 	.word	0x20000200
 8000158:	20000400 	.word	0x20000400
 800015c:	55555555 	.word	0x55555555
 8000160:	20000000 	.word	0x20000000
 8000164:	20000200 	.word	0x20000200
 8000168:	08003de0 	.word	0x08003de0
 800016c:	20000400 	.word	0x20000400
 8000170:	20000400 	.word	0x20000400
 8000174:	20000400 	.word	0x20000400
 8000178:	20001148 	.word	0x20001148
 800017c:	080000c0 	.word	0x080000c0
 8000180:	080000c0 	.word	0x080000c0
 8000184:	080000c0 	.word	0x080000c0
 8000188:	080000c0 	.word	0x080000c0
 800018c:	08002241 	.word	0x08002241

08000190 <_port_switch>:
 8000190:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000192:	4644      	mov	r4, r8
 8000194:	464d      	mov	r5, r9
 8000196:	4656      	mov	r6, sl
 8000198:	465f      	mov	r7, fp
 800019a:	b4f0      	push	{r4, r5, r6, r7}
 800019c:	466b      	mov	r3, sp
 800019e:	60cb      	str	r3, [r1, #12]
 80001a0:	68c3      	ldr	r3, [r0, #12]
 80001a2:	469d      	mov	sp, r3
 80001a4:	bcf0      	pop	{r4, r5, r6, r7}
 80001a6:	46a0      	mov	r8, r4
 80001a8:	46a9      	mov	r9, r5
 80001aa:	46b2      	mov	sl, r6
 80001ac:	46bb      	mov	fp, r7
 80001ae:	bdf0      	pop	{r4, r5, r6, r7, pc}

080001b0 <_port_thread_start>:
 80001b0:	f002 faae 	bl	8002710 <_dbg_check_unlock>
 80001b4:	b662      	cpsie	i
 80001b6:	1c28      	adds	r0, r5, #0
 80001b8:	47a0      	blx	r4
 80001ba:	2000      	movs	r0, #0
 80001bc:	f003 fbb0 	bl	8003920 <chThdExit>

080001c0 <_port_switch_from_isr>:
 80001c0:	f002 fa8e 	bl	80026e0 <_dbg_check_lock>
 80001c4:	f003 f8bc 	bl	8003340 <chSchDoReschedule>
 80001c8:	f002 faa2 	bl	8002710 <_dbg_check_unlock>

080001cc <_port_exit_from_isr>:
 80001cc:	4a01      	ldr	r2, [pc, #4]	; (80001d4 <_port_exit_from_isr+0x8>)
 80001ce:	4b02      	ldr	r3, [pc, #8]	; (80001d8 <_port_exit_from_isr+0xc>)
 80001d0:	6013      	str	r3, [r2, #0]
 80001d2:	e7fe      	b.n	80001d2 <_port_exit_from_isr+0x6>
 80001d4:	e000ed04 	.word	0xe000ed04
 80001d8:	80000000 	.word	0x80000000
 80001dc:	00000000 	.word	0x00000000

080001e0 <can_lld_tx_handler>:
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
static void can_lld_tx_handler(CANDriver *canp) {
 80001e0:	b500      	push	{lr}
 80001e2:	b085      	sub	sp, #20
 80001e4:	9001      	str	r0, [sp, #4]
  uint32_t tsr;
  eventflags_t flags;

  /* Clearing IRQ sources.*/
  tsr = canp->can->TSR;
 80001e6:	9b01      	ldr	r3, [sp, #4]
 80001e8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80001ea:	689b      	ldr	r3, [r3, #8]
 80001ec:	9302      	str	r3, [sp, #8]
  canp->can->TSR = tsr;
 80001ee:	9b01      	ldr	r3, [sp, #4]
 80001f0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80001f2:	9a02      	ldr	r2, [sp, #8]
 80001f4:	609a      	str	r2, [r3, #8]

  /* Flags to be signaled through the TX event source.*/
  flags = 0U;
 80001f6:	2300      	movs	r3, #0
 80001f8:	9303      	str	r3, [sp, #12]

  /* Checking mailbox 0.*/
  if ((tsr & CAN_TSR_RQCP0) != 0U) {
 80001fa:	9b02      	ldr	r3, [sp, #8]
 80001fc:	2201      	movs	r2, #1
 80001fe:	4013      	ands	r3, r2
 8000200:	d00d      	beq.n	800021e <can_lld_tx_handler+0x3e>
    if ((tsr & (CAN_TSR_ALST0 | CAN_TSR_TERR0)) != 0U) {
 8000202:	9b02      	ldr	r3, [sp, #8]
 8000204:	220c      	movs	r2, #12
 8000206:	4013      	ands	r3, r2
 8000208:	d005      	beq.n	8000216 <can_lld_tx_handler+0x36>
      flags |= CAN_MAILBOX_TO_MASK(1U) << 16U;
 800020a:	9b03      	ldr	r3, [sp, #12]
 800020c:	2280      	movs	r2, #128	; 0x80
 800020e:	0252      	lsls	r2, r2, #9
 8000210:	4313      	orrs	r3, r2
 8000212:	9303      	str	r3, [sp, #12]
 8000214:	e003      	b.n	800021e <can_lld_tx_handler+0x3e>
    }
    else {
      flags |= CAN_MAILBOX_TO_MASK(1U);
 8000216:	9b03      	ldr	r3, [sp, #12]
 8000218:	2201      	movs	r2, #1
 800021a:	4313      	orrs	r3, r2
 800021c:	9303      	str	r3, [sp, #12]
    }
  }

  /* Checking mailbox 1.*/
  if ((tsr & CAN_TSR_RQCP1) != 0U) {
 800021e:	9a02      	ldr	r2, [sp, #8]
 8000220:	2380      	movs	r3, #128	; 0x80
 8000222:	005b      	lsls	r3, r3, #1
 8000224:	4013      	ands	r3, r2
 8000226:	d00e      	beq.n	8000246 <can_lld_tx_handler+0x66>
    if ((tsr & (CAN_TSR_ALST1 | CAN_TSR_TERR1)) != 0U) {
 8000228:	9a02      	ldr	r2, [sp, #8]
 800022a:	23c0      	movs	r3, #192	; 0xc0
 800022c:	011b      	lsls	r3, r3, #4
 800022e:	4013      	ands	r3, r2
 8000230:	d005      	beq.n	800023e <can_lld_tx_handler+0x5e>
      flags |= CAN_MAILBOX_TO_MASK(2U) << 16U;
 8000232:	9b03      	ldr	r3, [sp, #12]
 8000234:	2280      	movs	r2, #128	; 0x80
 8000236:	0292      	lsls	r2, r2, #10
 8000238:	4313      	orrs	r3, r2
 800023a:	9303      	str	r3, [sp, #12]
 800023c:	e003      	b.n	8000246 <can_lld_tx_handler+0x66>
    }
    else {
      flags |= CAN_MAILBOX_TO_MASK(2U);
 800023e:	9b03      	ldr	r3, [sp, #12]
 8000240:	2202      	movs	r2, #2
 8000242:	4313      	orrs	r3, r2
 8000244:	9303      	str	r3, [sp, #12]
    }
  }

  /* Checking mailbox 2.*/
  if ((tsr & CAN_TSR_RQCP2) != 0U) {
 8000246:	9a02      	ldr	r2, [sp, #8]
 8000248:	2380      	movs	r3, #128	; 0x80
 800024a:	025b      	lsls	r3, r3, #9
 800024c:	4013      	ands	r3, r2
 800024e:	d00e      	beq.n	800026e <can_lld_tx_handler+0x8e>
    if ((tsr & (CAN_TSR_ALST2 | CAN_TSR_TERR2)) != 0U) {
 8000250:	9a02      	ldr	r2, [sp, #8]
 8000252:	23c0      	movs	r3, #192	; 0xc0
 8000254:	031b      	lsls	r3, r3, #12
 8000256:	4013      	ands	r3, r2
 8000258:	d005      	beq.n	8000266 <can_lld_tx_handler+0x86>
      flags |= CAN_MAILBOX_TO_MASK(3U) << 16U;
 800025a:	9b03      	ldr	r3, [sp, #12]
 800025c:	2280      	movs	r2, #128	; 0x80
 800025e:	02d2      	lsls	r2, r2, #11
 8000260:	4313      	orrs	r3, r2
 8000262:	9303      	str	r3, [sp, #12]
 8000264:	e003      	b.n	800026e <can_lld_tx_handler+0x8e>
    }
    else {
      flags |= CAN_MAILBOX_TO_MASK(3U);
 8000266:	9b03      	ldr	r3, [sp, #12]
 8000268:	2204      	movs	r2, #4
 800026a:	4313      	orrs	r3, r2
 800026c:	9303      	str	r3, [sp, #12]
    }
  }

  /* Signaling flags and waking up threads waiting for a transmission slot.*/
  osalSysLockFromISR();
 800026e:	f001 f86f 	bl	8001350 <osalSysLockFromISR.lto_priv.2>
  osalThreadDequeueAllI(&canp->txqueue, MSG_OK);
 8000272:	9b01      	ldr	r3, [sp, #4]
 8000274:	3308      	adds	r3, #8
 8000276:	2100      	movs	r1, #0
 8000278:	0018      	movs	r0, r3
 800027a:	f001 f889 	bl	8001390 <osalThreadDequeueAllI.lto_priv.61>
  osalEventBroadcastFlagsI(&canp->txempty_event, flags);
 800027e:	9b01      	ldr	r3, [sp, #4]
 8000280:	331c      	adds	r3, #28
 8000282:	9a03      	ldr	r2, [sp, #12]
 8000284:	0011      	movs	r1, r2
 8000286:	0018      	movs	r0, r3
 8000288:	f001 f892 	bl	80013b0 <osalEventBroadcastFlagsI.lto_priv.60>
  osalSysUnlockFromISR();
 800028c:	f001 f868 	bl	8001360 <osalSysUnlockFromISR.lto_priv.0>
}
 8000290:	b005      	add	sp, #20
 8000292:	bd00      	pop	{pc}
	...

080002a0 <can_lld_rx0_handler>:
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
static void can_lld_rx0_handler(CANDriver *canp) {
 80002a0:	b500      	push	{lr}
 80002a2:	b085      	sub	sp, #20
 80002a4:	9001      	str	r0, [sp, #4]
  uint32_t rf0r;

  rf0r = canp->can->RF0R;
 80002a6:	9b01      	ldr	r3, [sp, #4]
 80002a8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80002aa:	68db      	ldr	r3, [r3, #12]
 80002ac:	9303      	str	r3, [sp, #12]
  if ((rf0r & CAN_RF0R_FMP0) > 0) {
 80002ae:	9b03      	ldr	r3, [sp, #12]
 80002b0:	2203      	movs	r2, #3
 80002b2:	4013      	ands	r3, r2
 80002b4:	d017      	beq.n	80002e6 <can_lld_rx0_handler+0x46>
    /* No more receive events until the queue 0 has been emptied.*/
    canp->can->IER &= ~CAN_IER_FMPIE0;
 80002b6:	9b01      	ldr	r3, [sp, #4]
 80002b8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80002ba:	9a01      	ldr	r2, [sp, #4]
 80002bc:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80002be:	6952      	ldr	r2, [r2, #20]
 80002c0:	2102      	movs	r1, #2
 80002c2:	438a      	bics	r2, r1
 80002c4:	615a      	str	r2, [r3, #20]
    osalSysLockFromISR();
 80002c6:	f001 f843 	bl	8001350 <osalSysLockFromISR.lto_priv.2>
    osalThreadDequeueAllI(&canp->rxqueue, MSG_OK);
 80002ca:	9b01      	ldr	r3, [sp, #4]
 80002cc:	3310      	adds	r3, #16
 80002ce:	2100      	movs	r1, #0
 80002d0:	0018      	movs	r0, r3
 80002d2:	f001 f85d 	bl	8001390 <osalThreadDequeueAllI.lto_priv.61>
    osalEventBroadcastFlagsI(&canp->rxfull_event, CAN_MAILBOX_TO_MASK(1U));
 80002d6:	9b01      	ldr	r3, [sp, #4]
 80002d8:	3318      	adds	r3, #24
 80002da:	2101      	movs	r1, #1
 80002dc:	0018      	movs	r0, r3
 80002de:	f001 f867 	bl	80013b0 <osalEventBroadcastFlagsI.lto_priv.60>
    osalSysUnlockFromISR();
 80002e2:	f001 f83d 	bl	8001360 <osalSysUnlockFromISR.lto_priv.0>
  }
  if ((rf0r & CAN_RF0R_FOVR0) > 0) {
 80002e6:	9b03      	ldr	r3, [sp, #12]
 80002e8:	2210      	movs	r2, #16
 80002ea:	4013      	ands	r3, r2
 80002ec:	d00d      	beq.n	800030a <can_lld_rx0_handler+0x6a>
    /* Overflow events handling.*/
    canp->can->RF0R = CAN_RF0R_FOVR0;
 80002ee:	9b01      	ldr	r3, [sp, #4]
 80002f0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80002f2:	2210      	movs	r2, #16
 80002f4:	60da      	str	r2, [r3, #12]
    osalSysLockFromISR();
 80002f6:	f001 f82b 	bl	8001350 <osalSysLockFromISR.lto_priv.2>
    osalEventBroadcastFlagsI(&canp->error_event, CAN_OVERFLOW_ERROR);
 80002fa:	9b01      	ldr	r3, [sp, #4]
 80002fc:	3320      	adds	r3, #32
 80002fe:	2110      	movs	r1, #16
 8000300:	0018      	movs	r0, r3
 8000302:	f001 f855 	bl	80013b0 <osalEventBroadcastFlagsI.lto_priv.60>
    osalSysUnlockFromISR();
 8000306:	f001 f82b 	bl	8001360 <osalSysUnlockFromISR.lto_priv.0>
  }
}
 800030a:	b005      	add	sp, #20
 800030c:	bd00      	pop	{pc}
 800030e:	46c0      	nop			; (mov r8, r8)

08000310 <can_lld_rx1_handler>:
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
static void can_lld_rx1_handler(CANDriver *canp) {
 8000310:	b500      	push	{lr}
 8000312:	b085      	sub	sp, #20
 8000314:	9001      	str	r0, [sp, #4]
  uint32_t rf1r;

  rf1r = canp->can->RF1R;
 8000316:	9b01      	ldr	r3, [sp, #4]
 8000318:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800031a:	691b      	ldr	r3, [r3, #16]
 800031c:	9303      	str	r3, [sp, #12]
  if ((rf1r & CAN_RF1R_FMP1) > 0) {
 800031e:	9b03      	ldr	r3, [sp, #12]
 8000320:	2203      	movs	r2, #3
 8000322:	4013      	ands	r3, r2
 8000324:	d017      	beq.n	8000356 <can_lld_rx1_handler+0x46>
    /* No more receive events until the queue 0 has been emptied.*/
    canp->can->IER &= ~CAN_IER_FMPIE1;
 8000326:	9b01      	ldr	r3, [sp, #4]
 8000328:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800032a:	9a01      	ldr	r2, [sp, #4]
 800032c:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800032e:	6952      	ldr	r2, [r2, #20]
 8000330:	2110      	movs	r1, #16
 8000332:	438a      	bics	r2, r1
 8000334:	615a      	str	r2, [r3, #20]
    osalSysLockFromISR();
 8000336:	f001 f80b 	bl	8001350 <osalSysLockFromISR.lto_priv.2>
    osalThreadDequeueAllI(&canp->rxqueue, MSG_OK);
 800033a:	9b01      	ldr	r3, [sp, #4]
 800033c:	3310      	adds	r3, #16
 800033e:	2100      	movs	r1, #0
 8000340:	0018      	movs	r0, r3
 8000342:	f001 f825 	bl	8001390 <osalThreadDequeueAllI.lto_priv.61>
    osalEventBroadcastFlagsI(&canp->rxfull_event, CAN_MAILBOX_TO_MASK(2U));
 8000346:	9b01      	ldr	r3, [sp, #4]
 8000348:	3318      	adds	r3, #24
 800034a:	2102      	movs	r1, #2
 800034c:	0018      	movs	r0, r3
 800034e:	f001 f82f 	bl	80013b0 <osalEventBroadcastFlagsI.lto_priv.60>
    osalSysUnlockFromISR();
 8000352:	f001 f805 	bl	8001360 <osalSysUnlockFromISR.lto_priv.0>
  }
  if ((rf1r & CAN_RF1R_FOVR1) > 0) {
 8000356:	9b03      	ldr	r3, [sp, #12]
 8000358:	2210      	movs	r2, #16
 800035a:	4013      	ands	r3, r2
 800035c:	d00d      	beq.n	800037a <can_lld_rx1_handler+0x6a>
    /* Overflow events handling.*/
    canp->can->RF1R = CAN_RF1R_FOVR1;
 800035e:	9b01      	ldr	r3, [sp, #4]
 8000360:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000362:	2210      	movs	r2, #16
 8000364:	611a      	str	r2, [r3, #16]
    osalSysLockFromISR();
 8000366:	f000 fff3 	bl	8001350 <osalSysLockFromISR.lto_priv.2>
    osalEventBroadcastFlagsI(&canp->error_event, CAN_OVERFLOW_ERROR);
 800036a:	9b01      	ldr	r3, [sp, #4]
 800036c:	3320      	adds	r3, #32
 800036e:	2110      	movs	r1, #16
 8000370:	0018      	movs	r0, r3
 8000372:	f001 f81d 	bl	80013b0 <osalEventBroadcastFlagsI.lto_priv.60>
    osalSysUnlockFromISR();
 8000376:	f000 fff3 	bl	8001360 <osalSysUnlockFromISR.lto_priv.0>
  }
}
 800037a:	b005      	add	sp, #20
 800037c:	bd00      	pop	{pc}
 800037e:	46c0      	nop			; (mov r8, r8)

08000380 <can_lld_sce_handler>:
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
static void can_lld_sce_handler(CANDriver *canp) {
 8000380:	b500      	push	{lr}
 8000382:	b087      	sub	sp, #28
 8000384:	9001      	str	r0, [sp, #4]
  uint32_t msr;

  /* Clearing IRQ sources.*/
  msr = canp->can->MSR;
 8000386:	9b01      	ldr	r3, [sp, #4]
 8000388:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800038a:	685b      	ldr	r3, [r3, #4]
 800038c:	9305      	str	r3, [sp, #20]
  canp->can->MSR = msr;
 800038e:	9b01      	ldr	r3, [sp, #4]
 8000390:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000392:	9a05      	ldr	r2, [sp, #20]
 8000394:	605a      	str	r2, [r3, #4]

  /* Wakeup event.*/
#if CAN_USE_SLEEP_MODE
  if (msr & CAN_MSR_WKUI) {
 8000396:	9b05      	ldr	r3, [sp, #20]
 8000398:	2208      	movs	r2, #8
 800039a:	4013      	ands	r3, r2
 800039c:	d014      	beq.n	80003c8 <can_lld_sce_handler+0x48>
    canp->state = CAN_READY;
 800039e:	9b01      	ldr	r3, [sp, #4]
 80003a0:	2203      	movs	r2, #3
 80003a2:	701a      	strb	r2, [r3, #0]
    canp->can->MCR &= ~CAN_MCR_SLEEP;
 80003a4:	9b01      	ldr	r3, [sp, #4]
 80003a6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80003a8:	9a01      	ldr	r2, [sp, #4]
 80003aa:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80003ac:	6812      	ldr	r2, [r2, #0]
 80003ae:	2102      	movs	r1, #2
 80003b0:	438a      	bics	r2, r1
 80003b2:	601a      	str	r2, [r3, #0]
    osalSysLockFromISR();
 80003b4:	f000 ffcc 	bl	8001350 <osalSysLockFromISR.lto_priv.2>
    osalEventBroadcastFlagsI(&canp->wakeup_event, 0);
 80003b8:	9b01      	ldr	r3, [sp, #4]
 80003ba:	3328      	adds	r3, #40	; 0x28
 80003bc:	2100      	movs	r1, #0
 80003be:	0018      	movs	r0, r3
 80003c0:	f000 fff6 	bl	80013b0 <osalEventBroadcastFlagsI.lto_priv.60>
    osalSysUnlockFromISR();
 80003c4:	f000 ffcc 	bl	8001360 <osalSysUnlockFromISR.lto_priv.0>
  }
#endif /* CAN_USE_SLEEP_MODE */
  /* Error event.*/
  if (msr & CAN_MSR_ERRI) {
 80003c8:	9b05      	ldr	r3, [sp, #20]
 80003ca:	2204      	movs	r2, #4
 80003cc:	4013      	ands	r3, r2
 80003ce:	d013      	beq.n	80003f8 <can_lld_sce_handler+0x78>
    eventflags_t flags;
    uint32_t esr = canp->can->ESR;
 80003d0:	9b01      	ldr	r3, [sp, #4]
 80003d2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80003d4:	699b      	ldr	r3, [r3, #24]
 80003d6:	9304      	str	r3, [sp, #16]
#if STM32_CAN_REPORT_ALL_ERRORS
    flags = (eventflags_t)(esr & 7);
    if ((esr & CAN_ESR_LEC) > 0)
      flags |= CAN_FRAMING_ERROR;
#else
    flags = 0;
 80003d8:	2300      	movs	r3, #0
 80003da:	9303      	str	r3, [sp, #12]
#endif

    osalSysLockFromISR();
 80003dc:	f000 ffb8 	bl	8001350 <osalSysLockFromISR.lto_priv.2>
    /* The content of the ESR register is copied unchanged in the upper
       half word of the listener flags mask.*/
    osalEventBroadcastFlagsI(&canp->error_event,
 80003e0:	9b01      	ldr	r3, [sp, #4]
 80003e2:	3320      	adds	r3, #32
 80003e4:	0018      	movs	r0, r3
                             flags | (eventflags_t)(esr << 16U));
 80003e6:	9b04      	ldr	r3, [sp, #16]
 80003e8:	041a      	lsls	r2, r3, #16
    osalEventBroadcastFlagsI(&canp->error_event,
 80003ea:	9b03      	ldr	r3, [sp, #12]
 80003ec:	4313      	orrs	r3, r2
 80003ee:	0019      	movs	r1, r3
 80003f0:	f000 ffde 	bl	80013b0 <osalEventBroadcastFlagsI.lto_priv.60>
    osalSysUnlockFromISR();
 80003f4:	f000 ffb4 	bl	8001360 <osalSysUnlockFromISR.lto_priv.0>
  }
}
 80003f8:	b007      	add	sp, #28
 80003fa:	bd00      	pop	{pc}
 80003fc:	0000      	movs	r0, r0
	...

08000400 <VectorB8>:
/**
 * @brief   CAN1 unified interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN1_UNIFIED_HANDLER) {
 8000400:	b500      	push	{lr}
 8000402:	b083      	sub	sp, #12
 8000404:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 8000406:	9301      	str	r3, [sp, #4]
 8000408:	4b10      	ldr	r3, [pc, #64]	; (800044c <VectorB8+0x4c>)
 800040a:	0018      	movs	r0, r3
 800040c:	f002 faf8 	bl	8002a00 <_trace_isr_enter>
 8000410:	f002 f9c6 	bl	80027a0 <_dbg_check_enter_isr>

  can_lld_tx_handler(&CAND1);
 8000414:	4b0e      	ldr	r3, [pc, #56]	; (8000450 <VectorB8+0x50>)
 8000416:	0018      	movs	r0, r3
 8000418:	f7ff fee2 	bl	80001e0 <can_lld_tx_handler>
  can_lld_rx0_handler(&CAND1);
 800041c:	4b0c      	ldr	r3, [pc, #48]	; (8000450 <VectorB8+0x50>)
 800041e:	0018      	movs	r0, r3
 8000420:	f7ff ff3e 	bl	80002a0 <can_lld_rx0_handler>
  can_lld_rx1_handler(&CAND1);
 8000424:	4b0a      	ldr	r3, [pc, #40]	; (8000450 <VectorB8+0x50>)
 8000426:	0018      	movs	r0, r3
 8000428:	f7ff ff72 	bl	8000310 <can_lld_rx1_handler>
  can_lld_sce_handler(&CAND1);
 800042c:	4b08      	ldr	r3, [pc, #32]	; (8000450 <VectorB8+0x50>)
 800042e:	0018      	movs	r0, r3
 8000430:	f7ff ffa6 	bl	8000380 <can_lld_sce_handler>

  OSAL_IRQ_EPILOGUE();
 8000434:	f002 f9d4 	bl	80027e0 <_dbg_check_leave_isr>
 8000438:	4b04      	ldr	r3, [pc, #16]	; (800044c <VectorB8+0x4c>)
 800043a:	0018      	movs	r0, r3
 800043c:	f002 fb08 	bl	8002a50 <_trace_isr_leave>
 8000440:	9b01      	ldr	r3, [sp, #4]
 8000442:	0018      	movs	r0, r3
 8000444:	f001 f94c 	bl	80016e0 <_port_irq_epilogue>
}
 8000448:	b003      	add	sp, #12
 800044a:	bd00      	pop	{pc}
 800044c:	08003cac 	.word	0x08003cac
 8000450:	20000d88 	.word	0x20000d88
	...

08000460 <can_lld_init>:
/**
 * @brief   Low level CAN driver initialization.
 *
 * @notapi
 */
void can_lld_init(void) {
 8000460:	b510      	push	{r4, lr}

#if STM32_CAN_USE_CAN1
  /* Driver initialization.*/
  canObjectInit(&CAND1);
 8000462:	4b07      	ldr	r3, [pc, #28]	; (8000480 <can_lld_init+0x20>)
 8000464:	0018      	movs	r0, r3
 8000466:	f000 fca3 	bl	8000db0 <canObjectInit>
  CAND1.can = CAN1;
 800046a:	4b05      	ldr	r3, [pc, #20]	; (8000480 <can_lld_init+0x20>)
 800046c:	4a05      	ldr	r2, [pc, #20]	; (8000484 <can_lld_init+0x24>)
 800046e:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Filters initialization.*/
#if STM32_HAS_CAN2
  can_lld_set_filters(&CAND1, STM32_CAN_MAX_FILTERS / 2, 0, NULL);
#else
  can_lld_set_filters(&CAND1, STM32_CAN_MAX_FILTERS, 0, NULL);
 8000470:	4803      	ldr	r0, [pc, #12]	; (8000480 <can_lld_init+0x20>)
 8000472:	2300      	movs	r3, #0
 8000474:	2200      	movs	r2, #0
 8000476:	210e      	movs	r1, #14
 8000478:	f000 ffaa 	bl	80013d0 <can_lld_set_filters.lto_priv.58>
#if STM32_HAS_CAN3
#if STM32_CAN_USE_CAN3
  can_lld_set_filters(&CAND3, STM32_CAN3_MAX_FILTERS, 0, NULL);
#endif
#endif
}
 800047c:	bd10      	pop	{r4, pc}
 800047e:	46c0      	nop			; (mov r8, r8)
 8000480:	20000d88 	.word	0x20000d88
 8000484:	40006400 	.word	0x40006400
	...

08000490 <can_lld_start>:
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
void can_lld_start(CANDriver *canp) {
 8000490:	b500      	push	{lr}
 8000492:	b083      	sub	sp, #12
 8000494:	9001      	str	r0, [sp, #4]

  /* Clock activation.*/
#if STM32_CAN_USE_CAN1
  if (&CAND1 == canp) {
 8000496:	9a01      	ldr	r2, [sp, #4]
 8000498:	4b16      	ldr	r3, [pc, #88]	; (80004f4 <can_lld_start+0x64>)
 800049a:	429a      	cmp	r2, r3
 800049c:	d10a      	bne.n	80004b4 <can_lld_start+0x24>
#if defined(STM32_CAN1_UNIFIED_NUMBER)
    nvicEnableVector(STM32_CAN1_UNIFIED_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
 800049e:	2103      	movs	r1, #3
 80004a0:	201e      	movs	r0, #30
 80004a2:	f000 fdfd 	bl	80010a0 <nvicEnableVector>
    nvicEnableVector(STM32_CAN1_TX_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
    nvicEnableVector(STM32_CAN1_RX0_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
    nvicEnableVector(STM32_CAN1_RX1_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
    nvicEnableVector(STM32_CAN1_SCE_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
#endif
    rccEnableCAN1(FALSE);
 80004a6:	4b14      	ldr	r3, [pc, #80]	; (80004f8 <can_lld_start+0x68>)
 80004a8:	4a13      	ldr	r2, [pc, #76]	; (80004f8 <can_lld_start+0x68>)
 80004aa:	69d2      	ldr	r2, [r2, #28]
 80004ac:	2180      	movs	r1, #128	; 0x80
 80004ae:	0489      	lsls	r1, r1, #18
 80004b0:	430a      	orrs	r2, r1
 80004b2:	61da      	str	r2, [r3, #28]
    rccEnableCAN3(FALSE);
  }
#endif

  /* Configuring CAN. */
  canp->can->MCR = CAN_MCR_INRQ;
 80004b4:	9b01      	ldr	r3, [sp, #4]
 80004b6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80004b8:	2201      	movs	r2, #1
 80004ba:	601a      	str	r2, [r3, #0]
 80004bc:	e002      	b.n	80004c4 <can_lld_start+0x34>
  while ((canp->can->MSR & CAN_MSR_INAK) == 0)
    osalThreadSleepS(1);
 80004be:	2001      	movs	r0, #1
 80004c0:	f000 ff56 	bl	8001370 <osalThreadSleepS.lto_priv.59>
  while ((canp->can->MSR & CAN_MSR_INAK) == 0)
 80004c4:	9b01      	ldr	r3, [sp, #4]
 80004c6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80004c8:	685b      	ldr	r3, [r3, #4]
 80004ca:	2201      	movs	r2, #1
 80004cc:	4013      	ands	r3, r2
 80004ce:	d0f6      	beq.n	80004be <can_lld_start+0x2e>
  canp->can->BTR = canp->config->btr;
 80004d0:	9b01      	ldr	r3, [sp, #4]
 80004d2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80004d4:	9a01      	ldr	r2, [sp, #4]
 80004d6:	6852      	ldr	r2, [r2, #4]
 80004d8:	6852      	ldr	r2, [r2, #4]
 80004da:	61da      	str	r2, [r3, #28]
  canp->can->MCR = canp->config->mcr;
 80004dc:	9b01      	ldr	r3, [sp, #4]
 80004de:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80004e0:	9a01      	ldr	r2, [sp, #4]
 80004e2:	6852      	ldr	r2, [r2, #4]
 80004e4:	6812      	ldr	r2, [r2, #0]
 80004e6:	601a      	str	r2, [r3, #0]
  canp->can->IER = CAN_IER_TMEIE  | CAN_IER_FMPIE0 | CAN_IER_FMPIE1 |
                   CAN_IER_WKUIE  | CAN_IER_ERRIE  | CAN_IER_LECIE  |
                   CAN_IER_BOFIE  | CAN_IER_EPVIE  | CAN_IER_EWGIE  |
                   CAN_IER_FOVIE0 | CAN_IER_FOVIE1;
#else
  canp->can->IER = CAN_IER_TMEIE  | CAN_IER_FMPIE0 | CAN_IER_FMPIE1 |
 80004e8:	9b01      	ldr	r3, [sp, #4]
 80004ea:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80004ec:	4a03      	ldr	r2, [pc, #12]	; (80004fc <can_lld_start+0x6c>)
 80004ee:	615a      	str	r2, [r3, #20]
                   CAN_IER_WKUIE  | CAN_IER_ERRIE  |
                   CAN_IER_BOFIE  | CAN_IER_EPVIE  | CAN_IER_EWGIE  |
                   CAN_IER_FOVIE0 | CAN_IER_FOVIE1;
#endif
}
 80004f0:	b003      	add	sp, #12
 80004f2:	bd00      	pop	{pc}
 80004f4:	20000d88 	.word	0x20000d88
 80004f8:	40021000 	.word	0x40021000
 80004fc:	0001875b 	.word	0x0001875b

08000500 <can_lld_is_tx_empty>:
 * @retval FALSE        no space in the transmit queue.
 * @retval TRUE         transmit slot available.
 *
 * @notapi
 */
bool can_lld_is_tx_empty(CANDriver *canp, canmbx_t mailbox) {
 8000500:	b082      	sub	sp, #8
 8000502:	9001      	str	r0, [sp, #4]
 8000504:	9100      	str	r1, [sp, #0]

  switch (mailbox) {
 8000506:	9b00      	ldr	r3, [sp, #0]
 8000508:	2b01      	cmp	r3, #1
 800050a:	d00f      	beq.n	800052c <can_lld_is_tx_empty+0x2c>
 800050c:	d304      	bcc.n	8000518 <can_lld_is_tx_empty+0x18>
 800050e:	2b02      	cmp	r3, #2
 8000510:	d016      	beq.n	8000540 <can_lld_is_tx_empty+0x40>
 8000512:	2b03      	cmp	r3, #3
 8000514:	d01e      	beq.n	8000554 <can_lld_is_tx_empty+0x54>
 8000516:	e027      	b.n	8000568 <can_lld_is_tx_empty+0x68>
  case CAN_ANY_MAILBOX:
    return (canp->can->TSR & CAN_TSR_TME) != 0;
 8000518:	9b01      	ldr	r3, [sp, #4]
 800051a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800051c:	689a      	ldr	r2, [r3, #8]
 800051e:	23e0      	movs	r3, #224	; 0xe0
 8000520:	055b      	lsls	r3, r3, #21
 8000522:	4013      	ands	r3, r2
 8000524:	1e5a      	subs	r2, r3, #1
 8000526:	4193      	sbcs	r3, r2
 8000528:	b2db      	uxtb	r3, r3
 800052a:	e01e      	b.n	800056a <can_lld_is_tx_empty+0x6a>
  case 1:
    return (canp->can->TSR & CAN_TSR_TME0) != 0;
 800052c:	9b01      	ldr	r3, [sp, #4]
 800052e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000530:	689a      	ldr	r2, [r3, #8]
 8000532:	2380      	movs	r3, #128	; 0x80
 8000534:	04db      	lsls	r3, r3, #19
 8000536:	4013      	ands	r3, r2
 8000538:	1e5a      	subs	r2, r3, #1
 800053a:	4193      	sbcs	r3, r2
 800053c:	b2db      	uxtb	r3, r3
 800053e:	e014      	b.n	800056a <can_lld_is_tx_empty+0x6a>
  case 2:
    return (canp->can->TSR & CAN_TSR_TME1) != 0;
 8000540:	9b01      	ldr	r3, [sp, #4]
 8000542:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000544:	689a      	ldr	r2, [r3, #8]
 8000546:	2380      	movs	r3, #128	; 0x80
 8000548:	051b      	lsls	r3, r3, #20
 800054a:	4013      	ands	r3, r2
 800054c:	1e5a      	subs	r2, r3, #1
 800054e:	4193      	sbcs	r3, r2
 8000550:	b2db      	uxtb	r3, r3
 8000552:	e00a      	b.n	800056a <can_lld_is_tx_empty+0x6a>
  case 3:
    return (canp->can->TSR & CAN_TSR_TME2) != 0;
 8000554:	9b01      	ldr	r3, [sp, #4]
 8000556:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000558:	689a      	ldr	r2, [r3, #8]
 800055a:	2380      	movs	r3, #128	; 0x80
 800055c:	055b      	lsls	r3, r3, #21
 800055e:	4013      	ands	r3, r2
 8000560:	1e5a      	subs	r2, r3, #1
 8000562:	4193      	sbcs	r3, r2
 8000564:	b2db      	uxtb	r3, r3
 8000566:	e000      	b.n	800056a <can_lld_is_tx_empty+0x6a>
  default:
    return FALSE;
 8000568:	2300      	movs	r3, #0
  }
}
 800056a:	0018      	movs	r0, r3
 800056c:	b002      	add	sp, #8
 800056e:	4770      	bx	lr

08000570 <can_lld_transmit>:
 *
 * @notapi
 */
void can_lld_transmit(CANDriver *canp,
                      canmbx_t mailbox,
                      const CANTxFrame *ctfp) {
 8000570:	b086      	sub	sp, #24
 8000572:	9003      	str	r0, [sp, #12]
 8000574:	9102      	str	r1, [sp, #8]
 8000576:	9201      	str	r2, [sp, #4]
  uint32_t tir;
  CAN_TxMailBox_TypeDef *tmbp;

  /* Pointer to a free transmission mailbox.*/
  switch (mailbox) {
 8000578:	9b02      	ldr	r3, [sp, #8]
 800057a:	2b01      	cmp	r3, #1
 800057c:	d012      	beq.n	80005a4 <can_lld_transmit+0x34>
 800057e:	d304      	bcc.n	800058a <can_lld_transmit+0x1a>
 8000580:	2b02      	cmp	r3, #2
 8000582:	d015      	beq.n	80005b0 <can_lld_transmit+0x40>
 8000584:	2b03      	cmp	r3, #3
 8000586:	d019      	beq.n	80005bc <can_lld_transmit+0x4c>
 8000588:	e057      	b.n	800063a <can_lld_transmit+0xca>
  case CAN_ANY_MAILBOX:
    tmbp = &canp->can->sTxMailBox[(canp->can->TSR & CAN_TSR_CODE) >> 24];
 800058a:	9b03      	ldr	r3, [sp, #12]
 800058c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800058e:	9b03      	ldr	r3, [sp, #12]
 8000590:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000592:	689b      	ldr	r3, [r3, #8]
 8000594:	0e1b      	lsrs	r3, r3, #24
 8000596:	2103      	movs	r1, #3
 8000598:	400b      	ands	r3, r1
 800059a:	3318      	adds	r3, #24
 800059c:	011b      	lsls	r3, r3, #4
 800059e:	18d3      	adds	r3, r2, r3
 80005a0:	9304      	str	r3, [sp, #16]
 80005a2:	e010      	b.n	80005c6 <can_lld_transmit+0x56>
    break;
  case 1:
    tmbp = &canp->can->sTxMailBox[0];
 80005a4:	9b03      	ldr	r3, [sp, #12]
 80005a6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80005a8:	3381      	adds	r3, #129	; 0x81
 80005aa:	33ff      	adds	r3, #255	; 0xff
 80005ac:	9304      	str	r3, [sp, #16]
 80005ae:	e00a      	b.n	80005c6 <can_lld_transmit+0x56>
    break;
  case 2:
    tmbp = &canp->can->sTxMailBox[1];
 80005b0:	9b03      	ldr	r3, [sp, #12]
 80005b2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80005b4:	3391      	adds	r3, #145	; 0x91
 80005b6:	33ff      	adds	r3, #255	; 0xff
 80005b8:	9304      	str	r3, [sp, #16]
 80005ba:	e004      	b.n	80005c6 <can_lld_transmit+0x56>
    break;
  case 3:
    tmbp = &canp->can->sTxMailBox[2];
 80005bc:	9b03      	ldr	r3, [sp, #12]
 80005be:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80005c0:	33a1      	adds	r3, #161	; 0xa1
 80005c2:	33ff      	adds	r3, #255	; 0xff
 80005c4:	9304      	str	r3, [sp, #16]
  default:
    return;
  }

  /* Preparing the message.*/
  if (ctfp->IDE)
 80005c6:	9b01      	ldr	r3, [sp, #4]
 80005c8:	781b      	ldrb	r3, [r3, #0]
 80005ca:	2220      	movs	r2, #32
 80005cc:	4013      	ands	r3, r2
 80005ce:	b2db      	uxtb	r3, r3
 80005d0:	2b00      	cmp	r3, #0
 80005d2:	d00f      	beq.n	80005f4 <can_lld_transmit+0x84>
    tir = ((uint32_t)ctfp->EID << 3) | ((uint32_t)ctfp->RTR << 1) |
 80005d4:	9b01      	ldr	r3, [sp, #4]
 80005d6:	685b      	ldr	r3, [r3, #4]
 80005d8:	00db      	lsls	r3, r3, #3
 80005da:	08db      	lsrs	r3, r3, #3
 80005dc:	00da      	lsls	r2, r3, #3
 80005de:	9b01      	ldr	r3, [sp, #4]
 80005e0:	781b      	ldrb	r3, [r3, #0]
 80005e2:	06db      	lsls	r3, r3, #27
 80005e4:	0fdb      	lsrs	r3, r3, #31
 80005e6:	b2db      	uxtb	r3, r3
 80005e8:	005b      	lsls	r3, r3, #1
 80005ea:	4313      	orrs	r3, r2
 80005ec:	2204      	movs	r2, #4
 80005ee:	4313      	orrs	r3, r2
 80005f0:	9305      	str	r3, [sp, #20]
 80005f2:	e00d      	b.n	8000610 <can_lld_transmit+0xa0>
          CAN_TI0R_IDE;
  else
    tir = ((uint32_t)ctfp->SID << 21) | ((uint32_t)ctfp->RTR << 1);
 80005f4:	9b01      	ldr	r3, [sp, #4]
 80005f6:	889b      	ldrh	r3, [r3, #4]
 80005f8:	055b      	lsls	r3, r3, #21
 80005fa:	0d5b      	lsrs	r3, r3, #21
 80005fc:	b29b      	uxth	r3, r3
 80005fe:	055a      	lsls	r2, r3, #21
 8000600:	9b01      	ldr	r3, [sp, #4]
 8000602:	781b      	ldrb	r3, [r3, #0]
 8000604:	06db      	lsls	r3, r3, #27
 8000606:	0fdb      	lsrs	r3, r3, #31
 8000608:	b2db      	uxtb	r3, r3
 800060a:	005b      	lsls	r3, r3, #1
 800060c:	4313      	orrs	r3, r2
 800060e:	9305      	str	r3, [sp, #20]
  tmbp->TDTR = ctfp->DLC;
 8000610:	9b01      	ldr	r3, [sp, #4]
 8000612:	781b      	ldrb	r3, [r3, #0]
 8000614:	071b      	lsls	r3, r3, #28
 8000616:	0f1b      	lsrs	r3, r3, #28
 8000618:	b2db      	uxtb	r3, r3
 800061a:	001a      	movs	r2, r3
 800061c:	9b04      	ldr	r3, [sp, #16]
 800061e:	605a      	str	r2, [r3, #4]
  tmbp->TDLR = ctfp->data32[0];
 8000620:	9b01      	ldr	r3, [sp, #4]
 8000622:	689a      	ldr	r2, [r3, #8]
 8000624:	9b04      	ldr	r3, [sp, #16]
 8000626:	609a      	str	r2, [r3, #8]
  tmbp->TDHR = ctfp->data32[1];
 8000628:	9b01      	ldr	r3, [sp, #4]
 800062a:	68da      	ldr	r2, [r3, #12]
 800062c:	9b04      	ldr	r3, [sp, #16]
 800062e:	60da      	str	r2, [r3, #12]
  tmbp->TIR  = tir | CAN_TI0R_TXRQ;
 8000630:	9b05      	ldr	r3, [sp, #20]
 8000632:	2201      	movs	r2, #1
 8000634:	431a      	orrs	r2, r3
 8000636:	9b04      	ldr	r3, [sp, #16]
 8000638:	601a      	str	r2, [r3, #0]
}
 800063a:	b006      	add	sp, #24
 800063c:	4770      	bx	lr
 800063e:	46c0      	nop			; (mov r8, r8)

08000640 <can_lld_is_rx_nonempty>:
 * @retval FALSE        no space in the transmit queue.
 * @retval TRUE         transmit slot available.
 *
 * @notapi
 */
bool can_lld_is_rx_nonempty(CANDriver *canp, canmbx_t mailbox) {
 8000640:	b082      	sub	sp, #8
 8000642:	9001      	str	r0, [sp, #4]
 8000644:	9100      	str	r1, [sp, #0]

  switch (mailbox) {
 8000646:	9b00      	ldr	r3, [sp, #0]
 8000648:	2b01      	cmp	r3, #1
 800064a:	d017      	beq.n	800067c <can_lld_is_rx_nonempty+0x3c>
 800064c:	d302      	bcc.n	8000654 <can_lld_is_rx_nonempty+0x14>
 800064e:	2b02      	cmp	r3, #2
 8000650:	d01d      	beq.n	800068e <can_lld_is_rx_nonempty+0x4e>
 8000652:	e025      	b.n	80006a0 <can_lld_is_rx_nonempty+0x60>
  case CAN_ANY_MAILBOX:
    return ((canp->can->RF0R & CAN_RF0R_FMP0) != 0 ||
 8000654:	9b01      	ldr	r3, [sp, #4]
 8000656:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000658:	68db      	ldr	r3, [r3, #12]
 800065a:	2203      	movs	r2, #3
 800065c:	4013      	ands	r3, r2
 800065e:	d105      	bne.n	800066c <can_lld_is_rx_nonempty+0x2c>
            (canp->can->RF1R & CAN_RF1R_FMP1) != 0);
 8000660:	9b01      	ldr	r3, [sp, #4]
 8000662:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000664:	691b      	ldr	r3, [r3, #16]
 8000666:	2203      	movs	r2, #3
 8000668:	4013      	ands	r3, r2
    return ((canp->can->RF0R & CAN_RF0R_FMP0) != 0 ||
 800066a:	d001      	beq.n	8000670 <can_lld_is_rx_nonempty+0x30>
 800066c:	2301      	movs	r3, #1
 800066e:	e000      	b.n	8000672 <can_lld_is_rx_nonempty+0x32>
 8000670:	2300      	movs	r3, #0
 8000672:	1c1a      	adds	r2, r3, #0
 8000674:	2301      	movs	r3, #1
 8000676:	4013      	ands	r3, r2
 8000678:	b2db      	uxtb	r3, r3
 800067a:	e012      	b.n	80006a2 <can_lld_is_rx_nonempty+0x62>
  case 1:
    return (canp->can->RF0R & CAN_RF0R_FMP0) != 0;
 800067c:	9b01      	ldr	r3, [sp, #4]
 800067e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000680:	68db      	ldr	r3, [r3, #12]
 8000682:	2203      	movs	r2, #3
 8000684:	4013      	ands	r3, r2
 8000686:	1e5a      	subs	r2, r3, #1
 8000688:	4193      	sbcs	r3, r2
 800068a:	b2db      	uxtb	r3, r3
 800068c:	e009      	b.n	80006a2 <can_lld_is_rx_nonempty+0x62>
  case 2:
    return (canp->can->RF1R & CAN_RF1R_FMP1) != 0;
 800068e:	9b01      	ldr	r3, [sp, #4]
 8000690:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000692:	691b      	ldr	r3, [r3, #16]
 8000694:	2203      	movs	r2, #3
 8000696:	4013      	ands	r3, r2
 8000698:	1e5a      	subs	r2, r3, #1
 800069a:	4193      	sbcs	r3, r2
 800069c:	b2db      	uxtb	r3, r3
 800069e:	e000      	b.n	80006a2 <can_lld_is_rx_nonempty+0x62>
  default:
    return FALSE;
 80006a0:	2300      	movs	r3, #0
  }
}
 80006a2:	0018      	movs	r0, r3
 80006a4:	b002      	add	sp, #8
 80006a6:	4770      	bx	lr
	...

080006b0 <can_lld_receive>:
 *
 * @notapi
 */
void can_lld_receive(CANDriver *canp,
                     canmbx_t mailbox,
                     CANRxFrame *crfp) {
 80006b0:	b086      	sub	sp, #24
 80006b2:	9003      	str	r0, [sp, #12]
 80006b4:	9102      	str	r1, [sp, #8]
 80006b6:	9201      	str	r2, [sp, #4]
  uint32_t rir, rdtr;

  if (mailbox == CAN_ANY_MAILBOX) {
 80006b8:	9b02      	ldr	r3, [sp, #8]
 80006ba:	2b00      	cmp	r3, #0
 80006bc:	d111      	bne.n	80006e2 <can_lld_receive+0x32>
    if ((canp->can->RF0R & CAN_RF0R_FMP0) != 0)
 80006be:	9b03      	ldr	r3, [sp, #12]
 80006c0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80006c2:	68db      	ldr	r3, [r3, #12]
 80006c4:	2203      	movs	r2, #3
 80006c6:	4013      	ands	r3, r2
 80006c8:	d002      	beq.n	80006d0 <can_lld_receive+0x20>
      mailbox = 1;
 80006ca:	2301      	movs	r3, #1
 80006cc:	9302      	str	r3, [sp, #8]
 80006ce:	e008      	b.n	80006e2 <can_lld_receive+0x32>
    else if ((canp->can->RF1R & CAN_RF1R_FMP1) != 0)
 80006d0:	9b03      	ldr	r3, [sp, #12]
 80006d2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80006d4:	691b      	ldr	r3, [r3, #16]
 80006d6:	2203      	movs	r2, #3
 80006d8:	4013      	ands	r3, r2
 80006da:	d100      	bne.n	80006de <can_lld_receive+0x2e>
 80006dc:	e0c7      	b.n	800086e <can_lld_receive+0x1be>
      mailbox = 2;
 80006de:	2302      	movs	r3, #2
 80006e0:	9302      	str	r3, [sp, #8]
    else {
      /* Should not happen, do nothing.*/
      return;
    }
  }
  switch (mailbox) {
 80006e2:	9b02      	ldr	r3, [sp, #8]
 80006e4:	2b01      	cmp	r3, #1
 80006e6:	d002      	beq.n	80006ee <can_lld_receive+0x3e>
 80006e8:	2b02      	cmp	r3, #2
 80006ea:	d02d      	beq.n	8000748 <can_lld_receive+0x98>
 80006ec:	e0bf      	b.n	800086e <can_lld_receive+0x1be>
  case 1:
    /* Fetches the message.*/
    rir  = canp->can->sFIFOMailBox[0].RIR;
 80006ee:	9b03      	ldr	r3, [sp, #12]
 80006f0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80006f2:	23d8      	movs	r3, #216	; 0xd8
 80006f4:	005b      	lsls	r3, r3, #1
 80006f6:	58d3      	ldr	r3, [r2, r3]
 80006f8:	9305      	str	r3, [sp, #20]
    rdtr = canp->can->sFIFOMailBox[0].RDTR;
 80006fa:	9b03      	ldr	r3, [sp, #12]
 80006fc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80006fe:	23da      	movs	r3, #218	; 0xda
 8000700:	005b      	lsls	r3, r3, #1
 8000702:	58d3      	ldr	r3, [r2, r3]
 8000704:	9304      	str	r3, [sp, #16]
    crfp->data32[0] = canp->can->sFIFOMailBox[0].RDLR;
 8000706:	9b03      	ldr	r3, [sp, #12]
 8000708:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800070a:	23dc      	movs	r3, #220	; 0xdc
 800070c:	005b      	lsls	r3, r3, #1
 800070e:	58d2      	ldr	r2, [r2, r3]
 8000710:	9b01      	ldr	r3, [sp, #4]
 8000712:	611a      	str	r2, [r3, #16]
    crfp->data32[1] = canp->can->sFIFOMailBox[0].RDHR;
 8000714:	9b03      	ldr	r3, [sp, #12]
 8000716:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000718:	23de      	movs	r3, #222	; 0xde
 800071a:	005b      	lsls	r3, r3, #1
 800071c:	58d2      	ldr	r2, [r2, r3]
 800071e:	9b01      	ldr	r3, [sp, #4]
 8000720:	615a      	str	r2, [r3, #20]

    /* Releases the mailbox.*/
    canp->can->RF0R = CAN_RF0R_RFOM0;
 8000722:	9b03      	ldr	r3, [sp, #12]
 8000724:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000726:	2220      	movs	r2, #32
 8000728:	60da      	str	r2, [r3, #12]

    /* If the queue is empty re-enables the interrupt in order to generate
       events again.*/
    if ((canp->can->RF0R & CAN_RF0R_FMP0) == 0)
 800072a:	9b03      	ldr	r3, [sp, #12]
 800072c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800072e:	68db      	ldr	r3, [r3, #12]
 8000730:	2203      	movs	r2, #3
 8000732:	4013      	ands	r3, r2
 8000734:	d135      	bne.n	80007a2 <can_lld_receive+0xf2>
      canp->can->IER |= CAN_IER_FMPIE0;
 8000736:	9b03      	ldr	r3, [sp, #12]
 8000738:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800073a:	9a03      	ldr	r2, [sp, #12]
 800073c:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800073e:	6952      	ldr	r2, [r2, #20]
 8000740:	2102      	movs	r1, #2
 8000742:	430a      	orrs	r2, r1
 8000744:	615a      	str	r2, [r3, #20]
 8000746:	e02f      	b.n	80007a8 <can_lld_receive+0xf8>
    break;
  case 2:
    /* Fetches the message.*/
    rir  = canp->can->sFIFOMailBox[1].RIR;
 8000748:	9b03      	ldr	r3, [sp, #12]
 800074a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800074c:	23e0      	movs	r3, #224	; 0xe0
 800074e:	005b      	lsls	r3, r3, #1
 8000750:	58d3      	ldr	r3, [r2, r3]
 8000752:	9305      	str	r3, [sp, #20]
    rdtr = canp->can->sFIFOMailBox[1].RDTR;
 8000754:	9b03      	ldr	r3, [sp, #12]
 8000756:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000758:	23e2      	movs	r3, #226	; 0xe2
 800075a:	005b      	lsls	r3, r3, #1
 800075c:	58d3      	ldr	r3, [r2, r3]
 800075e:	9304      	str	r3, [sp, #16]
    crfp->data32[0] = canp->can->sFIFOMailBox[1].RDLR;
 8000760:	9b03      	ldr	r3, [sp, #12]
 8000762:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000764:	23e4      	movs	r3, #228	; 0xe4
 8000766:	005b      	lsls	r3, r3, #1
 8000768:	58d2      	ldr	r2, [r2, r3]
 800076a:	9b01      	ldr	r3, [sp, #4]
 800076c:	611a      	str	r2, [r3, #16]
    crfp->data32[1] = canp->can->sFIFOMailBox[1].RDHR;
 800076e:	9b03      	ldr	r3, [sp, #12]
 8000770:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000772:	23e6      	movs	r3, #230	; 0xe6
 8000774:	005b      	lsls	r3, r3, #1
 8000776:	58d2      	ldr	r2, [r2, r3]
 8000778:	9b01      	ldr	r3, [sp, #4]
 800077a:	615a      	str	r2, [r3, #20]

    /* Releases the mailbox.*/
    canp->can->RF1R = CAN_RF1R_RFOM1;
 800077c:	9b03      	ldr	r3, [sp, #12]
 800077e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000780:	2220      	movs	r2, #32
 8000782:	611a      	str	r2, [r3, #16]

    /* If the queue is empty re-enables the interrupt in order to generate
       events again.*/
    if ((canp->can->RF1R & CAN_RF1R_FMP1) == 0)
 8000784:	9b03      	ldr	r3, [sp, #12]
 8000786:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000788:	691b      	ldr	r3, [r3, #16]
 800078a:	2203      	movs	r2, #3
 800078c:	4013      	ands	r3, r2
 800078e:	d10a      	bne.n	80007a6 <can_lld_receive+0xf6>
      canp->can->IER |= CAN_IER_FMPIE1;
 8000790:	9b03      	ldr	r3, [sp, #12]
 8000792:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000794:	9a03      	ldr	r2, [sp, #12]
 8000796:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8000798:	6952      	ldr	r2, [r2, #20]
 800079a:	2110      	movs	r1, #16
 800079c:	430a      	orrs	r2, r1
 800079e:	615a      	str	r2, [r3, #20]
 80007a0:	e002      	b.n	80007a8 <can_lld_receive+0xf8>
      canp->can->IER |= CAN_IER_FMPIE0;
 80007a2:	46c0      	nop			; (mov r8, r8)
 80007a4:	e000      	b.n	80007a8 <can_lld_receive+0xf8>
      canp->can->IER |= CAN_IER_FMPIE1;
 80007a6:	46c0      	nop			; (mov r8, r8)
    /* Should not happen, do nothing.*/
    return;
  }

  /* Decodes the various fields in the RX frame.*/
  crfp->RTR = (rir & CAN_RI0R_RTR) >> 1;
 80007a8:	9b05      	ldr	r3, [sp, #20]
 80007aa:	085b      	lsrs	r3, r3, #1
 80007ac:	b2db      	uxtb	r3, r3
 80007ae:	1c1a      	adds	r2, r3, #0
 80007b0:	2301      	movs	r3, #1
 80007b2:	4013      	ands	r3, r2
 80007b4:	b2da      	uxtb	r2, r3
 80007b6:	9b01      	ldr	r3, [sp, #4]
 80007b8:	2101      	movs	r1, #1
 80007ba:	400a      	ands	r2, r1
 80007bc:	0110      	lsls	r0, r2, #4
 80007be:	791a      	ldrb	r2, [r3, #4]
 80007c0:	2110      	movs	r1, #16
 80007c2:	438a      	bics	r2, r1
 80007c4:	1c11      	adds	r1, r2, #0
 80007c6:	1c02      	adds	r2, r0, #0
 80007c8:	430a      	orrs	r2, r1
 80007ca:	711a      	strb	r2, [r3, #4]
  crfp->IDE = (rir & CAN_RI0R_IDE) >> 2;
 80007cc:	9b05      	ldr	r3, [sp, #20]
 80007ce:	089b      	lsrs	r3, r3, #2
 80007d0:	b2db      	uxtb	r3, r3
 80007d2:	1c1a      	adds	r2, r3, #0
 80007d4:	2301      	movs	r3, #1
 80007d6:	4013      	ands	r3, r2
 80007d8:	b2da      	uxtb	r2, r3
 80007da:	9b01      	ldr	r3, [sp, #4]
 80007dc:	2101      	movs	r1, #1
 80007de:	400a      	ands	r2, r1
 80007e0:	0150      	lsls	r0, r2, #5
 80007e2:	791a      	ldrb	r2, [r3, #4]
 80007e4:	2120      	movs	r1, #32
 80007e6:	438a      	bics	r2, r1
 80007e8:	1c11      	adds	r1, r2, #0
 80007ea:	1c02      	adds	r2, r0, #0
 80007ec:	430a      	orrs	r2, r1
 80007ee:	711a      	strb	r2, [r3, #4]
  if (crfp->IDE)
 80007f0:	9b01      	ldr	r3, [sp, #4]
 80007f2:	791b      	ldrb	r3, [r3, #4]
 80007f4:	2220      	movs	r2, #32
 80007f6:	4013      	ands	r3, r2
 80007f8:	b2db      	uxtb	r3, r3
 80007fa:	2b00      	cmp	r3, #0
 80007fc:	d00c      	beq.n	8000818 <can_lld_receive+0x168>
    crfp->EID = rir >> 3;
 80007fe:	9b05      	ldr	r3, [sp, #20]
 8000800:	08db      	lsrs	r3, r3, #3
 8000802:	00db      	lsls	r3, r3, #3
 8000804:	08da      	lsrs	r2, r3, #3
 8000806:	9b01      	ldr	r3, [sp, #4]
 8000808:	00d2      	lsls	r2, r2, #3
 800080a:	08d2      	lsrs	r2, r2, #3
 800080c:	6899      	ldr	r1, [r3, #8]
 800080e:	0f49      	lsrs	r1, r1, #29
 8000810:	0749      	lsls	r1, r1, #29
 8000812:	430a      	orrs	r2, r1
 8000814:	609a      	str	r2, [r3, #8]
 8000816:	e00f      	b.n	8000838 <can_lld_receive+0x188>
  else
    crfp->SID = rir >> 21;
 8000818:	9b05      	ldr	r3, [sp, #20]
 800081a:	0d5b      	lsrs	r3, r3, #21
 800081c:	b29b      	uxth	r3, r3
 800081e:	055b      	lsls	r3, r3, #21
 8000820:	0d5b      	lsrs	r3, r3, #21
 8000822:	b29a      	uxth	r2, r3
 8000824:	9b01      	ldr	r3, [sp, #4]
 8000826:	0552      	lsls	r2, r2, #21
 8000828:	0d50      	lsrs	r0, r2, #21
 800082a:	891a      	ldrh	r2, [r3, #8]
 800082c:	0ad2      	lsrs	r2, r2, #11
 800082e:	02d2      	lsls	r2, r2, #11
 8000830:	1c11      	adds	r1, r2, #0
 8000832:	1c02      	adds	r2, r0, #0
 8000834:	430a      	orrs	r2, r1
 8000836:	811a      	strh	r2, [r3, #8]
  crfp->DLC = rdtr & CAN_RDT0R_DLC;
 8000838:	9b04      	ldr	r3, [sp, #16]
 800083a:	b2db      	uxtb	r3, r3
 800083c:	1c1a      	adds	r2, r3, #0
 800083e:	230f      	movs	r3, #15
 8000840:	4013      	ands	r3, r2
 8000842:	b2da      	uxtb	r2, r3
 8000844:	9b01      	ldr	r3, [sp, #4]
 8000846:	210f      	movs	r1, #15
 8000848:	400a      	ands	r2, r1
 800084a:	0010      	movs	r0, r2
 800084c:	791a      	ldrb	r2, [r3, #4]
 800084e:	210f      	movs	r1, #15
 8000850:	438a      	bics	r2, r1
 8000852:	1c11      	adds	r1, r2, #0
 8000854:	1c02      	adds	r2, r0, #0
 8000856:	430a      	orrs	r2, r1
 8000858:	711a      	strb	r2, [r3, #4]
  crfp->FMI = (uint8_t)(rdtr >> 8);
 800085a:	9b04      	ldr	r3, [sp, #16]
 800085c:	0a1b      	lsrs	r3, r3, #8
 800085e:	b2da      	uxtb	r2, r3
 8000860:	9b01      	ldr	r3, [sp, #4]
 8000862:	701a      	strb	r2, [r3, #0]
  crfp->TIME = (uint16_t)(rdtr >> 16);
 8000864:	9b04      	ldr	r3, [sp, #16]
 8000866:	0c1b      	lsrs	r3, r3, #16
 8000868:	b29a      	uxth	r2, r3
 800086a:	9b01      	ldr	r3, [sp, #4]
 800086c:	805a      	strh	r2, [r3, #2]
}
 800086e:	b006      	add	sp, #24
 8000870:	4770      	bx	lr
 8000872:	46c0      	nop			; (mov r8, r8)
	...

08000880 <initgpio>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {
 8000880:	b082      	sub	sp, #8
 8000882:	9001      	str	r0, [sp, #4]
 8000884:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 8000886:	9b00      	ldr	r3, [sp, #0]
 8000888:	685a      	ldr	r2, [r3, #4]
 800088a:	9b01      	ldr	r3, [sp, #4]
 800088c:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800088e:	9b00      	ldr	r3, [sp, #0]
 8000890:	689a      	ldr	r2, [r3, #8]
 8000892:	9b01      	ldr	r3, [sp, #4]
 8000894:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8000896:	9b00      	ldr	r3, [sp, #0]
 8000898:	68da      	ldr	r2, [r3, #12]
 800089a:	9b01      	ldr	r3, [sp, #4]
 800089c:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 800089e:	9b00      	ldr	r3, [sp, #0]
 80008a0:	691a      	ldr	r2, [r3, #16]
 80008a2:	9b01      	ldr	r3, [sp, #4]
 80008a4:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 80008a6:	9b00      	ldr	r3, [sp, #0]
 80008a8:	695a      	ldr	r2, [r3, #20]
 80008aa:	9b01      	ldr	r3, [sp, #4]
 80008ac:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 80008ae:	9b00      	ldr	r3, [sp, #0]
 80008b0:	699a      	ldr	r2, [r3, #24]
 80008b2:	9b01      	ldr	r3, [sp, #4]
 80008b4:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80008b6:	9b00      	ldr	r3, [sp, #0]
 80008b8:	681a      	ldr	r2, [r3, #0]
 80008ba:	9b01      	ldr	r3, [sp, #4]
 80008bc:	601a      	str	r2, [r3, #0]
}
 80008be:	b002      	add	sp, #8
 80008c0:	4770      	bx	lr
 80008c2:	46c0      	nop			; (mov r8, r8)
	...

080008d0 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 80008d0:	b500      	push	{lr}
 80008d2:	b083      	sub	sp, #12
 80008d4:	9001      	str	r0, [sp, #4]
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 80008d6:	4b12      	ldr	r3, [pc, #72]	; (8000920 <_pal_lld_init+0x50>)
 80008d8:	4a11      	ldr	r2, [pc, #68]	; (8000920 <_pal_lld_init+0x50>)
 80008da:	6952      	ldr	r2, [r2, #20]
 80008dc:	219c      	movs	r1, #156	; 0x9c
 80008de:	03c9      	lsls	r1, r1, #15
 80008e0:	430a      	orrs	r2, r1
 80008e2:	615a      	str	r2, [r3, #20]

  /*
   * Initial GPIO setup.
   */
#if STM32_HAS_GPIOA
  initgpio(GPIOA, &config->PAData);
 80008e4:	9a01      	ldr	r2, [sp, #4]
 80008e6:	2390      	movs	r3, #144	; 0x90
 80008e8:	05db      	lsls	r3, r3, #23
 80008ea:	0011      	movs	r1, r2
 80008ec:	0018      	movs	r0, r3
 80008ee:	f7ff ffc7 	bl	8000880 <initgpio>
#endif
#if STM32_HAS_GPIOB
  initgpio(GPIOB, &config->PBData);
 80008f2:	9b01      	ldr	r3, [sp, #4]
 80008f4:	331c      	adds	r3, #28
 80008f6:	4a0b      	ldr	r2, [pc, #44]	; (8000924 <_pal_lld_init+0x54>)
 80008f8:	0019      	movs	r1, r3
 80008fa:	0010      	movs	r0, r2
 80008fc:	f7ff ffc0 	bl	8000880 <initgpio>
#endif
#if STM32_HAS_GPIOC
  initgpio(GPIOC, &config->PCData);
 8000900:	9b01      	ldr	r3, [sp, #4]
 8000902:	3338      	adds	r3, #56	; 0x38
 8000904:	4a08      	ldr	r2, [pc, #32]	; (8000928 <_pal_lld_init+0x58>)
 8000906:	0019      	movs	r1, r3
 8000908:	0010      	movs	r0, r2
 800090a:	f7ff ffb9 	bl	8000880 <initgpio>
#endif
#if STM32_HAS_GPIOE
  initgpio(GPIOE, &config->PEData);
#endif
#if STM32_HAS_GPIOF
  initgpio(GPIOF, &config->PFData);
 800090e:	9b01      	ldr	r3, [sp, #4]
 8000910:	3354      	adds	r3, #84	; 0x54
 8000912:	4a06      	ldr	r2, [pc, #24]	; (800092c <_pal_lld_init+0x5c>)
 8000914:	0019      	movs	r1, r3
 8000916:	0010      	movs	r0, r2
 8000918:	f7ff ffb2 	bl	8000880 <initgpio>
  initgpio(GPIOJ, &config->PJData);
#endif
#if STM32_HAS_GPIOK
  initgpio(GPIOK, &config->PKData);
#endif
}
 800091c:	b003      	add	sp, #12
 800091e:	bd00      	pop	{pc}
 8000920:	40021000 	.word	0x40021000
 8000924:	48000400 	.word	0x48000400
 8000928:	48000800 	.word	0x48000800
 800092c:	48001400 	.word	0x48001400

08000930 <port_lock>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000930:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8000932:	4770      	bx	lr
	...

08000940 <port_unlock>:
  __ASM volatile ("cpsie i" : : : "memory");
 8000940:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8000942:	4770      	bx	lr
	...

08000950 <port_lock_from_isr>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8000950:	b510      	push	{r4, lr}

  port_lock();
 8000952:	f7ff ffed 	bl	8000930 <port_lock>
}
 8000956:	bd10      	pop	{r4, pc}
	...

08000960 <port_unlock_from_isr>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8000960:	b510      	push	{r4, lr}

  port_unlock();
 8000962:	f7ff ffed 	bl	8000940 <port_unlock>
}
 8000966:	bd10      	pop	{r4, pc}
	...

08000970 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8000970:	b510      	push	{r4, lr}

  port_lock_from_isr();
 8000972:	f7ff ffed 	bl	8000950 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8000976:	f001 fee3 	bl	8002740 <_dbg_check_lock_from_isr>
}
 800097a:	bd10      	pop	{r4, pc}
 800097c:	0000      	movs	r0, r0
	...

08000980 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8000980:	b510      	push	{r4, lr}

  _dbg_check_unlock_from_isr();
 8000982:	f001 fef5 	bl	8002770 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8000986:	f7ff ffeb 	bl	8000960 <port_unlock_from_isr>
}
 800098a:	bd10      	pop	{r4, pc}
 800098c:	0000      	movs	r0, r0
	...

08000990 <osalSysLockFromISR.lto_priv.3>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8000990:	b510      	push	{r4, lr}

  chSysLockFromISR();
 8000992:	f7ff ffed 	bl	8000970 <chSysLockFromISR>
}
 8000996:	bd10      	pop	{r4, pc}
	...

080009a0 <osalSysUnlockFromISR.lto_priv.1>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 80009a0:	b510      	push	{r4, lr}

  chSysUnlockFromISR();
 80009a2:	f7ff ffed 	bl	8000980 <chSysUnlockFromISR>
}
 80009a6:	bd10      	pop	{r4, pc}
	...

080009b0 <osalOsTimerHandlerI>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
 80009b0:	b510      	push	{r4, lr}

  chSysTimerHandlerI();
 80009b2:	f001 fe55 	bl	8002660 <chSysTimerHandlerI>
}
 80009b6:	bd10      	pop	{r4, pc}
	...

080009c0 <Vector7C>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 80009c0:	b500      	push	{lr}
 80009c2:	b083      	sub	sp, #12
 80009c4:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 80009c6:	9301      	str	r3, [sp, #4]
 80009c8:	4b10      	ldr	r3, [pc, #64]	; (8000a0c <Vector7C+0x4c>)
 80009ca:	0018      	movs	r0, r3
 80009cc:	f002 f818 	bl	8002a00 <_trace_isr_enter>
 80009d0:	f001 fee6 	bl	80027a0 <_dbg_check_enter_isr>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 80009d4:	2380      	movs	r3, #128	; 0x80
 80009d6:	05db      	lsls	r3, r3, #23
 80009d8:	691b      	ldr	r3, [r3, #16]
 80009da:	2202      	movs	r2, #2
 80009dc:	4013      	ands	r3, r2
 80009de:	d009      	beq.n	80009f4 <Vector7C+0x34>
    STM32_ST_TIM->SR = 0U;
 80009e0:	2380      	movs	r3, #128	; 0x80
 80009e2:	05db      	lsls	r3, r3, #23
 80009e4:	2200      	movs	r2, #0
 80009e6:	611a      	str	r2, [r3, #16]

    osalSysLockFromISR();
 80009e8:	f7ff ffd2 	bl	8000990 <osalSysLockFromISR.lto_priv.3>
    osalOsTimerHandlerI();
 80009ec:	f7ff ffe0 	bl	80009b0 <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
 80009f0:	f7ff ffd6 	bl	80009a0 <osalSysUnlockFromISR.lto_priv.1>
  }

  OSAL_IRQ_EPILOGUE();
 80009f4:	f001 fef4 	bl	80027e0 <_dbg_check_leave_isr>
 80009f8:	4b04      	ldr	r3, [pc, #16]	; (8000a0c <Vector7C+0x4c>)
 80009fa:	0018      	movs	r0, r3
 80009fc:	f002 f828 	bl	8002a50 <_trace_isr_leave>
 8000a00:	9b01      	ldr	r3, [sp, #4]
 8000a02:	0018      	movs	r0, r3
 8000a04:	f000 fe6c 	bl	80016e0 <_port_irq_epilogue>
}
 8000a08:	b003      	add	sp, #12
 8000a0a:	bd00      	pop	{pc}
 8000a0c:	08003cc4 	.word	0x08003cc4

08000a10 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 8000a10:	b510      	push	{r4, lr}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8000a12:	4b19      	ldr	r3, [pc, #100]	; (8000a78 <st_lld_init+0x68>)
 8000a14:	4a18      	ldr	r2, [pc, #96]	; (8000a78 <st_lld_init+0x68>)
 8000a16:	69d2      	ldr	r2, [r2, #28]
 8000a18:	2101      	movs	r1, #1
 8000a1a:	430a      	orrs	r2, r1
 8000a1c:	61da      	str	r2, [r3, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8000a1e:	4b17      	ldr	r3, [pc, #92]	; (8000a7c <st_lld_init+0x6c>)
 8000a20:	4a16      	ldr	r2, [pc, #88]	; (8000a7c <st_lld_init+0x6c>)
 8000a22:	6892      	ldr	r2, [r2, #8]
 8000a24:	2101      	movs	r1, #1
 8000a26:	430a      	orrs	r2, r1
 8000a28:	609a      	str	r2, [r3, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8000a2a:	2380      	movs	r3, #128	; 0x80
 8000a2c:	05db      	lsls	r3, r3, #23
 8000a2e:	4a14      	ldr	r2, [pc, #80]	; (8000a80 <st_lld_init+0x70>)
 8000a30:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8000a32:	2380      	movs	r3, #128	; 0x80
 8000a34:	05db      	lsls	r3, r3, #23
 8000a36:	2201      	movs	r2, #1
 8000a38:	4252      	negs	r2, r2
 8000a3a:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8000a3c:	2380      	movs	r3, #128	; 0x80
 8000a3e:	05db      	lsls	r3, r3, #23
 8000a40:	2200      	movs	r2, #0
 8000a42:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8000a44:	2380      	movs	r3, #128	; 0x80
 8000a46:	05db      	lsls	r3, r3, #23
 8000a48:	2200      	movs	r2, #0
 8000a4a:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8000a4c:	2380      	movs	r3, #128	; 0x80
 8000a4e:	05db      	lsls	r3, r3, #23
 8000a50:	2200      	movs	r2, #0
 8000a52:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8000a54:	2380      	movs	r3, #128	; 0x80
 8000a56:	05db      	lsls	r3, r3, #23
 8000a58:	2200      	movs	r2, #0
 8000a5a:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8000a5c:	2380      	movs	r3, #128	; 0x80
 8000a5e:	05db      	lsls	r3, r3, #23
 8000a60:	2201      	movs	r2, #1
 8000a62:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8000a64:	2380      	movs	r3, #128	; 0x80
 8000a66:	05db      	lsls	r3, r3, #23
 8000a68:	2201      	movs	r2, #1
 8000a6a:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8000a6c:	2102      	movs	r1, #2
 8000a6e:	200f      	movs	r0, #15
 8000a70:	f000 fb16 	bl	80010a0 <nvicEnableVector>
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8000a74:	bd10      	pop	{r4, pc}
 8000a76:	46c0      	nop			; (mov r8, r8)
 8000a78:	40021000 	.word	0x40021000
 8000a7c:	40015800 	.word	0x40015800
 8000a80:	000012bf 	.word	0x000012bf
	...

08000a90 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
 8000a90:	b510      	push	{r4, lr}

  stm32_clock_init();
 8000a92:	f000 fba5 	bl	80011e0 <stm32_clock_init>
}
 8000a96:	bd10      	pop	{r4, pc}
	...

08000aa0 <boardInit>:
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
}
 8000aa0:	4770      	bx	lr
 8000aa2:	46c0      	nop			; (mov r8, r8)
	...

08000ab0 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8000ab0:	b082      	sub	sp, #8
 8000ab2:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 8000ab4:	4b02      	ldr	r3, [pc, #8]	; (8000ac0 <chRegSetThreadName+0x10>)
 8000ab6:	699b      	ldr	r3, [r3, #24]
 8000ab8:	9a01      	ldr	r2, [sp, #4]
 8000aba:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 8000abc:	b002      	add	sp, #8
 8000abe:	4770      	bx	lr
 8000ac0:	200004d8 	.word	0x200004d8
	...

08000ad0 <chEvtRegisterMask>:
 *
 * @api
 */
static inline void chEvtRegisterMask(event_source_t *esp,
                                     event_listener_t *elp,
                                     eventmask_t events) {
 8000ad0:	b500      	push	{lr}
 8000ad2:	b085      	sub	sp, #20
 8000ad4:	9003      	str	r0, [sp, #12]
 8000ad6:	9102      	str	r1, [sp, #8]
 8000ad8:	9201      	str	r2, [sp, #4]

  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 8000ada:	2301      	movs	r3, #1
 8000adc:	425b      	negs	r3, r3
 8000ade:	9a01      	ldr	r2, [sp, #4]
 8000ae0:	9902      	ldr	r1, [sp, #8]
 8000ae2:	9803      	ldr	r0, [sp, #12]
 8000ae4:	f001 fb6c 	bl	80021c0 <chEvtRegisterMaskWithFlags>
}
 8000ae8:	b005      	add	sp, #20
 8000aea:	bd00      	pop	{pc}
 8000aec:	0000      	movs	r0, r0
	...

08000af0 <chEvtRegister>:
 *
 * @api
 */
static inline void chEvtRegister(event_source_t *esp,
                                 event_listener_t *elp,
                                 eventid_t event) {
 8000af0:	b500      	push	{lr}
 8000af2:	b085      	sub	sp, #20
 8000af4:	9003      	str	r0, [sp, #12]
 8000af6:	9102      	str	r1, [sp, #8]
 8000af8:	9201      	str	r2, [sp, #4]

  chEvtRegisterMask(esp, elp, EVENT_MASK(event));
 8000afa:	9b01      	ldr	r3, [sp, #4]
 8000afc:	2201      	movs	r2, #1
 8000afe:	409a      	lsls	r2, r3
 8000b00:	9902      	ldr	r1, [sp, #8]
 8000b02:	9b03      	ldr	r3, [sp, #12]
 8000b04:	0018      	movs	r0, r3
 8000b06:	f7ff ffe3 	bl	8000ad0 <chEvtRegisterMask>
}
 8000b0a:	b005      	add	sp, #20
 8000b0c:	bd00      	pop	{pc}
 8000b0e:	46c0      	nop			; (mov r8, r8)

08000b10 <can_rx>:

/*
 * Receiver thread.
 */
static THD_WORKING_AREA(can_rx_wa, 256);
static THD_FUNCTION(can_rx, p) {
 8000b10:	b500      	push	{lr}
 8000b12:	b08f      	sub	sp, #60	; 0x3c
 8000b14:	9001      	str	r0, [sp, #4]
  event_listener_t el;
  CANRxFrame rxmsg;

  (void)p;
  chRegSetThreadName("receiver");
 8000b16:	4b11      	ldr	r3, [pc, #68]	; (8000b5c <can_rx+0x4c>)
 8000b18:	0018      	movs	r0, r3
 8000b1a:	f7ff ffc9 	bl	8000ab0 <chRegSetThreadName>
  chEvtRegister(&CAND1.rxfull_event, &el, 0);
 8000b1e:	a909      	add	r1, sp, #36	; 0x24
 8000b20:	4b0f      	ldr	r3, [pc, #60]	; (8000b60 <can_rx+0x50>)
 8000b22:	2200      	movs	r2, #0
 8000b24:	0018      	movs	r0, r3
 8000b26:	f7ff ffe3 	bl	8000af0 <chEvtRegister>
  while (true) {
    if (chEvtWaitAnyTimeout(ALL_EVENTS, MS2ST(100)) == 0)
 8000b2a:	23fa      	movs	r3, #250	; 0xfa
 8000b2c:	009a      	lsls	r2, r3, #2
 8000b2e:	2301      	movs	r3, #1
 8000b30:	425b      	negs	r3, r3
 8000b32:	0011      	movs	r1, r2
 8000b34:	0018      	movs	r0, r3
 8000b36:	f000 fe93 	bl	8001860 <chEvtWaitAnyTimeout>
 8000b3a:	1e03      	subs	r3, r0, #0
 8000b3c:	d104      	bne.n	8000b48 <can_rx+0x38>
      continue;
 8000b3e:	e7f4      	b.n	8000b2a <can_rx+0x1a>
    while (canReceive(&CAND1, CAN_ANY_MAILBOX, &rxmsg, TIME_IMMEDIATE) == MSG_OK) {
      /* Process message.*/
      palTogglePad(GPIOC, LINE_LED_GREEN);
 8000b40:	4b08      	ldr	r3, [pc, #32]	; (8000b64 <can_rx+0x54>)
 8000b42:	4a08      	ldr	r2, [pc, #32]	; (8000b64 <can_rx+0x54>)
 8000b44:	6952      	ldr	r2, [r2, #20]
 8000b46:	615a      	str	r2, [r3, #20]
    while (canReceive(&CAND1, CAN_ANY_MAILBOX, &rxmsg, TIME_IMMEDIATE) == MSG_OK) {
 8000b48:	aa02      	add	r2, sp, #8
 8000b4a:	4807      	ldr	r0, [pc, #28]	; (8000b68 <can_rx+0x58>)
 8000b4c:	2300      	movs	r3, #0
 8000b4e:	2100      	movs	r1, #0
 8000b50:	f000 f9de 	bl	8000f10 <canReceiveTimeout>
 8000b54:	1e03      	subs	r3, r0, #0
 8000b56:	d0f3      	beq.n	8000b40 <can_rx+0x30>
 8000b58:	e7e7      	b.n	8000b2a <can_rx+0x1a>
 8000b5a:	46c0      	nop			; (mov r8, r8)
 8000b5c:	08003d48 	.word	0x08003d48
 8000b60:	20000da0 	.word	0x20000da0
 8000b64:	48000800 	.word	0x48000800
 8000b68:	20000d88 	.word	0x20000d88
 8000b6c:	00000000 	.word	0x00000000

08000b70 <can_tx>:

/*
 * Transmitter thread.
 */
static THD_WORKING_AREA(can_tx_wa, 256);
static THD_FUNCTION(can_tx, p) {
 8000b70:	b500      	push	{lr}
 8000b72:	b087      	sub	sp, #28
 8000b74:	9001      	str	r0, [sp, #4]
  CANTxFrame txmsg;

  (void)p;
  chRegSetThreadName("transmitter");
 8000b76:	4b17      	ldr	r3, [pc, #92]	; (8000bd4 <can_tx+0x64>)
 8000b78:	0018      	movs	r0, r3
 8000b7a:	f7ff ff99 	bl	8000ab0 <chRegSetThreadName>
  txmsg.IDE = CAN_IDE_EXT;
 8000b7e:	ab02      	add	r3, sp, #8
 8000b80:	781a      	ldrb	r2, [r3, #0]
 8000b82:	2120      	movs	r1, #32
 8000b84:	430a      	orrs	r2, r1
 8000b86:	701a      	strb	r2, [r3, #0]
  txmsg.EID = 0x01234567;
 8000b88:	ab02      	add	r3, sp, #8
 8000b8a:	685a      	ldr	r2, [r3, #4]
 8000b8c:	0f52      	lsrs	r2, r2, #29
 8000b8e:	0752      	lsls	r2, r2, #29
 8000b90:	4911      	ldr	r1, [pc, #68]	; (8000bd8 <can_tx+0x68>)
 8000b92:	430a      	orrs	r2, r1
 8000b94:	605a      	str	r2, [r3, #4]
  txmsg.RTR = CAN_RTR_DATA;
 8000b96:	ab02      	add	r3, sp, #8
 8000b98:	781a      	ldrb	r2, [r3, #0]
 8000b9a:	2110      	movs	r1, #16
 8000b9c:	438a      	bics	r2, r1
 8000b9e:	701a      	strb	r2, [r3, #0]
  txmsg.DLC = 8;
 8000ba0:	ab02      	add	r3, sp, #8
 8000ba2:	781a      	ldrb	r2, [r3, #0]
 8000ba4:	210f      	movs	r1, #15
 8000ba6:	438a      	bics	r2, r1
 8000ba8:	1c11      	adds	r1, r2, #0
 8000baa:	2208      	movs	r2, #8
 8000bac:	430a      	orrs	r2, r1
 8000bae:	701a      	strb	r2, [r3, #0]
  txmsg.data32[0] = 0x55AA55AA;
 8000bb0:	ab02      	add	r3, sp, #8
 8000bb2:	4a0a      	ldr	r2, [pc, #40]	; (8000bdc <can_tx+0x6c>)
 8000bb4:	609a      	str	r2, [r3, #8]
  txmsg.data32[1] = 0x00FF00FF;
 8000bb6:	ab02      	add	r3, sp, #8
 8000bb8:	4a09      	ldr	r2, [pc, #36]	; (8000be0 <can_tx+0x70>)
 8000bba:	60da      	str	r2, [r3, #12]

  while (true) {
    canTransmit(&CAND1, CAN_ANY_MAILBOX, &txmsg, MS2ST(100));
 8000bbc:	23fa      	movs	r3, #250	; 0xfa
 8000bbe:	009b      	lsls	r3, r3, #2
 8000bc0:	aa02      	add	r2, sp, #8
 8000bc2:	4808      	ldr	r0, [pc, #32]	; (8000be4 <can_tx+0x74>)
 8000bc4:	2100      	movs	r1, #0
 8000bc6:	f000 f94b 	bl	8000e60 <canTransmitTimeout>
    chThdSleepMilliseconds(500);
 8000bca:	4b07      	ldr	r3, [pc, #28]	; (8000be8 <can_tx+0x78>)
 8000bcc:	0018      	movs	r0, r3
 8000bce:	f002 fef7 	bl	80039c0 <chThdSleep>
 8000bd2:	e7f3      	b.n	8000bbc <can_tx+0x4c>
 8000bd4:	08003d54 	.word	0x08003d54
 8000bd8:	01234567 	.word	0x01234567
 8000bdc:	55aa55aa 	.word	0x55aa55aa
 8000be0:	00ff00ff 	.word	0x00ff00ff
 8000be4:	20000d88 	.word	0x20000d88
 8000be8:	00001388 	.word	0x00001388
 8000bec:	00000000 	.word	0x00000000

08000bf0 <main>:
}

/*
 * Application entry point.
 */
int main(void) {
 8000bf0:	b500      	push	{lr}
 8000bf2:	b083      	sub	sp, #12
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 8000bf4:	f000 fdac 	bl	8001750 <halInit>
  chSysInit();
 8000bf8:	f001 fcea 	bl	80025d0 <chSysInit>

  /*
   * Activates the CAN driver 1.
   */
  canStart(&CAND1, &cancfg);
 8000bfc:	4a0f      	ldr	r2, [pc, #60]	; (8000c3c <main+0x4c>)
 8000bfe:	4b10      	ldr	r3, [pc, #64]	; (8000c40 <main+0x50>)
 8000c00:	0011      	movs	r1, r2
 8000c02:	0018      	movs	r0, r3
 8000c04:	f000 f904 	bl	8000e10 <canStart>

  /*
   * Starting the transmitter and receiver threads.
   */
  chThdCreateStatic(can_rx_wa, sizeof(can_rx_wa), NORMALPRIO + 7, can_rx, NULL);
 8000c08:	4a0e      	ldr	r2, [pc, #56]	; (8000c44 <main+0x54>)
 8000c0a:	23e4      	movs	r3, #228	; 0xe4
 8000c0c:	0059      	lsls	r1, r3, #1
 8000c0e:	480e      	ldr	r0, [pc, #56]	; (8000c48 <main+0x58>)
 8000c10:	2300      	movs	r3, #0
 8000c12:	9300      	str	r3, [sp, #0]
 8000c14:	0013      	movs	r3, r2
 8000c16:	2287      	movs	r2, #135	; 0x87
 8000c18:	f002 fdc2 	bl	80037a0 <chThdCreateStatic>
  chThdCreateStatic(can_tx_wa, sizeof(can_tx_wa), NORMALPRIO + 7, can_tx, NULL);
 8000c1c:	4a0b      	ldr	r2, [pc, #44]	; (8000c4c <main+0x5c>)
 8000c1e:	23e4      	movs	r3, #228	; 0xe4
 8000c20:	0059      	lsls	r1, r3, #1
 8000c22:	480b      	ldr	r0, [pc, #44]	; (8000c50 <main+0x60>)
 8000c24:	2300      	movs	r3, #0
 8000c26:	9300      	str	r3, [sp, #0]
 8000c28:	0013      	movs	r3, r2
 8000c2a:	2287      	movs	r2, #135	; 0x87
 8000c2c:	f002 fdb8 	bl	80037a0 <chThdCreateStatic>

  /*
   * Normal main() thread activity, in this demo it does nothing.
   */
  while (true) {
    chThdSleepMilliseconds(500);
 8000c30:	4b08      	ldr	r3, [pc, #32]	; (8000c54 <main+0x64>)
 8000c32:	0018      	movs	r0, r3
 8000c34:	f002 fec4 	bl	80039c0 <chThdSleep>
 8000c38:	e7fa      	b.n	8000c30 <main+0x40>
 8000c3a:	46c0      	nop			; (mov r8, r8)
 8000c3c:	08003d40 	.word	0x08003d40
 8000c40:	20000d88 	.word	0x20000d88
 8000c44:	08000b11 	.word	0x08000b11
 8000c48:	20000db8 	.word	0x20000db8
 8000c4c:	08000b71 	.word	0x08000b71
 8000c50:	20000f80 	.word	0x20000f80
 8000c54:	00001388 	.word	0x00001388
	...

08000c60 <port_lock.lto_priv.64>:
  __ASM volatile ("cpsid i" : : : "memory");
 8000c60:	b672      	cpsid	i
}
 8000c62:	4770      	bx	lr
	...

08000c70 <port_unlock.lto_priv.62>:
  __ASM volatile ("cpsie i" : : : "memory");
 8000c70:	b662      	cpsie	i
}
 8000c72:	4770      	bx	lr
	...

08000c80 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8000c80:	b082      	sub	sp, #8
 8000c82:	9001      	str	r0, [sp, #4]

  tqp->next = (thread_t *)tqp;
 8000c84:	9b01      	ldr	r3, [sp, #4]
 8000c86:	9a01      	ldr	r2, [sp, #4]
 8000c88:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8000c8a:	9b01      	ldr	r3, [sp, #4]
 8000c8c:	9a01      	ldr	r2, [sp, #4]
 8000c8e:	605a      	str	r2, [r3, #4]
}
 8000c90:	b002      	add	sp, #8
 8000c92:	4770      	bx	lr
	...

08000ca0 <chSysLock>:
static inline void chSysLock(void) {
 8000ca0:	b510      	push	{r4, lr}
  port_lock();
 8000ca2:	f7ff ffdd 	bl	8000c60 <port_lock.lto_priv.64>
  _dbg_check_lock();
 8000ca6:	f001 fd1b 	bl	80026e0 <_dbg_check_lock>
}
 8000caa:	bd10      	pop	{r4, pc}
 8000cac:	0000      	movs	r0, r0
	...

08000cb0 <chSysUnlock>:
static inline void chSysUnlock(void) {
 8000cb0:	b510      	push	{r4, lr}
  _dbg_check_unlock();
 8000cb2:	f001 fd2d 	bl	8002710 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8000cb6:	4b0a      	ldr	r3, [pc, #40]	; (8000ce0 <chSysUnlock+0x30>)
 8000cb8:	681a      	ldr	r2, [r3, #0]
 8000cba:	4b09      	ldr	r3, [pc, #36]	; (8000ce0 <chSysUnlock+0x30>)
 8000cbc:	429a      	cmp	r2, r3
 8000cbe:	d00b      	beq.n	8000cd8 <chSysUnlock+0x28>
 8000cc0:	4b07      	ldr	r3, [pc, #28]	; (8000ce0 <chSysUnlock+0x30>)
 8000cc2:	699b      	ldr	r3, [r3, #24]
 8000cc4:	689a      	ldr	r2, [r3, #8]
 8000cc6:	4b06      	ldr	r3, [pc, #24]	; (8000ce0 <chSysUnlock+0x30>)
 8000cc8:	681b      	ldr	r3, [r3, #0]
 8000cca:	689b      	ldr	r3, [r3, #8]
 8000ccc:	429a      	cmp	r2, r3
 8000cce:	d203      	bcs.n	8000cd8 <chSysUnlock+0x28>
 8000cd0:	4b04      	ldr	r3, [pc, #16]	; (8000ce4 <chSysUnlock+0x34>)
 8000cd2:	0018      	movs	r0, r3
 8000cd4:	f001 fcb4 	bl	8002640 <chSysHalt>
  port_unlock();
 8000cd8:	f7ff ffca 	bl	8000c70 <port_unlock.lto_priv.62>
}
 8000cdc:	bd10      	pop	{r4, pc}
 8000cde:	46c0      	nop			; (mov r8, r8)
 8000ce0:	200004d8 	.word	0x200004d8
 8000ce4:	08003c5c 	.word	0x08003c5c
	...

08000cf0 <chThdQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 8000cf0:	b500      	push	{lr}
 8000cf2:	b083      	sub	sp, #12
 8000cf4:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
 8000cf6:	9b01      	ldr	r3, [sp, #4]
 8000cf8:	0018      	movs	r0, r3
 8000cfa:	f7ff ffc1 	bl	8000c80 <queue_init>
}
 8000cfe:	b003      	add	sp, #12
 8000d00:	bd00      	pop	{pc}
 8000d02:	46c0      	nop			; (mov r8, r8)
	...

08000d10 <chEvtObjectInit>:
static inline void chEvtObjectInit(event_source_t *esp) {
 8000d10:	b082      	sub	sp, #8
 8000d12:	9001      	str	r0, [sp, #4]
  esp->next = (event_listener_t *)esp;
 8000d14:	9b01      	ldr	r3, [sp, #4]
 8000d16:	9a01      	ldr	r2, [sp, #4]
 8000d18:	601a      	str	r2, [r3, #0]
}
 8000d1a:	b002      	add	sp, #8
 8000d1c:	4770      	bx	lr
 8000d1e:	46c0      	nop			; (mov r8, r8)

08000d20 <osalSysLock.lto_priv.88>:
static inline void osalSysLock(void) {
 8000d20:	b510      	push	{r4, lr}
  chSysLock();
 8000d22:	f7ff ffbd 	bl	8000ca0 <chSysLock>
}
 8000d26:	bd10      	pop	{r4, pc}
	...

08000d30 <osalSysUnlock.lto_priv.86>:
static inline void osalSysUnlock(void) {
 8000d30:	b510      	push	{r4, lr}
  chSysUnlock();
 8000d32:	f7ff ffbd 	bl	8000cb0 <chSysUnlock>
}
 8000d36:	bd10      	pop	{r4, pc}
	...

08000d40 <osalThreadQueueObjectInit.lto_priv.84>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
 8000d40:	b500      	push	{lr}
 8000d42:	b083      	sub	sp, #12
 8000d44:	9001      	str	r0, [sp, #4]

  chThdQueueObjectInit(tqp);
 8000d46:	9b01      	ldr	r3, [sp, #4]
 8000d48:	0018      	movs	r0, r3
 8000d4a:	f7ff ffd1 	bl	8000cf0 <chThdQueueObjectInit>
}
 8000d4e:	b003      	add	sp, #12
 8000d50:	bd00      	pop	{pc}
 8000d52:	46c0      	nop			; (mov r8, r8)
	...

08000d60 <osalThreadEnqueueTimeoutS.lto_priv.82>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {
 8000d60:	b500      	push	{lr}
 8000d62:	b083      	sub	sp, #12
 8000d64:	9001      	str	r0, [sp, #4]
 8000d66:	9100      	str	r1, [sp, #0]

  return chThdEnqueueTimeoutS(tqp, time);
 8000d68:	9a00      	ldr	r2, [sp, #0]
 8000d6a:	9b01      	ldr	r3, [sp, #4]
 8000d6c:	0011      	movs	r1, r2
 8000d6e:	0018      	movs	r0, r3
 8000d70:	f000 ff2e 	bl	8001bd0 <chThdEnqueueTimeoutS>
 8000d74:	0003      	movs	r3, r0
}
 8000d76:	0018      	movs	r0, r3
 8000d78:	b003      	add	sp, #12
 8000d7a:	bd00      	pop	{pc}
 8000d7c:	0000      	movs	r0, r0
	...

08000d80 <osalEventObjectInit>:
 *
 * @param[out] esp      pointer to the event flags object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
 8000d80:	b500      	push	{lr}
 8000d82:	b083      	sub	sp, #12
 8000d84:	9001      	str	r0, [sp, #4]

  chEvtObjectInit(esp);
 8000d86:	9b01      	ldr	r3, [sp, #4]
 8000d88:	0018      	movs	r0, r3
 8000d8a:	f7ff ffc1 	bl	8000d10 <chEvtObjectInit>
}
 8000d8e:	b003      	add	sp, #12
 8000d90:	bd00      	pop	{pc}
 8000d92:	46c0      	nop			; (mov r8, r8)
	...

08000da0 <canInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void canInit(void) {
 8000da0:	b510      	push	{r4, lr}

  can_lld_init();
 8000da2:	f7ff fb5d 	bl	8000460 <can_lld_init>
}
 8000da6:	bd10      	pop	{r4, pc}
	...

08000db0 <canObjectInit>:
 *
 * @param[out] canp     pointer to the @p CANDriver object
 *
 * @init
 */
void canObjectInit(CANDriver *canp) {
 8000db0:	b500      	push	{lr}
 8000db2:	b083      	sub	sp, #12
 8000db4:	9001      	str	r0, [sp, #4]

  canp->state    = CAN_STOP;
 8000db6:	9b01      	ldr	r3, [sp, #4]
 8000db8:	2201      	movs	r2, #1
 8000dba:	701a      	strb	r2, [r3, #0]
  canp->config   = NULL;
 8000dbc:	9b01      	ldr	r3, [sp, #4]
 8000dbe:	2200      	movs	r2, #0
 8000dc0:	605a      	str	r2, [r3, #4]
  osalThreadQueueObjectInit(&canp->txqueue);
 8000dc2:	9b01      	ldr	r3, [sp, #4]
 8000dc4:	3308      	adds	r3, #8
 8000dc6:	0018      	movs	r0, r3
 8000dc8:	f7ff ffba 	bl	8000d40 <osalThreadQueueObjectInit.lto_priv.84>
  osalThreadQueueObjectInit(&canp->rxqueue);
 8000dcc:	9b01      	ldr	r3, [sp, #4]
 8000dce:	3310      	adds	r3, #16
 8000dd0:	0018      	movs	r0, r3
 8000dd2:	f7ff ffb5 	bl	8000d40 <osalThreadQueueObjectInit.lto_priv.84>
  osalEventObjectInit(&canp->rxfull_event);
 8000dd6:	9b01      	ldr	r3, [sp, #4]
 8000dd8:	3318      	adds	r3, #24
 8000dda:	0018      	movs	r0, r3
 8000ddc:	f7ff ffd0 	bl	8000d80 <osalEventObjectInit>
  osalEventObjectInit(&canp->txempty_event);
 8000de0:	9b01      	ldr	r3, [sp, #4]
 8000de2:	331c      	adds	r3, #28
 8000de4:	0018      	movs	r0, r3
 8000de6:	f7ff ffcb 	bl	8000d80 <osalEventObjectInit>
  osalEventObjectInit(&canp->error_event);
 8000dea:	9b01      	ldr	r3, [sp, #4]
 8000dec:	3320      	adds	r3, #32
 8000dee:	0018      	movs	r0, r3
 8000df0:	f7ff ffc6 	bl	8000d80 <osalEventObjectInit>
#if CAN_USE_SLEEP_MODE == TRUE
  osalEventObjectInit(&canp->sleep_event);
 8000df4:	9b01      	ldr	r3, [sp, #4]
 8000df6:	3324      	adds	r3, #36	; 0x24
 8000df8:	0018      	movs	r0, r3
 8000dfa:	f7ff ffc1 	bl	8000d80 <osalEventObjectInit>
  osalEventObjectInit(&canp->wakeup_event);
 8000dfe:	9b01      	ldr	r3, [sp, #4]
 8000e00:	3328      	adds	r3, #40	; 0x28
 8000e02:	0018      	movs	r0, r3
 8000e04:	f7ff ffbc 	bl	8000d80 <osalEventObjectInit>
#endif
}
 8000e08:	b003      	add	sp, #12
 8000e0a:	bd00      	pop	{pc}
 8000e0c:	0000      	movs	r0, r0
	...

08000e10 <canStart>:
 * @param[in] config    pointer to the @p CANConfig object. Depending on
 *                      the implementation the value can be @p NULL.
 *
 * @api
 */
void canStart(CANDriver *canp, const CANConfig *config) {
 8000e10:	b500      	push	{lr}
 8000e12:	b083      	sub	sp, #12
 8000e14:	9001      	str	r0, [sp, #4]
 8000e16:	9100      	str	r1, [sp, #0]

  osalDbgCheck(canp != NULL);
 8000e18:	9b01      	ldr	r3, [sp, #4]
 8000e1a:	2b00      	cmp	r3, #0
 8000e1c:	d103      	bne.n	8000e26 <canStart+0x16>
 8000e1e:	4b0f      	ldr	r3, [pc, #60]	; (8000e5c <canStart+0x4c>)
 8000e20:	0018      	movs	r0, r3
 8000e22:	f001 fc0d 	bl	8002640 <chSysHalt>

  osalSysLock();
 8000e26:	f7ff ff7b 	bl	8000d20 <osalSysLock.lto_priv.88>
  osalDbgAssert(canp->state == CAN_STOP, "invalid state");
 8000e2a:	9b01      	ldr	r3, [sp, #4]
 8000e2c:	781b      	ldrb	r3, [r3, #0]
 8000e2e:	2b01      	cmp	r3, #1
 8000e30:	d003      	beq.n	8000e3a <canStart+0x2a>
 8000e32:	4b0a      	ldr	r3, [pc, #40]	; (8000e5c <canStart+0x4c>)
 8000e34:	0018      	movs	r0, r3
 8000e36:	f001 fc03 	bl	8002640 <chSysHalt>

  /* Entering initialization mode. */
  canp->state = CAN_STARTING;
 8000e3a:	9b01      	ldr	r3, [sp, #4]
 8000e3c:	2202      	movs	r2, #2
 8000e3e:	701a      	strb	r2, [r3, #0]
  canp->config = config;
 8000e40:	9b01      	ldr	r3, [sp, #4]
 8000e42:	9a00      	ldr	r2, [sp, #0]
 8000e44:	605a      	str	r2, [r3, #4]

  /* Low level initialization, could be a slow process and sleeps could
     be performed inside.*/
  can_lld_start(canp);
 8000e46:	9b01      	ldr	r3, [sp, #4]
 8000e48:	0018      	movs	r0, r3
 8000e4a:	f7ff fb21 	bl	8000490 <can_lld_start>

  /* The driver finally goes into the ready state.*/
  canp->state = CAN_READY;
 8000e4e:	9b01      	ldr	r3, [sp, #4]
 8000e50:	2203      	movs	r2, #3
 8000e52:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 8000e54:	f7ff ff6c 	bl	8000d30 <osalSysUnlock.lto_priv.86>
}
 8000e58:	b003      	add	sp, #12
 8000e5a:	bd00      	pop	{pc}
 8000e5c:	08003c50 	.word	0x08003c50

08000e60 <canTransmitTimeout>:
 * @api
 */
msg_t canTransmitTimeout(CANDriver *canp,
                         canmbx_t mailbox,
                         const CANTxFrame *ctfp,
                         systime_t timeout) {
 8000e60:	b500      	push	{lr}
 8000e62:	b087      	sub	sp, #28
 8000e64:	9003      	str	r0, [sp, #12]
 8000e66:	9102      	str	r1, [sp, #8]
 8000e68:	9201      	str	r2, [sp, #4]
 8000e6a:	9300      	str	r3, [sp, #0]

  osalDbgCheck((canp != NULL) && (ctfp != NULL) &&
 8000e6c:	9b03      	ldr	r3, [sp, #12]
 8000e6e:	2b00      	cmp	r3, #0
 8000e70:	d005      	beq.n	8000e7e <canTransmitTimeout+0x1e>
 8000e72:	9b01      	ldr	r3, [sp, #4]
 8000e74:	2b00      	cmp	r3, #0
 8000e76:	d002      	beq.n	8000e7e <canTransmitTimeout+0x1e>
 8000e78:	9b02      	ldr	r3, [sp, #8]
 8000e7a:	2b03      	cmp	r3, #3
 8000e7c:	d903      	bls.n	8000e86 <canTransmitTimeout+0x26>
 8000e7e:	4b20      	ldr	r3, [pc, #128]	; (8000f00 <canTransmitTimeout+0xa0>)
 8000e80:	0018      	movs	r0, r3
 8000e82:	f001 fbdd 	bl	8002640 <chSysHalt>
               (mailbox <= (canmbx_t)CAN_TX_MAILBOXES));

  osalSysLock();
 8000e86:	f7ff ff4b 	bl	8000d20 <osalSysLock.lto_priv.88>
  osalDbgAssert((canp->state == CAN_READY) || (canp->state == CAN_SLEEP),
 8000e8a:	9b03      	ldr	r3, [sp, #12]
 8000e8c:	781b      	ldrb	r3, [r3, #0]
 8000e8e:	2b03      	cmp	r3, #3
 8000e90:	d018      	beq.n	8000ec4 <canTransmitTimeout+0x64>
 8000e92:	9b03      	ldr	r3, [sp, #12]
 8000e94:	781b      	ldrb	r3, [r3, #0]
 8000e96:	2b04      	cmp	r3, #4
 8000e98:	d014      	beq.n	8000ec4 <canTransmitTimeout+0x64>
 8000e9a:	4b19      	ldr	r3, [pc, #100]	; (8000f00 <canTransmitTimeout+0xa0>)
 8000e9c:	0018      	movs	r0, r3
 8000e9e:	f001 fbcf 	bl	8002640 <chSysHalt>
 8000ea2:	e00f      	b.n	8000ec4 <canTransmitTimeout+0x64>
                "invalid state");

  /*lint -save -e9007 [13.5] Right side is supposed to be pure.*/
  while ((canp->state == CAN_SLEEP) || !can_lld_is_tx_empty(canp, mailbox)) {
  /*lint -restore*/
   msg_t msg = osalThreadEnqueueTimeoutS(&canp->txqueue, timeout);
 8000ea4:	9b03      	ldr	r3, [sp, #12]
 8000ea6:	3308      	adds	r3, #8
 8000ea8:	9a00      	ldr	r2, [sp, #0]
 8000eaa:	0011      	movs	r1, r2
 8000eac:	0018      	movs	r0, r3
 8000eae:	f7ff ff57 	bl	8000d60 <osalThreadEnqueueTimeoutS.lto_priv.82>
 8000eb2:	0003      	movs	r3, r0
 8000eb4:	9305      	str	r3, [sp, #20]
    if (msg != MSG_OK) {
 8000eb6:	9b05      	ldr	r3, [sp, #20]
 8000eb8:	2b00      	cmp	r3, #0
 8000eba:	d003      	beq.n	8000ec4 <canTransmitTimeout+0x64>
      osalSysUnlock();
 8000ebc:	f7ff ff38 	bl	8000d30 <osalSysUnlock.lto_priv.86>
      return msg;
 8000ec0:	9b05      	ldr	r3, [sp, #20]
 8000ec2:	e019      	b.n	8000ef8 <canTransmitTimeout+0x98>
  while ((canp->state == CAN_SLEEP) || !can_lld_is_tx_empty(canp, mailbox)) {
 8000ec4:	9b03      	ldr	r3, [sp, #12]
 8000ec6:	781b      	ldrb	r3, [r3, #0]
 8000ec8:	2b04      	cmp	r3, #4
 8000eca:	d0eb      	beq.n	8000ea4 <canTransmitTimeout+0x44>
 8000ecc:	9a02      	ldr	r2, [sp, #8]
 8000ece:	9b03      	ldr	r3, [sp, #12]
 8000ed0:	0011      	movs	r1, r2
 8000ed2:	0018      	movs	r0, r3
 8000ed4:	f7ff fb14 	bl	8000500 <can_lld_is_tx_empty>
 8000ed8:	0003      	movs	r3, r0
 8000eda:	001a      	movs	r2, r3
 8000edc:	2301      	movs	r3, #1
 8000ede:	4053      	eors	r3, r2
 8000ee0:	b2db      	uxtb	r3, r3
 8000ee2:	2b00      	cmp	r3, #0
 8000ee4:	d1de      	bne.n	8000ea4 <canTransmitTimeout+0x44>
    }
  }
  can_lld_transmit(canp, mailbox, ctfp);
 8000ee6:	9a01      	ldr	r2, [sp, #4]
 8000ee8:	9902      	ldr	r1, [sp, #8]
 8000eea:	9b03      	ldr	r3, [sp, #12]
 8000eec:	0018      	movs	r0, r3
 8000eee:	f7ff fb3f 	bl	8000570 <can_lld_transmit>
  osalSysUnlock();
 8000ef2:	f7ff ff1d 	bl	8000d30 <osalSysUnlock.lto_priv.86>
  return MSG_OK;
 8000ef6:	2300      	movs	r3, #0
}
 8000ef8:	0018      	movs	r0, r3
 8000efa:	b007      	add	sp, #28
 8000efc:	bd00      	pop	{pc}
 8000efe:	46c0      	nop			; (mov r8, r8)
 8000f00:	08003c68 	.word	0x08003c68
	...

08000f10 <canReceiveTimeout>:
 * @api
 */
msg_t canReceiveTimeout(CANDriver *canp,
                        canmbx_t mailbox,
                        CANRxFrame *crfp,
                        systime_t timeout) {
 8000f10:	b500      	push	{lr}
 8000f12:	b087      	sub	sp, #28
 8000f14:	9003      	str	r0, [sp, #12]
 8000f16:	9102      	str	r1, [sp, #8]
 8000f18:	9201      	str	r2, [sp, #4]
 8000f1a:	9300      	str	r3, [sp, #0]

  osalDbgCheck((canp != NULL) && (crfp != NULL) &&
 8000f1c:	9b03      	ldr	r3, [sp, #12]
 8000f1e:	2b00      	cmp	r3, #0
 8000f20:	d005      	beq.n	8000f2e <canReceiveTimeout+0x1e>
 8000f22:	9b01      	ldr	r3, [sp, #4]
 8000f24:	2b00      	cmp	r3, #0
 8000f26:	d002      	beq.n	8000f2e <canReceiveTimeout+0x1e>
 8000f28:	9b02      	ldr	r3, [sp, #8]
 8000f2a:	2b02      	cmp	r3, #2
 8000f2c:	d903      	bls.n	8000f36 <canReceiveTimeout+0x26>
 8000f2e:	4b20      	ldr	r3, [pc, #128]	; (8000fb0 <canReceiveTimeout+0xa0>)
 8000f30:	0018      	movs	r0, r3
 8000f32:	f001 fb85 	bl	8002640 <chSysHalt>
               (mailbox <= (canmbx_t)CAN_RX_MAILBOXES));

  osalSysLock();
 8000f36:	f7ff fef3 	bl	8000d20 <osalSysLock.lto_priv.88>
  osalDbgAssert((canp->state == CAN_READY) || (canp->state == CAN_SLEEP),
 8000f3a:	9b03      	ldr	r3, [sp, #12]
 8000f3c:	781b      	ldrb	r3, [r3, #0]
 8000f3e:	2b03      	cmp	r3, #3
 8000f40:	d018      	beq.n	8000f74 <canReceiveTimeout+0x64>
 8000f42:	9b03      	ldr	r3, [sp, #12]
 8000f44:	781b      	ldrb	r3, [r3, #0]
 8000f46:	2b04      	cmp	r3, #4
 8000f48:	d014      	beq.n	8000f74 <canReceiveTimeout+0x64>
 8000f4a:	4b19      	ldr	r3, [pc, #100]	; (8000fb0 <canReceiveTimeout+0xa0>)
 8000f4c:	0018      	movs	r0, r3
 8000f4e:	f001 fb77 	bl	8002640 <chSysHalt>
 8000f52:	e00f      	b.n	8000f74 <canReceiveTimeout+0x64>
                "invalid state");

  /*lint -save -e9007 [13.5] Right side is supposed to be pure.*/
  while ((canp->state == CAN_SLEEP) || !can_lld_is_rx_nonempty(canp, mailbox)) {
  /*lint -restore*/
    msg_t msg = osalThreadEnqueueTimeoutS(&canp->rxqueue, timeout);
 8000f54:	9b03      	ldr	r3, [sp, #12]
 8000f56:	3310      	adds	r3, #16
 8000f58:	9a00      	ldr	r2, [sp, #0]
 8000f5a:	0011      	movs	r1, r2
 8000f5c:	0018      	movs	r0, r3
 8000f5e:	f7ff feff 	bl	8000d60 <osalThreadEnqueueTimeoutS.lto_priv.82>
 8000f62:	0003      	movs	r3, r0
 8000f64:	9305      	str	r3, [sp, #20]
    if (msg != MSG_OK) {
 8000f66:	9b05      	ldr	r3, [sp, #20]
 8000f68:	2b00      	cmp	r3, #0
 8000f6a:	d003      	beq.n	8000f74 <canReceiveTimeout+0x64>
      osalSysUnlock();
 8000f6c:	f7ff fee0 	bl	8000d30 <osalSysUnlock.lto_priv.86>
      return msg;
 8000f70:	9b05      	ldr	r3, [sp, #20]
 8000f72:	e019      	b.n	8000fa8 <canReceiveTimeout+0x98>
  while ((canp->state == CAN_SLEEP) || !can_lld_is_rx_nonempty(canp, mailbox)) {
 8000f74:	9b03      	ldr	r3, [sp, #12]
 8000f76:	781b      	ldrb	r3, [r3, #0]
 8000f78:	2b04      	cmp	r3, #4
 8000f7a:	d0eb      	beq.n	8000f54 <canReceiveTimeout+0x44>
 8000f7c:	9a02      	ldr	r2, [sp, #8]
 8000f7e:	9b03      	ldr	r3, [sp, #12]
 8000f80:	0011      	movs	r1, r2
 8000f82:	0018      	movs	r0, r3
 8000f84:	f7ff fb5c 	bl	8000640 <can_lld_is_rx_nonempty>
 8000f88:	0003      	movs	r3, r0
 8000f8a:	001a      	movs	r2, r3
 8000f8c:	2301      	movs	r3, #1
 8000f8e:	4053      	eors	r3, r2
 8000f90:	b2db      	uxtb	r3, r3
 8000f92:	2b00      	cmp	r3, #0
 8000f94:	d1de      	bne.n	8000f54 <canReceiveTimeout+0x44>
    }
  }
  can_lld_receive(canp, mailbox, crfp);
 8000f96:	9a01      	ldr	r2, [sp, #4]
 8000f98:	9902      	ldr	r1, [sp, #8]
 8000f9a:	9b03      	ldr	r3, [sp, #12]
 8000f9c:	0018      	movs	r0, r3
 8000f9e:	f7ff fb87 	bl	80006b0 <can_lld_receive>
  osalSysUnlock();
 8000fa2:	f7ff fec5 	bl	8000d30 <osalSysUnlock.lto_priv.86>
  return MSG_OK;
 8000fa6:	2300      	movs	r3, #0
}
 8000fa8:	0018      	movs	r0, r3
 8000faa:	b007      	add	sp, #28
 8000fac:	bd00      	pop	{pc}
 8000fae:	46c0      	nop			; (mov r8, r8)
 8000fb0:	08003c7c 	.word	0x08003c7c
	...

08000fc0 <st_lld_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {
 8000fc0:	b082      	sub	sp, #8
 8000fc2:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000fc4:	2380      	movs	r3, #128	; 0x80
 8000fc6:	05db      	lsls	r3, r3, #23
 8000fc8:	9a01      	ldr	r2, [sp, #4]
 8000fca:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8000fcc:	2380      	movs	r3, #128	; 0x80
 8000fce:	05db      	lsls	r3, r3, #23
 8000fd0:	2200      	movs	r2, #0
 8000fd2:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000fd4:	2380      	movs	r3, #128	; 0x80
 8000fd6:	05db      	lsls	r3, r3, #23
 8000fd8:	2202      	movs	r2, #2
 8000fda:	60da      	str	r2, [r3, #12]
}
 8000fdc:	b002      	add	sp, #8
 8000fde:	4770      	bx	lr

08000fe0 <st_lld_stop_alarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8000fe0:	2380      	movs	r3, #128	; 0x80
 8000fe2:	05db      	lsls	r3, r3, #23
 8000fe4:	2200      	movs	r2, #0
 8000fe6:	60da      	str	r2, [r3, #12]
}
 8000fe8:	4770      	bx	lr
 8000fea:	46c0      	nop			; (mov r8, r8)
 8000fec:	0000      	movs	r0, r0
	...

08000ff0 <st_lld_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {
 8000ff0:	b082      	sub	sp, #8
 8000ff2:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000ff4:	2380      	movs	r3, #128	; 0x80
 8000ff6:	05db      	lsls	r3, r3, #23
 8000ff8:	9a01      	ldr	r2, [sp, #4]
 8000ffa:	635a      	str	r2, [r3, #52]	; 0x34
}
 8000ffc:	b002      	add	sp, #8
 8000ffe:	4770      	bx	lr

08001000 <st_lld_is_alarm_active>:
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8001000:	2380      	movs	r3, #128	; 0x80
 8001002:	05db      	lsls	r3, r3, #23
 8001004:	68db      	ldr	r3, [r3, #12]
 8001006:	2202      	movs	r2, #2
 8001008:	4013      	ands	r3, r2
 800100a:	1e5a      	subs	r2, r3, #1
 800100c:	4193      	sbcs	r3, r2
 800100e:	b2db      	uxtb	r3, r3
}
 8001010:	0018      	movs	r0, r3
 8001012:	4770      	bx	lr
	...

08001020 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 8001020:	b510      	push	{r4, lr}

  st_lld_init();
 8001022:	f7ff fcf5 	bl	8000a10 <st_lld_init>
}
 8001026:	bd10      	pop	{r4, pc}
	...

08001030 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 8001030:	b500      	push	{lr}
 8001032:	b083      	sub	sp, #12
 8001034:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8001036:	f7ff ffe3 	bl	8001000 <st_lld_is_alarm_active>
 800103a:	1e03      	subs	r3, r0, #0
 800103c:	d003      	beq.n	8001046 <stStartAlarm+0x16>
 800103e:	4b05      	ldr	r3, [pc, #20]	; (8001054 <stStartAlarm+0x24>)
 8001040:	0018      	movs	r0, r3
 8001042:	f001 fafd 	bl	8002640 <chSysHalt>

  st_lld_start_alarm(abstime);
 8001046:	9b01      	ldr	r3, [sp, #4]
 8001048:	0018      	movs	r0, r3
 800104a:	f7ff ffb9 	bl	8000fc0 <st_lld_start_alarm>
}
 800104e:	b003      	add	sp, #12
 8001050:	bd00      	pop	{pc}
 8001052:	46c0      	nop			; (mov r8, r8)
 8001054:	08003c90 	.word	0x08003c90
	...

08001060 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 8001060:	b510      	push	{r4, lr}

  st_lld_stop_alarm();
 8001062:	f7ff ffbd 	bl	8000fe0 <st_lld_stop_alarm>
}
 8001066:	bd10      	pop	{r4, pc}
	...

08001070 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8001070:	b500      	push	{lr}
 8001072:	b083      	sub	sp, #12
 8001074:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8001076:	f7ff ffc3 	bl	8001000 <st_lld_is_alarm_active>
 800107a:	0003      	movs	r3, r0
 800107c:	001a      	movs	r2, r3
 800107e:	2301      	movs	r3, #1
 8001080:	4053      	eors	r3, r2
 8001082:	b2db      	uxtb	r3, r3
 8001084:	2b00      	cmp	r3, #0
 8001086:	d003      	beq.n	8001090 <stSetAlarm+0x20>
 8001088:	4b04      	ldr	r3, [pc, #16]	; (800109c <stSetAlarm+0x2c>)
 800108a:	0018      	movs	r0, r3
 800108c:	f001 fad8 	bl	8002640 <chSysHalt>

  st_lld_set_alarm(abstime);
 8001090:	9b01      	ldr	r3, [sp, #4]
 8001092:	0018      	movs	r0, r3
 8001094:	f7ff ffac 	bl	8000ff0 <st_lld_set_alarm>
}
 8001098:	b003      	add	sp, #12
 800109a:	bd00      	pop	{pc}
 800109c:	08003ca0 	.word	0x08003ca0

080010a0 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 80010a0:	b530      	push	{r4, r5, lr}
 80010a2:	b083      	sub	sp, #12
 80010a4:	9001      	str	r0, [sp, #4]
 80010a6:	9100      	str	r1, [sp, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 80010a8:	4c1b      	ldr	r4, [pc, #108]	; (8001118 <nvicEnableVector+0x78>)
 80010aa:	9b01      	ldr	r3, [sp, #4]
 80010ac:	089b      	lsrs	r3, r3, #2
 80010ae:	491a      	ldr	r1, [pc, #104]	; (8001118 <nvicEnableVector+0x78>)
 80010b0:	9a01      	ldr	r2, [sp, #4]
 80010b2:	0892      	lsrs	r2, r2, #2
 80010b4:	32c0      	adds	r2, #192	; 0xc0
 80010b6:	0092      	lsls	r2, r2, #2
 80010b8:	5852      	ldr	r2, [r2, r1]
 80010ba:	9901      	ldr	r1, [sp, #4]
 80010bc:	2003      	movs	r0, #3
 80010be:	4001      	ands	r1, r0
 80010c0:	00c9      	lsls	r1, r1, #3
 80010c2:	20ff      	movs	r0, #255	; 0xff
 80010c4:	4088      	lsls	r0, r1
 80010c6:	0001      	movs	r1, r0
 80010c8:	43c9      	mvns	r1, r1
 80010ca:	4011      	ands	r1, r2
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
 80010cc:	9a00      	ldr	r2, [sp, #0]
 80010ce:	0190      	lsls	r0, r2, #6
 80010d0:	9a01      	ldr	r2, [sp, #4]
 80010d2:	2503      	movs	r5, #3
 80010d4:	402a      	ands	r2, r5
 80010d6:	00d2      	lsls	r2, r2, #3
 80010d8:	4090      	lsls	r0, r2
 80010da:	0002      	movs	r2, r0
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 80010dc:	430a      	orrs	r2, r1
 80010de:	33c0      	adds	r3, #192	; 0xc0
 80010e0:	009b      	lsls	r3, r3, #2
 80010e2:	511a      	str	r2, [r3, r4]
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80010e4:	490c      	ldr	r1, [pc, #48]	; (8001118 <nvicEnableVector+0x78>)
 80010e6:	9b01      	ldr	r3, [sp, #4]
 80010e8:	095b      	lsrs	r3, r3, #5
 80010ea:	9a01      	ldr	r2, [sp, #4]
 80010ec:	201f      	movs	r0, #31
 80010ee:	4002      	ands	r2, r0
 80010f0:	2001      	movs	r0, #1
 80010f2:	4090      	lsls	r0, r2
 80010f4:	0002      	movs	r2, r0
 80010f6:	3360      	adds	r3, #96	; 0x60
 80010f8:	009b      	lsls	r3, r3, #2
 80010fa:	505a      	str	r2, [r3, r1]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80010fc:	4906      	ldr	r1, [pc, #24]	; (8001118 <nvicEnableVector+0x78>)
 80010fe:	9b01      	ldr	r3, [sp, #4]
 8001100:	095b      	lsrs	r3, r3, #5
 8001102:	9a01      	ldr	r2, [sp, #4]
 8001104:	201f      	movs	r0, #31
 8001106:	4002      	ands	r2, r0
 8001108:	2001      	movs	r0, #1
 800110a:	4090      	lsls	r0, r2
 800110c:	0002      	movs	r2, r0
 800110e:	009b      	lsls	r3, r3, #2
 8001110:	505a      	str	r2, [r3, r1]
}
 8001112:	b003      	add	sp, #12
 8001114:	bd30      	pop	{r4, r5, pc}
 8001116:	46c0      	nop			; (mov r8, r8)
 8001118:	e000e100 	.word	0xe000e100
 800111c:	00000000 	.word	0x00000000

08001120 <hal_lld_backup_domain_init>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8001120:	4b15      	ldr	r3, [pc, #84]	; (8001178 <hal_lld_backup_domain_init+0x58>)
 8001122:	4a15      	ldr	r2, [pc, #84]	; (8001178 <hal_lld_backup_domain_init+0x58>)
 8001124:	6812      	ldr	r2, [r2, #0]
 8001126:	2180      	movs	r1, #128	; 0x80
 8001128:	0049      	lsls	r1, r1, #1
 800112a:	430a      	orrs	r2, r1
 800112c:	601a      	str	r2, [r3, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 800112e:	4b13      	ldr	r3, [pc, #76]	; (800117c <hal_lld_backup_domain_init+0x5c>)
 8001130:	6a1a      	ldr	r2, [r3, #32]
 8001132:	23c0      	movs	r3, #192	; 0xc0
 8001134:	009b      	lsls	r3, r3, #2
 8001136:	401a      	ands	r2, r3
 8001138:	2380      	movs	r3, #128	; 0x80
 800113a:	009b      	lsls	r3, r3, #2
 800113c:	429a      	cmp	r2, r3
 800113e:	d006      	beq.n	800114e <hal_lld_backup_domain_init+0x2e>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8001140:	4b0e      	ldr	r3, [pc, #56]	; (800117c <hal_lld_backup_domain_init+0x5c>)
 8001142:	2280      	movs	r2, #128	; 0x80
 8001144:	0252      	lsls	r2, r2, #9
 8001146:	621a      	str	r2, [r3, #32]
    RCC->BDCR = 0;
 8001148:	4b0c      	ldr	r3, [pc, #48]	; (800117c <hal_lld_backup_domain_init+0x5c>)
 800114a:	2200      	movs	r2, #0
 800114c:	621a      	str	r2, [r3, #32]
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 800114e:	4b0b      	ldr	r3, [pc, #44]	; (800117c <hal_lld_backup_domain_init+0x5c>)
 8001150:	6a1a      	ldr	r2, [r3, #32]
 8001152:	2380      	movs	r3, #128	; 0x80
 8001154:	021b      	lsls	r3, r3, #8
 8001156:	4013      	ands	r3, r2
 8001158:	d10d      	bne.n	8001176 <hal_lld_backup_domain_init+0x56>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 800115a:	4b08      	ldr	r3, [pc, #32]	; (800117c <hal_lld_backup_domain_init+0x5c>)
 800115c:	4a07      	ldr	r2, [pc, #28]	; (800117c <hal_lld_backup_domain_init+0x5c>)
 800115e:	6a12      	ldr	r2, [r2, #32]
 8001160:	2180      	movs	r1, #128	; 0x80
 8001162:	0089      	lsls	r1, r1, #2
 8001164:	430a      	orrs	r2, r1
 8001166:	621a      	str	r2, [r3, #32]

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 8001168:	4b04      	ldr	r3, [pc, #16]	; (800117c <hal_lld_backup_domain_init+0x5c>)
 800116a:	4a04      	ldr	r2, [pc, #16]	; (800117c <hal_lld_backup_domain_init+0x5c>)
 800116c:	6a12      	ldr	r2, [r2, #32]
 800116e:	2180      	movs	r1, #128	; 0x80
 8001170:	0209      	lsls	r1, r1, #8
 8001172:	430a      	orrs	r2, r1
 8001174:	621a      	str	r2, [r3, #32]
  }
#endif /* STM32_RTCSEL != STM32_RTCSEL_NOCLOCK */
}
 8001176:	4770      	bx	lr
 8001178:	40007000 	.word	0x40007000
 800117c:	40021000 	.word	0x40021000

08001180 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 8001180:	b510      	push	{r4, lr}

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 8001182:	4b12      	ldr	r3, [pc, #72]	; (80011cc <hal_lld_init+0x4c>)
 8001184:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001186:	4b11      	ldr	r3, [pc, #68]	; (80011cc <hal_lld_init+0x4c>)
 8001188:	2201      	movs	r2, #1
 800118a:	4252      	negs	r2, r2
 800118c:	629a      	str	r2, [r3, #40]	; 0x28
 800118e:	4b0f      	ldr	r3, [pc, #60]	; (80011cc <hal_lld_init+0x4c>)
 8001190:	2200      	movs	r2, #0
 8001192:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 8001194:	4b0d      	ldr	r3, [pc, #52]	; (80011cc <hal_lld_init+0x4c>)
 8001196:	691b      	ldr	r3, [r3, #16]
 8001198:	4b0c      	ldr	r3, [pc, #48]	; (80011cc <hal_lld_init+0x4c>)
 800119a:	2201      	movs	r2, #1
 800119c:	4252      	negs	r2, r2
 800119e:	611a      	str	r2, [r3, #16]
 80011a0:	4b0a      	ldr	r3, [pc, #40]	; (80011cc <hal_lld_init+0x4c>)
 80011a2:	2200      	movs	r2, #0
 80011a4:	611a      	str	r2, [r3, #16]
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 80011a6:	4b09      	ldr	r3, [pc, #36]	; (80011cc <hal_lld_init+0x4c>)
 80011a8:	4a08      	ldr	r2, [pc, #32]	; (80011cc <hal_lld_init+0x4c>)
 80011aa:	68d2      	ldr	r2, [r2, #12]
 80011ac:	4908      	ldr	r1, [pc, #32]	; (80011d0 <hal_lld_init+0x50>)
 80011ae:	430a      	orrs	r2, r1
 80011b0:	60da      	str	r2, [r3, #12]
 80011b2:	4b06      	ldr	r3, [pc, #24]	; (80011cc <hal_lld_init+0x4c>)
 80011b4:	2200      	movs	r2, #0
 80011b6:	60da      	str	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 80011b8:	4b04      	ldr	r3, [pc, #16]	; (80011cc <hal_lld_init+0x4c>)
 80011ba:	4a04      	ldr	r2, [pc, #16]	; (80011cc <hal_lld_init+0x4c>)
 80011bc:	69d2      	ldr	r2, [r2, #28]
 80011be:	2180      	movs	r1, #128	; 0x80
 80011c0:	0549      	lsls	r1, r1, #21
 80011c2:	430a      	orrs	r2, r1
 80011c4:	61da      	str	r2, [r3, #28]

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 80011c6:	f7ff ffab 	bl	8001120 <hal_lld_backup_domain_init>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 80011ca:	bd10      	pop	{r4, pc}
 80011cc:	40021000 	.word	0x40021000
 80011d0:	ffbfffff 	.word	0xffbfffff
	...

080011e0 <stm32_clock_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80011e0:	4b32      	ldr	r3, [pc, #200]	; (80012ac <stm32_clock_init+0xcc>)
 80011e2:	4a32      	ldr	r2, [pc, #200]	; (80012ac <stm32_clock_init+0xcc>)
 80011e4:	6812      	ldr	r2, [r2, #0]
 80011e6:	2101      	movs	r1, #1
 80011e8:	430a      	orrs	r2, r1
 80011ea:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80011ec:	4b2f      	ldr	r3, [pc, #188]	; (80012ac <stm32_clock_init+0xcc>)
 80011ee:	681b      	ldr	r3, [r3, #0]
 80011f0:	2202      	movs	r2, #2
 80011f2:	4013      	ands	r3, r2
 80011f4:	d0fa      	beq.n	80011ec <stm32_clock_init+0xc>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 80011f6:	4b2d      	ldr	r3, [pc, #180]	; (80012ac <stm32_clock_init+0xcc>)
 80011f8:	4a2c      	ldr	r2, [pc, #176]	; (80012ac <stm32_clock_init+0xcc>)
 80011fa:	6852      	ldr	r2, [r2, #4]
 80011fc:	2103      	movs	r1, #3
 80011fe:	438a      	bics	r2, r1
 8001200:	605a      	str	r2, [r3, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8001202:	4b2a      	ldr	r3, [pc, #168]	; (80012ac <stm32_clock_init+0xcc>)
 8001204:	4a29      	ldr	r2, [pc, #164]	; (80012ac <stm32_clock_init+0xcc>)
 8001206:	6852      	ldr	r2, [r2, #4]
 8001208:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800120a:	4b28      	ldr	r3, [pc, #160]	; (80012ac <stm32_clock_init+0xcc>)
 800120c:	685b      	ldr	r3, [r3, #4]
 800120e:	220c      	movs	r2, #12
 8001210:	4013      	ands	r3, r2
 8001212:	d1fa      	bne.n	800120a <stm32_clock_init+0x2a>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8001214:	4b25      	ldr	r3, [pc, #148]	; (80012ac <stm32_clock_init+0xcc>)
 8001216:	4a25      	ldr	r2, [pc, #148]	; (80012ac <stm32_clock_init+0xcc>)
 8001218:	6812      	ldr	r2, [r2, #0]
 800121a:	21f9      	movs	r1, #249	; 0xf9
 800121c:	400a      	ands	r2, r1
 800121e:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8001220:	4b22      	ldr	r3, [pc, #136]	; (80012ac <stm32_clock_init+0xcc>)
 8001222:	2200      	movs	r2, #0
 8001224:	605a      	str	r2, [r3, #4]
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_HSI14_ENABLED
  /* HSI14 activation.*/
  RCC->CR2 |= RCC_CR2_HSI14ON;
 8001226:	4b21      	ldr	r3, [pc, #132]	; (80012ac <stm32_clock_init+0xcc>)
 8001228:	4a20      	ldr	r2, [pc, #128]	; (80012ac <stm32_clock_init+0xcc>)
 800122a:	6b52      	ldr	r2, [r2, #52]	; 0x34
 800122c:	2101      	movs	r1, #1
 800122e:	430a      	orrs	r2, r1
 8001230:	635a      	str	r2, [r3, #52]	; 0x34
  while (!(RCC->CR2 & RCC_CR2_HSI14RDY))
 8001232:	4b1e      	ldr	r3, [pc, #120]	; (80012ac <stm32_clock_init+0xcc>)
 8001234:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8001236:	2202      	movs	r2, #2
 8001238:	4013      	ands	r3, r2
 800123a:	d0fa      	beq.n	8001232 <stm32_clock_init+0x52>
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 800123c:	4b1b      	ldr	r3, [pc, #108]	; (80012ac <stm32_clock_init+0xcc>)
 800123e:	4a1b      	ldr	r2, [pc, #108]	; (80012ac <stm32_clock_init+0xcc>)
 8001240:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8001242:	2101      	movs	r1, #1
 8001244:	430a      	orrs	r2, r1
 8001246:	625a      	str	r2, [r3, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8001248:	4b18      	ldr	r3, [pc, #96]	; (80012ac <stm32_clock_init+0xcc>)
 800124a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800124c:	2202      	movs	r2, #2
 800124e:	4013      	ands	r3, r2
 8001250:	d0fa      	beq.n	8001248 <stm32_clock_init+0x68>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  /* CFGR2 must be configured first since CFGR value could change CFGR2 */
  RCC->CFGR2 = STM32_PREDIV;
 8001252:	4b16      	ldr	r3, [pc, #88]	; (80012ac <stm32_clock_init+0xcc>)
 8001254:	2200      	movs	r2, #0
 8001256:	62da      	str	r2, [r3, #44]	; 0x2c
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 8001258:	4b14      	ldr	r3, [pc, #80]	; (80012ac <stm32_clock_init+0xcc>)
 800125a:	22a0      	movs	r2, #160	; 0xa0
 800125c:	0392      	lsls	r2, r2, #14
 800125e:	605a      	str	r2, [r3, #4]
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE |
               ((STM32_PREDIV & STM32_PLLXTPRE_MASK) << STM32_PLLXTPRE_OFFSET);
#if STM32_CECSW == STM32_CECSW_OFF
  RCC->CFGR3 = STM32_USBSW  | STM32_I2C1SW | STM32_USART1SW;
#else
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
 8001260:	4b12      	ldr	r3, [pc, #72]	; (80012ac <stm32_clock_init+0xcc>)
 8001262:	2200      	movs	r2, #0
 8001264:	631a      	str	r2, [r3, #48]	; 0x30
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8001266:	4b11      	ldr	r3, [pc, #68]	; (80012ac <stm32_clock_init+0xcc>)
 8001268:	4a10      	ldr	r2, [pc, #64]	; (80012ac <stm32_clock_init+0xcc>)
 800126a:	6812      	ldr	r2, [r2, #0]
 800126c:	2180      	movs	r1, #128	; 0x80
 800126e:	0449      	lsls	r1, r1, #17
 8001270:	430a      	orrs	r2, r1
 8001272:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8001274:	4b0d      	ldr	r3, [pc, #52]	; (80012ac <stm32_clock_init+0xcc>)
 8001276:	681a      	ldr	r2, [r3, #0]
 8001278:	2380      	movs	r3, #128	; 0x80
 800127a:	049b      	lsls	r3, r3, #18
 800127c:	4013      	ands	r3, r2
 800127e:	d0f9      	beq.n	8001274 <stm32_clock_init+0x94>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8001280:	4b0b      	ldr	r3, [pc, #44]	; (80012b0 <stm32_clock_init+0xd0>)
 8001282:	2211      	movs	r2, #17
 8001284:	601a      	str	r2, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8001286:	4b09      	ldr	r3, [pc, #36]	; (80012ac <stm32_clock_init+0xcc>)
 8001288:	4a08      	ldr	r2, [pc, #32]	; (80012ac <stm32_clock_init+0xcc>)
 800128a:	6852      	ldr	r2, [r2, #4]
 800128c:	2102      	movs	r1, #2
 800128e:	430a      	orrs	r2, r1
 8001290:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8001292:	4b06      	ldr	r3, [pc, #24]	; (80012ac <stm32_clock_init+0xcc>)
 8001294:	685b      	ldr	r3, [r3, #4]
 8001296:	220c      	movs	r2, #12
 8001298:	4013      	ands	r3, r2
 800129a:	2b08      	cmp	r3, #8
 800129c:	d1f9      	bne.n	8001292 <stm32_clock_init+0xb2>
    ;                                       /* Waits selection complete.    */
#endif

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 800129e:	4b03      	ldr	r3, [pc, #12]	; (80012ac <stm32_clock_init+0xcc>)
 80012a0:	4a02      	ldr	r2, [pc, #8]	; (80012ac <stm32_clock_init+0xcc>)
 80012a2:	6992      	ldr	r2, [r2, #24]
 80012a4:	2101      	movs	r1, #1
 80012a6:	430a      	orrs	r2, r1
 80012a8:	619a      	str	r2, [r3, #24]
#endif /* !STM32_NO_INIT */
}
 80012aa:	4770      	bx	lr
 80012ac:	40021000 	.word	0x40021000
 80012b0:	40022000 	.word	0x40022000
	...

080012c0 <port_lock.lto_priv.65>:
  __ASM volatile ("cpsid i" : : : "memory");
 80012c0:	b672      	cpsid	i
}
 80012c2:	4770      	bx	lr
	...

080012d0 <port_unlock.lto_priv.63>:
  __ASM volatile ("cpsie i" : : : "memory");
 80012d0:	b662      	cpsie	i
}
 80012d2:	4770      	bx	lr
	...

080012e0 <port_lock_from_isr>:
static inline void port_lock_from_isr(void) {
 80012e0:	b510      	push	{r4, lr}
  port_lock();
 80012e2:	f7ff ffed 	bl	80012c0 <port_lock.lto_priv.65>
}
 80012e6:	bd10      	pop	{r4, pc}
	...

080012f0 <port_unlock_from_isr>:
static inline void port_unlock_from_isr(void) {
 80012f0:	b510      	push	{r4, lr}
  port_unlock();
 80012f2:	f7ff ffed 	bl	80012d0 <port_unlock.lto_priv.63>
}
 80012f6:	bd10      	pop	{r4, pc}
	...

08001300 <chSysLockFromISR>:
static inline void chSysLockFromISR(void) {
 8001300:	b510      	push	{r4, lr}
  port_lock_from_isr();
 8001302:	f7ff ffed 	bl	80012e0 <port_lock_from_isr>
  _dbg_check_lock_from_isr();
 8001306:	f001 fa1b 	bl	8002740 <_dbg_check_lock_from_isr>
}
 800130a:	bd10      	pop	{r4, pc}
 800130c:	0000      	movs	r0, r0
	...

08001310 <chSysUnlockFromISR>:
static inline void chSysUnlockFromISR(void) {
 8001310:	b510      	push	{r4, lr}
  _dbg_check_unlock_from_isr();
 8001312:	f001 fa2d 	bl	8002770 <_dbg_check_unlock_from_isr>
  port_unlock_from_isr();
 8001316:	f7ff ffeb 	bl	80012f0 <port_unlock_from_isr>
}
 800131a:	bd10      	pop	{r4, pc}
 800131c:	0000      	movs	r0, r0
	...

08001320 <chThdSleepS>:
static inline void chThdSleepS(systime_t time) {
 8001320:	b500      	push	{lr}
 8001322:	b083      	sub	sp, #12
 8001324:	9001      	str	r0, [sp, #4]
  chDbgCheck(time != TIME_IMMEDIATE);
 8001326:	9b01      	ldr	r3, [sp, #4]
 8001328:	2b00      	cmp	r3, #0
 800132a:	d103      	bne.n	8001334 <chThdSleepS+0x14>
 800132c:	4b05      	ldr	r3, [pc, #20]	; (8001344 <chThdSleepS+0x24>)
 800132e:	0018      	movs	r0, r3
 8001330:	f001 f986 	bl	8002640 <chSysHalt>
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8001334:	9b01      	ldr	r3, [sp, #4]
 8001336:	0019      	movs	r1, r3
 8001338:	2008      	movs	r0, #8
 800133a:	f001 ff01 	bl	8003140 <chSchGoSleepTimeoutS>
}
 800133e:	b003      	add	sp, #12
 8001340:	bd00      	pop	{pc}
 8001342:	46c0      	nop			; (mov r8, r8)
 8001344:	08003cb8 	.word	0x08003cb8
	...

08001350 <osalSysLockFromISR.lto_priv.2>:
static inline void osalSysLockFromISR(void) {
 8001350:	b510      	push	{r4, lr}
  chSysLockFromISR();
 8001352:	f7ff ffd5 	bl	8001300 <chSysLockFromISR>
}
 8001356:	bd10      	pop	{r4, pc}
	...

08001360 <osalSysUnlockFromISR.lto_priv.0>:
static inline void osalSysUnlockFromISR(void) {
 8001360:	b510      	push	{r4, lr}
  chSysUnlockFromISR();
 8001362:	f7ff ffd5 	bl	8001310 <chSysUnlockFromISR>
}
 8001366:	bd10      	pop	{r4, pc}
	...

08001370 <osalThreadSleepS.lto_priv.59>:
static inline void osalThreadSleepS(systime_t time) {
 8001370:	b500      	push	{lr}
 8001372:	b083      	sub	sp, #12
 8001374:	9001      	str	r0, [sp, #4]
  chThdSleepS(time);
 8001376:	9b01      	ldr	r3, [sp, #4]
 8001378:	0018      	movs	r0, r3
 800137a:	f7ff ffd1 	bl	8001320 <chThdSleepS>
}
 800137e:	b003      	add	sp, #12
 8001380:	bd00      	pop	{pc}
 8001382:	46c0      	nop			; (mov r8, r8)
	...

08001390 <osalThreadDequeueAllI.lto_priv.61>:
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8001390:	b500      	push	{lr}
 8001392:	b083      	sub	sp, #12
 8001394:	9001      	str	r0, [sp, #4]
 8001396:	9100      	str	r1, [sp, #0]
  chThdDequeueAllI(tqp, msg);
 8001398:	9a00      	ldr	r2, [sp, #0]
 800139a:	9b01      	ldr	r3, [sp, #4]
 800139c:	0011      	movs	r1, r2
 800139e:	0018      	movs	r0, r3
 80013a0:	f000 fc36 	bl	8001c10 <chThdDequeueAllI>
}
 80013a4:	b003      	add	sp, #12
 80013a6:	bd00      	pop	{pc}
	...

080013b0 <osalEventBroadcastFlagsI.lto_priv.60>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 80013b0:	b500      	push	{lr}
 80013b2:	b083      	sub	sp, #12
 80013b4:	9001      	str	r0, [sp, #4]
 80013b6:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
 80013b8:	9a00      	ldr	r2, [sp, #0]
 80013ba:	9b01      	ldr	r3, [sp, #4]
 80013bc:	0011      	movs	r1, r2
 80013be:	0018      	movs	r0, r3
 80013c0:	f000 f9de 	bl	8001780 <chEvtBroadcastFlagsI>
}
 80013c4:	b003      	add	sp, #12
 80013c6:	bd00      	pop	{pc}
	...

080013d0 <can_lld_set_filters.lto_priv.58>:
                                const CANFilter *cfp) {
 80013d0:	b086      	sub	sp, #24
 80013d2:	9003      	str	r0, [sp, #12]
 80013d4:	9102      	str	r1, [sp, #8]
 80013d6:	9201      	str	r2, [sp, #4]
 80013d8:	9300      	str	r3, [sp, #0]
  if(canp == &CAND1) {
 80013da:	9a03      	ldr	r2, [sp, #12]
 80013dc:	4b86      	ldr	r3, [pc, #536]	; (80015f8 <can_lld_set_filters.lto_priv.58+0x228>)
 80013de:	429a      	cmp	r2, r3
 80013e0:	d125      	bne.n	800142e <can_lld_set_filters.lto_priv.58+0x5e>
    rccEnableCAN1(FALSE);
 80013e2:	4b86      	ldr	r3, [pc, #536]	; (80015fc <can_lld_set_filters.lto_priv.58+0x22c>)
 80013e4:	4a85      	ldr	r2, [pc, #532]	; (80015fc <can_lld_set_filters.lto_priv.58+0x22c>)
 80013e6:	69d2      	ldr	r2, [r2, #28]
 80013e8:	2180      	movs	r1, #128	; 0x80
 80013ea:	0489      	lsls	r1, r1, #18
 80013ec:	430a      	orrs	r2, r1
 80013ee:	61da      	str	r2, [r3, #28]
    canp->can->FMR = (canp->can->FMR & 0xFFFF0000) | CAN_FMR_FINIT;
 80013f0:	9b03      	ldr	r3, [sp, #12]
 80013f2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80013f4:	9b03      	ldr	r3, [sp, #12]
 80013f6:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 80013f8:	2380      	movs	r3, #128	; 0x80
 80013fa:	009b      	lsls	r3, r3, #2
 80013fc:	58cb      	ldr	r3, [r1, r3]
 80013fe:	0c1b      	lsrs	r3, r3, #16
 8001400:	041b      	lsls	r3, r3, #16
 8001402:	2101      	movs	r1, #1
 8001404:	4319      	orrs	r1, r3
 8001406:	2380      	movs	r3, #128	; 0x80
 8001408:	009b      	lsls	r3, r3, #2
 800140a:	50d1      	str	r1, [r2, r3]
    canp->can->FMR = (canp->can->FMR & 0xFFFF0000) | (can2sb << 8) | CAN_FMR_FINIT;
 800140c:	9b03      	ldr	r3, [sp, #12]
 800140e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001410:	9b03      	ldr	r3, [sp, #12]
 8001412:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8001414:	2380      	movs	r3, #128	; 0x80
 8001416:	009b      	lsls	r3, r3, #2
 8001418:	58cb      	ldr	r3, [r1, r3]
 800141a:	0c1b      	lsrs	r3, r3, #16
 800141c:	0419      	lsls	r1, r3, #16
 800141e:	9b02      	ldr	r3, [sp, #8]
 8001420:	021b      	lsls	r3, r3, #8
 8001422:	430b      	orrs	r3, r1
 8001424:	2101      	movs	r1, #1
 8001426:	4319      	orrs	r1, r3
 8001428:	2380      	movs	r3, #128	; 0x80
 800142a:	009b      	lsls	r3, r3, #2
 800142c:	50d1      	str	r1, [r2, r3]
  if (num > 0) {
 800142e:	9b01      	ldr	r3, [sp, #4]
 8001430:	2b00      	cmp	r3, #0
 8001432:	d100      	bne.n	8001436 <can_lld_set_filters.lto_priv.58+0x66>
 8001434:	e0a3      	b.n	800157e <can_lld_set_filters.lto_priv.58+0x1ae>
    canp->can->FA1R = 0;
 8001436:	9b03      	ldr	r3, [sp, #12]
 8001438:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800143a:	2387      	movs	r3, #135	; 0x87
 800143c:	009b      	lsls	r3, r3, #2
 800143e:	2100      	movs	r1, #0
 8001440:	50d1      	str	r1, [r2, r3]
    canp->can->FM1R = 0;
 8001442:	9b03      	ldr	r3, [sp, #12]
 8001444:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001446:	2381      	movs	r3, #129	; 0x81
 8001448:	009b      	lsls	r3, r3, #2
 800144a:	2100      	movs	r1, #0
 800144c:	50d1      	str	r1, [r2, r3]
    canp->can->FS1R = 0;
 800144e:	9b03      	ldr	r3, [sp, #12]
 8001450:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001452:	2383      	movs	r3, #131	; 0x83
 8001454:	009b      	lsls	r3, r3, #2
 8001456:	2100      	movs	r1, #0
 8001458:	50d1      	str	r1, [r2, r3]
    canp->can->FFA1R = 0;
 800145a:	9b03      	ldr	r3, [sp, #12]
 800145c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800145e:	2385      	movs	r3, #133	; 0x85
 8001460:	009b      	lsls	r3, r3, #2
 8001462:	2100      	movs	r1, #0
 8001464:	50d1      	str	r1, [r2, r3]
    if(canp == &CAND1) {
 8001466:	9a03      	ldr	r2, [sp, #12]
 8001468:	4b63      	ldr	r3, [pc, #396]	; (80015f8 <can_lld_set_filters.lto_priv.58+0x228>)
 800146a:	429a      	cmp	r2, r3
 800146c:	d118      	bne.n	80014a0 <can_lld_set_filters.lto_priv.58+0xd0>
      for (i = 0; i < STM32_CAN_MAX_FILTERS; i++) {
 800146e:	2300      	movs	r3, #0
 8001470:	9305      	str	r3, [sp, #20]
 8001472:	e012      	b.n	800149a <can_lld_set_filters.lto_priv.58+0xca>
        canp->can->sFilterRegister[i].FR1 = 0;
 8001474:	9b03      	ldr	r3, [sp, #12]
 8001476:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001478:	9a05      	ldr	r2, [sp, #20]
 800147a:	3248      	adds	r2, #72	; 0x48
 800147c:	00d2      	lsls	r2, r2, #3
 800147e:	2100      	movs	r1, #0
 8001480:	50d1      	str	r1, [r2, r3]
        canp->can->sFilterRegister[i].FR2 = 0;
 8001482:	9b03      	ldr	r3, [sp, #12]
 8001484:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001486:	9b05      	ldr	r3, [sp, #20]
 8001488:	3348      	adds	r3, #72	; 0x48
 800148a:	00db      	lsls	r3, r3, #3
 800148c:	18d3      	adds	r3, r2, r3
 800148e:	3304      	adds	r3, #4
 8001490:	2200      	movs	r2, #0
 8001492:	601a      	str	r2, [r3, #0]
      for (i = 0; i < STM32_CAN_MAX_FILTERS; i++) {
 8001494:	9b05      	ldr	r3, [sp, #20]
 8001496:	3301      	adds	r3, #1
 8001498:	9305      	str	r3, [sp, #20]
 800149a:	9b05      	ldr	r3, [sp, #20]
 800149c:	2b0d      	cmp	r3, #13
 800149e:	d9e9      	bls.n	8001474 <can_lld_set_filters.lto_priv.58+0xa4>
    for (i = 0; i < num; i++) {
 80014a0:	2300      	movs	r3, #0
 80014a2:	9305      	str	r3, [sp, #20]
 80014a4:	e066      	b.n	8001574 <can_lld_set_filters.lto_priv.58+0x1a4>
      fmask = 1 << cfp->filter;
 80014a6:	9b00      	ldr	r3, [sp, #0]
 80014a8:	681b      	ldr	r3, [r3, #0]
 80014aa:	2201      	movs	r2, #1
 80014ac:	409a      	lsls	r2, r3
 80014ae:	0013      	movs	r3, r2
 80014b0:	9304      	str	r3, [sp, #16]
      if (cfp->mode)
 80014b2:	9b00      	ldr	r3, [sp, #0]
 80014b4:	791b      	ldrb	r3, [r3, #4]
 80014b6:	2201      	movs	r2, #1
 80014b8:	4013      	ands	r3, r2
 80014ba:	b2db      	uxtb	r3, r3
 80014bc:	2b00      	cmp	r3, #0
 80014be:	d00b      	beq.n	80014d8 <can_lld_set_filters.lto_priv.58+0x108>
        canp->can->FM1R |= fmask;
 80014c0:	9b03      	ldr	r3, [sp, #12]
 80014c2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80014c4:	9b03      	ldr	r3, [sp, #12]
 80014c6:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 80014c8:	2381      	movs	r3, #129	; 0x81
 80014ca:	009b      	lsls	r3, r3, #2
 80014cc:	58c9      	ldr	r1, [r1, r3]
 80014ce:	9b04      	ldr	r3, [sp, #16]
 80014d0:	4319      	orrs	r1, r3
 80014d2:	2381      	movs	r3, #129	; 0x81
 80014d4:	009b      	lsls	r3, r3, #2
 80014d6:	50d1      	str	r1, [r2, r3]
      if (cfp->scale)
 80014d8:	9b00      	ldr	r3, [sp, #0]
 80014da:	791b      	ldrb	r3, [r3, #4]
 80014dc:	2202      	movs	r2, #2
 80014de:	4013      	ands	r3, r2
 80014e0:	b2db      	uxtb	r3, r3
 80014e2:	2b00      	cmp	r3, #0
 80014e4:	d00b      	beq.n	80014fe <can_lld_set_filters.lto_priv.58+0x12e>
        canp->can->FS1R |= fmask;
 80014e6:	9b03      	ldr	r3, [sp, #12]
 80014e8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80014ea:	9b03      	ldr	r3, [sp, #12]
 80014ec:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 80014ee:	2383      	movs	r3, #131	; 0x83
 80014f0:	009b      	lsls	r3, r3, #2
 80014f2:	58c9      	ldr	r1, [r1, r3]
 80014f4:	9b04      	ldr	r3, [sp, #16]
 80014f6:	4319      	orrs	r1, r3
 80014f8:	2383      	movs	r3, #131	; 0x83
 80014fa:	009b      	lsls	r3, r3, #2
 80014fc:	50d1      	str	r1, [r2, r3]
      if (cfp->assignment)
 80014fe:	9b00      	ldr	r3, [sp, #0]
 8001500:	791b      	ldrb	r3, [r3, #4]
 8001502:	2204      	movs	r2, #4
 8001504:	4013      	ands	r3, r2
 8001506:	b2db      	uxtb	r3, r3
 8001508:	2b00      	cmp	r3, #0
 800150a:	d00b      	beq.n	8001524 <can_lld_set_filters.lto_priv.58+0x154>
        canp->can->FFA1R |= fmask;
 800150c:	9b03      	ldr	r3, [sp, #12]
 800150e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001510:	9b03      	ldr	r3, [sp, #12]
 8001512:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8001514:	2385      	movs	r3, #133	; 0x85
 8001516:	009b      	lsls	r3, r3, #2
 8001518:	58c9      	ldr	r1, [r1, r3]
 800151a:	9b04      	ldr	r3, [sp, #16]
 800151c:	4319      	orrs	r1, r3
 800151e:	2385      	movs	r3, #133	; 0x85
 8001520:	009b      	lsls	r3, r3, #2
 8001522:	50d1      	str	r1, [r2, r3]
      canp->can->sFilterRegister[cfp->filter].FR1 = cfp->register1;
 8001524:	9b03      	ldr	r3, [sp, #12]
 8001526:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001528:	9b00      	ldr	r3, [sp, #0]
 800152a:	6818      	ldr	r0, [r3, #0]
 800152c:	9b00      	ldr	r3, [sp, #0]
 800152e:	6899      	ldr	r1, [r3, #8]
 8001530:	0003      	movs	r3, r0
 8001532:	3348      	adds	r3, #72	; 0x48
 8001534:	00db      	lsls	r3, r3, #3
 8001536:	5099      	str	r1, [r3, r2]
      canp->can->sFilterRegister[cfp->filter].FR2 = cfp->register2;
 8001538:	9b03      	ldr	r3, [sp, #12]
 800153a:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 800153c:	9b00      	ldr	r3, [sp, #0]
 800153e:	6818      	ldr	r0, [r3, #0]
 8001540:	9b00      	ldr	r3, [sp, #0]
 8001542:	68da      	ldr	r2, [r3, #12]
 8001544:	0003      	movs	r3, r0
 8001546:	3348      	adds	r3, #72	; 0x48
 8001548:	00db      	lsls	r3, r3, #3
 800154a:	18cb      	adds	r3, r1, r3
 800154c:	3304      	adds	r3, #4
 800154e:	601a      	str	r2, [r3, #0]
      canp->can->FA1R |= fmask;
 8001550:	9b03      	ldr	r3, [sp, #12]
 8001552:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001554:	9b03      	ldr	r3, [sp, #12]
 8001556:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8001558:	2387      	movs	r3, #135	; 0x87
 800155a:	009b      	lsls	r3, r3, #2
 800155c:	58c9      	ldr	r1, [r1, r3]
 800155e:	9b04      	ldr	r3, [sp, #16]
 8001560:	4319      	orrs	r1, r3
 8001562:	2387      	movs	r3, #135	; 0x87
 8001564:	009b      	lsls	r3, r3, #2
 8001566:	50d1      	str	r1, [r2, r3]
      cfp++;
 8001568:	9b00      	ldr	r3, [sp, #0]
 800156a:	3310      	adds	r3, #16
 800156c:	9300      	str	r3, [sp, #0]
    for (i = 0; i < num; i++) {
 800156e:	9b05      	ldr	r3, [sp, #20]
 8001570:	3301      	adds	r3, #1
 8001572:	9305      	str	r3, [sp, #20]
 8001574:	9a05      	ldr	r2, [sp, #20]
 8001576:	9b01      	ldr	r3, [sp, #4]
 8001578:	429a      	cmp	r2, r3
 800157a:	d394      	bcc.n	80014a6 <can_lld_set_filters.lto_priv.58+0xd6>
 800157c:	e023      	b.n	80015c6 <can_lld_set_filters.lto_priv.58+0x1f6>
    canp->can->sFilterRegister[0].FR1 = 0;
 800157e:	9b03      	ldr	r3, [sp, #12]
 8001580:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001582:	2390      	movs	r3, #144	; 0x90
 8001584:	009b      	lsls	r3, r3, #2
 8001586:	2100      	movs	r1, #0
 8001588:	50d1      	str	r1, [r2, r3]
    canp->can->sFilterRegister[0].FR2 = 0;
 800158a:	9b03      	ldr	r3, [sp, #12]
 800158c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800158e:	2391      	movs	r3, #145	; 0x91
 8001590:	009b      	lsls	r3, r3, #2
 8001592:	2100      	movs	r1, #0
 8001594:	50d1      	str	r1, [r2, r3]
    canp->can->FM1R = 0;
 8001596:	9b03      	ldr	r3, [sp, #12]
 8001598:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800159a:	2381      	movs	r3, #129	; 0x81
 800159c:	009b      	lsls	r3, r3, #2
 800159e:	2100      	movs	r1, #0
 80015a0:	50d1      	str	r1, [r2, r3]
    canp->can->FFA1R = 0;
 80015a2:	9b03      	ldr	r3, [sp, #12]
 80015a4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80015a6:	2385      	movs	r3, #133	; 0x85
 80015a8:	009b      	lsls	r3, r3, #2
 80015aa:	2100      	movs	r1, #0
 80015ac:	50d1      	str	r1, [r2, r3]
    canp->can->FS1R = 1;
 80015ae:	9b03      	ldr	r3, [sp, #12]
 80015b0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80015b2:	2383      	movs	r3, #131	; 0x83
 80015b4:	009b      	lsls	r3, r3, #2
 80015b6:	2101      	movs	r1, #1
 80015b8:	50d1      	str	r1, [r2, r3]
    canp->can->FA1R = 1;
 80015ba:	9b03      	ldr	r3, [sp, #12]
 80015bc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80015be:	2387      	movs	r3, #135	; 0x87
 80015c0:	009b      	lsls	r3, r3, #2
 80015c2:	2101      	movs	r1, #1
 80015c4:	50d1      	str	r1, [r2, r3]
  canp->can->FMR &= ~CAN_FMR_FINIT;
 80015c6:	9b03      	ldr	r3, [sp, #12]
 80015c8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80015ca:	9b03      	ldr	r3, [sp, #12]
 80015cc:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 80015ce:	2380      	movs	r3, #128	; 0x80
 80015d0:	009b      	lsls	r3, r3, #2
 80015d2:	58cb      	ldr	r3, [r1, r3]
 80015d4:	2101      	movs	r1, #1
 80015d6:	438b      	bics	r3, r1
 80015d8:	0019      	movs	r1, r3
 80015da:	2380      	movs	r3, #128	; 0x80
 80015dc:	009b      	lsls	r3, r3, #2
 80015de:	50d1      	str	r1, [r2, r3]
  if(canp == &CAND1) {
 80015e0:	9a03      	ldr	r2, [sp, #12]
 80015e2:	4b05      	ldr	r3, [pc, #20]	; (80015f8 <can_lld_set_filters.lto_priv.58+0x228>)
 80015e4:	429a      	cmp	r2, r3
 80015e6:	d105      	bne.n	80015f4 <can_lld_set_filters.lto_priv.58+0x224>
    rccDisableCAN1(FALSE);
 80015e8:	4b04      	ldr	r3, [pc, #16]	; (80015fc <can_lld_set_filters.lto_priv.58+0x22c>)
 80015ea:	4a04      	ldr	r2, [pc, #16]	; (80015fc <can_lld_set_filters.lto_priv.58+0x22c>)
 80015ec:	69d2      	ldr	r2, [r2, #28]
 80015ee:	4904      	ldr	r1, [pc, #16]	; (8001600 <can_lld_set_filters.lto_priv.58+0x230>)
 80015f0:	400a      	ands	r2, r1
 80015f2:	61da      	str	r2, [r3, #28]
}
 80015f4:	b006      	add	sp, #24
 80015f6:	4770      	bx	lr
 80015f8:	20000d88 	.word	0x20000d88
 80015fc:	40021000 	.word	0x40021000
 8001600:	fdffffff 	.word	0xfdffffff
	...

08001610 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
 8001610:	b500      	push	{lr}
 8001612:	b085      	sub	sp, #20
 8001614:	9001      	str	r0, [sp, #4]
 8001616:	9100      	str	r1, [sp, #0]
  struct pool_header *php = objp;
 8001618:	9b00      	ldr	r3, [sp, #0]
 800161a:	9303      	str	r3, [sp, #12]

  chDbgCheckClassI();
 800161c:	f001 f900 	bl	8002820 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) && (objp != NULL));
 8001620:	9b01      	ldr	r3, [sp, #4]
 8001622:	2b00      	cmp	r3, #0
 8001624:	d002      	beq.n	800162c <chPoolFreeI+0x1c>
 8001626:	9b00      	ldr	r3, [sp, #0]
 8001628:	2b00      	cmp	r3, #0
 800162a:	d103      	bne.n	8001634 <chPoolFreeI+0x24>
 800162c:	4b06      	ldr	r3, [pc, #24]	; (8001648 <chPoolFreeI+0x38>)
 800162e:	0018      	movs	r0, r3
 8001630:	f001 f806 	bl	8002640 <chSysHalt>

  php->next = mp->next;
 8001634:	9b01      	ldr	r3, [sp, #4]
 8001636:	681a      	ldr	r2, [r3, #0]
 8001638:	9b03      	ldr	r3, [sp, #12]
 800163a:	601a      	str	r2, [r3, #0]
  mp->next = php;
 800163c:	9b01      	ldr	r3, [sp, #4]
 800163e:	9a03      	ldr	r2, [sp, #12]
 8001640:	601a      	str	r2, [r3, #0]
}
 8001642:	b005      	add	sp, #20
 8001644:	bd00      	pop	{pc}
 8001646:	46c0      	nop			; (mov r8, r8)
 8001648:	08003c44 	.word	0x08003c44
 800164c:	00000000 	.word	0x00000000

08001650 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
 8001650:	b500      	push	{lr}
 8001652:	b083      	sub	sp, #12
 8001654:	9001      	str	r0, [sp, #4]
 8001656:	9100      	str	r1, [sp, #0]

  chSysLock();
 8001658:	f000 fa92 	bl	8001b80 <chSysLock.lto_priv.100>
  chPoolFreeI(mp, objp);
 800165c:	9a00      	ldr	r2, [sp, #0]
 800165e:	9b01      	ldr	r3, [sp, #4]
 8001660:	0011      	movs	r1, r2
 8001662:	0018      	movs	r0, r3
 8001664:	f7ff ffd4 	bl	8001610 <chPoolFreeI>
  chSysUnlock();
 8001668:	f000 fa92 	bl	8001b90 <chSysUnlock.lto_priv.97>
}
 800166c:	b003      	add	sp, #12
 800166e:	bd00      	pop	{pc}

08001670 <port_lock.lto_priv.112>:
  __ASM volatile ("cpsid i" : : : "memory");
 8001670:	b672      	cpsid	i
}
 8001672:	4770      	bx	lr
	...

08001680 <port_unlock.lto_priv.109>:
  __ASM volatile ("cpsie i" : : : "memory");
 8001680:	b662      	cpsie	i
}
 8001682:	4770      	bx	lr
	...

08001690 <port_lock_from_isr>:
static inline void port_lock_from_isr(void) {
 8001690:	b510      	push	{r4, lr}
  port_lock();
 8001692:	f7ff ffed 	bl	8001670 <port_lock.lto_priv.112>
}
 8001696:	bd10      	pop	{r4, pc}
	...

080016a0 <port_unlock_from_isr>:
static inline void port_unlock_from_isr(void) {
 80016a0:	b510      	push	{r4, lr}
  port_unlock();
 80016a2:	f7ff ffed 	bl	8001680 <port_unlock.lto_priv.109>
}
 80016a6:	bd10      	pop	{r4, pc}
	...

080016b0 <NMI_Handler>:
 * @brief   NMI vector.
 * @details The NMI vector is used for exception mode re-entering after a
 *          context switch.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void NMI_Handler(void) {
 80016b0:	b590      	push	{r4, r7, lr}
 80016b2:	b083      	sub	sp, #12
 80016b4:	af00      	add	r7, sp, #0
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80016b6:	f3ef 8309 	mrs	r3, PSP
 80016ba:	001c      	movs	r4, r3
  return(result);
 80016bc:	0023      	movs	r3, r4
/*lint -restore*/

  /* The port_extctx structure is pointed by the PSP register.*/
  struct port_extctx *ctxp = (struct port_extctx *)__get_PSP();
 80016be:	607b      	str	r3, [r7, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 80016c0:	687b      	ldr	r3, [r7, #4]
 80016c2:	3320      	adds	r3, #32
 80016c4:	607b      	str	r3, [r7, #4]

  /* Writing back the modified PSP value.*/
  __set_PSP((uint32_t)ctxp);
 80016c6:	687b      	ldr	r3, [r7, #4]
 80016c8:	603b      	str	r3, [r7, #0]
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 80016ca:	683b      	ldr	r3, [r7, #0]
 80016cc:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 80016d0:	f7ff ffe6 	bl	80016a0 <port_unlock_from_isr>
}
 80016d4:	46bd      	mov	sp, r7
 80016d6:	b003      	add	sp, #12
 80016d8:	bd90      	pop	{r4, r7, pc}
 80016da:	46c0      	nop			; (mov r8, r8)
 80016dc:	0000      	movs	r0, r0
	...

080016e0 <_port_irq_epilogue>:
/**
 * @brief   IRQ epilogue code.
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {
 80016e0:	b590      	push	{r4, r7, lr}
 80016e2:	b085      	sub	sp, #20
 80016e4:	af00      	add	r7, sp, #0
 80016e6:	6078      	str	r0, [r7, #4]

  if (lr != (regarm_t)0xFFFFFFF1U) {
 80016e8:	687b      	ldr	r3, [r7, #4]
 80016ea:	330f      	adds	r3, #15
 80016ec:	d01d      	beq.n	800172a <_port_irq_epilogue+0x4a>
    struct port_extctx *ctxp;

    port_lock_from_isr();
 80016ee:	f7ff ffcf 	bl	8001690 <port_lock_from_isr>
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80016f2:	f3ef 8309 	mrs	r3, PSP
 80016f6:	001c      	movs	r4, r3
  return(result);
 80016f8:	0023      	movs	r3, r4

    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
 80016fa:	60fb      	str	r3, [r7, #12]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 80016fc:	68fb      	ldr	r3, [r7, #12]
 80016fe:	3b20      	subs	r3, #32
 8001700:	60fb      	str	r3, [r7, #12]

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
 8001702:	68fb      	ldr	r3, [r7, #12]
 8001704:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8001706:	68bb      	ldr	r3, [r7, #8]
 8001708:	f383 8809 	msr	PSP, r3

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 800170c:	68fb      	ldr	r3, [r7, #12]
 800170e:	2280      	movs	r2, #128	; 0x80
 8001710:	0452      	lsls	r2, r2, #17
 8001712:	61da      	str	r2, [r3, #28]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8001714:	f001 fdbc 	bl	8003290 <chSchIsPreemptionRequired>
 8001718:	1e03      	subs	r3, r0, #0
 800171a:	d003      	beq.n	8001724 <_port_irq_epilogue+0x44>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 800171c:	68fb      	ldr	r3, [r7, #12]
 800171e:	4a04      	ldr	r2, [pc, #16]	; (8001730 <_port_irq_epilogue+0x50>)
 8001720:	619a      	str	r2, [r3, #24]
 8001722:	e002      	b.n	800172a <_port_irq_epilogue+0x4a>
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8001724:	68fb      	ldr	r3, [r7, #12]
 8001726:	4a03      	ldr	r2, [pc, #12]	; (8001734 <_port_irq_epilogue+0x54>)
 8001728:	619a      	str	r2, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
  }
}
 800172a:	46bd      	mov	sp, r7
 800172c:	b005      	add	sp, #20
 800172e:	bd90      	pop	{r4, r7, pc}
 8001730:	080001c1 	.word	0x080001c1
 8001734:	080001cc 	.word	0x080001cc
	...

08001740 <osalInit>:
}
 8001740:	4770      	bx	lr
 8001742:	46c0      	nop			; (mov r8, r8)
	...

08001750 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8001750:	b510      	push	{r4, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8001752:	f7ff fff5 	bl	8001740 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 8001756:	f7ff fd13 	bl	8001180 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 800175a:	4b05      	ldr	r3, [pc, #20]	; (8001770 <halInit+0x20>)
 800175c:	0018      	movs	r0, r3
 800175e:	f7ff f8b7 	bl	80008d0 <_pal_lld_init>
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
#endif
#if (HAL_USE_CAN == TRUE) || defined(__DOXYGEN__)
  canInit();
 8001762:	f7ff fb1d 	bl	8000da0 <canInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8001766:	f7ff f99b 	bl	8000aa0 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 800176a:	f7ff fc59 	bl	8001020 <stInit>
#endif
}
 800176e:	bd10      	pop	{r4, pc}
 8001770:	08003cd0 	.word	0x08003cd0
	...

08001780 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8001780:	b500      	push	{lr}
 8001782:	b085      	sub	sp, #20
 8001784:	9001      	str	r0, [sp, #4]
 8001786:	9100      	str	r1, [sp, #0]
  event_listener_t *elp;

  chDbgCheckClassI();
 8001788:	f001 f84a 	bl	8002820 <chDbgCheckClassI>
  chDbgCheck(esp != NULL);
 800178c:	9b01      	ldr	r3, [sp, #4]
 800178e:	2b00      	cmp	r3, #0
 8001790:	d103      	bne.n	800179a <chEvtBroadcastFlagsI+0x1a>
 8001792:	4b14      	ldr	r3, [pc, #80]	; (80017e4 <chEvtBroadcastFlagsI+0x64>)
 8001794:	0018      	movs	r0, r3
 8001796:	f000 ff53 	bl	8002640 <chSysHalt>

  elp = esp->next;
 800179a:	9b01      	ldr	r3, [sp, #4]
 800179c:	681b      	ldr	r3, [r3, #0]
 800179e:	9303      	str	r3, [sp, #12]
 80017a0:	e019      	b.n	80017d6 <chEvtBroadcastFlagsI+0x56>
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->flags |= flags;
 80017a2:	9b03      	ldr	r3, [sp, #12]
 80017a4:	68da      	ldr	r2, [r3, #12]
 80017a6:	9b00      	ldr	r3, [sp, #0]
 80017a8:	431a      	orrs	r2, r3
 80017aa:	9b03      	ldr	r3, [sp, #12]
 80017ac:	60da      	str	r2, [r3, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 80017ae:	9b00      	ldr	r3, [sp, #0]
 80017b0:	2b00      	cmp	r3, #0
 80017b2:	d005      	beq.n	80017c0 <chEvtBroadcastFlagsI+0x40>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
 80017b4:	9b03      	ldr	r3, [sp, #12]
 80017b6:	68da      	ldr	r2, [r3, #12]
 80017b8:	9b03      	ldr	r3, [sp, #12]
 80017ba:	691b      	ldr	r3, [r3, #16]
 80017bc:	4013      	ands	r3, r2
    if ((flags == (eventflags_t)0) ||
 80017be:	d007      	beq.n	80017d0 <chEvtBroadcastFlagsI+0x50>
      chEvtSignalI(elp->listener, elp->events);
 80017c0:	9b03      	ldr	r3, [sp, #12]
 80017c2:	685a      	ldr	r2, [r3, #4]
 80017c4:	9b03      	ldr	r3, [sp, #12]
 80017c6:	689b      	ldr	r3, [r3, #8]
 80017c8:	0019      	movs	r1, r3
 80017ca:	0010      	movs	r0, r2
 80017cc:	f000 f810 	bl	80017f0 <chEvtSignalI>
    }
    elp = elp->next;
 80017d0:	9b03      	ldr	r3, [sp, #12]
 80017d2:	681b      	ldr	r3, [r3, #0]
 80017d4:	9303      	str	r3, [sp, #12]
  while (elp != (event_listener_t *)esp) {
 80017d6:	9a03      	ldr	r2, [sp, #12]
 80017d8:	9b01      	ldr	r3, [sp, #4]
 80017da:	429a      	cmp	r2, r3
 80017dc:	d1e1      	bne.n	80017a2 <chEvtBroadcastFlagsI+0x22>
  }
}
 80017de:	b005      	add	sp, #20
 80017e0:	bd00      	pop	{pc}
 80017e2:	46c0      	nop			; (mov r8, r8)
 80017e4:	08003be4 	.word	0x08003be4
	...

080017f0 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 80017f0:	b500      	push	{lr}
 80017f2:	b083      	sub	sp, #12
 80017f4:	9001      	str	r0, [sp, #4]
 80017f6:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
 80017f8:	f001 f812 	bl	8002820 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 80017fc:	9b01      	ldr	r3, [sp, #4]
 80017fe:	2b00      	cmp	r3, #0
 8001800:	d103      	bne.n	800180a <chEvtSignalI+0x1a>
 8001802:	4b16      	ldr	r3, [pc, #88]	; (800185c <chEvtSignalI+0x6c>)
 8001804:	0018      	movs	r0, r3
 8001806:	f000 ff1b 	bl	8002640 <chSysHalt>

  tp->epending |= events;
 800180a:	9b01      	ldr	r3, [sp, #4]
 800180c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800180e:	9b00      	ldr	r3, [sp, #0]
 8001810:	431a      	orrs	r2, r3
 8001812:	9b01      	ldr	r3, [sp, #4]
 8001814:	635a      	str	r2, [r3, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8001816:	9b01      	ldr	r3, [sp, #4]
 8001818:	2220      	movs	r2, #32
 800181a:	5c9b      	ldrb	r3, [r3, r2]
 800181c:	2b0a      	cmp	r3, #10
 800181e:	d105      	bne.n	800182c <chEvtSignalI+0x3c>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8001820:	9b01      	ldr	r3, [sp, #4]
 8001822:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001824:	9b01      	ldr	r3, [sp, #4]
 8001826:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001828:	4013      	ands	r3, r2
  if (((tp->state == CH_STATE_WTOREVT) &&
 800182a:	d10d      	bne.n	8001848 <chEvtSignalI+0x58>
      ((tp->state == CH_STATE_WTANDEVT) &&
 800182c:	9b01      	ldr	r3, [sp, #4]
 800182e:	2220      	movs	r2, #32
 8001830:	5c9b      	ldrb	r3, [r3, r2]
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8001832:	2b0b      	cmp	r3, #11
 8001834:	d10f      	bne.n	8001856 <chEvtSignalI+0x66>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 8001836:	9b01      	ldr	r3, [sp, #4]
 8001838:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800183a:	9b01      	ldr	r3, [sp, #4]
 800183c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800183e:	401a      	ands	r2, r3
 8001840:	9b01      	ldr	r3, [sp, #4]
 8001842:	6a5b      	ldr	r3, [r3, #36]	; 0x24
      ((tp->state == CH_STATE_WTANDEVT) &&
 8001844:	429a      	cmp	r2, r3
 8001846:	d106      	bne.n	8001856 <chEvtSignalI+0x66>
    tp->u.rdymsg = MSG_OK;
 8001848:	9b01      	ldr	r3, [sp, #4]
 800184a:	2200      	movs	r2, #0
 800184c:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 800184e:	9b01      	ldr	r3, [sp, #4]
 8001850:	0018      	movs	r0, r3
 8001852:	f001 fb7d 	bl	8002f50 <chSchReadyI>
  }
}
 8001856:	b003      	add	sp, #12
 8001858:	bd00      	pop	{pc}
 800185a:	46c0      	nop			; (mov r8, r8)
 800185c:	08003bfc 	.word	0x08003bfc

08001860 <chEvtWaitAnyTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
 8001860:	b500      	push	{lr}
 8001862:	b085      	sub	sp, #20
 8001864:	9001      	str	r0, [sp, #4]
 8001866:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 8001868:	4b19      	ldr	r3, [pc, #100]	; (80018d0 <chEvtWaitAnyTimeout+0x70>)
 800186a:	699b      	ldr	r3, [r3, #24]
 800186c:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 800186e:	f000 fc7f 	bl	8002170 <chSysLock.lto_priv.147>
  m = ctp->epending & events;
 8001872:	9b02      	ldr	r3, [sp, #8]
 8001874:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8001876:	9a01      	ldr	r2, [sp, #4]
 8001878:	4013      	ands	r3, r2
 800187a:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 800187c:	9b03      	ldr	r3, [sp, #12]
 800187e:	2b00      	cmp	r3, #0
 8001880:	d119      	bne.n	80018b6 <chEvtWaitAnyTimeout+0x56>
    if (TIME_IMMEDIATE == time) {
 8001882:	9b00      	ldr	r3, [sp, #0]
 8001884:	2b00      	cmp	r3, #0
 8001886:	d103      	bne.n	8001890 <chEvtWaitAnyTimeout+0x30>
      chSysUnlock();
 8001888:	f000 fc7a 	bl	8002180 <chSysUnlock.lto_priv.142>
      return (eventmask_t)0;
 800188c:	2300      	movs	r3, #0
 800188e:	e01c      	b.n	80018ca <chEvtWaitAnyTimeout+0x6a>
    }
    ctp->u.ewmask = events;
 8001890:	9b02      	ldr	r3, [sp, #8]
 8001892:	9a01      	ldr	r2, [sp, #4]
 8001894:	625a      	str	r2, [r3, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8001896:	9b00      	ldr	r3, [sp, #0]
 8001898:	0019      	movs	r1, r3
 800189a:	200a      	movs	r0, #10
 800189c:	f001 fc50 	bl	8003140 <chSchGoSleepTimeoutS>
 80018a0:	1e03      	subs	r3, r0, #0
 80018a2:	da03      	bge.n	80018ac <chEvtWaitAnyTimeout+0x4c>
      chSysUnlock();
 80018a4:	f000 fc6c 	bl	8002180 <chSysUnlock.lto_priv.142>
      return (eventmask_t)0;
 80018a8:	2300      	movs	r3, #0
 80018aa:	e00e      	b.n	80018ca <chEvtWaitAnyTimeout+0x6a>
    }
    m = ctp->epending & events;
 80018ac:	9b02      	ldr	r3, [sp, #8]
 80018ae:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80018b0:	9a01      	ldr	r2, [sp, #4]
 80018b2:	4013      	ands	r3, r2
 80018b4:	9303      	str	r3, [sp, #12]
  }
  ctp->epending &= ~m;
 80018b6:	9b02      	ldr	r3, [sp, #8]
 80018b8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80018ba:	9a03      	ldr	r2, [sp, #12]
 80018bc:	43d2      	mvns	r2, r2
 80018be:	401a      	ands	r2, r3
 80018c0:	9b02      	ldr	r3, [sp, #8]
 80018c2:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 80018c4:	f000 fc5c 	bl	8002180 <chSysUnlock.lto_priv.142>

  return m;
 80018c8:	9b03      	ldr	r3, [sp, #12]
}
 80018ca:	0018      	movs	r0, r3
 80018cc:	b005      	add	sp, #20
 80018ce:	bd00      	pop	{pc}
 80018d0:	200004d8 	.word	0x200004d8
	...

080018e0 <port_lock.lto_priv.136>:
  __ASM volatile ("cpsid i" : : : "memory");
 80018e0:	b672      	cpsid	i
}
 80018e2:	4770      	bx	lr
	...

080018f0 <port_unlock.lto_priv.131>:
  __ASM volatile ("cpsie i" : : : "memory");
 80018f0:	b662      	cpsie	i
}
 80018f2:	4770      	bx	lr
	...

08001900 <chSysLock.lto_priv.151>:
static inline void chSysLock(void) {
 8001900:	b510      	push	{r4, lr}
  port_lock();
 8001902:	f7ff ffed 	bl	80018e0 <port_lock.lto_priv.136>
  _dbg_check_lock();
 8001906:	f000 feeb 	bl	80026e0 <_dbg_check_lock>
}
 800190a:	bd10      	pop	{r4, pc}
 800190c:	0000      	movs	r0, r0
	...

08001910 <chSysUnlock.lto_priv.146>:
static inline void chSysUnlock(void) {
 8001910:	b510      	push	{r4, lr}
  _dbg_check_unlock();
 8001912:	f000 fefd 	bl	8002710 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001916:	4b0a      	ldr	r3, [pc, #40]	; (8001940 <chSysUnlock.lto_priv.146+0x30>)
 8001918:	681a      	ldr	r2, [r3, #0]
 800191a:	4b09      	ldr	r3, [pc, #36]	; (8001940 <chSysUnlock.lto_priv.146+0x30>)
 800191c:	429a      	cmp	r2, r3
 800191e:	d00b      	beq.n	8001938 <chSysUnlock.lto_priv.146+0x28>
 8001920:	4b07      	ldr	r3, [pc, #28]	; (8001940 <chSysUnlock.lto_priv.146+0x30>)
 8001922:	699b      	ldr	r3, [r3, #24]
 8001924:	689a      	ldr	r2, [r3, #8]
 8001926:	4b06      	ldr	r3, [pc, #24]	; (8001940 <chSysUnlock.lto_priv.146+0x30>)
 8001928:	681b      	ldr	r3, [r3, #0]
 800192a:	689b      	ldr	r3, [r3, #8]
 800192c:	429a      	cmp	r2, r3
 800192e:	d203      	bcs.n	8001938 <chSysUnlock.lto_priv.146+0x28>
 8001930:	4b04      	ldr	r3, [pc, #16]	; (8001944 <chSysUnlock.lto_priv.146+0x34>)
 8001932:	0018      	movs	r0, r3
 8001934:	f000 fe84 	bl	8002640 <chSysHalt>
  port_unlock();
 8001938:	f7ff ffda 	bl	80018f0 <port_unlock.lto_priv.131>
}
 800193c:	bd10      	pop	{r4, pc}
 800193e:	46c0      	nop			; (mov r8, r8)
 8001940:	200004d8 	.word	0x200004d8
 8001944:	08003c20 	.word	0x08003c20
	...

08001950 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = __heap_base__;
 8001950:	4b03      	ldr	r3, [pc, #12]	; (8001960 <_core_init+0x10>)
 8001952:	4a04      	ldr	r2, [pc, #16]	; (8001964 <_core_init+0x14>)
 8001954:	601a      	str	r2, [r3, #0]
  endmem  = __heap_end__;
 8001956:	4b04      	ldr	r3, [pc, #16]	; (8001968 <_core_init+0x18>)
 8001958:	4a04      	ldr	r2, [pc, #16]	; (800196c <_core_init+0x1c>)
 800195a:	601a      	str	r2, [r3, #0]
  static uint8_t static_heap[CH_CFG_MEMCORE_SIZE];

  nextmem = &static_heap[0];
  endmem  = &static_heap[CH_CFG_MEMCORE_SIZE];
#endif
}
 800195c:	4770      	bx	lr
 800195e:	46c0      	nop			; (mov r8, r8)
 8001960:	20000d5c 	.word	0x20000d5c
 8001964:	20001148 	.word	0x20001148
 8001968:	20000d60 	.word	0x20000d60
 800196c:	20001800 	.word	0x20001800

08001970 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocAlignedI(size_t size, unsigned align) {
 8001970:	b500      	push	{lr}
 8001972:	b085      	sub	sp, #20
 8001974:	9001      	str	r0, [sp, #4]
 8001976:	9100      	str	r1, [sp, #0]
  uint8_t *p;

  chDbgCheckClassI();
 8001978:	f000 ff52 	bl	8002820 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 800197c:	9b00      	ldr	r3, [sp, #0]
 800197e:	2b00      	cmp	r3, #0
 8001980:	d004      	beq.n	800198c <chCoreAllocAlignedI+0x1c>
 8001982:	9b00      	ldr	r3, [sp, #0]
 8001984:	3b01      	subs	r3, #1
 8001986:	9a00      	ldr	r2, [sp, #0]
 8001988:	4013      	ands	r3, r2
 800198a:	d003      	beq.n	8001994 <chCoreAllocAlignedI+0x24>
 800198c:	4b14      	ldr	r3, [pc, #80]	; (80019e0 <chCoreAllocAlignedI+0x70>)
 800198e:	0018      	movs	r0, r3
 8001990:	f000 fe56 	bl	8002640 <chSysHalt>

  size = MEM_ALIGN_NEXT(size, align);
 8001994:	9a00      	ldr	r2, [sp, #0]
 8001996:	9b01      	ldr	r3, [sp, #4]
 8001998:	18d3      	adds	r3, r2, r3
 800199a:	3b01      	subs	r3, #1
 800199c:	9a00      	ldr	r2, [sp, #0]
 800199e:	4252      	negs	r2, r2
 80019a0:	4013      	ands	r3, r2
 80019a2:	9301      	str	r3, [sp, #4]
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 80019a4:	4b0f      	ldr	r3, [pc, #60]	; (80019e4 <chCoreAllocAlignedI+0x74>)
 80019a6:	681b      	ldr	r3, [r3, #0]
 80019a8:	001a      	movs	r2, r3
 80019aa:	9b00      	ldr	r3, [sp, #0]
 80019ac:	18d3      	adds	r3, r2, r3
 80019ae:	3b01      	subs	r3, #1
 80019b0:	9a00      	ldr	r2, [sp, #0]
 80019b2:	4252      	negs	r2, r2
 80019b4:	4013      	ands	r3, r2
 80019b6:	9303      	str	r3, [sp, #12]

  if (((size_t)endmem - (size_t)p) < size) {
 80019b8:	4b0b      	ldr	r3, [pc, #44]	; (80019e8 <chCoreAllocAlignedI+0x78>)
 80019ba:	681b      	ldr	r3, [r3, #0]
 80019bc:	001a      	movs	r2, r3
 80019be:	9b03      	ldr	r3, [sp, #12]
 80019c0:	1ad2      	subs	r2, r2, r3
 80019c2:	9b01      	ldr	r3, [sp, #4]
 80019c4:	429a      	cmp	r2, r3
 80019c6:	d201      	bcs.n	80019cc <chCoreAllocAlignedI+0x5c>
    return NULL;
 80019c8:	2300      	movs	r3, #0
 80019ca:	e005      	b.n	80019d8 <chCoreAllocAlignedI+0x68>
  }
  nextmem = p + size;
 80019cc:	9a03      	ldr	r2, [sp, #12]
 80019ce:	9b01      	ldr	r3, [sp, #4]
 80019d0:	18d2      	adds	r2, r2, r3
 80019d2:	4b04      	ldr	r3, [pc, #16]	; (80019e4 <chCoreAllocAlignedI+0x74>)
 80019d4:	601a      	str	r2, [r3, #0]

  return p;
 80019d6:	9b03      	ldr	r3, [sp, #12]
}
 80019d8:	0018      	movs	r0, r3
 80019da:	b005      	add	sp, #20
 80019dc:	bd00      	pop	{pc}
 80019de:	46c0      	nop			; (mov r8, r8)
 80019e0:	08003c0c 	.word	0x08003c0c
 80019e4:	20000d5c 	.word	0x20000d5c
 80019e8:	20000d60 	.word	0x20000d60
 80019ec:	00000000 	.word	0x00000000

080019f0 <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
 80019f0:	b500      	push	{lr}
 80019f2:	b085      	sub	sp, #20
 80019f4:	9001      	str	r0, [sp, #4]
 80019f6:	9100      	str	r1, [sp, #0]
  void *p;

  chSysLock();
 80019f8:	f7ff ff82 	bl	8001900 <chSysLock.lto_priv.151>
  p = chCoreAllocAlignedI(size, align);
 80019fc:	9a00      	ldr	r2, [sp, #0]
 80019fe:	9b01      	ldr	r3, [sp, #4]
 8001a00:	0011      	movs	r1, r2
 8001a02:	0018      	movs	r0, r3
 8001a04:	f7ff ffb4 	bl	8001970 <chCoreAllocAlignedI>
 8001a08:	0003      	movs	r3, r0
 8001a0a:	9303      	str	r3, [sp, #12]
  chSysUnlock();
 8001a0c:	f7ff ff80 	bl	8001910 <chSysUnlock.lto_priv.146>

  return p;
 8001a10:	9b03      	ldr	r3, [sp, #12]
}
 8001a12:	0018      	movs	r0, r3
 8001a14:	b005      	add	sp, #20
 8001a16:	bd00      	pop	{pc}
	...

08001a20 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
 8001a20:	b510      	push	{r4, lr}

  default_heap.provider = chCoreAllocAligned;
 8001a22:	4b07      	ldr	r3, [pc, #28]	; (8001a40 <_heap_init+0x20>)
 8001a24:	4a07      	ldr	r2, [pc, #28]	; (8001a44 <_heap_init+0x24>)
 8001a26:	601a      	str	r2, [r3, #0]
  H_NEXT(&default_heap.header) = NULL;
 8001a28:	4b05      	ldr	r3, [pc, #20]	; (8001a40 <_heap_init+0x20>)
 8001a2a:	2200      	movs	r2, #0
 8001a2c:	609a      	str	r2, [r3, #8]
  H_PAGES(&default_heap.header) = 0;
 8001a2e:	4b04      	ldr	r3, [pc, #16]	; (8001a40 <_heap_init+0x20>)
 8001a30:	2200      	movs	r2, #0
 8001a32:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
 8001a34:	4b04      	ldr	r3, [pc, #16]	; (8001a48 <_heap_init+0x28>)
 8001a36:	0018      	movs	r0, r3
 8001a38:	f000 fa62 	bl	8001f00 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
#endif
}
 8001a3c:	bd10      	pop	{r4, pc}
 8001a3e:	46c0      	nop			; (mov r8, r8)
 8001a40:	20000d68 	.word	0x20000d68
 8001a44:	080019f1 	.word	0x080019f1
 8001a48:	20000d78 	.word	0x20000d78
 8001a4c:	00000000 	.word	0x00000000

08001a50 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8001a50:	b500      	push	{lr}
 8001a52:	b087      	sub	sp, #28
 8001a54:	9001      	str	r0, [sp, #4]
  heap_header_t *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
 8001a56:	9b01      	ldr	r3, [sp, #4]
 8001a58:	2b00      	cmp	r3, #0
 8001a5a:	d003      	beq.n	8001a64 <chHeapFree+0x14>
 8001a5c:	9b01      	ldr	r3, [sp, #4]
 8001a5e:	2207      	movs	r2, #7
 8001a60:	4013      	ands	r3, r2
 8001a62:	d003      	beq.n	8001a6c <chHeapFree+0x1c>
 8001a64:	4b3d      	ldr	r3, [pc, #244]	; (8001b5c <chHeapFree+0x10c>)
 8001a66:	0018      	movs	r0, r3
 8001a68:	f000 fdea 	bl	8002640 <chSysHalt>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
 8001a6c:	9b01      	ldr	r3, [sp, #4]
 8001a6e:	3b08      	subs	r3, #8
 8001a70:	9304      	str	r3, [sp, #16]
  /*lint -restore*/
  heapp = H_HEAP(hp);
 8001a72:	9b04      	ldr	r3, [sp, #16]
 8001a74:	681b      	ldr	r3, [r3, #0]
 8001a76:	9303      	str	r3, [sp, #12]
  qp = &heapp->header;
 8001a78:	9b03      	ldr	r3, [sp, #12]
 8001a7a:	3308      	adds	r3, #8
 8001a7c:	9305      	str	r3, [sp, #20]

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8001a7e:	9b04      	ldr	r3, [sp, #16]
 8001a80:	685b      	ldr	r3, [r3, #4]
 8001a82:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8001a84:	08da      	lsrs	r2, r3, #3
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8001a86:	9b04      	ldr	r3, [sp, #16]
 8001a88:	605a      	str	r2, [r3, #4]

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8001a8a:	9b03      	ldr	r3, [sp, #12]
 8001a8c:	3310      	adds	r3, #16
 8001a8e:	0018      	movs	r0, r3
 8001a90:	f000 fa4e 	bl	8001f30 <chMtxLock>

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 8001a94:	9a04      	ldr	r2, [sp, #16]
 8001a96:	9b05      	ldr	r3, [sp, #20]
 8001a98:	429a      	cmp	r2, r3
 8001a9a:	d30c      	bcc.n	8001ab6 <chHeapFree+0x66>
 8001a9c:	9b05      	ldr	r3, [sp, #20]
 8001a9e:	685b      	ldr	r3, [r3, #4]
 8001aa0:	3301      	adds	r3, #1
 8001aa2:	00db      	lsls	r3, r3, #3
 8001aa4:	9a05      	ldr	r2, [sp, #20]
 8001aa6:	18d2      	adds	r2, r2, r3
 8001aa8:	9b04      	ldr	r3, [sp, #16]
 8001aaa:	429a      	cmp	r2, r3
 8001aac:	d903      	bls.n	8001ab6 <chHeapFree+0x66>
 8001aae:	4b2b      	ldr	r3, [pc, #172]	; (8001b5c <chHeapFree+0x10c>)
 8001ab0:	0018      	movs	r0, r3
 8001ab2:	f000 fdc5 	bl	8002640 <chSysHalt>

    if (((qp == &heapp->header) || (hp > qp)) &&
 8001ab6:	9b03      	ldr	r3, [sp, #12]
 8001ab8:	3308      	adds	r3, #8
 8001aba:	001a      	movs	r2, r3
 8001abc:	9b05      	ldr	r3, [sp, #20]
 8001abe:	429a      	cmp	r2, r3
 8001ac0:	d003      	beq.n	8001aca <chHeapFree+0x7a>
 8001ac2:	9a04      	ldr	r2, [sp, #16]
 8001ac4:	9b05      	ldr	r3, [sp, #20]
 8001ac6:	429a      	cmp	r2, r3
 8001ac8:	d942      	bls.n	8001b50 <chHeapFree+0x100>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8001aca:	9b05      	ldr	r3, [sp, #20]
 8001acc:	681b      	ldr	r3, [r3, #0]
    if (((qp == &heapp->header) || (hp > qp)) &&
 8001ace:	2b00      	cmp	r3, #0
 8001ad0:	d004      	beq.n	8001adc <chHeapFree+0x8c>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8001ad2:	9b05      	ldr	r3, [sp, #20]
 8001ad4:	681a      	ldr	r2, [r3, #0]
 8001ad6:	9b04      	ldr	r3, [sp, #16]
 8001ad8:	429a      	cmp	r2, r3
 8001ada:	d939      	bls.n	8001b50 <chHeapFree+0x100>
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
 8001adc:	9b05      	ldr	r3, [sp, #20]
 8001ade:	681a      	ldr	r2, [r3, #0]
 8001ae0:	9b04      	ldr	r3, [sp, #16]
 8001ae2:	601a      	str	r2, [r3, #0]
      H_NEXT(qp) = hp;
 8001ae4:	9b05      	ldr	r3, [sp, #20]
 8001ae6:	9a04      	ldr	r2, [sp, #16]
 8001ae8:	601a      	str	r2, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8001aea:	9b04      	ldr	r3, [sp, #16]
 8001aec:	685b      	ldr	r3, [r3, #4]
 8001aee:	3301      	adds	r3, #1
 8001af0:	00db      	lsls	r3, r3, #3
 8001af2:	9a04      	ldr	r2, [sp, #16]
 8001af4:	18d2      	adds	r2, r2, r3
 8001af6:	9b04      	ldr	r3, [sp, #16]
 8001af8:	681b      	ldr	r3, [r3, #0]
 8001afa:	429a      	cmp	r2, r3
 8001afc:	d10d      	bne.n	8001b1a <chHeapFree+0xca>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8001afe:	9b04      	ldr	r3, [sp, #16]
 8001b00:	685a      	ldr	r2, [r3, #4]
 8001b02:	9b04      	ldr	r3, [sp, #16]
 8001b04:	681b      	ldr	r3, [r3, #0]
 8001b06:	685b      	ldr	r3, [r3, #4]
 8001b08:	18d3      	adds	r3, r2, r3
 8001b0a:	1c5a      	adds	r2, r3, #1
 8001b0c:	9b04      	ldr	r3, [sp, #16]
 8001b0e:	605a      	str	r2, [r3, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 8001b10:	9b04      	ldr	r3, [sp, #16]
 8001b12:	681b      	ldr	r3, [r3, #0]
 8001b14:	681a      	ldr	r2, [r3, #0]
 8001b16:	9b04      	ldr	r3, [sp, #16]
 8001b18:	601a      	str	r2, [r3, #0]
      }
      if ((H_LIMIT(qp) == hp)) {
 8001b1a:	9b05      	ldr	r3, [sp, #20]
 8001b1c:	685b      	ldr	r3, [r3, #4]
 8001b1e:	3301      	adds	r3, #1
 8001b20:	00db      	lsls	r3, r3, #3
 8001b22:	9a05      	ldr	r2, [sp, #20]
 8001b24:	18d2      	adds	r2, r2, r3
 8001b26:	9b04      	ldr	r3, [sp, #16]
 8001b28:	429a      	cmp	r2, r3
 8001b2a:	d10b      	bne.n	8001b44 <chHeapFree+0xf4>
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8001b2c:	9b05      	ldr	r3, [sp, #20]
 8001b2e:	685a      	ldr	r2, [r3, #4]
 8001b30:	9b04      	ldr	r3, [sp, #16]
 8001b32:	685b      	ldr	r3, [r3, #4]
 8001b34:	18d3      	adds	r3, r2, r3
 8001b36:	1c5a      	adds	r2, r3, #1
 8001b38:	9b05      	ldr	r3, [sp, #20]
 8001b3a:	605a      	str	r2, [r3, #4]
        H_NEXT(qp) = H_NEXT(hp);
 8001b3c:	9b04      	ldr	r3, [sp, #16]
 8001b3e:	681a      	ldr	r2, [r3, #0]
 8001b40:	9b05      	ldr	r3, [sp, #20]
 8001b42:	601a      	str	r2, [r3, #0]
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 8001b44:	9b03      	ldr	r3, [sp, #12]
 8001b46:	3310      	adds	r3, #16
 8001b48:	0018      	movs	r0, r3
 8001b4a:	f000 fa89 	bl	8002060 <chMtxUnlock>
 8001b4e:	e003      	b.n	8001b58 <chHeapFree+0x108>
    qp = H_NEXT(qp);
 8001b50:	9b05      	ldr	r3, [sp, #20]
 8001b52:	681b      	ldr	r3, [r3, #0]
 8001b54:	9305      	str	r3, [sp, #20]
 8001b56:	e79d      	b.n	8001a94 <chHeapFree+0x44>

  return;
}
 8001b58:	b007      	add	sp, #28
 8001b5a:	bd00      	pop	{pc}
 8001b5c:	08003c2c 	.word	0x08003c2c

08001b60 <port_lock.lto_priv.137>:
  __ASM volatile ("cpsid i" : : : "memory");
 8001b60:	b672      	cpsid	i
}
 8001b62:	4770      	bx	lr
	...

08001b70 <port_unlock.lto_priv.132>:
  __ASM volatile ("cpsie i" : : : "memory");
 8001b70:	b662      	cpsie	i
}
 8001b72:	4770      	bx	lr
	...

08001b80 <chSysLock.lto_priv.100>:
static inline void chSysLock(void) {
 8001b80:	b510      	push	{r4, lr}
  port_lock();
 8001b82:	f7ff ffed 	bl	8001b60 <port_lock.lto_priv.137>
  _dbg_check_lock();
 8001b86:	f000 fdab 	bl	80026e0 <_dbg_check_lock>
}
 8001b8a:	bd10      	pop	{r4, pc}
 8001b8c:	0000      	movs	r0, r0
	...

08001b90 <chSysUnlock.lto_priv.97>:
static inline void chSysUnlock(void) {
 8001b90:	b510      	push	{r4, lr}
  _dbg_check_unlock();
 8001b92:	f000 fdbd 	bl	8002710 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001b96:	4b0a      	ldr	r3, [pc, #40]	; (8001bc0 <chSysUnlock.lto_priv.97+0x30>)
 8001b98:	681a      	ldr	r2, [r3, #0]
 8001b9a:	4b09      	ldr	r3, [pc, #36]	; (8001bc0 <chSysUnlock.lto_priv.97+0x30>)
 8001b9c:	429a      	cmp	r2, r3
 8001b9e:	d00b      	beq.n	8001bb8 <chSysUnlock.lto_priv.97+0x28>
 8001ba0:	4b07      	ldr	r3, [pc, #28]	; (8001bc0 <chSysUnlock.lto_priv.97+0x30>)
 8001ba2:	699b      	ldr	r3, [r3, #24]
 8001ba4:	689a      	ldr	r2, [r3, #8]
 8001ba6:	4b06      	ldr	r3, [pc, #24]	; (8001bc0 <chSysUnlock.lto_priv.97+0x30>)
 8001ba8:	681b      	ldr	r3, [r3, #0]
 8001baa:	689b      	ldr	r3, [r3, #8]
 8001bac:	429a      	cmp	r2, r3
 8001bae:	d203      	bcs.n	8001bb8 <chSysUnlock.lto_priv.97+0x28>
 8001bb0:	4b04      	ldr	r3, [pc, #16]	; (8001bc4 <chSysUnlock.lto_priv.97+0x34>)
 8001bb2:	0018      	movs	r0, r3
 8001bb4:	f000 fd44 	bl	8002640 <chSysHalt>
  port_unlock();
 8001bb8:	f7ff ffda 	bl	8001b70 <port_unlock.lto_priv.132>
}
 8001bbc:	bd10      	pop	{r4, pc}
 8001bbe:	46c0      	nop			; (mov r8, r8)
 8001bc0:	200004d8 	.word	0x200004d8
 8001bc4:	08003c38 	.word	0x08003c38
	...

08001bd0 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8001bd0:	b500      	push	{lr}
 8001bd2:	b083      	sub	sp, #12
 8001bd4:	9001      	str	r0, [sp, #4]
 8001bd6:	9100      	str	r1, [sp, #0]

  if (TIME_IMMEDIATE == timeout) {
 8001bd8:	9b00      	ldr	r3, [sp, #0]
 8001bda:	2b00      	cmp	r3, #0
 8001bdc:	d102      	bne.n	8001be4 <chThdEnqueueTimeoutS+0x14>
    return MSG_TIMEOUT;
 8001bde:	2301      	movs	r3, #1
 8001be0:	425b      	negs	r3, r3
 8001be2:	e00c      	b.n	8001bfe <chThdEnqueueTimeoutS+0x2e>
  }

  queue_insert(currp, tqp);
 8001be4:	4b07      	ldr	r3, [pc, #28]	; (8001c04 <chThdEnqueueTimeoutS+0x34>)
 8001be6:	699b      	ldr	r3, [r3, #24]
 8001be8:	9a01      	ldr	r2, [sp, #4]
 8001bea:	0011      	movs	r1, r2
 8001bec:	0018      	movs	r0, r3
 8001bee:	f001 fc3f 	bl	8003470 <queue_insert.lto_priv.198>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8001bf2:	9b00      	ldr	r3, [sp, #0]
 8001bf4:	0019      	movs	r1, r3
 8001bf6:	2004      	movs	r0, #4
 8001bf8:	f001 faa2 	bl	8003140 <chSchGoSleepTimeoutS>
 8001bfc:	0003      	movs	r3, r0
}
 8001bfe:	0018      	movs	r0, r3
 8001c00:	b003      	add	sp, #12
 8001c02:	bd00      	pop	{pc}
 8001c04:	200004d8 	.word	0x200004d8
	...

08001c10 <chThdDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8001c10:	b500      	push	{lr}
 8001c12:	b083      	sub	sp, #12
 8001c14:	9001      	str	r0, [sp, #4]
 8001c16:	9100      	str	r1, [sp, #0]
 8001c18:	e005      	b.n	8001c26 <chThdDequeueAllI+0x16>

  while (queue_notempty(tqp)) {
    chThdDoDequeueNextI(tqp, msg);
 8001c1a:	9a00      	ldr	r2, [sp, #0]
 8001c1c:	9b01      	ldr	r3, [sp, #4]
 8001c1e:	0011      	movs	r1, r2
 8001c20:	0018      	movs	r0, r3
 8001c22:	f001 fc9d 	bl	8003560 <chThdDoDequeueNextI.lto_priv.201>
  while (queue_notempty(tqp)) {
 8001c26:	9b01      	ldr	r3, [sp, #4]
 8001c28:	0018      	movs	r0, r3
 8001c2a:	f001 fc01 	bl	8003430 <queue_notempty.lto_priv.186>
 8001c2e:	1e03      	subs	r3, r0, #0
 8001c30:	d1f3      	bne.n	8001c1a <chThdDequeueAllI+0xa>
  }
}
 8001c32:	b003      	add	sp, #12
 8001c34:	bd00      	pop	{pc}
 8001c36:	46c0      	nop			; (mov r8, r8)
	...

08001c40 <port_lock.lto_priv.165>:
  __ASM volatile ("cpsid i" : : : "memory");
 8001c40:	b672      	cpsid	i
}
 8001c42:	4770      	bx	lr
	...

08001c50 <port_unlock.lto_priv.160>:
  __ASM volatile ("cpsie i" : : : "memory");
 8001c50:	b662      	cpsie	i
}
 8001c52:	4770      	bx	lr
	...

08001c60 <chSysLock.lto_priv.177>:
static inline void chSysLock(void) {
 8001c60:	b510      	push	{r4, lr}
  port_lock();
 8001c62:	f7ff ffed 	bl	8001c40 <port_lock.lto_priv.165>
  _dbg_check_lock();
 8001c66:	f000 fd3b 	bl	80026e0 <_dbg_check_lock>
}
 8001c6a:	bd10      	pop	{r4, pc}
 8001c6c:	0000      	movs	r0, r0
	...

08001c70 <chSysUnlock.lto_priv.172>:
static inline void chSysUnlock(void) {
 8001c70:	b510      	push	{r4, lr}
  _dbg_check_unlock();
 8001c72:	f000 fd4d 	bl	8002710 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001c76:	4b0a      	ldr	r3, [pc, #40]	; (8001ca0 <chSysUnlock.lto_priv.172+0x30>)
 8001c78:	681a      	ldr	r2, [r3, #0]
 8001c7a:	4b09      	ldr	r3, [pc, #36]	; (8001ca0 <chSysUnlock.lto_priv.172+0x30>)
 8001c7c:	429a      	cmp	r2, r3
 8001c7e:	d00b      	beq.n	8001c98 <chSysUnlock.lto_priv.172+0x28>
 8001c80:	4b07      	ldr	r3, [pc, #28]	; (8001ca0 <chSysUnlock.lto_priv.172+0x30>)
 8001c82:	699b      	ldr	r3, [r3, #24]
 8001c84:	689a      	ldr	r2, [r3, #8]
 8001c86:	4b06      	ldr	r3, [pc, #24]	; (8001ca0 <chSysUnlock.lto_priv.172+0x30>)
 8001c88:	681b      	ldr	r3, [r3, #0]
 8001c8a:	689b      	ldr	r3, [r3, #8]
 8001c8c:	429a      	cmp	r2, r3
 8001c8e:	d203      	bcs.n	8001c98 <chSysUnlock.lto_priv.172+0x28>
 8001c90:	4b04      	ldr	r3, [pc, #16]	; (8001ca4 <chSysUnlock.lto_priv.172+0x34>)
 8001c92:	0018      	movs	r0, r3
 8001c94:	f000 fcd4 	bl	8002640 <chSysHalt>
  port_unlock();
 8001c98:	f7ff ffda 	bl	8001c50 <port_unlock.lto_priv.160>
}
 8001c9c:	bd10      	pop	{r4, pc}
 8001c9e:	46c0      	nop			; (mov r8, r8)
 8001ca0:	200004d8 	.word	0x200004d8
 8001ca4:	08003b6c 	.word	0x08003b6c
	...

08001cb0 <chThdGetWorkingAreaX>:
static inline stkalign_t *chThdGetWorkingAreaX(thread_t *tp) {
 8001cb0:	b082      	sub	sp, #8
 8001cb2:	9001      	str	r0, [sp, #4]
  return tp->wabase;
 8001cb4:	9b01      	ldr	r3, [sp, #4]
 8001cb6:	69db      	ldr	r3, [r3, #28]
}
 8001cb8:	0018      	movs	r0, r3
 8001cba:	b002      	add	sp, #8
 8001cbc:	4770      	bx	lr
 8001cbe:	46c0      	nop			; (mov r8, r8)

08001cc0 <chRegFirstThread>:
 *
 * @return              A reference to the most ancient thread.
 *
 * @api
 */
thread_t *chRegFirstThread(void) {
 8001cc0:	b500      	push	{lr}
 8001cc2:	b083      	sub	sp, #12
  thread_t *tp;

  chSysLock();
 8001cc4:	f7ff ffcc 	bl	8001c60 <chSysLock.lto_priv.177>
  tp = ch.rlist.newer;
 8001cc8:	4b08      	ldr	r3, [pc, #32]	; (8001cec <chRegFirstThread+0x2c>)
 8001cca:	691b      	ldr	r3, [r3, #16]
 8001ccc:	9301      	str	r3, [sp, #4]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 8001cce:	9b01      	ldr	r3, [sp, #4]
 8001cd0:	2222      	movs	r2, #34	; 0x22
 8001cd2:	5c9b      	ldrb	r3, [r3, r2]
 8001cd4:	3301      	adds	r3, #1
 8001cd6:	b2d9      	uxtb	r1, r3
 8001cd8:	9b01      	ldr	r3, [sp, #4]
 8001cda:	2222      	movs	r2, #34	; 0x22
 8001cdc:	5499      	strb	r1, [r3, r2]
#endif
  chSysUnlock();
 8001cde:	f7ff ffc7 	bl	8001c70 <chSysUnlock.lto_priv.172>

  return tp;
 8001ce2:	9b01      	ldr	r3, [sp, #4]
}
 8001ce4:	0018      	movs	r0, r3
 8001ce6:	b003      	add	sp, #12
 8001ce8:	bd00      	pop	{pc}
 8001cea:	46c0      	nop			; (mov r8, r8)
 8001cec:	200004d8 	.word	0x200004d8

08001cf0 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
 8001cf0:	b500      	push	{lr}
 8001cf2:	b085      	sub	sp, #20
 8001cf4:	9001      	str	r0, [sp, #4]
  thread_t *ntp;

  chSysLock();
 8001cf6:	f7ff ffb3 	bl	8001c60 <chSysLock.lto_priv.177>
  ntp = tp->newer;
 8001cfa:	9b01      	ldr	r3, [sp, #4]
 8001cfc:	691b      	ldr	r3, [r3, #16]
 8001cfe:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 8001d00:	9a03      	ldr	r2, [sp, #12]
 8001d02:	4b10      	ldr	r3, [pc, #64]	; (8001d44 <chRegNextThread+0x54>)
 8001d04:	429a      	cmp	r2, r3
 8001d06:	d102      	bne.n	8001d0e <chRegNextThread+0x1e>
  /*lint -restore*/
    ntp = NULL;
 8001d08:	2300      	movs	r3, #0
 8001d0a:	9303      	str	r3, [sp, #12]
 8001d0c:	e010      	b.n	8001d30 <chRegNextThread+0x40>
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 8001d0e:	9b03      	ldr	r3, [sp, #12]
 8001d10:	2222      	movs	r2, #34	; 0x22
 8001d12:	5c9b      	ldrb	r3, [r3, r2]
 8001d14:	2bff      	cmp	r3, #255	; 0xff
 8001d16:	d103      	bne.n	8001d20 <chRegNextThread+0x30>
 8001d18:	4b0b      	ldr	r3, [pc, #44]	; (8001d48 <chRegNextThread+0x58>)
 8001d1a:	0018      	movs	r0, r3
 8001d1c:	f000 fc90 	bl	8002640 <chSysHalt>
    ntp->refs++;
 8001d20:	9b03      	ldr	r3, [sp, #12]
 8001d22:	2222      	movs	r2, #34	; 0x22
 8001d24:	5c9b      	ldrb	r3, [r3, r2]
 8001d26:	3301      	adds	r3, #1
 8001d28:	b2d9      	uxtb	r1, r3
 8001d2a:	9b03      	ldr	r3, [sp, #12]
 8001d2c:	2222      	movs	r2, #34	; 0x22
 8001d2e:	5499      	strb	r1, [r3, r2]
  }
#endif
  chSysUnlock();
 8001d30:	f7ff ff9e 	bl	8001c70 <chSysUnlock.lto_priv.172>
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 8001d34:	9b01      	ldr	r3, [sp, #4]
 8001d36:	0018      	movs	r0, r3
 8001d38:	f001 fd9a 	bl	8003870 <chThdRelease>
#endif

  return ntp;
 8001d3c:	9b03      	ldr	r3, [sp, #12]
}
 8001d3e:	0018      	movs	r0, r3
 8001d40:	b005      	add	sp, #20
 8001d42:	bd00      	pop	{pc}
 8001d44:	200004d8 	.word	0x200004d8
 8001d48:	08003b78 	.word	0x08003b78
 8001d4c:	00000000 	.word	0x00000000

08001d50 <chRegFindThreadByWorkingArea>:
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByWorkingArea(stkalign_t *wa) {
 8001d50:	b500      	push	{lr}
 8001d52:	b085      	sub	sp, #20
 8001d54:	9001      	str	r0, [sp, #4]
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
 8001d56:	f7ff ffb3 	bl	8001cc0 <chRegFirstThread>
 8001d5a:	0003      	movs	r3, r0
 8001d5c:	9303      	str	r3, [sp, #12]
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 8001d5e:	9b03      	ldr	r3, [sp, #12]
 8001d60:	0018      	movs	r0, r3
 8001d62:	f7ff ffa5 	bl	8001cb0 <chThdGetWorkingAreaX>
 8001d66:	0002      	movs	r2, r0
 8001d68:	9b01      	ldr	r3, [sp, #4]
 8001d6a:	429a      	cmp	r2, r3
 8001d6c:	d101      	bne.n	8001d72 <chRegFindThreadByWorkingArea+0x22>
      return ctp;
 8001d6e:	9b03      	ldr	r3, [sp, #12]
 8001d70:	e009      	b.n	8001d86 <chRegFindThreadByWorkingArea+0x36>
    }
    ctp = chRegNextThread(ctp);
 8001d72:	9b03      	ldr	r3, [sp, #12]
 8001d74:	0018      	movs	r0, r3
 8001d76:	f7ff ffbb 	bl	8001cf0 <chRegNextThread>
 8001d7a:	0003      	movs	r3, r0
 8001d7c:	9303      	str	r3, [sp, #12]
  } while (ctp != NULL);
 8001d7e:	9b03      	ldr	r3, [sp, #12]
 8001d80:	2b00      	cmp	r3, #0
 8001d82:	d1ec      	bne.n	8001d5e <chRegFindThreadByWorkingArea+0xe>

  return NULL;
 8001d84:	2300      	movs	r3, #0
}
 8001d86:	0018      	movs	r0, r3
 8001d88:	b005      	add	sp, #20
 8001d8a:	bd00      	pop	{pc}
 8001d8c:	0000      	movs	r0, r0
	...

08001d90 <port_lock.lto_priv.167>:
  __ASM volatile ("cpsid i" : : : "memory");
 8001d90:	b672      	cpsid	i
}
 8001d92:	4770      	bx	lr
	...

08001da0 <port_unlock.lto_priv.162>:
  __ASM volatile ("cpsie i" : : : "memory");
 8001da0:	b662      	cpsie	i
}
 8001da2:	4770      	bx	lr
	...

08001db0 <queue_init.lto_priv.191>:
static inline void queue_init(threads_queue_t *tqp) {
 8001db0:	b082      	sub	sp, #8
 8001db2:	9001      	str	r0, [sp, #4]
  tqp->next = (thread_t *)tqp;
 8001db4:	9b01      	ldr	r3, [sp, #4]
 8001db6:	9a01      	ldr	r2, [sp, #4]
 8001db8:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8001dba:	9b01      	ldr	r3, [sp, #4]
 8001dbc:	9a01      	ldr	r2, [sp, #4]
 8001dbe:	605a      	str	r2, [r3, #4]
}
 8001dc0:	b002      	add	sp, #8
 8001dc2:	4770      	bx	lr
	...

08001dd0 <queue_notempty.lto_priv.188>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8001dd0:	b082      	sub	sp, #8
 8001dd2:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->next != (const thread_t *)tqp);
 8001dd4:	9b01      	ldr	r3, [sp, #4]
 8001dd6:	681a      	ldr	r2, [r3, #0]
 8001dd8:	9b01      	ldr	r3, [sp, #4]
 8001dda:	1ad3      	subs	r3, r2, r3
 8001ddc:	1e5a      	subs	r2, r3, #1
 8001dde:	4193      	sbcs	r3, r2
 8001de0:	b2db      	uxtb	r3, r3
}
 8001de2:	0018      	movs	r0, r3
 8001de4:	b002      	add	sp, #8
 8001de6:	4770      	bx	lr
	...

08001df0 <queue_prio_insert.lto_priv.184>:
  tlp->next = tp->queue.next;

  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {
 8001df0:	b084      	sub	sp, #16
 8001df2:	9001      	str	r0, [sp, #4]
 8001df4:	9100      	str	r1, [sp, #0]

  thread_t *cp = (thread_t *)tqp;
 8001df6:	9b00      	ldr	r3, [sp, #0]
 8001df8:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->queue.next;
 8001dfa:	9b03      	ldr	r3, [sp, #12]
 8001dfc:	681b      	ldr	r3, [r3, #0]
 8001dfe:	9303      	str	r3, [sp, #12]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8001e00:	9a03      	ldr	r2, [sp, #12]
 8001e02:	9b00      	ldr	r3, [sp, #0]
 8001e04:	429a      	cmp	r2, r3
 8001e06:	d005      	beq.n	8001e14 <queue_prio_insert.lto_priv.184+0x24>
 8001e08:	9b03      	ldr	r3, [sp, #12]
 8001e0a:	689a      	ldr	r2, [r3, #8]
 8001e0c:	9b01      	ldr	r3, [sp, #4]
 8001e0e:	689b      	ldr	r3, [r3, #8]
 8001e10:	429a      	cmp	r2, r3
 8001e12:	d2f2      	bcs.n	8001dfa <queue_prio_insert.lto_priv.184+0xa>
  tp->queue.next             = cp;
 8001e14:	9b01      	ldr	r3, [sp, #4]
 8001e16:	9a03      	ldr	r2, [sp, #12]
 8001e18:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 8001e1a:	9b03      	ldr	r3, [sp, #12]
 8001e1c:	685a      	ldr	r2, [r3, #4]
 8001e1e:	9b01      	ldr	r3, [sp, #4]
 8001e20:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8001e22:	9b01      	ldr	r3, [sp, #4]
 8001e24:	685b      	ldr	r3, [r3, #4]
 8001e26:	9a01      	ldr	r2, [sp, #4]
 8001e28:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 8001e2a:	9b03      	ldr	r3, [sp, #12]
 8001e2c:	9a01      	ldr	r2, [sp, #4]
 8001e2e:	605a      	str	r2, [r3, #4]
}
 8001e30:	b004      	add	sp, #16
 8001e32:	4770      	bx	lr
	...

08001e40 <queue_fifo_remove.lto_priv.182>:
  tp->queue.prev             = tqp->prev;
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8001e40:	b084      	sub	sp, #16
 8001e42:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
 8001e44:	9b01      	ldr	r3, [sp, #4]
 8001e46:	681b      	ldr	r3, [r3, #0]
 8001e48:	9303      	str	r3, [sp, #12]

  tqp->next             = tp->queue.next;
 8001e4a:	9b03      	ldr	r3, [sp, #12]
 8001e4c:	681a      	ldr	r2, [r3, #0]
 8001e4e:	9b01      	ldr	r3, [sp, #4]
 8001e50:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8001e52:	9b01      	ldr	r3, [sp, #4]
 8001e54:	681b      	ldr	r3, [r3, #0]
 8001e56:	9a01      	ldr	r2, [sp, #4]
 8001e58:	605a      	str	r2, [r3, #4]

  return tp;
 8001e5a:	9b03      	ldr	r3, [sp, #12]
}
 8001e5c:	0018      	movs	r0, r3
 8001e5e:	b004      	add	sp, #16
 8001e60:	4770      	bx	lr
 8001e62:	46c0      	nop			; (mov r8, r8)
	...

08001e70 <queue_dequeue>:
  tqp->prev->queue.next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
 8001e70:	b082      	sub	sp, #8
 8001e72:	9001      	str	r0, [sp, #4]

  tp->queue.prev->queue.next = tp->queue.next;
 8001e74:	9b01      	ldr	r3, [sp, #4]
 8001e76:	685b      	ldr	r3, [r3, #4]
 8001e78:	9a01      	ldr	r2, [sp, #4]
 8001e7a:	6812      	ldr	r2, [r2, #0]
 8001e7c:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8001e7e:	9b01      	ldr	r3, [sp, #4]
 8001e80:	681b      	ldr	r3, [r3, #0]
 8001e82:	9a01      	ldr	r2, [sp, #4]
 8001e84:	6852      	ldr	r2, [r2, #4]
 8001e86:	605a      	str	r2, [r3, #4]

  return tp;
 8001e88:	9b01      	ldr	r3, [sp, #4]
}
 8001e8a:	0018      	movs	r0, r3
 8001e8c:	b002      	add	sp, #8
 8001e8e:	4770      	bx	lr

08001e90 <chSysLock.lto_priv.179>:
static inline void chSysLock(void) {
 8001e90:	b510      	push	{r4, lr}
  port_lock();
 8001e92:	f7ff ff7d 	bl	8001d90 <port_lock.lto_priv.167>
  _dbg_check_lock();
 8001e96:	f000 fc23 	bl	80026e0 <_dbg_check_lock>
}
 8001e9a:	bd10      	pop	{r4, pc}
 8001e9c:	0000      	movs	r0, r0
	...

08001ea0 <chSysUnlock.lto_priv.174>:
static inline void chSysUnlock(void) {
 8001ea0:	b510      	push	{r4, lr}
  _dbg_check_unlock();
 8001ea2:	f000 fc35 	bl	8002710 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001ea6:	4b0a      	ldr	r3, [pc, #40]	; (8001ed0 <chSysUnlock.lto_priv.174+0x30>)
 8001ea8:	681a      	ldr	r2, [r3, #0]
 8001eaa:	4b09      	ldr	r3, [pc, #36]	; (8001ed0 <chSysUnlock.lto_priv.174+0x30>)
 8001eac:	429a      	cmp	r2, r3
 8001eae:	d00b      	beq.n	8001ec8 <chSysUnlock.lto_priv.174+0x28>
 8001eb0:	4b07      	ldr	r3, [pc, #28]	; (8001ed0 <chSysUnlock.lto_priv.174+0x30>)
 8001eb2:	699b      	ldr	r3, [r3, #24]
 8001eb4:	689a      	ldr	r2, [r3, #8]
 8001eb6:	4b06      	ldr	r3, [pc, #24]	; (8001ed0 <chSysUnlock.lto_priv.174+0x30>)
 8001eb8:	681b      	ldr	r3, [r3, #0]
 8001eba:	689b      	ldr	r3, [r3, #8]
 8001ebc:	429a      	cmp	r2, r3
 8001ebe:	d203      	bcs.n	8001ec8 <chSysUnlock.lto_priv.174+0x28>
 8001ec0:	4b04      	ldr	r3, [pc, #16]	; (8001ed4 <chSysUnlock.lto_priv.174+0x34>)
 8001ec2:	0018      	movs	r0, r3
 8001ec4:	f000 fbbc 	bl	8002640 <chSysHalt>
  port_unlock();
 8001ec8:	f7ff ff6a 	bl	8001da0 <port_unlock.lto_priv.162>
}
 8001ecc:	bd10      	pop	{r4, pc}
 8001ece:	46c0      	nop			; (mov r8, r8)
 8001ed0:	200004d8 	.word	0x200004d8
 8001ed4:	08003b98 	.word	0x08003b98
	...

08001ee0 <chMtxQueueNotEmptyS>:
 * @return              The mutex queue status.
 *
 * @deprecated
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {
 8001ee0:	b500      	push	{lr}
 8001ee2:	b083      	sub	sp, #12
 8001ee4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();
 8001ee6:	f000 fcb3 	bl	8002850 <chDbgCheckClassS>

  return queue_notempty(&mp->queue);
 8001eea:	9b01      	ldr	r3, [sp, #4]
 8001eec:	0018      	movs	r0, r3
 8001eee:	f7ff ff6f 	bl	8001dd0 <queue_notempty.lto_priv.188>
 8001ef2:	0003      	movs	r3, r0
}
 8001ef4:	0018      	movs	r0, r3
 8001ef6:	b003      	add	sp, #12
 8001ef8:	bd00      	pop	{pc}
 8001efa:	46c0      	nop			; (mov r8, r8)
 8001efc:	0000      	movs	r0, r0
	...

08001f00 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 8001f00:	b500      	push	{lr}
 8001f02:	b083      	sub	sp, #12
 8001f04:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);
 8001f06:	9b01      	ldr	r3, [sp, #4]
 8001f08:	2b00      	cmp	r3, #0
 8001f0a:	d103      	bne.n	8001f14 <chMtxObjectInit+0x14>
 8001f0c:	4b06      	ldr	r3, [pc, #24]	; (8001f28 <chMtxObjectInit+0x28>)
 8001f0e:	0018      	movs	r0, r3
 8001f10:	f000 fb96 	bl	8002640 <chSysHalt>

  queue_init(&mp->queue);
 8001f14:	9b01      	ldr	r3, [sp, #4]
 8001f16:	0018      	movs	r0, r3
 8001f18:	f7ff ff4a 	bl	8001db0 <queue_init.lto_priv.191>
  mp->owner = NULL;
 8001f1c:	9b01      	ldr	r3, [sp, #4]
 8001f1e:	2200      	movs	r2, #0
 8001f20:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
#endif
}
 8001f22:	b003      	add	sp, #12
 8001f24:	bd00      	pop	{pc}
 8001f26:	46c0      	nop			; (mov r8, r8)
 8001f28:	08003b88 	.word	0x08003b88
 8001f2c:	00000000 	.word	0x00000000

08001f30 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 8001f30:	b500      	push	{lr}
 8001f32:	b083      	sub	sp, #12
 8001f34:	9001      	str	r0, [sp, #4]

  chSysLock();
 8001f36:	f7ff ffab 	bl	8001e90 <chSysLock.lto_priv.179>
  chMtxLockS(mp);
 8001f3a:	9b01      	ldr	r3, [sp, #4]
 8001f3c:	0018      	movs	r0, r3
 8001f3e:	f000 f807 	bl	8001f50 <chMtxLockS>
  chSysUnlock();
 8001f42:	f7ff ffad 	bl	8001ea0 <chSysUnlock.lto_priv.174>
}
 8001f46:	b003      	add	sp, #12
 8001f48:	bd00      	pop	{pc}
 8001f4a:	46c0      	nop			; (mov r8, r8)
 8001f4c:	0000      	movs	r0, r0
	...

08001f50 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8001f50:	b500      	push	{lr}
 8001f52:	b085      	sub	sp, #20
 8001f54:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8001f56:	4b3e      	ldr	r3, [pc, #248]	; (8002050 <chMtxLockS+0x100>)
 8001f58:	699b      	ldr	r3, [r3, #24]
 8001f5a:	9302      	str	r3, [sp, #8]

  chDbgCheckClassS();
 8001f5c:	f000 fc78 	bl	8002850 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 8001f60:	9b01      	ldr	r3, [sp, #4]
 8001f62:	2b00      	cmp	r3, #0
 8001f64:	d103      	bne.n	8001f6e <chMtxLockS+0x1e>
 8001f66:	4b3b      	ldr	r3, [pc, #236]	; (8002054 <chMtxLockS+0x104>)
 8001f68:	0018      	movs	r0, r3
 8001f6a:	f000 fb69 	bl	8002640 <chSysHalt>

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8001f6e:	9b01      	ldr	r3, [sp, #4]
 8001f70:	689b      	ldr	r3, [r3, #8]
 8001f72:	2b00      	cmp	r3, #0
 8001f74:	d05f      	beq.n	8002036 <chMtxLockS+0xe6>
    else {
#endif
      /* Priority inheritance protocol; explores the thread-mutex dependencies
         boosting the priority of all the affected threads to equal the
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;
 8001f76:	9b01      	ldr	r3, [sp, #4]
 8001f78:	689b      	ldr	r3, [r3, #8]
 8001f7a:	9303      	str	r3, [sp, #12]
 8001f7c:	e036      	b.n	8001fec <chMtxLockS+0x9c>

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;
 8001f7e:	9b02      	ldr	r3, [sp, #8]
 8001f80:	689a      	ldr	r2, [r3, #8]
 8001f82:	9b03      	ldr	r3, [sp, #12]
 8001f84:	609a      	str	r2, [r3, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8001f86:	9b03      	ldr	r3, [sp, #12]
 8001f88:	2220      	movs	r2, #32
 8001f8a:	5c9b      	ldrb	r3, [r3, r2]
 8001f8c:	2b06      	cmp	r3, #6
 8001f8e:	d004      	beq.n	8001f9a <chMtxLockS+0x4a>
 8001f90:	2b07      	cmp	r3, #7
 8001f92:	d012      	beq.n	8001fba <chMtxLockS+0x6a>
 8001f94:	2b00      	cmp	r3, #0
 8001f96:	d01c      	beq.n	8001fd2 <chMtxLockS+0x82>
 8001f98:	e02e      	b.n	8001ff8 <chMtxLockS+0xa8>
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8001f9a:	9b03      	ldr	r3, [sp, #12]
 8001f9c:	0018      	movs	r0, r3
 8001f9e:	f7ff ff67 	bl	8001e70 <queue_dequeue>
 8001fa2:	0002      	movs	r2, r0
 8001fa4:	9b03      	ldr	r3, [sp, #12]
 8001fa6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001fa8:	0019      	movs	r1, r3
 8001faa:	0010      	movs	r0, r2
 8001fac:	f7ff ff20 	bl	8001df0 <queue_prio_insert.lto_priv.184>
          tp = tp->u.wtmtxp->owner;
 8001fb0:	9b03      	ldr	r3, [sp, #12]
 8001fb2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001fb4:	689b      	ldr	r3, [r3, #8]
 8001fb6:	9303      	str	r3, [sp, #12]
 8001fb8:	e018      	b.n	8001fec <chMtxLockS+0x9c>
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8001fba:	9b03      	ldr	r3, [sp, #12]
 8001fbc:	0018      	movs	r0, r3
 8001fbe:	f7ff ff57 	bl	8001e70 <queue_dequeue>
 8001fc2:	0002      	movs	r2, r0
 8001fc4:	9b03      	ldr	r3, [sp, #12]
 8001fc6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001fc8:	0019      	movs	r1, r3
 8001fca:	0010      	movs	r0, r2
 8001fcc:	f7ff ff10 	bl	8001df0 <queue_prio_insert.lto_priv.184>
 8001fd0:	e012      	b.n	8001ff8 <chMtxLockS+0xa8>
          break;
#endif
        case CH_STATE_READY:
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
 8001fd2:	9b03      	ldr	r3, [sp, #12]
 8001fd4:	2220      	movs	r2, #32
 8001fd6:	2101      	movs	r1, #1
 8001fd8:	5499      	strb	r1, [r3, r2]
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 8001fda:	9b03      	ldr	r3, [sp, #12]
 8001fdc:	0018      	movs	r0, r3
 8001fde:	f7ff ff47 	bl	8001e70 <queue_dequeue>
 8001fe2:	0003      	movs	r3, r0
 8001fe4:	0018      	movs	r0, r3
 8001fe6:	f000 ffb3 	bl	8002f50 <chSchReadyI>
 8001fea:	e005      	b.n	8001ff8 <chMtxLockS+0xa8>
      while (tp->prio < ctp->prio) {
 8001fec:	9b03      	ldr	r3, [sp, #12]
 8001fee:	689a      	ldr	r2, [r3, #8]
 8001ff0:	9b02      	ldr	r3, [sp, #8]
 8001ff2:	689b      	ldr	r3, [r3, #8]
 8001ff4:	429a      	cmp	r2, r3
 8001ff6:	d3c2      	bcc.n	8001f7e <chMtxLockS+0x2e>
        }
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
 8001ff8:	9a01      	ldr	r2, [sp, #4]
 8001ffa:	9b02      	ldr	r3, [sp, #8]
 8001ffc:	0011      	movs	r1, r2
 8001ffe:	0018      	movs	r0, r3
 8002000:	f7ff fef6 	bl	8001df0 <queue_prio_insert.lto_priv.184>
      ctp->u.wtmtxp = mp;
 8002004:	9b02      	ldr	r3, [sp, #8]
 8002006:	9a01      	ldr	r2, [sp, #4]
 8002008:	625a      	str	r2, [r3, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 800200a:	2006      	movs	r0, #6
 800200c:	f001 f820 	bl	8003050 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == ctp, "not owner");
 8002010:	9b01      	ldr	r3, [sp, #4]
 8002012:	689a      	ldr	r2, [r3, #8]
 8002014:	9b02      	ldr	r3, [sp, #8]
 8002016:	429a      	cmp	r2, r3
 8002018:	d003      	beq.n	8002022 <chMtxLockS+0xd2>
 800201a:	4b0e      	ldr	r3, [pc, #56]	; (8002054 <chMtxLockS+0x104>)
 800201c:	0018      	movs	r0, r3
 800201e:	f000 fb0f 	bl	8002640 <chSysHalt>
      chDbgAssert(ctp->mtxlist == mp, "not owned");
 8002022:	9b02      	ldr	r3, [sp, #8]
 8002024:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002026:	9b01      	ldr	r3, [sp, #4]
 8002028:	429a      	cmp	r2, r3
 800202a:	d00e      	beq.n	800204a <chMtxLockS+0xfa>
 800202c:	4b09      	ldr	r3, [pc, #36]	; (8002054 <chMtxLockS+0x104>)
 800202e:	0018      	movs	r0, r3
 8002030:	f000 fb06 	bl	8002640 <chSysHalt>
 8002034:	e009      	b.n	800204a <chMtxLockS+0xfa>
    chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
 8002036:	9b01      	ldr	r3, [sp, #4]
 8002038:	9a02      	ldr	r2, [sp, #8]
 800203a:	609a      	str	r2, [r3, #8]
    mp->next = ctp->mtxlist;
 800203c:	9b02      	ldr	r3, [sp, #8]
 800203e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002040:	9b01      	ldr	r3, [sp, #4]
 8002042:	60da      	str	r2, [r3, #12]
    ctp->mtxlist = mp;
 8002044:	9b02      	ldr	r3, [sp, #8]
 8002046:	9a01      	ldr	r2, [sp, #4]
 8002048:	639a      	str	r2, [r3, #56]	; 0x38
  }
}
 800204a:	b005      	add	sp, #20
 800204c:	bd00      	pop	{pc}
 800204e:	46c0      	nop			; (mov r8, r8)
 8002050:	200004d8 	.word	0x200004d8
 8002054:	08003ba4 	.word	0x08003ba4
	...

08002060 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8002060:	b500      	push	{lr}
 8002062:	b087      	sub	sp, #28
 8002064:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8002066:	4b37      	ldr	r3, [pc, #220]	; (8002144 <chMtxUnlock+0xe4>)
 8002068:	699b      	ldr	r3, [r3, #24]
 800206a:	9303      	str	r3, [sp, #12]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 800206c:	9b01      	ldr	r3, [sp, #4]
 800206e:	2b00      	cmp	r3, #0
 8002070:	d103      	bne.n	800207a <chMtxUnlock+0x1a>
 8002072:	4b35      	ldr	r3, [pc, #212]	; (8002148 <chMtxUnlock+0xe8>)
 8002074:	0018      	movs	r0, r3
 8002076:	f000 fae3 	bl	8002640 <chSysHalt>

  chSysLock();
 800207a:	f7ff ff09 	bl	8001e90 <chSysLock.lto_priv.179>

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 800207e:	9b03      	ldr	r3, [sp, #12]
 8002080:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002082:	2b00      	cmp	r3, #0
 8002084:	d103      	bne.n	800208e <chMtxUnlock+0x2e>
 8002086:	4b30      	ldr	r3, [pc, #192]	; (8002148 <chMtxUnlock+0xe8>)
 8002088:	0018      	movs	r0, r3
 800208a:	f000 fad9 	bl	8002640 <chSysHalt>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
 800208e:	9b03      	ldr	r3, [sp, #12]
 8002090:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002092:	689a      	ldr	r2, [r3, #8]
 8002094:	9b03      	ldr	r3, [sp, #12]
 8002096:	429a      	cmp	r2, r3
 8002098:	d003      	beq.n	80020a2 <chMtxUnlock+0x42>
 800209a:	4b2b      	ldr	r3, [pc, #172]	; (8002148 <chMtxUnlock+0xe8>)
 800209c:	0018      	movs	r0, r3
 800209e:	f000 facf 	bl	8002640 <chSysHalt>
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
#endif

    chDbgAssert(ctp->mtxlist == mp, "not next in list");
 80020a2:	9b03      	ldr	r3, [sp, #12]
 80020a4:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80020a6:	9b01      	ldr	r3, [sp, #4]
 80020a8:	429a      	cmp	r2, r3
 80020aa:	d003      	beq.n	80020b4 <chMtxUnlock+0x54>
 80020ac:	4b26      	ldr	r3, [pc, #152]	; (8002148 <chMtxUnlock+0xe8>)
 80020ae:	0018      	movs	r0, r3
 80020b0:	f000 fac6 	bl	8002640 <chSysHalt>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 80020b4:	9b01      	ldr	r3, [sp, #4]
 80020b6:	68da      	ldr	r2, [r3, #12]
 80020b8:	9b03      	ldr	r3, [sp, #12]
 80020ba:	639a      	str	r2, [r3, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 80020bc:	9b01      	ldr	r3, [sp, #4]
 80020be:	0018      	movs	r0, r3
 80020c0:	f7ff ff0e 	bl	8001ee0 <chMtxQueueNotEmptyS>
 80020c4:	1e03      	subs	r3, r0, #0
 80020c6:	d036      	beq.n	8002136 <chMtxUnlock+0xd6>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 80020c8:	9b03      	ldr	r3, [sp, #12]
 80020ca:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80020cc:	9304      	str	r3, [sp, #16]
      lmp = ctp->mtxlist;
 80020ce:	9b03      	ldr	r3, [sp, #12]
 80020d0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80020d2:	9305      	str	r3, [sp, #20]
 80020d4:	e012      	b.n	80020fc <chMtxUnlock+0x9c>
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 80020d6:	9b05      	ldr	r3, [sp, #20]
 80020d8:	0018      	movs	r0, r3
 80020da:	f7ff ff01 	bl	8001ee0 <chMtxQueueNotEmptyS>
 80020de:	1e03      	subs	r3, r0, #0
 80020e0:	d009      	beq.n	80020f6 <chMtxUnlock+0x96>
            (lmp->queue.next->prio > newprio)) {
 80020e2:	9b05      	ldr	r3, [sp, #20]
 80020e4:	681b      	ldr	r3, [r3, #0]
 80020e6:	689a      	ldr	r2, [r3, #8]
        if (chMtxQueueNotEmptyS(lmp) &&
 80020e8:	9b04      	ldr	r3, [sp, #16]
 80020ea:	429a      	cmp	r2, r3
 80020ec:	d903      	bls.n	80020f6 <chMtxUnlock+0x96>
          newprio = lmp->queue.next->prio;
 80020ee:	9b05      	ldr	r3, [sp, #20]
 80020f0:	681b      	ldr	r3, [r3, #0]
 80020f2:	689b      	ldr	r3, [r3, #8]
 80020f4:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->next;
 80020f6:	9b05      	ldr	r3, [sp, #20]
 80020f8:	68db      	ldr	r3, [r3, #12]
 80020fa:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
 80020fc:	9b05      	ldr	r3, [sp, #20]
 80020fe:	2b00      	cmp	r3, #0
 8002100:	d1e9      	bne.n	80020d6 <chMtxUnlock+0x76>
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 8002102:	9b03      	ldr	r3, [sp, #12]
 8002104:	9a04      	ldr	r2, [sp, #16]
 8002106:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
 8002108:	9b01      	ldr	r3, [sp, #4]
 800210a:	0018      	movs	r0, r3
 800210c:	f7ff fe98 	bl	8001e40 <queue_fifo_remove.lto_priv.182>
 8002110:	0003      	movs	r3, r0
 8002112:	9302      	str	r3, [sp, #8]
      mp->owner = tp;
 8002114:	9b01      	ldr	r3, [sp, #4]
 8002116:	9a02      	ldr	r2, [sp, #8]
 8002118:	609a      	str	r2, [r3, #8]
      mp->next = tp->mtxlist;
 800211a:	9b02      	ldr	r3, [sp, #8]
 800211c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800211e:	9b01      	ldr	r3, [sp, #4]
 8002120:	60da      	str	r2, [r3, #12]
      tp->mtxlist = mp;
 8002122:	9b02      	ldr	r3, [sp, #8]
 8002124:	9a01      	ldr	r2, [sp, #4]
 8002126:	639a      	str	r2, [r3, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8002128:	9b02      	ldr	r3, [sp, #8]
 800212a:	0018      	movs	r0, r3
 800212c:	f000 ff10 	bl	8002f50 <chSchReadyI>
      chSchRescheduleS();
 8002130:	f001 f89e 	bl	8003270 <chSchRescheduleS>
 8002134:	e002      	b.n	800213c <chMtxUnlock+0xdc>
    }
    else {
      mp->owner = NULL;
 8002136:	9b01      	ldr	r3, [sp, #4]
 8002138:	2200      	movs	r2, #0
 800213a:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
 800213c:	f7ff feb0 	bl	8001ea0 <chSysUnlock.lto_priv.174>
}
 8002140:	b007      	add	sp, #28
 8002142:	bd00      	pop	{pc}
 8002144:	200004d8 	.word	0x200004d8
 8002148:	08003bb0 	.word	0x08003bb0
 800214c:	00000000 	.word	0x00000000

08002150 <port_lock.lto_priv.169>:
  __ASM volatile ("cpsid i" : : : "memory");
 8002150:	b672      	cpsid	i
}
 8002152:	4770      	bx	lr
	...

08002160 <port_unlock.lto_priv.164>:
  __ASM volatile ("cpsie i" : : : "memory");
 8002160:	b662      	cpsie	i
}
 8002162:	4770      	bx	lr
	...

08002170 <chSysLock.lto_priv.147>:
static inline void chSysLock(void) {
 8002170:	b510      	push	{r4, lr}
  port_lock();
 8002172:	f7ff ffed 	bl	8002150 <port_lock.lto_priv.169>
  _dbg_check_lock();
 8002176:	f000 fab3 	bl	80026e0 <_dbg_check_lock>
}
 800217a:	bd10      	pop	{r4, pc}
 800217c:	0000      	movs	r0, r0
	...

08002180 <chSysUnlock.lto_priv.142>:
static inline void chSysUnlock(void) {
 8002180:	b510      	push	{r4, lr}
  _dbg_check_unlock();
 8002182:	f000 fac5 	bl	8002710 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002186:	4b0a      	ldr	r3, [pc, #40]	; (80021b0 <chSysUnlock.lto_priv.142+0x30>)
 8002188:	681a      	ldr	r2, [r3, #0]
 800218a:	4b09      	ldr	r3, [pc, #36]	; (80021b0 <chSysUnlock.lto_priv.142+0x30>)
 800218c:	429a      	cmp	r2, r3
 800218e:	d00b      	beq.n	80021a8 <chSysUnlock.lto_priv.142+0x28>
 8002190:	4b07      	ldr	r3, [pc, #28]	; (80021b0 <chSysUnlock.lto_priv.142+0x30>)
 8002192:	699b      	ldr	r3, [r3, #24]
 8002194:	689a      	ldr	r2, [r3, #8]
 8002196:	4b06      	ldr	r3, [pc, #24]	; (80021b0 <chSysUnlock.lto_priv.142+0x30>)
 8002198:	681b      	ldr	r3, [r3, #0]
 800219a:	689b      	ldr	r3, [r3, #8]
 800219c:	429a      	cmp	r2, r3
 800219e:	d203      	bcs.n	80021a8 <chSysUnlock.lto_priv.142+0x28>
 80021a0:	4b04      	ldr	r3, [pc, #16]	; (80021b4 <chSysUnlock.lto_priv.142+0x34>)
 80021a2:	0018      	movs	r0, r3
 80021a4:	f000 fa4c 	bl	8002640 <chSysHalt>
  port_unlock();
 80021a8:	f7ff ffda 	bl	8002160 <port_unlock.lto_priv.164>
}
 80021ac:	bd10      	pop	{r4, pc}
 80021ae:	46c0      	nop			; (mov r8, r8)
 80021b0:	200004d8 	.word	0x200004d8
 80021b4:	08003bd8 	.word	0x08003bd8
	...

080021c0 <chEvtRegisterMaskWithFlags>:
                                eventflags_t wflags) {
 80021c0:	b500      	push	{lr}
 80021c2:	b085      	sub	sp, #20
 80021c4:	9003      	str	r0, [sp, #12]
 80021c6:	9102      	str	r1, [sp, #8]
 80021c8:	9201      	str	r2, [sp, #4]
 80021ca:	9300      	str	r3, [sp, #0]
  chDbgCheck((esp != NULL) && (elp != NULL));
 80021cc:	9b03      	ldr	r3, [sp, #12]
 80021ce:	2b00      	cmp	r3, #0
 80021d0:	d002      	beq.n	80021d8 <chEvtRegisterMaskWithFlags+0x18>
 80021d2:	9b02      	ldr	r3, [sp, #8]
 80021d4:	2b00      	cmp	r3, #0
 80021d6:	d103      	bne.n	80021e0 <chEvtRegisterMaskWithFlags+0x20>
 80021d8:	4b0e      	ldr	r3, [pc, #56]	; (8002214 <chEvtRegisterMaskWithFlags+0x54>)
 80021da:	0018      	movs	r0, r3
 80021dc:	f000 fa30 	bl	8002640 <chSysHalt>
  chSysLock();
 80021e0:	f7ff ffc6 	bl	8002170 <chSysLock.lto_priv.147>
  elp->next     = esp->next;
 80021e4:	9b03      	ldr	r3, [sp, #12]
 80021e6:	681a      	ldr	r2, [r3, #0]
 80021e8:	9b02      	ldr	r3, [sp, #8]
 80021ea:	601a      	str	r2, [r3, #0]
  esp->next     = elp;
 80021ec:	9b03      	ldr	r3, [sp, #12]
 80021ee:	9a02      	ldr	r2, [sp, #8]
 80021f0:	601a      	str	r2, [r3, #0]
  elp->listener = currp;
 80021f2:	4b09      	ldr	r3, [pc, #36]	; (8002218 <chEvtRegisterMaskWithFlags+0x58>)
 80021f4:	699a      	ldr	r2, [r3, #24]
 80021f6:	9b02      	ldr	r3, [sp, #8]
 80021f8:	605a      	str	r2, [r3, #4]
  elp->events   = events;
 80021fa:	9b02      	ldr	r3, [sp, #8]
 80021fc:	9a01      	ldr	r2, [sp, #4]
 80021fe:	609a      	str	r2, [r3, #8]
  elp->flags    = (eventflags_t)0;
 8002200:	9b02      	ldr	r3, [sp, #8]
 8002202:	2200      	movs	r2, #0
 8002204:	60da      	str	r2, [r3, #12]
  elp->wflags   = wflags;
 8002206:	9b02      	ldr	r3, [sp, #8]
 8002208:	9a00      	ldr	r2, [sp, #0]
 800220a:	611a      	str	r2, [r3, #16]
  chSysUnlock();
 800220c:	f7ff ffb8 	bl	8002180 <chSysUnlock.lto_priv.142>
}
 8002210:	b005      	add	sp, #20
 8002212:	bd00      	pop	{pc}
 8002214:	08003bbc 	.word	0x08003bbc
 8002218:	200004d8 	.word	0x200004d8
 800221c:	00000000 	.word	0x00000000

08002220 <__core_init>:

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8002220:	4770      	bx	lr
 8002222:	46c0      	nop			; (mov r8, r8)
	...

08002230 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8002230:	4770      	bx	lr
 8002232:	46c0      	nop			; (mov r8, r8)
	...

08002240 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8002240:	e7fe      	b.n	8002240 <__default_exit>
 8002242:	46c0      	nop			; (mov r8, r8)
	...

08002250 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8002250:	b084      	sub	sp, #16
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8002252:	4b16      	ldr	r3, [pc, #88]	; (80022ac <__init_ram_areas+0x5c>)
 8002254:	9303      	str	r3, [sp, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 8002256:	9b03      	ldr	r3, [sp, #12]
 8002258:	681b      	ldr	r3, [r3, #0]
 800225a:	9302      	str	r3, [sp, #8]
    uint32_t *p = rap->init_area;
 800225c:	9b03      	ldr	r3, [sp, #12]
 800225e:	685b      	ldr	r3, [r3, #4]
 8002260:	9301      	str	r3, [sp, #4]
 8002262:	e009      	b.n	8002278 <__init_ram_areas+0x28>

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
      *p = *tp;
 8002264:	9b02      	ldr	r3, [sp, #8]
 8002266:	681a      	ldr	r2, [r3, #0]
 8002268:	9b01      	ldr	r3, [sp, #4]
 800226a:	601a      	str	r2, [r3, #0]
      p++;
 800226c:	9b01      	ldr	r3, [sp, #4]
 800226e:	3304      	adds	r3, #4
 8002270:	9301      	str	r3, [sp, #4]
      tp++;
 8002272:	9b02      	ldr	r3, [sp, #8]
 8002274:	3304      	adds	r3, #4
 8002276:	9302      	str	r3, [sp, #8]
    while (p < rap->clear_area) {
 8002278:	9b03      	ldr	r3, [sp, #12]
 800227a:	689a      	ldr	r2, [r3, #8]
 800227c:	9b01      	ldr	r3, [sp, #4]
 800227e:	429a      	cmp	r2, r3
 8002280:	d8f0      	bhi.n	8002264 <__init_ram_areas+0x14>
 8002282:	e005      	b.n	8002290 <__init_ram_areas+0x40>
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8002284:	9b01      	ldr	r3, [sp, #4]
 8002286:	2200      	movs	r2, #0
 8002288:	601a      	str	r2, [r3, #0]
      p++;
 800228a:	9b01      	ldr	r3, [sp, #4]
 800228c:	3304      	adds	r3, #4
 800228e:	9301      	str	r3, [sp, #4]
    while (p < rap->no_init_area) {
 8002290:	9b03      	ldr	r3, [sp, #12]
 8002292:	68da      	ldr	r2, [r3, #12]
 8002294:	9b01      	ldr	r3, [sp, #4]
 8002296:	429a      	cmp	r2, r3
 8002298:	d8f4      	bhi.n	8002284 <__init_ram_areas+0x34>
    }
    rap++;
 800229a:	9b03      	ldr	r3, [sp, #12]
 800229c:	3310      	adds	r3, #16
 800229e:	9303      	str	r3, [sp, #12]
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 80022a0:	9a03      	ldr	r2, [sp, #12]
 80022a2:	4b03      	ldr	r3, [pc, #12]	; (80022b0 <__init_ram_areas+0x60>)
 80022a4:	429a      	cmp	r2, r3
 80022a6:	d3d6      	bcc.n	8002256 <__init_ram_areas+0x6>
#endif
}
 80022a8:	b004      	add	sp, #16
 80022aa:	4770      	bx	lr
 80022ac:	080039dc 	.word	0x080039dc
 80022b0:	08003a5c 	.word	0x08003a5c
	...

080022c0 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 80022c0:	e7fe      	b.n	80022c0 <BusFault_Handler>
 80022c2:	46c0      	nop			; (mov r8, r8)
	...

080022d0 <NVIC_SetPriority>:
  \note    The priority cannot be set for every core interrupt.
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 80022d0:	b530      	push	{r4, r5, lr}
 80022d2:	b083      	sub	sp, #12
 80022d4:	0002      	movs	r2, r0
 80022d6:	9100      	str	r1, [sp, #0]
 80022d8:	466b      	mov	r3, sp
 80022da:	3307      	adds	r3, #7
 80022dc:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) < 0)
 80022de:	466b      	mov	r3, sp
 80022e0:	3307      	adds	r3, #7
 80022e2:	781b      	ldrb	r3, [r3, #0]
 80022e4:	2b7f      	cmp	r3, #127	; 0x7f
 80022e6:	d936      	bls.n	8002356 <NVIC_SetPriority+0x86>
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80022e8:	4c32      	ldr	r4, [pc, #200]	; (80023b4 <NVIC_SetPriority+0xe4>)
 80022ea:	466b      	mov	r3, sp
 80022ec:	3307      	adds	r3, #7
 80022ee:	781b      	ldrb	r3, [r3, #0]
 80022f0:	001a      	movs	r2, r3
 80022f2:	230f      	movs	r3, #15
 80022f4:	4013      	ands	r3, r2
 80022f6:	3b08      	subs	r3, #8
 80022f8:	0899      	lsrs	r1, r3, #2
 80022fa:	4a2e      	ldr	r2, [pc, #184]	; (80023b4 <NVIC_SetPriority+0xe4>)
 80022fc:	466b      	mov	r3, sp
 80022fe:	3307      	adds	r3, #7
 8002300:	781b      	ldrb	r3, [r3, #0]
 8002302:	0018      	movs	r0, r3
 8002304:	230f      	movs	r3, #15
 8002306:	4003      	ands	r3, r0
 8002308:	3b08      	subs	r3, #8
 800230a:	089b      	lsrs	r3, r3, #2
 800230c:	3306      	adds	r3, #6
 800230e:	009b      	lsls	r3, r3, #2
 8002310:	18d3      	adds	r3, r2, r3
 8002312:	3304      	adds	r3, #4
 8002314:	681b      	ldr	r3, [r3, #0]
 8002316:	466a      	mov	r2, sp
 8002318:	3207      	adds	r2, #7
 800231a:	7812      	ldrb	r2, [r2, #0]
 800231c:	0010      	movs	r0, r2
 800231e:	2203      	movs	r2, #3
 8002320:	4002      	ands	r2, r0
 8002322:	00d2      	lsls	r2, r2, #3
 8002324:	20ff      	movs	r0, #255	; 0xff
 8002326:	4090      	lsls	r0, r2
 8002328:	0002      	movs	r2, r0
 800232a:	43d2      	mvns	r2, r2
 800232c:	401a      	ands	r2, r3
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 800232e:	9b00      	ldr	r3, [sp, #0]
 8002330:	019b      	lsls	r3, r3, #6
 8002332:	20ff      	movs	r0, #255	; 0xff
 8002334:	4018      	ands	r0, r3
 8002336:	466b      	mov	r3, sp
 8002338:	3307      	adds	r3, #7
 800233a:	781b      	ldrb	r3, [r3, #0]
 800233c:	001d      	movs	r5, r3
 800233e:	2303      	movs	r3, #3
 8002340:	402b      	ands	r3, r5
 8002342:	00db      	lsls	r3, r3, #3
 8002344:	4098      	lsls	r0, r3
 8002346:	0003      	movs	r3, r0
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8002348:	431a      	orrs	r2, r3
 800234a:	1d8b      	adds	r3, r1, #6
 800234c:	009b      	lsls	r3, r3, #2
 800234e:	18e3      	adds	r3, r4, r3
 8002350:	3304      	adds	r3, #4
 8002352:	601a      	str	r2, [r3, #0]
 8002354:	e02b      	b.n	80023ae <NVIC_SetPriority+0xde>
  }
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8002356:	4c18      	ldr	r4, [pc, #96]	; (80023b8 <NVIC_SetPriority+0xe8>)
 8002358:	466b      	mov	r3, sp
 800235a:	3307      	adds	r3, #7
 800235c:	781b      	ldrb	r3, [r3, #0]
 800235e:	b25b      	sxtb	r3, r3
 8002360:	089b      	lsrs	r3, r3, #2
 8002362:	4915      	ldr	r1, [pc, #84]	; (80023b8 <NVIC_SetPriority+0xe8>)
 8002364:	466a      	mov	r2, sp
 8002366:	3207      	adds	r2, #7
 8002368:	7812      	ldrb	r2, [r2, #0]
 800236a:	b252      	sxtb	r2, r2
 800236c:	0892      	lsrs	r2, r2, #2
 800236e:	32c0      	adds	r2, #192	; 0xc0
 8002370:	0092      	lsls	r2, r2, #2
 8002372:	5852      	ldr	r2, [r2, r1]
 8002374:	4669      	mov	r1, sp
 8002376:	3107      	adds	r1, #7
 8002378:	7809      	ldrb	r1, [r1, #0]
 800237a:	0008      	movs	r0, r1
 800237c:	2103      	movs	r1, #3
 800237e:	4001      	ands	r1, r0
 8002380:	00c9      	lsls	r1, r1, #3
 8002382:	20ff      	movs	r0, #255	; 0xff
 8002384:	4088      	lsls	r0, r1
 8002386:	0001      	movs	r1, r0
 8002388:	43c9      	mvns	r1, r1
 800238a:	4011      	ands	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 800238c:	9a00      	ldr	r2, [sp, #0]
 800238e:	0192      	lsls	r2, r2, #6
 8002390:	20ff      	movs	r0, #255	; 0xff
 8002392:	4010      	ands	r0, r2
 8002394:	466a      	mov	r2, sp
 8002396:	3207      	adds	r2, #7
 8002398:	7812      	ldrb	r2, [r2, #0]
 800239a:	0015      	movs	r5, r2
 800239c:	2203      	movs	r2, #3
 800239e:	402a      	ands	r2, r5
 80023a0:	00d2      	lsls	r2, r2, #3
 80023a2:	4090      	lsls	r0, r2
 80023a4:	0002      	movs	r2, r0
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80023a6:	430a      	orrs	r2, r1
 80023a8:	33c0      	adds	r3, #192	; 0xc0
 80023aa:	009b      	lsls	r3, r3, #2
 80023ac:	511a      	str	r2, [r3, r4]
  }
}
 80023ae:	b003      	add	sp, #12
 80023b0:	bd30      	pop	{r4, r5, pc}
 80023b2:	46c0      	nop			; (mov r8, r8)
 80023b4:	e000ed00 	.word	0xe000ed00
 80023b8:	e000e100 	.word	0xe000e100
 80023bc:	00000000 	.word	0x00000000

080023c0 <port_init>:
static inline void port_init(void) {
 80023c0:	b510      	push	{r4, lr}
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 80023c2:	2302      	movs	r3, #2
 80023c4:	425b      	negs	r3, r3
 80023c6:	2100      	movs	r1, #0
 80023c8:	0018      	movs	r0, r3
 80023ca:	f7ff ff81 	bl	80022d0 <NVIC_SetPriority>
}
 80023ce:	bd10      	pop	{r4, pc}

080023d0 <port_lock.lto_priv.236>:
  __ASM volatile ("cpsid i" : : : "memory");
 80023d0:	b672      	cpsid	i
}
 80023d2:	4770      	bx	lr
	...

080023e0 <port_unlock.lto_priv.231>:
  __ASM volatile ("cpsie i" : : : "memory");
 80023e0:	b662      	cpsie	i
}
 80023e2:	4770      	bx	lr
	...

080023f0 <port_lock_from_isr.lto_priv.252>:
static inline void port_lock_from_isr(void) {
 80023f0:	b510      	push	{r4, lr}
  port_lock();
 80023f2:	f7ff ffed 	bl	80023d0 <port_lock.lto_priv.236>
}
 80023f6:	bd10      	pop	{r4, pc}
	...

08002400 <port_unlock_from_isr.lto_priv.248>:
static inline void port_unlock_from_isr(void) {
 8002400:	b510      	push	{r4, lr}
  port_unlock();
 8002402:	f7ff ffed 	bl	80023e0 <port_unlock.lto_priv.231>
}
 8002406:	bd10      	pop	{r4, pc}
	...

08002410 <port_disable>:
  __ASM volatile ("cpsid i" : : : "memory");
 8002410:	b672      	cpsid	i
 * @brief   Disables all the interrupt sources.
 */
static inline void port_disable(void) {

  __disable_irq();
}
 8002412:	4770      	bx	lr
	...

08002420 <port_enable>:
  __ASM volatile ("cpsie i" : : : "memory");
 8002420:	b662      	cpsie	i
 * @brief   Enables all the interrupt sources.
 */
static inline void port_enable(void) {

  __enable_irq();
}
 8002422:	4770      	bx	lr
	...

08002430 <port_wait_for_interrupt>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 8002430:	4770      	bx	lr
 8002432:	46c0      	nop			; (mov r8, r8)
	...

08002440 <st_lld_get_counter.lto_priv.227>:
  return (systime_t)STM32_ST_TIM->CNT;
 8002440:	2380      	movs	r3, #128	; 0x80
 8002442:	05db      	lsls	r3, r3, #23
 8002444:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8002446:	0018      	movs	r0, r3
 8002448:	4770      	bx	lr
 800244a:	46c0      	nop			; (mov r8, r8)
 800244c:	0000      	movs	r0, r0
	...

08002450 <port_timer_stop_alarm.lto_priv.258>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 8002450:	b510      	push	{r4, lr}

  stStopAlarm();
 8002452:	f7fe fe05 	bl	8001060 <stStopAlarm>
}
 8002456:	bd10      	pop	{r4, pc}
	...

08002460 <port_timer_set_alarm.lto_priv.256>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 8002460:	b500      	push	{lr}
 8002462:	b083      	sub	sp, #12
 8002464:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
 8002466:	9b01      	ldr	r3, [sp, #4]
 8002468:	0018      	movs	r0, r3
 800246a:	f7fe fe01 	bl	8001070 <stSetAlarm>
}
 800246e:	b003      	add	sp, #12
 8002470:	bd00      	pop	{pc}
 8002472:	46c0      	nop			; (mov r8, r8)
	...

08002480 <port_timer_get_time.lto_priv.223>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8002480:	b510      	push	{r4, lr}

  return stGetCounter();
 8002482:	f7ff ffdd 	bl	8002440 <st_lld_get_counter.lto_priv.227>
 8002486:	0003      	movs	r3, r0
}
 8002488:	0018      	movs	r0, r3
 800248a:	bd10      	pop	{r4, pc}
 800248c:	0000      	movs	r0, r0
	...

08002490 <chSysEnable>:
static inline void chSysEnable(void) {
 8002490:	b510      	push	{r4, lr}
  _dbg_check_enable();
 8002492:	f000 f90d 	bl	80026b0 <_dbg_check_enable>
  port_enable();
 8002496:	f7ff ffc3 	bl	8002420 <port_enable>
}
 800249a:	bd10      	pop	{r4, pc}
 800249c:	0000      	movs	r0, r0
	...

080024a0 <chSysLockFromISR.lto_priv.246>:
static inline void chSysLockFromISR(void) {
 80024a0:	b510      	push	{r4, lr}
  port_lock_from_isr();
 80024a2:	f7ff ffa5 	bl	80023f0 <port_lock_from_isr.lto_priv.252>
  _dbg_check_lock_from_isr();
 80024a6:	f000 f94b 	bl	8002740 <_dbg_check_lock_from_isr>
}
 80024aa:	bd10      	pop	{r4, pc}
 80024ac:	0000      	movs	r0, r0
	...

080024b0 <chSysUnlockFromISR.lto_priv.244>:
static inline void chSysUnlockFromISR(void) {
 80024b0:	b510      	push	{r4, lr}
  _dbg_check_unlock_from_isr();
 80024b2:	f000 f95d 	bl	8002770 <_dbg_check_unlock_from_isr>
  port_unlock_from_isr();
 80024b6:	f7ff ffa3 	bl	8002400 <port_unlock_from_isr.lto_priv.248>
}
 80024ba:	bd10      	pop	{r4, pc}
 80024bc:	0000      	movs	r0, r0
	...

080024c0 <chVTGetSystemTimeX.lto_priv.215>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 80024c0:	b510      	push	{r4, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 80024c2:	f7ff ffdd 	bl	8002480 <port_timer_get_time.lto_priv.223>
 80024c6:	0003      	movs	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80024c8:	0018      	movs	r0, r3
 80024ca:	bd10      	pop	{r4, pc}
 80024cc:	0000      	movs	r0, r0
	...

080024d0 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
 80024d0:	b500      	push	{lr}
 80024d2:	b085      	sub	sp, #20

  chDbgCheckClassI();
 80024d4:	f000 f9a4 	bl	8002820 <chDbgCheckClassI>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.next;
 80024d8:	4b33      	ldr	r3, [pc, #204]	; (80025a8 <chVTDoTickI+0xd8>)
 80024da:	69db      	ldr	r3, [r3, #28]
 80024dc:	9303      	str	r3, [sp, #12]
  now = chVTGetSystemTimeX();
 80024de:	f7ff ffef 	bl	80024c0 <chVTGetSystemTimeX.lto_priv.215>
 80024e2:	0003      	movs	r3, r0
 80024e4:	9302      	str	r3, [sp, #8]
 80024e6:	e02b      	b.n	8002540 <chVTDoTickI+0x70>
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;
 80024e8:	4b2f      	ldr	r3, [pc, #188]	; (80025a8 <chVTDoTickI+0xd8>)
 80024ea:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80024ec:	9b03      	ldr	r3, [sp, #12]
 80024ee:	689b      	ldr	r3, [r3, #8]
 80024f0:	18d2      	adds	r2, r2, r3
 80024f2:	4b2d      	ldr	r3, [pc, #180]	; (80025a8 <chVTDoTickI+0xd8>)
 80024f4:	629a      	str	r2, [r3, #40]	; 0x28

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 80024f6:	9b03      	ldr	r3, [sp, #12]
 80024f8:	681b      	ldr	r3, [r3, #0]
 80024fa:	4a2c      	ldr	r2, [pc, #176]	; (80025ac <chVTDoTickI+0xdc>)
 80024fc:	605a      	str	r2, [r3, #4]
    ch.vtlist.next = vtp->next;
 80024fe:	9b03      	ldr	r3, [sp, #12]
 8002500:	681a      	ldr	r2, [r3, #0]
 8002502:	4b29      	ldr	r3, [pc, #164]	; (80025a8 <chVTDoTickI+0xd8>)
 8002504:	61da      	str	r2, [r3, #28]
    fn = vtp->func;
 8002506:	9b03      	ldr	r3, [sp, #12]
 8002508:	68db      	ldr	r3, [r3, #12]
 800250a:	9300      	str	r3, [sp, #0]
    vtp->func = NULL;
 800250c:	9b03      	ldr	r3, [sp, #12]
 800250e:	2200      	movs	r2, #0
 8002510:	60da      	str	r2, [r3, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8002512:	4b25      	ldr	r3, [pc, #148]	; (80025a8 <chVTDoTickI+0xd8>)
 8002514:	69da      	ldr	r2, [r3, #28]
 8002516:	4b25      	ldr	r3, [pc, #148]	; (80025ac <chVTDoTickI+0xdc>)
 8002518:	429a      	cmp	r2, r3
 800251a:	d101      	bne.n	8002520 <chVTDoTickI+0x50>
      port_timer_stop_alarm();
 800251c:	f7ff ff98 	bl	8002450 <port_timer_stop_alarm.lto_priv.258>
    }

    /* Leaving the system critical zone in order to execute the callback
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();
 8002520:	f7ff ffc6 	bl	80024b0 <chSysUnlockFromISR.lto_priv.244>

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->par);
 8002524:	9b03      	ldr	r3, [sp, #12]
 8002526:	691a      	ldr	r2, [r3, #16]
 8002528:	9b00      	ldr	r3, [sp, #0]
 800252a:	0010      	movs	r0, r2
 800252c:	4798      	blx	r3

    /* Re-entering the critical zone in order to continue the exploration
       of the list.*/
    chSysLockFromISR();
 800252e:	f7ff ffb7 	bl	80024a0 <chSysLockFromISR.lto_priv.246>

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.next;
 8002532:	4b1d      	ldr	r3, [pc, #116]	; (80025a8 <chVTDoTickI+0xd8>)
 8002534:	69db      	ldr	r3, [r3, #28]
 8002536:	9303      	str	r3, [sp, #12]
    now = chVTGetSystemTimeX();
 8002538:	f7ff ffc2 	bl	80024c0 <chVTGetSystemTimeX.lto_priv.215>
 800253c:	0003      	movs	r3, r0
 800253e:	9302      	str	r3, [sp, #8]
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8002540:	9b03      	ldr	r3, [sp, #12]
 8002542:	689a      	ldr	r2, [r3, #8]
 8002544:	4b18      	ldr	r3, [pc, #96]	; (80025a8 <chVTDoTickI+0xd8>)
 8002546:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002548:	9902      	ldr	r1, [sp, #8]
 800254a:	1acb      	subs	r3, r1, r3
 800254c:	429a      	cmp	r2, r3
 800254e:	d9cb      	bls.n	80024e8 <chVTDoTickI+0x18>
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8002550:	4b15      	ldr	r3, [pc, #84]	; (80025a8 <chVTDoTickI+0xd8>)
 8002552:	69da      	ldr	r2, [r3, #28]
 8002554:	4b15      	ldr	r3, [pc, #84]	; (80025ac <chVTDoTickI+0xdc>)
 8002556:	429a      	cmp	r2, r3
 8002558:	d024      	beq.n	80025a4 <chVTDoTickI+0xd4>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.lasttime + vtp->delta - now;
 800255a:	4b13      	ldr	r3, [pc, #76]	; (80025a8 <chVTDoTickI+0xd8>)
 800255c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800255e:	9b03      	ldr	r3, [sp, #12]
 8002560:	689b      	ldr	r3, [r3, #8]
 8002562:	18d2      	adds	r2, r2, r3
 8002564:	9b02      	ldr	r3, [sp, #8]
 8002566:	1ad3      	subs	r3, r2, r3
 8002568:	9301      	str	r3, [sp, #4]
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 800256a:	9b01      	ldr	r3, [sp, #4]
 800256c:	2b01      	cmp	r3, #1
 800256e:	d801      	bhi.n	8002574 <chVTDoTickI+0xa4>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8002570:	2302      	movs	r3, #2
 8002572:	9301      	str	r3, [sp, #4]
  }
  port_timer_set_alarm(now + delta);
 8002574:	9a02      	ldr	r2, [sp, #8]
 8002576:	9b01      	ldr	r3, [sp, #4]
 8002578:	18d3      	adds	r3, r2, r3
 800257a:	0018      	movs	r0, r3
 800257c:	f7ff ff70 	bl	8002460 <port_timer_set_alarm.lto_priv.256>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.lasttime) <=
 8002580:	f7ff ff9e 	bl	80024c0 <chVTGetSystemTimeX.lto_priv.215>
 8002584:	0002      	movs	r2, r0
 8002586:	4b08      	ldr	r3, [pc, #32]	; (80025a8 <chVTDoTickI+0xd8>)
 8002588:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800258a:	1ad2      	subs	r2, r2, r3
 800258c:	9902      	ldr	r1, [sp, #8]
 800258e:	9b01      	ldr	r3, [sp, #4]
 8002590:	18c9      	adds	r1, r1, r3
 8002592:	4b05      	ldr	r3, [pc, #20]	; (80025a8 <chVTDoTickI+0xd8>)
 8002594:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002596:	1acb      	subs	r3, r1, r3
 8002598:	429a      	cmp	r2, r3
 800259a:	d903      	bls.n	80025a4 <chVTDoTickI+0xd4>
 800259c:	4b04      	ldr	r3, [pc, #16]	; (80025b0 <chVTDoTickI+0xe0>)
 800259e:	0018      	movs	r0, r3
 80025a0:	f000 f84e 	bl	8002640 <chSysHalt>
              (now + delta - ch.vtlist.lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80025a4:	b005      	add	sp, #20
 80025a6:	bd00      	pop	{pc}
 80025a8:	200004d8 	.word	0x200004d8
 80025ac:	200004f4 	.word	0x200004f4
 80025b0:	08003a7c 	.word	0x08003a7c
	...

080025c0 <_idle_thread.lto_priv.57>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 80025c0:	b500      	push	{lr}
 80025c2:	b083      	sub	sp, #12
 80025c4:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 80025c6:	f7ff ff33 	bl	8002430 <port_wait_for_interrupt>
 80025ca:	e7fc      	b.n	80025c6 <_idle_thread.lto_priv.57+0x6>
 80025cc:	0000      	movs	r0, r0
	...

080025d0 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 80025d0:	b510      	push	{r4, lr}

  _scheduler_init();
 80025d2:	f000 fca5 	bl	8002f20 <_scheduler_init>
  _vt_init();
 80025d6:	f000 facb 	bl	8002b70 <_vt_init>
  _trace_init();
 80025da:	f000 f9b1 	bl	8002940 <_trace_init>

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  ch.dbg.isr_cnt  = (cnt_t)0;
 80025de:	4b12      	ldr	r3, [pc, #72]	; (8002628 <chSysInit+0x58>)
 80025e0:	2200      	movs	r2, #0
 80025e2:	631a      	str	r2, [r3, #48]	; 0x30
  ch.dbg.lock_cnt = (cnt_t)0;
 80025e4:	4b10      	ldr	r3, [pc, #64]	; (8002628 <chSysInit+0x58>)
 80025e6:	2200      	movs	r2, #0
 80025e8:	635a      	str	r2, [r3, #52]	; 0x34
#endif
#if CH_CFG_USE_TM == TRUE
  _tm_init();
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 80025ea:	f7ff f9b1 	bl	8001950 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 80025ee:	f7ff fa17 	bl	8001a20 <_heap_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 80025f2:	490e      	ldr	r1, [pc, #56]	; (800262c <chSysInit+0x5c>)
 80025f4:	4b0e      	ldr	r3, [pc, #56]	; (8002630 <chSysInit+0x60>)
 80025f6:	2280      	movs	r2, #128	; 0x80
 80025f8:	0018      	movs	r0, r3
 80025fa:	f000 ffe1 	bl	80035c0 <_thread_init>
 80025fe:	0002      	movs	r2, r0
 8002600:	4b09      	ldr	r3, [pc, #36]	; (8002628 <chSysInit+0x58>)
 8002602:	619a      	str	r2, [r3, #24]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  {
    /* Setting up the base address of the static main thread stack, the
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
 8002604:	4b08      	ldr	r3, [pc, #32]	; (8002628 <chSysInit+0x58>)
 8002606:	699b      	ldr	r3, [r3, #24]
 8002608:	4a0a      	ldr	r2, [pc, #40]	; (8002634 <chSysInit+0x64>)
 800260a:	61da      	str	r2, [r3, #28]
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 800260c:	4b06      	ldr	r3, [pc, #24]	; (8002628 <chSysInit+0x58>)
 800260e:	699b      	ldr	r3, [r3, #24]
 8002610:	2220      	movs	r2, #32
 8002612:	2101      	movs	r1, #1
 8002614:	5499      	strb	r1, [r3, r2]

  /* Port layer initialization last because it depend on some of the
     initializations performed before.*/
  port_init();
 8002616:	f7ff fed3 	bl	80023c0 <port_init>
  /* Starting measurement for this thread.*/
  chTMStartMeasurementX(&currp->stats);
#endif

  /* It is alive now.*/
  chSysEnable();
 800261a:	f7ff ff39 	bl	8002490 <chSysEnable>
    };

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreate(&idle_descriptor);
 800261e:	4b06      	ldr	r3, [pc, #24]	; (8002638 <chSysInit+0x68>)
 8002620:	0018      	movs	r0, r3
 8002622:	f001 f88d 	bl	8003740 <chThdCreate>
  }
#endif
}
 8002626:	bd10      	pop	{r4, pc}
 8002628:	200004d8 	.word	0x200004d8
 800262c:	08003b54 	.word	0x08003b54
 8002630:	20000d18 	.word	0x20000d18
 8002634:	20000200 	.word	0x20000200
 8002638:	08003a64 	.word	0x08003a64
 800263c:	00000000 	.word	0x00000000

08002640 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 8002640:	b500      	push	{lr}
 8002642:	b083      	sub	sp, #12
 8002644:	9001      	str	r0, [sp, #4]

  port_disable();
 8002646:	f7ff fee3 	bl	8002410 <port_disable>

  /* Logging the event.*/
  _trace_halt(reason);
 800264a:	9b01      	ldr	r3, [sp, #4]
 800264c:	0018      	movs	r0, r3
 800264e:	f000 fa27 	bl	8002aa0 <_trace_halt>

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8002652:	4b02      	ldr	r3, [pc, #8]	; (800265c <chSysHalt+0x1c>)
 8002654:	9a01      	ldr	r2, [sp, #4]
 8002656:	62da      	str	r2, [r3, #44]	; 0x2c
 8002658:	e7fe      	b.n	8002658 <chSysHalt+0x18>
 800265a:	46c0      	nop			; (mov r8, r8)
 800265c:	200004d8 	.word	0x200004d8

08002660 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8002660:	b510      	push	{r4, lr}

  chDbgCheckClassI();
 8002662:	f000 f8dd 	bl	8002820 <chDbgCheckClassI>
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->time++;
#endif
  chVTDoTickI();
 8002666:	f7ff ff33 	bl	80024d0 <chVTDoTickI>
  CH_CFG_SYSTEM_TICK_HOOK();
}
 800266a:	bd10      	pop	{r4, pc}
 800266c:	0000      	movs	r0, r0
	...

08002670 <port_lock.lto_priv.237>:
  __ASM volatile ("cpsid i" : : : "memory");
 8002670:	b672      	cpsid	i
}
 8002672:	4770      	bx	lr
	...

08002680 <port_unlock.lto_priv.232>:
  __ASM volatile ("cpsie i" : : : "memory");
 8002680:	b662      	cpsie	i
}
 8002682:	4770      	bx	lr
	...

08002690 <port_lock_from_isr.lto_priv.253>:
static inline void port_lock_from_isr(void) {
 8002690:	b510      	push	{r4, lr}
  port_lock();
 8002692:	f7ff ffed 	bl	8002670 <port_lock.lto_priv.237>
}
 8002696:	bd10      	pop	{r4, pc}
	...

080026a0 <port_unlock_from_isr.lto_priv.249>:
static inline void port_unlock_from_isr(void) {
 80026a0:	b510      	push	{r4, lr}
  port_unlock();
 80026a2:	f7ff ffed 	bl	8002680 <port_unlock.lto_priv.232>
}
 80026a6:	bd10      	pop	{r4, pc}
	...

080026b0 <_dbg_check_enable>:
/**
 * @brief   Guard code for @p chSysEnable().
 *
 * @notapi
 */
void _dbg_check_enable(void) {
 80026b0:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80026b2:	4b06      	ldr	r3, [pc, #24]	; (80026cc <_dbg_check_enable+0x1c>)
 80026b4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80026b6:	2b00      	cmp	r3, #0
 80026b8:	d103      	bne.n	80026c2 <_dbg_check_enable+0x12>
 80026ba:	4b04      	ldr	r3, [pc, #16]	; (80026cc <_dbg_check_enable+0x1c>)
 80026bc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80026be:	2b00      	cmp	r3, #0
 80026c0:	d003      	beq.n	80026ca <_dbg_check_enable+0x1a>
    chSysHalt("SV#3");
 80026c2:	4b03      	ldr	r3, [pc, #12]	; (80026d0 <_dbg_check_enable+0x20>)
 80026c4:	0018      	movs	r0, r3
 80026c6:	f7ff ffbb 	bl	8002640 <chSysHalt>
  }
}
 80026ca:	bd10      	pop	{r4, pc}
 80026cc:	200004d8 	.word	0x200004d8
 80026d0:	08003d60 	.word	0x08003d60
	...

080026e0 <_dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void _dbg_check_lock(void) {
 80026e0:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80026e2:	4b08      	ldr	r3, [pc, #32]	; (8002704 <_dbg_check_lock+0x24>)
 80026e4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80026e6:	2b00      	cmp	r3, #0
 80026e8:	d103      	bne.n	80026f2 <_dbg_check_lock+0x12>
 80026ea:	4b06      	ldr	r3, [pc, #24]	; (8002704 <_dbg_check_lock+0x24>)
 80026ec:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80026ee:	2b00      	cmp	r3, #0
 80026f0:	d003      	beq.n	80026fa <_dbg_check_lock+0x1a>
    chSysHalt("SV#4");
 80026f2:	4b05      	ldr	r3, [pc, #20]	; (8002708 <_dbg_check_lock+0x28>)
 80026f4:	0018      	movs	r0, r3
 80026f6:	f7ff ffa3 	bl	8002640 <chSysHalt>
  }
  _dbg_enter_lock();
 80026fa:	4b02      	ldr	r3, [pc, #8]	; (8002704 <_dbg_check_lock+0x24>)
 80026fc:	2201      	movs	r2, #1
 80026fe:	635a      	str	r2, [r3, #52]	; 0x34
}
 8002700:	bd10      	pop	{r4, pc}
 8002702:	46c0      	nop			; (mov r8, r8)
 8002704:	200004d8 	.word	0x200004d8
 8002708:	08003d68 	.word	0x08003d68
 800270c:	00000000 	.word	0x00000000

08002710 <_dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void _dbg_check_unlock(void) {
 8002710:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002712:	4b08      	ldr	r3, [pc, #32]	; (8002734 <_dbg_check_unlock+0x24>)
 8002714:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002716:	2b00      	cmp	r3, #0
 8002718:	d103      	bne.n	8002722 <_dbg_check_unlock+0x12>
 800271a:	4b06      	ldr	r3, [pc, #24]	; (8002734 <_dbg_check_unlock+0x24>)
 800271c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800271e:	2b00      	cmp	r3, #0
 8002720:	dc03      	bgt.n	800272a <_dbg_check_unlock+0x1a>
    chSysHalt("SV#5");
 8002722:	4b05      	ldr	r3, [pc, #20]	; (8002738 <_dbg_check_unlock+0x28>)
 8002724:	0018      	movs	r0, r3
 8002726:	f7ff ff8b 	bl	8002640 <chSysHalt>
  }
  _dbg_leave_lock();
 800272a:	4b02      	ldr	r3, [pc, #8]	; (8002734 <_dbg_check_unlock+0x24>)
 800272c:	2200      	movs	r2, #0
 800272e:	635a      	str	r2, [r3, #52]	; 0x34
}
 8002730:	bd10      	pop	{r4, pc}
 8002732:	46c0      	nop			; (mov r8, r8)
 8002734:	200004d8 	.word	0x200004d8
 8002738:	08003d70 	.word	0x08003d70
 800273c:	00000000 	.word	0x00000000

08002740 <_dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {
 8002740:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002742:	4b08      	ldr	r3, [pc, #32]	; (8002764 <_dbg_check_lock_from_isr+0x24>)
 8002744:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002746:	2b00      	cmp	r3, #0
 8002748:	dd03      	ble.n	8002752 <_dbg_check_lock_from_isr+0x12>
 800274a:	4b06      	ldr	r3, [pc, #24]	; (8002764 <_dbg_check_lock_from_isr+0x24>)
 800274c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800274e:	2b00      	cmp	r3, #0
 8002750:	d003      	beq.n	800275a <_dbg_check_lock_from_isr+0x1a>
    chSysHalt("SV#6");
 8002752:	4b05      	ldr	r3, [pc, #20]	; (8002768 <_dbg_check_lock_from_isr+0x28>)
 8002754:	0018      	movs	r0, r3
 8002756:	f7ff ff73 	bl	8002640 <chSysHalt>
  }
  _dbg_enter_lock();
 800275a:	4b02      	ldr	r3, [pc, #8]	; (8002764 <_dbg_check_lock_from_isr+0x24>)
 800275c:	2201      	movs	r2, #1
 800275e:	635a      	str	r2, [r3, #52]	; 0x34
}
 8002760:	bd10      	pop	{r4, pc}
 8002762:	46c0      	nop			; (mov r8, r8)
 8002764:	200004d8 	.word	0x200004d8
 8002768:	08003d78 	.word	0x08003d78
 800276c:	00000000 	.word	0x00000000

08002770 <_dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {
 8002770:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002772:	4b08      	ldr	r3, [pc, #32]	; (8002794 <_dbg_check_unlock_from_isr+0x24>)
 8002774:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002776:	2b00      	cmp	r3, #0
 8002778:	dd03      	ble.n	8002782 <_dbg_check_unlock_from_isr+0x12>
 800277a:	4b06      	ldr	r3, [pc, #24]	; (8002794 <_dbg_check_unlock_from_isr+0x24>)
 800277c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800277e:	2b00      	cmp	r3, #0
 8002780:	dc03      	bgt.n	800278a <_dbg_check_unlock_from_isr+0x1a>
    chSysHalt("SV#7");
 8002782:	4b05      	ldr	r3, [pc, #20]	; (8002798 <_dbg_check_unlock_from_isr+0x28>)
 8002784:	0018      	movs	r0, r3
 8002786:	f7ff ff5b 	bl	8002640 <chSysHalt>
  }
  _dbg_leave_lock();
 800278a:	4b02      	ldr	r3, [pc, #8]	; (8002794 <_dbg_check_unlock_from_isr+0x24>)
 800278c:	2200      	movs	r2, #0
 800278e:	635a      	str	r2, [r3, #52]	; 0x34
}
 8002790:	bd10      	pop	{r4, pc}
 8002792:	46c0      	nop			; (mov r8, r8)
 8002794:	200004d8 	.word	0x200004d8
 8002798:	08003d80 	.word	0x08003d80
 800279c:	00000000 	.word	0x00000000

080027a0 <_dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {
 80027a0:	b510      	push	{r4, lr}

  port_lock_from_isr();
 80027a2:	f7ff ff75 	bl	8002690 <port_lock_from_isr.lto_priv.253>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80027a6:	4b0a      	ldr	r3, [pc, #40]	; (80027d0 <_dbg_check_enter_isr+0x30>)
 80027a8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80027aa:	2b00      	cmp	r3, #0
 80027ac:	db03      	blt.n	80027b6 <_dbg_check_enter_isr+0x16>
 80027ae:	4b08      	ldr	r3, [pc, #32]	; (80027d0 <_dbg_check_enter_isr+0x30>)
 80027b0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80027b2:	2b00      	cmp	r3, #0
 80027b4:	d003      	beq.n	80027be <_dbg_check_enter_isr+0x1e>
    chSysHalt("SV#8");
 80027b6:	4b07      	ldr	r3, [pc, #28]	; (80027d4 <_dbg_check_enter_isr+0x34>)
 80027b8:	0018      	movs	r0, r3
 80027ba:	f7ff ff41 	bl	8002640 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
 80027be:	4b04      	ldr	r3, [pc, #16]	; (80027d0 <_dbg_check_enter_isr+0x30>)
 80027c0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80027c2:	1c5a      	adds	r2, r3, #1
 80027c4:	4b02      	ldr	r3, [pc, #8]	; (80027d0 <_dbg_check_enter_isr+0x30>)
 80027c6:	631a      	str	r2, [r3, #48]	; 0x30
  port_unlock_from_isr();
 80027c8:	f7ff ff6a 	bl	80026a0 <port_unlock_from_isr.lto_priv.249>
}
 80027cc:	bd10      	pop	{r4, pc}
 80027ce:	46c0      	nop			; (mov r8, r8)
 80027d0:	200004d8 	.word	0x200004d8
 80027d4:	08003d88 	.word	0x08003d88
	...

080027e0 <_dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {
 80027e0:	b510      	push	{r4, lr}

  port_lock_from_isr();
 80027e2:	f7ff ff55 	bl	8002690 <port_lock_from_isr.lto_priv.253>
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80027e6:	4b0a      	ldr	r3, [pc, #40]	; (8002810 <_dbg_check_leave_isr+0x30>)
 80027e8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80027ea:	2b00      	cmp	r3, #0
 80027ec:	dd03      	ble.n	80027f6 <_dbg_check_leave_isr+0x16>
 80027ee:	4b08      	ldr	r3, [pc, #32]	; (8002810 <_dbg_check_leave_isr+0x30>)
 80027f0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80027f2:	2b00      	cmp	r3, #0
 80027f4:	d003      	beq.n	80027fe <_dbg_check_leave_isr+0x1e>
    chSysHalt("SV#9");
 80027f6:	4b07      	ldr	r3, [pc, #28]	; (8002814 <_dbg_check_leave_isr+0x34>)
 80027f8:	0018      	movs	r0, r3
 80027fa:	f7ff ff21 	bl	8002640 <chSysHalt>
  }
  ch.dbg.isr_cnt--;
 80027fe:	4b04      	ldr	r3, [pc, #16]	; (8002810 <_dbg_check_leave_isr+0x30>)
 8002800:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002802:	1e5a      	subs	r2, r3, #1
 8002804:	4b02      	ldr	r3, [pc, #8]	; (8002810 <_dbg_check_leave_isr+0x30>)
 8002806:	631a      	str	r2, [r3, #48]	; 0x30
  port_unlock_from_isr();
 8002808:	f7ff ff4a 	bl	80026a0 <port_unlock_from_isr.lto_priv.249>
}
 800280c:	bd10      	pop	{r4, pc}
 800280e:	46c0      	nop			; (mov r8, r8)
 8002810:	200004d8 	.word	0x200004d8
 8002814:	08003d90 	.word	0x08003d90
	...

08002820 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
 8002820:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002822:	4b06      	ldr	r3, [pc, #24]	; (800283c <chDbgCheckClassI+0x1c>)
 8002824:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002826:	2b00      	cmp	r3, #0
 8002828:	db03      	blt.n	8002832 <chDbgCheckClassI+0x12>
 800282a:	4b04      	ldr	r3, [pc, #16]	; (800283c <chDbgCheckClassI+0x1c>)
 800282c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800282e:	2b00      	cmp	r3, #0
 8002830:	dc03      	bgt.n	800283a <chDbgCheckClassI+0x1a>
    chSysHalt("SV#10");
 8002832:	4b03      	ldr	r3, [pc, #12]	; (8002840 <chDbgCheckClassI+0x20>)
 8002834:	0018      	movs	r0, r3
 8002836:	f7ff ff03 	bl	8002640 <chSysHalt>
  }
}
 800283a:	bd10      	pop	{r4, pc}
 800283c:	200004d8 	.word	0x200004d8
 8002840:	08003d98 	.word	0x08003d98
	...

08002850 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 8002850:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002852:	4b06      	ldr	r3, [pc, #24]	; (800286c <chDbgCheckClassS+0x1c>)
 8002854:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002856:	2b00      	cmp	r3, #0
 8002858:	d103      	bne.n	8002862 <chDbgCheckClassS+0x12>
 800285a:	4b04      	ldr	r3, [pc, #16]	; (800286c <chDbgCheckClassS+0x1c>)
 800285c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800285e:	2b00      	cmp	r3, #0
 8002860:	dc03      	bgt.n	800286a <chDbgCheckClassS+0x1a>
    chSysHalt("SV#11");
 8002862:	4b03      	ldr	r3, [pc, #12]	; (8002870 <chDbgCheckClassS+0x20>)
 8002864:	0018      	movs	r0, r3
 8002866:	f7ff feeb 	bl	8002640 <chSysHalt>
  }
}
 800286a:	bd10      	pop	{r4, pc}
 800286c:	200004d8 	.word	0x200004d8
 8002870:	08003da0 	.word	0x08003da0
	...

08002880 <port_lock.lto_priv.238>:
  __ASM volatile ("cpsid i" : : : "memory");
 8002880:	b672      	cpsid	i
}
 8002882:	4770      	bx	lr
	...

08002890 <port_unlock.lto_priv.233>:
  __ASM volatile ("cpsie i" : : : "memory");
 8002890:	b662      	cpsie	i
}
 8002892:	4770      	bx	lr
	...

080028a0 <port_lock_from_isr.lto_priv.254>:
static inline void port_lock_from_isr(void) {
 80028a0:	b510      	push	{r4, lr}
  port_lock();
 80028a2:	f7ff ffed 	bl	8002880 <port_lock.lto_priv.238>
}
 80028a6:	bd10      	pop	{r4, pc}
	...

080028b0 <port_unlock_from_isr.lto_priv.250>:
static inline void port_unlock_from_isr(void) {
 80028b0:	b510      	push	{r4, lr}
  port_unlock();
 80028b2:	f7ff ffed 	bl	8002890 <port_unlock.lto_priv.233>
}
 80028b6:	bd10      	pop	{r4, pc}
	...

080028c0 <st_lld_get_counter.lto_priv.228>:
  return (systime_t)STM32_ST_TIM->CNT;
 80028c0:	2380      	movs	r3, #128	; 0x80
 80028c2:	05db      	lsls	r3, r3, #23
 80028c4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 80028c6:	0018      	movs	r0, r3
 80028c8:	4770      	bx	lr
 80028ca:	46c0      	nop			; (mov r8, r8)
 80028cc:	0000      	movs	r0, r0
	...

080028d0 <port_timer_get_time.lto_priv.224>:
static inline systime_t port_timer_get_time(void) {
 80028d0:	b510      	push	{r4, lr}
  return stGetCounter();
 80028d2:	f7ff fff5 	bl	80028c0 <st_lld_get_counter.lto_priv.228>
 80028d6:	0003      	movs	r3, r0
}
 80028d8:	0018      	movs	r0, r3
 80028da:	bd10      	pop	{r4, pc}
 80028dc:	0000      	movs	r0, r0
	...

080028e0 <chVTGetSystemTimeX.lto_priv.216>:
static inline systime_t chVTGetSystemTimeX(void) {
 80028e0:	b510      	push	{r4, lr}
  return port_timer_get_time();
 80028e2:	f7ff fff5 	bl	80028d0 <port_timer_get_time.lto_priv.224>
 80028e6:	0003      	movs	r3, r0
}
 80028e8:	0018      	movs	r0, r3
 80028ea:	bd10      	pop	{r4, pc}
 80028ec:	0000      	movs	r0, r0
	...

080028f0 <trace_next>:
/**
 * @brief   Writes a time stamp and increases the trace buffer pointer.
 *
 * @notapi
 */
static NOINLINE void trace_next(void) {
 80028f0:	b510      	push	{r4, lr}

  ch.dbg.trace_buffer.ptr->time    = chVTGetSystemTimeX();
 80028f2:	4b0d      	ldr	r3, [pc, #52]	; (8002928 <trace_next+0x38>)
 80028f4:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
 80028f6:	f7ff fff3 	bl	80028e0 <chVTGetSystemTimeX.lto_priv.216>
 80028fa:	0003      	movs	r3, r0
 80028fc:	6063      	str	r3, [r4, #4]
#if PORT_SUPPORTS_RT == TRUE
  ch.dbg.trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
#else
  ch.dbg.trace_buffer.ptr->rtstamp = (rtcnt_t)0;
 80028fe:	4b0a      	ldr	r3, [pc, #40]	; (8002928 <trace_next+0x38>)
 8002900:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002902:	681a      	ldr	r2, [r3, #0]
 8002904:	21ff      	movs	r1, #255	; 0xff
 8002906:	400a      	ands	r2, r1
 8002908:	601a      	str	r2, [r3, #0]
#endif

  /* Trace hook, useful in order to interface debug tools.*/
  CH_CFG_TRACE_HOOK(ch.dbg.trace_buffer.ptr);

  if (++ch.dbg.trace_buffer.ptr >=
 800290a:	4b07      	ldr	r3, [pc, #28]	; (8002928 <trace_next+0x38>)
 800290c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800290e:	3310      	adds	r3, #16
 8002910:	001a      	movs	r2, r3
 8002912:	4b05      	ldr	r3, [pc, #20]	; (8002928 <trace_next+0x38>)
 8002914:	63da      	str	r2, [r3, #60]	; 0x3c
 8002916:	4b04      	ldr	r3, [pc, #16]	; (8002928 <trace_next+0x38>)
 8002918:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800291a:	4b04      	ldr	r3, [pc, #16]	; (800292c <trace_next+0x3c>)
 800291c:	429a      	cmp	r2, r3
 800291e:	d302      	bcc.n	8002926 <trace_next+0x36>
      &ch.dbg.trace_buffer.buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.ptr = &ch.dbg.trace_buffer.buffer[0];
 8002920:	4b01      	ldr	r3, [pc, #4]	; (8002928 <trace_next+0x38>)
 8002922:	4a03      	ldr	r2, [pc, #12]	; (8002930 <trace_next+0x40>)
 8002924:	63da      	str	r2, [r3, #60]	; 0x3c
  }
}
 8002926:	bd10      	pop	{r4, pc}
 8002928:	200004d8 	.word	0x200004d8
 800292c:	20000d18 	.word	0x20000d18
 8002930:	20000518 	.word	0x20000518
	...

08002940 <_trace_init>:
#if (CH_DBG_TRACE_MASK != CH_DBG_TRACE_MASK_DISABLED) || defined(__DOXYGEN__)
/**
 * @brief   Trace circular buffer subsystem initialization.
 * @note    Internal use only.
 */
void _trace_init(void) {
 8002940:	b082      	sub	sp, #8
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)CH_DBG_TRACE_MASK;
 8002942:	4b0f      	ldr	r3, [pc, #60]	; (8002980 <_trace_init+0x40>)
 8002944:	220f      	movs	r2, #15
 8002946:	871a      	strh	r2, [r3, #56]	; 0x38
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
 8002948:	4b0d      	ldr	r3, [pc, #52]	; (8002980 <_trace_init+0x40>)
 800294a:	2280      	movs	r2, #128	; 0x80
 800294c:	875a      	strh	r2, [r3, #58]	; 0x3a
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
 800294e:	4b0c      	ldr	r3, [pc, #48]	; (8002980 <_trace_init+0x40>)
 8002950:	4a0c      	ldr	r2, [pc, #48]	; (8002984 <_trace_init+0x44>)
 8002952:	63da      	str	r2, [r3, #60]	; 0x3c
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8002954:	2300      	movs	r3, #0
 8002956:	9301      	str	r3, [sp, #4]
 8002958:	e00d      	b.n	8002976 <_trace_init+0x36>
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
 800295a:	4a09      	ldr	r2, [pc, #36]	; (8002980 <_trace_init+0x40>)
 800295c:	9b01      	ldr	r3, [sp, #4]
 800295e:	3301      	adds	r3, #1
 8002960:	2128      	movs	r1, #40	; 0x28
 8002962:	011b      	lsls	r3, r3, #4
 8002964:	18d3      	adds	r3, r2, r3
 8002966:	185b      	adds	r3, r3, r1
 8002968:	7a1a      	ldrb	r2, [r3, #8]
 800296a:	2107      	movs	r1, #7
 800296c:	438a      	bics	r2, r1
 800296e:	721a      	strb	r2, [r3, #8]
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8002970:	9b01      	ldr	r3, [sp, #4]
 8002972:	3301      	adds	r3, #1
 8002974:	9301      	str	r3, [sp, #4]
 8002976:	9b01      	ldr	r3, [sp, #4]
 8002978:	2b7f      	cmp	r3, #127	; 0x7f
 800297a:	d9ee      	bls.n	800295a <_trace_init+0x1a>
  }
}
 800297c:	b002      	add	sp, #8
 800297e:	4770      	bx	lr
 8002980:	200004d8 	.word	0x200004d8
 8002984:	20000518 	.word	0x20000518
	...

08002990 <_trace_switch>:
 * @param[in] ntp       the thread being switched in
 * @param[in] otp       the thread being switched out
 *
 * @notapi
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {
 8002990:	b500      	push	{lr}
 8002992:	b083      	sub	sp, #12
 8002994:	9001      	str	r0, [sp, #4]
 8002996:	9100      	str	r1, [sp, #0]

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8002998:	4b16      	ldr	r3, [pc, #88]	; (80029f4 <_trace_switch+0x64>)
 800299a:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800299c:	001a      	movs	r2, r3
 800299e:	2301      	movs	r3, #1
 80029a0:	4013      	ands	r3, r2
 80029a2:	d125      	bne.n	80029f0 <_trace_switch+0x60>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80029a4:	4b13      	ldr	r3, [pc, #76]	; (80029f4 <_trace_switch+0x64>)
 80029a6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80029a8:	781a      	ldrb	r2, [r3, #0]
 80029aa:	2107      	movs	r1, #7
 80029ac:	438a      	bics	r2, r1
 80029ae:	1c11      	adds	r1, r2, #0
 80029b0:	2201      	movs	r2, #1
 80029b2:	430a      	orrs	r2, r1
 80029b4:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 80029b6:	4b0f      	ldr	r3, [pc, #60]	; (80029f4 <_trace_switch+0x64>)
 80029b8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80029ba:	9a00      	ldr	r2, [sp, #0]
 80029bc:	2120      	movs	r1, #32
 80029be:	5c52      	ldrb	r2, [r2, r1]
 80029c0:	1c11      	adds	r1, r2, #0
 80029c2:	221f      	movs	r2, #31
 80029c4:	400a      	ands	r2, r1
 80029c6:	b2d2      	uxtb	r2, r2
 80029c8:	00d0      	lsls	r0, r2, #3
 80029ca:	781a      	ldrb	r2, [r3, #0]
 80029cc:	2107      	movs	r1, #7
 80029ce:	400a      	ands	r2, r1
 80029d0:	1c11      	adds	r1, r2, #0
 80029d2:	1c02      	adds	r2, r0, #0
 80029d4:	430a      	orrs	r2, r1
 80029d6:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 80029d8:	4b06      	ldr	r3, [pc, #24]	; (80029f4 <_trace_switch+0x64>)
 80029da:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80029dc:	4a05      	ldr	r2, [pc, #20]	; (80029f4 <_trace_switch+0x64>)
 80029de:	6992      	ldr	r2, [r2, #24]
 80029e0:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 80029e2:	4b04      	ldr	r3, [pc, #16]	; (80029f4 <_trace_switch+0x64>)
 80029e4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80029e6:	9a00      	ldr	r2, [sp, #0]
 80029e8:	6a52      	ldr	r2, [r2, #36]	; 0x24
 80029ea:	60da      	str	r2, [r3, #12]
    trace_next();
 80029ec:	f7ff ff80 	bl	80028f0 <trace_next>
  }
}
 80029f0:	b003      	add	sp, #12
 80029f2:	bd00      	pop	{pc}
 80029f4:	200004d8 	.word	0x200004d8
	...

08002a00 <_trace_isr_enter>:
 *
 * @param[in] isr       name of the isr
 *
 * @notapi
 */
void _trace_isr_enter(const char *isr) {
 8002a00:	b500      	push	{lr}
 8002a02:	b083      	sub	sp, #12
 8002a04:	9001      	str	r0, [sp, #4]

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002a06:	4b10      	ldr	r3, [pc, #64]	; (8002a48 <_trace_isr_enter+0x48>)
 8002a08:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8002a0a:	001a      	movs	r2, r3
 8002a0c:	2302      	movs	r3, #2
 8002a0e:	4013      	ands	r3, r2
 8002a10:	d118      	bne.n	8002a44 <_trace_isr_enter+0x44>
    port_lock_from_isr();
 8002a12:	f7ff ff45 	bl	80028a0 <port_lock_from_isr.lto_priv.254>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8002a16:	4b0c      	ldr	r3, [pc, #48]	; (8002a48 <_trace_isr_enter+0x48>)
 8002a18:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002a1a:	781a      	ldrb	r2, [r3, #0]
 8002a1c:	2107      	movs	r1, #7
 8002a1e:	438a      	bics	r2, r1
 8002a20:	1c11      	adds	r1, r2, #0
 8002a22:	2202      	movs	r2, #2
 8002a24:	430a      	orrs	r2, r1
 8002a26:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->state       = 0U;
 8002a28:	4b07      	ldr	r3, [pc, #28]	; (8002a48 <_trace_isr_enter+0x48>)
 8002a2a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002a2c:	781a      	ldrb	r2, [r3, #0]
 8002a2e:	2107      	movs	r1, #7
 8002a30:	400a      	ands	r2, r1
 8002a32:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8002a34:	4b04      	ldr	r3, [pc, #16]	; (8002a48 <_trace_isr_enter+0x48>)
 8002a36:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002a38:	9a01      	ldr	r2, [sp, #4]
 8002a3a:	609a      	str	r2, [r3, #8]
    trace_next();
 8002a3c:	f7ff ff58 	bl	80028f0 <trace_next>
    port_unlock_from_isr();
 8002a40:	f7ff ff36 	bl	80028b0 <port_unlock_from_isr.lto_priv.250>
  }
}
 8002a44:	b003      	add	sp, #12
 8002a46:	bd00      	pop	{pc}
 8002a48:	200004d8 	.word	0x200004d8
 8002a4c:	00000000 	.word	0x00000000

08002a50 <_trace_isr_leave>:
 *
 * @param[in] isr       name of the isr
 *
 * @notapi
 */
void _trace_isr_leave(const char *isr) {
 8002a50:	b500      	push	{lr}
 8002a52:	b083      	sub	sp, #12
 8002a54:	9001      	str	r0, [sp, #4]

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002a56:	4b10      	ldr	r3, [pc, #64]	; (8002a98 <_trace_isr_leave+0x48>)
 8002a58:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8002a5a:	001a      	movs	r2, r3
 8002a5c:	2302      	movs	r3, #2
 8002a5e:	4013      	ands	r3, r2
 8002a60:	d118      	bne.n	8002a94 <_trace_isr_leave+0x44>
    port_lock_from_isr();
 8002a62:	f7ff ff1d 	bl	80028a0 <port_lock_from_isr.lto_priv.254>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8002a66:	4b0c      	ldr	r3, [pc, #48]	; (8002a98 <_trace_isr_leave+0x48>)
 8002a68:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002a6a:	781a      	ldrb	r2, [r3, #0]
 8002a6c:	2107      	movs	r1, #7
 8002a6e:	438a      	bics	r2, r1
 8002a70:	1c11      	adds	r1, r2, #0
 8002a72:	2203      	movs	r2, #3
 8002a74:	430a      	orrs	r2, r1
 8002a76:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->state       = 0U;
 8002a78:	4b07      	ldr	r3, [pc, #28]	; (8002a98 <_trace_isr_leave+0x48>)
 8002a7a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002a7c:	781a      	ldrb	r2, [r3, #0]
 8002a7e:	2107      	movs	r1, #7
 8002a80:	400a      	ands	r2, r1
 8002a82:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8002a84:	4b04      	ldr	r3, [pc, #16]	; (8002a98 <_trace_isr_leave+0x48>)
 8002a86:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002a88:	9a01      	ldr	r2, [sp, #4]
 8002a8a:	609a      	str	r2, [r3, #8]
    trace_next();
 8002a8c:	f7ff ff30 	bl	80028f0 <trace_next>
    port_unlock_from_isr();
 8002a90:	f7ff ff0e 	bl	80028b0 <port_unlock_from_isr.lto_priv.250>
  }
}
 8002a94:	b003      	add	sp, #12
 8002a96:	bd00      	pop	{pc}
 8002a98:	200004d8 	.word	0x200004d8
 8002a9c:	00000000 	.word	0x00000000

08002aa0 <_trace_halt>:
 *
 * @param[in] reason    the halt error string
 *
 * @notapi
 */
void _trace_halt(const char *reason) {
 8002aa0:	b500      	push	{lr}
 8002aa2:	b083      	sub	sp, #12
 8002aa4:	9001      	str	r0, [sp, #4]

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
 8002aa6:	4b0e      	ldr	r3, [pc, #56]	; (8002ae0 <_trace_halt+0x40>)
 8002aa8:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8002aaa:	001a      	movs	r2, r3
 8002aac:	2304      	movs	r3, #4
 8002aae:	4013      	ands	r3, r2
 8002ab0:	d114      	bne.n	8002adc <_trace_halt+0x3c>
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 8002ab2:	4b0b      	ldr	r3, [pc, #44]	; (8002ae0 <_trace_halt+0x40>)
 8002ab4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002ab6:	781a      	ldrb	r2, [r3, #0]
 8002ab8:	2107      	movs	r1, #7
 8002aba:	438a      	bics	r2, r1
 8002abc:	1c11      	adds	r1, r2, #0
 8002abe:	2204      	movs	r2, #4
 8002ac0:	430a      	orrs	r2, r1
 8002ac2:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->state         = 0;
 8002ac4:	4b06      	ldr	r3, [pc, #24]	; (8002ae0 <_trace_halt+0x40>)
 8002ac6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002ac8:	781a      	ldrb	r2, [r3, #0]
 8002aca:	2107      	movs	r1, #7
 8002acc:	400a      	ands	r2, r1
 8002ace:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->u.halt.reason = reason;
 8002ad0:	4b03      	ldr	r3, [pc, #12]	; (8002ae0 <_trace_halt+0x40>)
 8002ad2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002ad4:	9a01      	ldr	r2, [sp, #4]
 8002ad6:	609a      	str	r2, [r3, #8]
    trace_next();
 8002ad8:	f7ff ff0a 	bl	80028f0 <trace_next>
  }
}
 8002adc:	b003      	add	sp, #12
 8002ade:	bd00      	pop	{pc}
 8002ae0:	200004d8 	.word	0x200004d8
	...

08002af0 <st_lld_get_counter.lto_priv.229>:
  return (systime_t)STM32_ST_TIM->CNT;
 8002af0:	2380      	movs	r3, #128	; 0x80
 8002af2:	05db      	lsls	r3, r3, #23
 8002af4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8002af6:	0018      	movs	r0, r3
 8002af8:	4770      	bx	lr
 8002afa:	46c0      	nop			; (mov r8, r8)
 8002afc:	0000      	movs	r0, r0
	...

08002b00 <port_timer_start_alarm>:
static inline void port_timer_start_alarm(systime_t time) {
 8002b00:	b500      	push	{lr}
 8002b02:	b083      	sub	sp, #12
 8002b04:	9001      	str	r0, [sp, #4]
  stStartAlarm(time);
 8002b06:	9b01      	ldr	r3, [sp, #4]
 8002b08:	0018      	movs	r0, r3
 8002b0a:	f7fe fa91 	bl	8001030 <stStartAlarm>
}
 8002b0e:	b003      	add	sp, #12
 8002b10:	bd00      	pop	{pc}
 8002b12:	46c0      	nop			; (mov r8, r8)
	...

08002b20 <port_timer_stop_alarm.lto_priv.259>:
static inline void port_timer_stop_alarm(void) {
 8002b20:	b510      	push	{r4, lr}
  stStopAlarm();
 8002b22:	f7fe fa9d 	bl	8001060 <stStopAlarm>
}
 8002b26:	bd10      	pop	{r4, pc}
	...

08002b30 <port_timer_set_alarm.lto_priv.257>:
static inline void port_timer_set_alarm(systime_t time) {
 8002b30:	b500      	push	{lr}
 8002b32:	b083      	sub	sp, #12
 8002b34:	9001      	str	r0, [sp, #4]
  stSetAlarm(time);
 8002b36:	9b01      	ldr	r3, [sp, #4]
 8002b38:	0018      	movs	r0, r3
 8002b3a:	f7fe fa99 	bl	8001070 <stSetAlarm>
}
 8002b3e:	b003      	add	sp, #12
 8002b40:	bd00      	pop	{pc}
 8002b42:	46c0      	nop			; (mov r8, r8)
	...

08002b50 <port_timer_get_time.lto_priv.225>:
static inline systime_t port_timer_get_time(void) {
 8002b50:	b510      	push	{r4, lr}
  return stGetCounter();
 8002b52:	f7ff ffcd 	bl	8002af0 <st_lld_get_counter.lto_priv.229>
 8002b56:	0003      	movs	r3, r0
}
 8002b58:	0018      	movs	r0, r3
 8002b5a:	bd10      	pop	{r4, pc}
 8002b5c:	0000      	movs	r0, r0
	...

08002b60 <chVTGetSystemTimeX.lto_priv.217>:
static inline systime_t chVTGetSystemTimeX(void) {
 8002b60:	b510      	push	{r4, lr}
  return port_timer_get_time();
 8002b62:	f7ff fff5 	bl	8002b50 <port_timer_get_time.lto_priv.225>
 8002b66:	0003      	movs	r3, r0
}
 8002b68:	0018      	movs	r0, r3
 8002b6a:	bd10      	pop	{r4, pc}
 8002b6c:	0000      	movs	r0, r0
	...

08002b70 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8002b70:	4b06      	ldr	r3, [pc, #24]	; (8002b8c <_vt_init+0x1c>)
 8002b72:	4a07      	ldr	r2, [pc, #28]	; (8002b90 <_vt_init+0x20>)
 8002b74:	61da      	str	r2, [r3, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8002b76:	4b05      	ldr	r3, [pc, #20]	; (8002b8c <_vt_init+0x1c>)
 8002b78:	4a05      	ldr	r2, [pc, #20]	; (8002b90 <_vt_init+0x20>)
 8002b7a:	621a      	str	r2, [r3, #32]
  ch.vtlist.delta = (systime_t)-1;
 8002b7c:	4b03      	ldr	r3, [pc, #12]	; (8002b8c <_vt_init+0x1c>)
 8002b7e:	2201      	movs	r2, #1
 8002b80:	4252      	negs	r2, r2
 8002b82:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 8002b84:	4b01      	ldr	r3, [pc, #4]	; (8002b8c <_vt_init+0x1c>)
 8002b86:	2200      	movs	r2, #0
 8002b88:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8002b8a:	4770      	bx	lr
 8002b8c:	200004d8 	.word	0x200004d8
 8002b90:	200004f4 	.word	0x200004f4
	...

08002ba0 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8002ba0:	b500      	push	{lr}
 8002ba2:	b089      	sub	sp, #36	; 0x24
 8002ba4:	9003      	str	r0, [sp, #12]
 8002ba6:	9102      	str	r1, [sp, #8]
 8002ba8:	9201      	str	r2, [sp, #4]
 8002baa:	9300      	str	r3, [sp, #0]
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
 8002bac:	f7ff fe38 	bl	8002820 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8002bb0:	9b03      	ldr	r3, [sp, #12]
 8002bb2:	2b00      	cmp	r3, #0
 8002bb4:	d005      	beq.n	8002bc2 <chVTDoSetI+0x22>
 8002bb6:	9b01      	ldr	r3, [sp, #4]
 8002bb8:	2b00      	cmp	r3, #0
 8002bba:	d002      	beq.n	8002bc2 <chVTDoSetI+0x22>
 8002bbc:	9b02      	ldr	r3, [sp, #8]
 8002bbe:	2b00      	cmp	r3, #0
 8002bc0:	d103      	bne.n	8002bca <chVTDoSetI+0x2a>
 8002bc2:	4b42      	ldr	r3, [pc, #264]	; (8002ccc <chVTDoSetI+0x12c>)
 8002bc4:	0018      	movs	r0, r3
 8002bc6:	f7ff fd3b 	bl	8002640 <chSysHalt>

  vtp->par = par;
 8002bca:	9b03      	ldr	r3, [sp, #12]
 8002bcc:	9a00      	ldr	r2, [sp, #0]
 8002bce:	611a      	str	r2, [r3, #16]
  vtp->func = vtfunc;
 8002bd0:	9b03      	ldr	r3, [sp, #12]
 8002bd2:	9a01      	ldr	r2, [sp, #4]
 8002bd4:	60da      	str	r2, [r3, #12]

#if CH_CFG_ST_TIMEDELTA > 0
  {
    systime_t now = chVTGetSystemTimeX();
 8002bd6:	f7ff ffc3 	bl	8002b60 <chVTGetSystemTimeX.lto_priv.217>
 8002bda:	0003      	movs	r3, r0
 8002bdc:	9305      	str	r3, [sp, #20]

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8002bde:	9b02      	ldr	r3, [sp, #8]
 8002be0:	2b01      	cmp	r3, #1
 8002be2:	d801      	bhi.n	8002be8 <chVTDoSetI+0x48>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 8002be4:	2302      	movs	r3, #2
 8002be6:	9302      	str	r3, [sp, #8]
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8002be8:	4b39      	ldr	r3, [pc, #228]	; (8002cd0 <chVTDoSetI+0x130>)
 8002bea:	69da      	ldr	r2, [r3, #28]
 8002bec:	4b39      	ldr	r3, [pc, #228]	; (8002cd4 <chVTDoSetI+0x134>)
 8002bee:	429a      	cmp	r2, r3
 8002bf0:	d119      	bne.n	8002c26 <chVTDoSetI+0x86>

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
 8002bf2:	4b37      	ldr	r3, [pc, #220]	; (8002cd0 <chVTDoSetI+0x130>)
 8002bf4:	9a05      	ldr	r2, [sp, #20]
 8002bf6:	629a      	str	r2, [r3, #40]	; 0x28
      ch.vtlist.next = vtp;
 8002bf8:	4b35      	ldr	r3, [pc, #212]	; (8002cd0 <chVTDoSetI+0x130>)
 8002bfa:	9a03      	ldr	r2, [sp, #12]
 8002bfc:	61da      	str	r2, [r3, #28]
      ch.vtlist.prev = vtp;
 8002bfe:	4b34      	ldr	r3, [pc, #208]	; (8002cd0 <chVTDoSetI+0x130>)
 8002c00:	9a03      	ldr	r2, [sp, #12]
 8002c02:	621a      	str	r2, [r3, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 8002c04:	9b03      	ldr	r3, [sp, #12]
 8002c06:	4a33      	ldr	r2, [pc, #204]	; (8002cd4 <chVTDoSetI+0x134>)
 8002c08:	601a      	str	r2, [r3, #0]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 8002c0a:	9b03      	ldr	r3, [sp, #12]
 8002c0c:	4a31      	ldr	r2, [pc, #196]	; (8002cd4 <chVTDoSetI+0x134>)
 8002c0e:	605a      	str	r2, [r3, #4]
      vtp->delta = delay;
 8002c10:	9b03      	ldr	r3, [sp, #12]
 8002c12:	9a02      	ldr	r2, [sp, #8]
 8002c14:	609a      	str	r2, [r3, #8]

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.lasttime + delay);
 8002c16:	4b2e      	ldr	r3, [pc, #184]	; (8002cd0 <chVTDoSetI+0x130>)
 8002c18:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8002c1a:	9b02      	ldr	r3, [sp, #8]
 8002c1c:	18d3      	adds	r3, r2, r3
 8002c1e:	0018      	movs	r0, r3
 8002c20:	f7ff ff6e 	bl	8002b00 <port_timer_start_alarm>
 8002c24:	e04f      	b.n	8002cc6 <chVTDoSetI+0x126>

      return;
    }

    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;
 8002c26:	4b2a      	ldr	r3, [pc, #168]	; (8002cd0 <chVTDoSetI+0x130>)
 8002c28:	69db      	ldr	r3, [r3, #28]
 8002c2a:	9307      	str	r3, [sp, #28]

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = now - ch.vtlist.lasttime + delay;
 8002c2c:	4b28      	ldr	r3, [pc, #160]	; (8002cd0 <chVTDoSetI+0x130>)
 8002c2e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002c30:	9a05      	ldr	r2, [sp, #20]
 8002c32:	1ad2      	subs	r2, r2, r3
 8002c34:	9b02      	ldr	r3, [sp, #8]
 8002c36:	18d3      	adds	r3, r2, r3
 8002c38:	9306      	str	r3, [sp, #24]

    if (delta < now - ch.vtlist.lasttime) {
 8002c3a:	4b25      	ldr	r3, [pc, #148]	; (8002cd0 <chVTDoSetI+0x130>)
 8002c3c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002c3e:	9a05      	ldr	r2, [sp, #20]
 8002c40:	1ad2      	subs	r2, r2, r3
 8002c42:	9b06      	ldr	r3, [sp, #24]
 8002c44:	429a      	cmp	r2, r3
 8002c46:	d908      	bls.n	8002c5a <chVTDoSetI+0xba>
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 8002c48:	9b07      	ldr	r3, [sp, #28]
 8002c4a:	689b      	ldr	r3, [r3, #8]
 8002c4c:	9a06      	ldr	r2, [sp, #24]
 8002c4e:	1ad3      	subs	r3, r2, r3
 8002c50:	9306      	str	r3, [sp, #24]
      p = p->next;
 8002c52:	9b07      	ldr	r3, [sp, #28]
 8002c54:	681b      	ldr	r3, [r3, #0]
 8002c56:	9307      	str	r3, [sp, #28]
 8002c58:	e014      	b.n	8002c84 <chVTDoSetI+0xe4>
    }
    else if (delta < p->delta) {
 8002c5a:	9b07      	ldr	r3, [sp, #28]
 8002c5c:	689a      	ldr	r2, [r3, #8]
 8002c5e:	9b06      	ldr	r3, [sp, #24]
 8002c60:	429a      	cmp	r2, r3
 8002c62:	d90f      	bls.n	8002c84 <chVTDoSetI+0xe4>
     /* A small delay that will become the first element in the delta list
        and next deadline.*/
      port_timer_set_alarm(ch.vtlist.lasttime + delta);
 8002c64:	4b1a      	ldr	r3, [pc, #104]	; (8002cd0 <chVTDoSetI+0x130>)
 8002c66:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8002c68:	9b06      	ldr	r3, [sp, #24]
 8002c6a:	18d3      	adds	r3, r2, r3
 8002c6c:	0018      	movs	r0, r3
 8002c6e:	f7ff ff5f 	bl	8002b30 <port_timer_set_alarm.lto_priv.257>
 8002c72:	e007      	b.n	8002c84 <chVTDoSetI+0xe4>
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    delta -= p->delta;
 8002c74:	9b07      	ldr	r3, [sp, #28]
 8002c76:	689b      	ldr	r3, [r3, #8]
 8002c78:	9a06      	ldr	r2, [sp, #24]
 8002c7a:	1ad3      	subs	r3, r2, r3
 8002c7c:	9306      	str	r3, [sp, #24]
    p = p->next;
 8002c7e:	9b07      	ldr	r3, [sp, #28]
 8002c80:	681b      	ldr	r3, [r3, #0]
 8002c82:	9307      	str	r3, [sp, #28]
  while (p->delta < delta) {
 8002c84:	9b07      	ldr	r3, [sp, #28]
 8002c86:	689a      	ldr	r2, [r3, #8]
 8002c88:	9b06      	ldr	r3, [sp, #24]
 8002c8a:	429a      	cmp	r2, r3
 8002c8c:	d3f2      	bcc.n	8002c74 <chVTDoSetI+0xd4>
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
 8002c8e:	9b03      	ldr	r3, [sp, #12]
 8002c90:	9a07      	ldr	r2, [sp, #28]
 8002c92:	601a      	str	r2, [r3, #0]
  vtp->prev = vtp->next->prev;
 8002c94:	9b03      	ldr	r3, [sp, #12]
 8002c96:	681b      	ldr	r3, [r3, #0]
 8002c98:	685a      	ldr	r2, [r3, #4]
 8002c9a:	9b03      	ldr	r3, [sp, #12]
 8002c9c:	605a      	str	r2, [r3, #4]
  vtp->prev->next = vtp;
 8002c9e:	9b03      	ldr	r3, [sp, #12]
 8002ca0:	685b      	ldr	r3, [r3, #4]
 8002ca2:	9a03      	ldr	r2, [sp, #12]
 8002ca4:	601a      	str	r2, [r3, #0]
  p->prev = vtp;
 8002ca6:	9b07      	ldr	r3, [sp, #28]
 8002ca8:	9a03      	ldr	r2, [sp, #12]
 8002caa:	605a      	str	r2, [r3, #4]
  vtp->delta = delta
 8002cac:	9b03      	ldr	r3, [sp, #12]
 8002cae:	9a06      	ldr	r2, [sp, #24]
 8002cb0:	609a      	str	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 8002cb2:	9b07      	ldr	r3, [sp, #28]
 8002cb4:	689a      	ldr	r2, [r3, #8]
 8002cb6:	9b06      	ldr	r3, [sp, #24]
 8002cb8:	1ad2      	subs	r2, r2, r3
 8002cba:	9b07      	ldr	r3, [sp, #28]
 8002cbc:	609a      	str	r2, [r3, #8]
  ch.vtlist.delta = (systime_t)-1;
 8002cbe:	4b04      	ldr	r3, [pc, #16]	; (8002cd0 <chVTDoSetI+0x130>)
 8002cc0:	2201      	movs	r2, #1
 8002cc2:	4252      	negs	r2, r2
 8002cc4:	625a      	str	r2, [r3, #36]	; 0x24
}
 8002cc6:	b009      	add	sp, #36	; 0x24
 8002cc8:	bd00      	pop	{pc}
 8002cca:	46c0      	nop			; (mov r8, r8)
 8002ccc:	08003a88 	.word	0x08003a88
 8002cd0:	200004d8 	.word	0x200004d8
 8002cd4:	200004f4 	.word	0x200004f4
	...

08002ce0 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8002ce0:	b500      	push	{lr}
 8002ce2:	b085      	sub	sp, #20
 8002ce4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8002ce6:	f7ff fd9b 	bl	8002820 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
 8002cea:	9b01      	ldr	r3, [sp, #4]
 8002cec:	2b00      	cmp	r3, #0
 8002cee:	d103      	bne.n	8002cf8 <chVTDoResetI+0x18>
 8002cf0:	4b36      	ldr	r3, [pc, #216]	; (8002dcc <chVTDoResetI+0xec>)
 8002cf2:	0018      	movs	r0, r3
 8002cf4:	f7ff fca4 	bl	8002640 <chSysHalt>
  chDbgAssert(vtp->func != NULL, "timer not set or already triggered");
 8002cf8:	9b01      	ldr	r3, [sp, #4]
 8002cfa:	68db      	ldr	r3, [r3, #12]
 8002cfc:	2b00      	cmp	r3, #0
 8002cfe:	d103      	bne.n	8002d08 <chVTDoResetI+0x28>
 8002d00:	4b32      	ldr	r3, [pc, #200]	; (8002dcc <chVTDoResetI+0xec>)
 8002d02:	0018      	movs	r0, r3
 8002d04:	f7ff fc9c 	bl	8002640 <chSysHalt>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8002d08:	4b31      	ldr	r3, [pc, #196]	; (8002dd0 <chVTDoResetI+0xf0>)
 8002d0a:	69da      	ldr	r2, [r3, #28]
 8002d0c:	9b01      	ldr	r3, [sp, #4]
 8002d0e:	429a      	cmp	r2, r3
 8002d10:	d01b      	beq.n	8002d4a <chVTDoResetI+0x6a>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8002d12:	9b01      	ldr	r3, [sp, #4]
 8002d14:	685b      	ldr	r3, [r3, #4]
 8002d16:	9a01      	ldr	r2, [sp, #4]
 8002d18:	6812      	ldr	r2, [r2, #0]
 8002d1a:	601a      	str	r2, [r3, #0]
    vtp->next->prev = vtp->prev;
 8002d1c:	9b01      	ldr	r3, [sp, #4]
 8002d1e:	681b      	ldr	r3, [r3, #0]
 8002d20:	9a01      	ldr	r2, [sp, #4]
 8002d22:	6852      	ldr	r2, [r2, #4]
 8002d24:	605a      	str	r2, [r3, #4]
    vtp->func = NULL;
 8002d26:	9b01      	ldr	r3, [sp, #4]
 8002d28:	2200      	movs	r2, #0
 8002d2a:	60da      	str	r2, [r3, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8002d2c:	9b01      	ldr	r3, [sp, #4]
 8002d2e:	681a      	ldr	r2, [r3, #0]
 8002d30:	4b28      	ldr	r3, [pc, #160]	; (8002dd4 <chVTDoResetI+0xf4>)
 8002d32:	429a      	cmp	r2, r3
 8002d34:	d047      	beq.n	8002dc6 <chVTDoResetI+0xe6>
      vtp->next->delta += vtp->delta;
 8002d36:	9b01      	ldr	r3, [sp, #4]
 8002d38:	681b      	ldr	r3, [r3, #0]
 8002d3a:	9a01      	ldr	r2, [sp, #4]
 8002d3c:	6812      	ldr	r2, [r2, #0]
 8002d3e:	6891      	ldr	r1, [r2, #8]
 8002d40:	9a01      	ldr	r2, [sp, #4]
 8002d42:	6892      	ldr	r2, [r2, #8]
 8002d44:	188a      	adds	r2, r1, r2
 8002d46:	609a      	str	r2, [r3, #8]
 8002d48:	e03e      	b.n	8002dc8 <chVTDoResetI+0xe8>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 8002d4a:	9b01      	ldr	r3, [sp, #4]
 8002d4c:	681a      	ldr	r2, [r3, #0]
 8002d4e:	4b20      	ldr	r3, [pc, #128]	; (8002dd0 <chVTDoResetI+0xf0>)
 8002d50:	61da      	str	r2, [r3, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8002d52:	4b1f      	ldr	r3, [pc, #124]	; (8002dd0 <chVTDoResetI+0xf0>)
 8002d54:	69db      	ldr	r3, [r3, #28]
 8002d56:	4a1f      	ldr	r2, [pc, #124]	; (8002dd4 <chVTDoResetI+0xf4>)
 8002d58:	605a      	str	r2, [r3, #4]
  vtp->func = NULL;
 8002d5a:	9b01      	ldr	r3, [sp, #4]
 8002d5c:	2200      	movs	r2, #0
 8002d5e:	60da      	str	r2, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8002d60:	4b1b      	ldr	r3, [pc, #108]	; (8002dd0 <chVTDoResetI+0xf0>)
 8002d62:	69da      	ldr	r2, [r3, #28]
 8002d64:	4b1b      	ldr	r3, [pc, #108]	; (8002dd4 <chVTDoResetI+0xf4>)
 8002d66:	429a      	cmp	r2, r3
 8002d68:	d102      	bne.n	8002d70 <chVTDoResetI+0x90>
    port_timer_stop_alarm();
 8002d6a:	f7ff fed9 	bl	8002b20 <port_timer_stop_alarm.lto_priv.259>
 8002d6e:	e02b      	b.n	8002dc8 <chVTDoResetI+0xe8>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 8002d70:	4b17      	ldr	r3, [pc, #92]	; (8002dd0 <chVTDoResetI+0xf0>)
 8002d72:	69db      	ldr	r3, [r3, #28]
 8002d74:	4a16      	ldr	r2, [pc, #88]	; (8002dd0 <chVTDoResetI+0xf0>)
 8002d76:	69d2      	ldr	r2, [r2, #28]
 8002d78:	6891      	ldr	r1, [r2, #8]
 8002d7a:	9a01      	ldr	r2, [sp, #4]
 8002d7c:	6892      	ldr	r2, [r2, #8]
 8002d7e:	188a      	adds	r2, r1, r2
 8002d80:	609a      	str	r2, [r3, #8]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 8002d82:	f7ff feed 	bl	8002b60 <chVTGetSystemTimeX.lto_priv.217>
 8002d86:	0002      	movs	r2, r0
 8002d88:	4b11      	ldr	r3, [pc, #68]	; (8002dd0 <chVTDoResetI+0xf0>)
 8002d8a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002d8c:	1ad3      	subs	r3, r2, r3
 8002d8e:	9302      	str	r3, [sp, #8]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 8002d90:	4b0f      	ldr	r3, [pc, #60]	; (8002dd0 <chVTDoResetI+0xf0>)
 8002d92:	69db      	ldr	r3, [r3, #28]
 8002d94:	689a      	ldr	r2, [r3, #8]
 8002d96:	9b02      	ldr	r3, [sp, #8]
 8002d98:	429a      	cmp	r2, r3
 8002d9a:	d915      	bls.n	8002dc8 <chVTDoResetI+0xe8>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 8002d9c:	4b0c      	ldr	r3, [pc, #48]	; (8002dd0 <chVTDoResetI+0xf0>)
 8002d9e:	69db      	ldr	r3, [r3, #28]
 8002da0:	689a      	ldr	r2, [r3, #8]
 8002da2:	9b02      	ldr	r3, [sp, #8]
 8002da4:	1ad3      	subs	r3, r2, r3
 8002da6:	9303      	str	r3, [sp, #12]

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8002da8:	9b03      	ldr	r3, [sp, #12]
 8002daa:	2b01      	cmp	r3, #1
 8002dac:	d801      	bhi.n	8002db2 <chVTDoResetI+0xd2>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8002dae:	2302      	movs	r3, #2
 8002db0:	9303      	str	r3, [sp, #12]
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
 8002db2:	4b07      	ldr	r3, [pc, #28]	; (8002dd0 <chVTDoResetI+0xf0>)
 8002db4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8002db6:	9b02      	ldr	r3, [sp, #8]
 8002db8:	18d2      	adds	r2, r2, r3
 8002dba:	9b03      	ldr	r3, [sp, #12]
 8002dbc:	18d3      	adds	r3, r2, r3
 8002dbe:	0018      	movs	r0, r3
 8002dc0:	f7ff feb6 	bl	8002b30 <port_timer_set_alarm.lto_priv.257>
 8002dc4:	e000      	b.n	8002dc8 <chVTDoResetI+0xe8>
      vtp->next->delta += vtp->delta;
 8002dc6:	46c0      	nop			; (mov r8, r8)
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8002dc8:	b005      	add	sp, #20
 8002dca:	bd00      	pop	{pc}
 8002dcc:	08003a94 	.word	0x08003a94
 8002dd0:	200004d8 	.word	0x200004d8
 8002dd4:	200004f4 	.word	0x200004f4
	...

08002de0 <port_lock.lto_priv.239>:
  __ASM volatile ("cpsid i" : : : "memory");
 8002de0:	b672      	cpsid	i
}
 8002de2:	4770      	bx	lr
	...

08002df0 <port_unlock.lto_priv.234>:
  __ASM volatile ("cpsie i" : : : "memory");
 8002df0:	b662      	cpsie	i
}
 8002df2:	4770      	bx	lr
	...

08002e00 <port_lock_from_isr.lto_priv.255>:
static inline void port_lock_from_isr(void) {
 8002e00:	b510      	push	{r4, lr}
  port_lock();
 8002e02:	f7ff ffed 	bl	8002de0 <port_lock.lto_priv.239>
}
 8002e06:	bd10      	pop	{r4, pc}
	...

08002e10 <port_unlock_from_isr.lto_priv.251>:
static inline void port_unlock_from_isr(void) {
 8002e10:	b510      	push	{r4, lr}
  port_unlock();
 8002e12:	f7ff ffed 	bl	8002df0 <port_unlock.lto_priv.234>
}
 8002e16:	bd10      	pop	{r4, pc}
	...

08002e20 <queue_init.lto_priv.221>:
static inline void queue_init(threads_queue_t *tqp) {
 8002e20:	b082      	sub	sp, #8
 8002e22:	9001      	str	r0, [sp, #4]
  tqp->next = (thread_t *)tqp;
 8002e24:	9b01      	ldr	r3, [sp, #4]
 8002e26:	9a01      	ldr	r2, [sp, #4]
 8002e28:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8002e2a:	9b01      	ldr	r3, [sp, #4]
 8002e2c:	9a01      	ldr	r2, [sp, #4]
 8002e2e:	605a      	str	r2, [r3, #4]
}
 8002e30:	b002      	add	sp, #8
 8002e32:	4770      	bx	lr
	...

08002e40 <queue_fifo_remove.lto_priv.219>:
static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8002e40:	b084      	sub	sp, #16
 8002e42:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
 8002e44:	9b01      	ldr	r3, [sp, #4]
 8002e46:	681b      	ldr	r3, [r3, #0]
 8002e48:	9303      	str	r3, [sp, #12]
  tqp->next             = tp->queue.next;
 8002e4a:	9b03      	ldr	r3, [sp, #12]
 8002e4c:	681a      	ldr	r2, [r3, #0]
 8002e4e:	9b01      	ldr	r3, [sp, #4]
 8002e50:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8002e52:	9b01      	ldr	r3, [sp, #4]
 8002e54:	681b      	ldr	r3, [r3, #0]
 8002e56:	9a01      	ldr	r2, [sp, #4]
 8002e58:	605a      	str	r2, [r3, #4]
  return tp;
 8002e5a:	9b03      	ldr	r3, [sp, #12]
}
 8002e5c:	0018      	movs	r0, r3
 8002e5e:	b004      	add	sp, #16
 8002e60:	4770      	bx	lr
 8002e62:	46c0      	nop			; (mov r8, r8)
	...

08002e70 <queue_dequeue>:
static inline thread_t *queue_dequeue(thread_t *tp) {
 8002e70:	b082      	sub	sp, #8
 8002e72:	9001      	str	r0, [sp, #4]
  tp->queue.prev->queue.next = tp->queue.next;
 8002e74:	9b01      	ldr	r3, [sp, #4]
 8002e76:	685b      	ldr	r3, [r3, #4]
 8002e78:	9a01      	ldr	r2, [sp, #4]
 8002e7a:	6812      	ldr	r2, [r2, #0]
 8002e7c:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8002e7e:	9b01      	ldr	r3, [sp, #4]
 8002e80:	681b      	ldr	r3, [r3, #0]
 8002e82:	9a01      	ldr	r2, [sp, #4]
 8002e84:	6852      	ldr	r2, [r2, #4]
 8002e86:	605a      	str	r2, [r3, #4]
  return tp;
 8002e88:	9b01      	ldr	r3, [sp, #4]
}
 8002e8a:	0018      	movs	r0, r3
 8002e8c:	b002      	add	sp, #8
 8002e8e:	4770      	bx	lr

08002e90 <chSchIsRescRequiredI>:
 * @retval false        if rescheduling is not necessary.
 * @retval true         if there is a ready thread at higher priority.
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {
 8002e90:	b510      	push	{r4, lr}

  chDbgCheckClassI();
 8002e92:	f7ff fcc5 	bl	8002820 <chDbgCheckClassI>

  return firstprio(&ch.rlist.queue) > currp->prio;
 8002e96:	4b06      	ldr	r3, [pc, #24]	; (8002eb0 <chSchIsRescRequiredI+0x20>)
 8002e98:	681b      	ldr	r3, [r3, #0]
 8002e9a:	689a      	ldr	r2, [r3, #8]
 8002e9c:	4b04      	ldr	r3, [pc, #16]	; (8002eb0 <chSchIsRescRequiredI+0x20>)
 8002e9e:	699b      	ldr	r3, [r3, #24]
 8002ea0:	689b      	ldr	r3, [r3, #8]
 8002ea2:	4293      	cmp	r3, r2
 8002ea4:	419b      	sbcs	r3, r3
 8002ea6:	425b      	negs	r3, r3
 8002ea8:	b2db      	uxtb	r3, r3
}
 8002eaa:	0018      	movs	r0, r3
 8002eac:	bd10      	pop	{r4, pc}
 8002eae:	46c0      	nop			; (mov r8, r8)
 8002eb0:	200004d8 	.word	0x200004d8
	...

08002ec0 <chSysLockFromISR.lto_priv.247>:
static inline void chSysLockFromISR(void) {
 8002ec0:	b510      	push	{r4, lr}
  port_lock_from_isr();
 8002ec2:	f7ff ff9d 	bl	8002e00 <port_lock_from_isr.lto_priv.255>
  _dbg_check_lock_from_isr();
 8002ec6:	f7ff fc3b 	bl	8002740 <_dbg_check_lock_from_isr>
}
 8002eca:	bd10      	pop	{r4, pc}
 8002ecc:	0000      	movs	r0, r0
	...

08002ed0 <chSysUnlockFromISR.lto_priv.245>:
static inline void chSysUnlockFromISR(void) {
 8002ed0:	b510      	push	{r4, lr}
  _dbg_check_unlock_from_isr();
 8002ed2:	f7ff fc4d 	bl	8002770 <_dbg_check_unlock_from_isr>
  port_unlock_from_isr();
 8002ed6:	f7ff ff9b 	bl	8002e10 <port_unlock_from_isr.lto_priv.251>
}
 8002eda:	bd10      	pop	{r4, pc}
 8002edc:	0000      	movs	r0, r0
	...

08002ee0 <chVTIsArmedI>:
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 8002ee0:	b500      	push	{lr}
 8002ee2:	b083      	sub	sp, #12
 8002ee4:	9001      	str	r0, [sp, #4]
  chDbgCheckClassI();
 8002ee6:	f7ff fc9b 	bl	8002820 <chDbgCheckClassI>
  return (bool)(vtp->func != NULL);
 8002eea:	9b01      	ldr	r3, [sp, #4]
 8002eec:	68db      	ldr	r3, [r3, #12]
 8002eee:	1e5a      	subs	r2, r3, #1
 8002ef0:	4193      	sbcs	r3, r2
 8002ef2:	b2db      	uxtb	r3, r3
}
 8002ef4:	0018      	movs	r0, r3
 8002ef6:	b003      	add	sp, #12
 8002ef8:	bd00      	pop	{pc}
 8002efa:	46c0      	nop			; (mov r8, r8)
 8002efc:	0000      	movs	r0, r0
	...

08002f00 <chSemFastSignalI>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 8002f00:	b500      	push	{lr}
 8002f02:	b083      	sub	sp, #12
 8002f04:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8002f06:	f7ff fc8b 	bl	8002820 <chDbgCheckClassI>

  sp->cnt++;
 8002f0a:	9b01      	ldr	r3, [sp, #4]
 8002f0c:	689b      	ldr	r3, [r3, #8]
 8002f0e:	1c5a      	adds	r2, r3, #1
 8002f10:	9b01      	ldr	r3, [sp, #4]
 8002f12:	609a      	str	r2, [r3, #8]
}
 8002f14:	b003      	add	sp, #12
 8002f16:	bd00      	pop	{pc}
	...

08002f20 <_scheduler_init>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
 8002f20:	b510      	push	{r4, lr}

  queue_init(&ch.rlist.queue);
 8002f22:	4b07      	ldr	r3, [pc, #28]	; (8002f40 <_scheduler_init+0x20>)
 8002f24:	0018      	movs	r0, r3
 8002f26:	f7ff ff7b 	bl	8002e20 <queue_init.lto_priv.221>
  ch.rlist.prio = NOPRIO;
 8002f2a:	4b05      	ldr	r3, [pc, #20]	; (8002f40 <_scheduler_init+0x20>)
 8002f2c:	2200      	movs	r2, #0
 8002f2e:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.newer = (thread_t *)&ch.rlist;
 8002f30:	4b03      	ldr	r3, [pc, #12]	; (8002f40 <_scheduler_init+0x20>)
 8002f32:	4a03      	ldr	r2, [pc, #12]	; (8002f40 <_scheduler_init+0x20>)
 8002f34:	611a      	str	r2, [r3, #16]
  ch.rlist.older = (thread_t *)&ch.rlist;
 8002f36:	4b02      	ldr	r3, [pc, #8]	; (8002f40 <_scheduler_init+0x20>)
 8002f38:	4a01      	ldr	r2, [pc, #4]	; (8002f40 <_scheduler_init+0x20>)
 8002f3a:	615a      	str	r2, [r3, #20]
#endif
}
 8002f3c:	bd10      	pop	{r4, pc}
 8002f3e:	46c0      	nop			; (mov r8, r8)
 8002f40:	200004d8 	.word	0x200004d8
	...

08002f50 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8002f50:	b500      	push	{lr}
 8002f52:	b085      	sub	sp, #20
 8002f54:	9001      	str	r0, [sp, #4]
  thread_t *cp;

  chDbgCheckClassI();
 8002f56:	f7ff fc63 	bl	8002820 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8002f5a:	9b01      	ldr	r3, [sp, #4]
 8002f5c:	2b00      	cmp	r3, #0
 8002f5e:	d103      	bne.n	8002f68 <chSchReadyI+0x18>
 8002f60:	4b19      	ldr	r3, [pc, #100]	; (8002fc8 <chSchReadyI+0x78>)
 8002f62:	0018      	movs	r0, r3
 8002f64:	f7ff fb6c 	bl	8002640 <chSysHalt>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8002f68:	9b01      	ldr	r3, [sp, #4]
 8002f6a:	2220      	movs	r2, #32
 8002f6c:	5c9b      	ldrb	r3, [r3, r2]
 8002f6e:	2b00      	cmp	r3, #0
 8002f70:	d004      	beq.n	8002f7c <chSchReadyI+0x2c>
 8002f72:	9b01      	ldr	r3, [sp, #4]
 8002f74:	2220      	movs	r2, #32
 8002f76:	5c9b      	ldrb	r3, [r3, r2]
 8002f78:	2b0f      	cmp	r3, #15
 8002f7a:	d103      	bne.n	8002f84 <chSchReadyI+0x34>
 8002f7c:	4b12      	ldr	r3, [pc, #72]	; (8002fc8 <chSchReadyI+0x78>)
 8002f7e:	0018      	movs	r0, r3
 8002f80:	f7ff fb5e 	bl	8002640 <chSysHalt>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8002f84:	9b01      	ldr	r3, [sp, #4]
 8002f86:	2220      	movs	r2, #32
 8002f88:	2100      	movs	r1, #0
 8002f8a:	5499      	strb	r1, [r3, r2]
  cp = (thread_t *)&ch.rlist.queue;
 8002f8c:	4b0f      	ldr	r3, [pc, #60]	; (8002fcc <chSchReadyI+0x7c>)
 8002f8e:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->queue.next;
 8002f90:	9b03      	ldr	r3, [sp, #12]
 8002f92:	681b      	ldr	r3, [r3, #0]
 8002f94:	9303      	str	r3, [sp, #12]
  } while (cp->prio >= tp->prio);
 8002f96:	9b03      	ldr	r3, [sp, #12]
 8002f98:	689a      	ldr	r2, [r3, #8]
 8002f9a:	9b01      	ldr	r3, [sp, #4]
 8002f9c:	689b      	ldr	r3, [r3, #8]
 8002f9e:	429a      	cmp	r2, r3
 8002fa0:	d2f6      	bcs.n	8002f90 <chSchReadyI+0x40>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8002fa2:	9b01      	ldr	r3, [sp, #4]
 8002fa4:	9a03      	ldr	r2, [sp, #12]
 8002fa6:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 8002fa8:	9b03      	ldr	r3, [sp, #12]
 8002faa:	685a      	ldr	r2, [r3, #4]
 8002fac:	9b01      	ldr	r3, [sp, #4]
 8002fae:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8002fb0:	9b01      	ldr	r3, [sp, #4]
 8002fb2:	685b      	ldr	r3, [r3, #4]
 8002fb4:	9a01      	ldr	r2, [sp, #4]
 8002fb6:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 8002fb8:	9b03      	ldr	r3, [sp, #12]
 8002fba:	9a01      	ldr	r2, [sp, #4]
 8002fbc:	605a      	str	r2, [r3, #4]

  return tp;
 8002fbe:	9b01      	ldr	r3, [sp, #4]
}
 8002fc0:	0018      	movs	r0, r3
 8002fc2:	b005      	add	sp, #20
 8002fc4:	bd00      	pop	{pc}
 8002fc6:	46c0      	nop			; (mov r8, r8)
 8002fc8:	08003aa4 	.word	0x08003aa4
 8002fcc:	200004d8 	.word	0x200004d8

08002fd0 <chSchReadyAheadI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyAheadI(thread_t *tp) {
 8002fd0:	b500      	push	{lr}
 8002fd2:	b085      	sub	sp, #20
 8002fd4:	9001      	str	r0, [sp, #4]
  thread_t *cp;

  chDbgCheckClassI();
 8002fd6:	f7ff fc23 	bl	8002820 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8002fda:	9b01      	ldr	r3, [sp, #4]
 8002fdc:	2b00      	cmp	r3, #0
 8002fde:	d103      	bne.n	8002fe8 <chSchReadyAheadI+0x18>
 8002fe0:	4b19      	ldr	r3, [pc, #100]	; (8003048 <chSchReadyAheadI+0x78>)
 8002fe2:	0018      	movs	r0, r3
 8002fe4:	f7ff fb2c 	bl	8002640 <chSysHalt>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8002fe8:	9b01      	ldr	r3, [sp, #4]
 8002fea:	2220      	movs	r2, #32
 8002fec:	5c9b      	ldrb	r3, [r3, r2]
 8002fee:	2b00      	cmp	r3, #0
 8002ff0:	d004      	beq.n	8002ffc <chSchReadyAheadI+0x2c>
 8002ff2:	9b01      	ldr	r3, [sp, #4]
 8002ff4:	2220      	movs	r2, #32
 8002ff6:	5c9b      	ldrb	r3, [r3, r2]
 8002ff8:	2b0f      	cmp	r3, #15
 8002ffa:	d103      	bne.n	8003004 <chSchReadyAheadI+0x34>
 8002ffc:	4b12      	ldr	r3, [pc, #72]	; (8003048 <chSchReadyAheadI+0x78>)
 8002ffe:	0018      	movs	r0, r3
 8003000:	f7ff fb1e 	bl	8002640 <chSysHalt>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8003004:	9b01      	ldr	r3, [sp, #4]
 8003006:	2220      	movs	r2, #32
 8003008:	2100      	movs	r1, #0
 800300a:	5499      	strb	r1, [r3, r2]
  cp = (thread_t *)&ch.rlist.queue;
 800300c:	4b0f      	ldr	r3, [pc, #60]	; (800304c <chSchReadyAheadI+0x7c>)
 800300e:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->queue.next;
 8003010:	9b03      	ldr	r3, [sp, #12]
 8003012:	681b      	ldr	r3, [r3, #0]
 8003014:	9303      	str	r3, [sp, #12]
  } while (cp->prio > tp->prio);
 8003016:	9b03      	ldr	r3, [sp, #12]
 8003018:	689a      	ldr	r2, [r3, #8]
 800301a:	9b01      	ldr	r3, [sp, #4]
 800301c:	689b      	ldr	r3, [r3, #8]
 800301e:	429a      	cmp	r2, r3
 8003020:	d8f6      	bhi.n	8003010 <chSchReadyAheadI+0x40>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8003022:	9b01      	ldr	r3, [sp, #4]
 8003024:	9a03      	ldr	r2, [sp, #12]
 8003026:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 8003028:	9b03      	ldr	r3, [sp, #12]
 800302a:	685a      	ldr	r2, [r3, #4]
 800302c:	9b01      	ldr	r3, [sp, #4]
 800302e:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8003030:	9b01      	ldr	r3, [sp, #4]
 8003032:	685b      	ldr	r3, [r3, #4]
 8003034:	9a01      	ldr	r2, [sp, #4]
 8003036:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 8003038:	9b03      	ldr	r3, [sp, #12]
 800303a:	9a01      	ldr	r2, [sp, #4]
 800303c:	605a      	str	r2, [r3, #4]

  return tp;
 800303e:	9b01      	ldr	r3, [sp, #4]
}
 8003040:	0018      	movs	r0, r3
 8003042:	b005      	add	sp, #20
 8003044:	bd00      	pop	{pc}
 8003046:	46c0      	nop			; (mov r8, r8)
 8003048:	08003ab0 	.word	0x08003ab0
 800304c:	200004d8 	.word	0x200004d8

08003050 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8003050:	b510      	push	{r4, lr}
 8003052:	b084      	sub	sp, #16
 8003054:	0002      	movs	r2, r0
 8003056:	466b      	mov	r3, sp
 8003058:	3307      	adds	r3, #7
 800305a:	701a      	strb	r2, [r3, #0]
  thread_t *otp = currp;
 800305c:	4b1b      	ldr	r3, [pc, #108]	; (80030cc <chSchGoSleepS+0x7c>)
 800305e:	699b      	ldr	r3, [r3, #24]
 8003060:	9303      	str	r3, [sp, #12]

  chDbgCheckClassS();
 8003062:	f7ff fbf5 	bl	8002850 <chDbgCheckClassS>

  /* New state.*/
  otp->state = newstate;
 8003066:	9b03      	ldr	r3, [sp, #12]
 8003068:	466a      	mov	r2, sp
 800306a:	3207      	adds	r2, #7
 800306c:	2120      	movs	r1, #32
 800306e:	7812      	ldrb	r2, [r2, #0]
 8003070:	545a      	strb	r2, [r3, r1]
     time quantum when it will wakeup.*/
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8003072:	4b16      	ldr	r3, [pc, #88]	; (80030cc <chSchGoSleepS+0x7c>)
 8003074:	0018      	movs	r0, r3
 8003076:	f7ff fee3 	bl	8002e40 <queue_fifo_remove.lto_priv.219>
 800307a:	0002      	movs	r2, r0
 800307c:	4b13      	ldr	r3, [pc, #76]	; (80030cc <chSchGoSleepS+0x7c>)
 800307e:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 8003080:	4b12      	ldr	r3, [pc, #72]	; (80030cc <chSchGoSleepS+0x7c>)
 8003082:	699b      	ldr	r3, [r3, #24]
 8003084:	2220      	movs	r2, #32
 8003086:	2101      	movs	r1, #1
 8003088:	5499      	strb	r1, [r3, r2]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800308a:	4b10      	ldr	r3, [pc, #64]	; (80030cc <chSchGoSleepS+0x7c>)
 800308c:	699b      	ldr	r3, [r3, #24]
 800308e:	9a03      	ldr	r2, [sp, #12]
 8003090:	0011      	movs	r1, r2
 8003092:	0018      	movs	r0, r3
 8003094:	f7ff fc7c 	bl	8002990 <_trace_switch>
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8003098:	f3ef 8309 	mrs	r3, PSP
 800309c:	001c      	movs	r4, r3
  return(result);
 800309e:	0023      	movs	r3, r4
 80030a0:	9302      	str	r3, [sp, #8]
 80030a2:	9b02      	ldr	r3, [sp, #8]
 80030a4:	3b24      	subs	r3, #36	; 0x24
 80030a6:	001a      	movs	r2, r3
 80030a8:	9b03      	ldr	r3, [sp, #12]
 80030aa:	69db      	ldr	r3, [r3, #28]
 80030ac:	429a      	cmp	r2, r3
 80030ae:	d203      	bcs.n	80030b8 <chSchGoSleepS+0x68>
 80030b0:	4b07      	ldr	r3, [pc, #28]	; (80030d0 <chSchGoSleepS+0x80>)
 80030b2:	0018      	movs	r0, r3
 80030b4:	f7ff fac4 	bl	8002640 <chSysHalt>
 80030b8:	4b04      	ldr	r3, [pc, #16]	; (80030cc <chSchGoSleepS+0x7c>)
 80030ba:	699b      	ldr	r3, [r3, #24]
 80030bc:	9a03      	ldr	r2, [sp, #12]
 80030be:	0011      	movs	r1, r2
 80030c0:	0018      	movs	r0, r3
 80030c2:	f7fd f865 	bl	8000190 <_port_switch>
}
 80030c6:	b004      	add	sp, #16
 80030c8:	bd10      	pop	{r4, pc}
 80030ca:	46c0      	nop			; (mov r8, r8)
 80030cc:	200004d8 	.word	0x200004d8
 80030d0:	08003da8 	.word	0x08003da8
	...

080030e0 <wakeup>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 80030e0:	b500      	push	{lr}
 80030e2:	b085      	sub	sp, #20
 80030e4:	9001      	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
 80030e6:	9b01      	ldr	r3, [sp, #4]
 80030e8:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
 80030ea:	f7ff fee9 	bl	8002ec0 <chSysLockFromISR.lto_priv.247>
  switch (tp->state) {
 80030ee:	9b03      	ldr	r3, [sp, #12]
 80030f0:	2220      	movs	r2, #32
 80030f2:	5c9b      	ldrb	r3, [r3, r2]
 80030f4:	2b07      	cmp	r3, #7
 80030f6:	d815      	bhi.n	8003124 <wakeup+0x44>
 80030f8:	009a      	lsls	r2, r3, #2
 80030fa:	4b10      	ldr	r3, [pc, #64]	; (800313c <wakeup+0x5c>)
 80030fc:	18d3      	adds	r3, r2, r3
 80030fe:	681b      	ldr	r3, [r3, #0]
 8003100:	469f      	mov	pc, r3
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 8003102:	f7ff fee5 	bl	8002ed0 <chSysUnlockFromISR.lto_priv.245>
 8003106:	e017      	b.n	8003138 <wakeup+0x58>
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 8003108:	9b03      	ldr	r3, [sp, #12]
 800310a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800310c:	2200      	movs	r2, #0
 800310e:	601a      	str	r2, [r3, #0]
 8003110:	e008      	b.n	8003124 <wakeup+0x44>
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 8003112:	9b03      	ldr	r3, [sp, #12]
 8003114:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003116:	0018      	movs	r0, r3
 8003118:	f7ff fef2 	bl	8002f00 <chSemFastSignalI>
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
 800311c:	9b03      	ldr	r3, [sp, #12]
 800311e:	0018      	movs	r0, r3
 8003120:	f7ff fea6 	bl	8002e70 <queue_dequeue>
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 8003124:	9b03      	ldr	r3, [sp, #12]
 8003126:	2201      	movs	r2, #1
 8003128:	4252      	negs	r2, r2
 800312a:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 800312c:	9b03      	ldr	r3, [sp, #12]
 800312e:	0018      	movs	r0, r3
 8003130:	f7ff ff0e 	bl	8002f50 <chSchReadyI>
  chSysUnlockFromISR();
 8003134:	f7ff fecc 	bl	8002ed0 <chSysUnlockFromISR.lto_priv.245>
}
 8003138:	b005      	add	sp, #20
 800313a:	bd00      	pop	{pc}
 800313c:	08003db8 	.word	0x08003db8

08003140 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8003140:	b500      	push	{lr}
 8003142:	b089      	sub	sp, #36	; 0x24
 8003144:	0002      	movs	r2, r0
 8003146:	9100      	str	r1, [sp, #0]
 8003148:	466b      	mov	r3, sp
 800314a:	3307      	adds	r3, #7
 800314c:	701a      	strb	r2, [r3, #0]

  chDbgCheckClassS();
 800314e:	f7ff fb7f 	bl	8002850 <chDbgCheckClassS>

  if (TIME_INFINITE != time) {
 8003152:	9b00      	ldr	r3, [sp, #0]
 8003154:	3301      	adds	r3, #1
 8003156:	d017      	beq.n	8003188 <chSchGoSleepTimeoutS+0x48>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8003158:	4b11      	ldr	r3, [pc, #68]	; (80031a0 <chSchGoSleepTimeoutS+0x60>)
 800315a:	699b      	ldr	r3, [r3, #24]
 800315c:	4a11      	ldr	r2, [pc, #68]	; (80031a4 <chSchGoSleepTimeoutS+0x64>)
 800315e:	9900      	ldr	r1, [sp, #0]
 8003160:	a803      	add	r0, sp, #12
 8003162:	f7ff fd1d 	bl	8002ba0 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8003166:	466b      	mov	r3, sp
 8003168:	3307      	adds	r3, #7
 800316a:	781b      	ldrb	r3, [r3, #0]
 800316c:	0018      	movs	r0, r3
 800316e:	f7ff ff6f 	bl	8003050 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8003172:	ab03      	add	r3, sp, #12
 8003174:	0018      	movs	r0, r3
 8003176:	f7ff feb3 	bl	8002ee0 <chVTIsArmedI>
 800317a:	1e03      	subs	r3, r0, #0
 800317c:	d00a      	beq.n	8003194 <chSchGoSleepTimeoutS+0x54>
      chVTDoResetI(&vt);
 800317e:	ab03      	add	r3, sp, #12
 8003180:	0018      	movs	r0, r3
 8003182:	f7ff fdad 	bl	8002ce0 <chVTDoResetI>
 8003186:	e005      	b.n	8003194 <chSchGoSleepTimeoutS+0x54>
    }
  }
  else {
    chSchGoSleepS(newstate);
 8003188:	466b      	mov	r3, sp
 800318a:	3307      	adds	r3, #7
 800318c:	781b      	ldrb	r3, [r3, #0]
 800318e:	0018      	movs	r0, r3
 8003190:	f7ff ff5e 	bl	8003050 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
 8003194:	4b02      	ldr	r3, [pc, #8]	; (80031a0 <chSchGoSleepTimeoutS+0x60>)
 8003196:	699b      	ldr	r3, [r3, #24]
 8003198:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 800319a:	0018      	movs	r0, r3
 800319c:	b009      	add	sp, #36	; 0x24
 800319e:	bd00      	pop	{pc}
 80031a0:	200004d8 	.word	0x200004d8
 80031a4:	080030e1 	.word	0x080030e1
	...

080031b0 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 80031b0:	b510      	push	{r4, lr}
 80031b2:	b084      	sub	sp, #16
 80031b4:	9001      	str	r0, [sp, #4]
 80031b6:	9100      	str	r1, [sp, #0]
  thread_t *otp = currp;
 80031b8:	4b27      	ldr	r3, [pc, #156]	; (8003258 <chSchWakeupS+0xa8>)
 80031ba:	699b      	ldr	r3, [r3, #24]
 80031bc:	9303      	str	r3, [sp, #12]

  chDbgCheckClassS();
 80031be:	f7ff fb47 	bl	8002850 <chDbgCheckClassS>

  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80031c2:	4b25      	ldr	r3, [pc, #148]	; (8003258 <chSchWakeupS+0xa8>)
 80031c4:	681a      	ldr	r2, [r3, #0]
 80031c6:	4b24      	ldr	r3, [pc, #144]	; (8003258 <chSchWakeupS+0xa8>)
 80031c8:	429a      	cmp	r2, r3
 80031ca:	d00b      	beq.n	80031e4 <chSchWakeupS+0x34>
 80031cc:	4b22      	ldr	r3, [pc, #136]	; (8003258 <chSchWakeupS+0xa8>)
 80031ce:	699b      	ldr	r3, [r3, #24]
 80031d0:	689a      	ldr	r2, [r3, #8]
 80031d2:	4b21      	ldr	r3, [pc, #132]	; (8003258 <chSchWakeupS+0xa8>)
 80031d4:	681b      	ldr	r3, [r3, #0]
 80031d6:	689b      	ldr	r3, [r3, #8]
 80031d8:	429a      	cmp	r2, r3
 80031da:	d203      	bcs.n	80031e4 <chSchWakeupS+0x34>
 80031dc:	4b1f      	ldr	r3, [pc, #124]	; (800325c <chSchWakeupS+0xac>)
 80031de:	0018      	movs	r0, r3
 80031e0:	f7ff fa2e 	bl	8002640 <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 80031e4:	9b01      	ldr	r3, [sp, #4]
 80031e6:	9a00      	ldr	r2, [sp, #0]
 80031e8:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 80031ea:	9b01      	ldr	r3, [sp, #4]
 80031ec:	689a      	ldr	r2, [r3, #8]
 80031ee:	9b03      	ldr	r3, [sp, #12]
 80031f0:	689b      	ldr	r3, [r3, #8]
 80031f2:	429a      	cmp	r2, r3
 80031f4:	d804      	bhi.n	8003200 <chSchWakeupS+0x50>
    (void) chSchReadyI(ntp);
 80031f6:	9b01      	ldr	r3, [sp, #4]
 80031f8:	0018      	movs	r0, r3
 80031fa:	f7ff fea9 	bl	8002f50 <chSchReadyI>
 80031fe:	e028      	b.n	8003252 <chSchWakeupS+0xa2>
  }
  else {
    otp = chSchReadyI(otp);
 8003200:	9b03      	ldr	r3, [sp, #12]
 8003202:	0018      	movs	r0, r3
 8003204:	f7ff fea4 	bl	8002f50 <chSchReadyI>
 8003208:	0003      	movs	r3, r0
 800320a:	9303      	str	r3, [sp, #12]
    if (otp->prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
 800320c:	4b12      	ldr	r3, [pc, #72]	; (8003258 <chSchWakeupS+0xa8>)
 800320e:	9a01      	ldr	r2, [sp, #4]
 8003210:	619a      	str	r2, [r3, #24]
    ntp->state = CH_STATE_CURRENT;
 8003212:	9b01      	ldr	r3, [sp, #4]
 8003214:	2220      	movs	r2, #32
 8003216:	2101      	movs	r1, #1
 8003218:	5499      	strb	r1, [r3, r2]

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 800321a:	9a03      	ldr	r2, [sp, #12]
 800321c:	9b01      	ldr	r3, [sp, #4]
 800321e:	0011      	movs	r1, r2
 8003220:	0018      	movs	r0, r3
 8003222:	f7ff fbb5 	bl	8002990 <_trace_switch>
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8003226:	f3ef 8309 	mrs	r3, PSP
 800322a:	001c      	movs	r4, r3
  return(result);
 800322c:	0023      	movs	r3, r4
 800322e:	9302      	str	r3, [sp, #8]
 8003230:	9b02      	ldr	r3, [sp, #8]
 8003232:	3b24      	subs	r3, #36	; 0x24
 8003234:	001a      	movs	r2, r3
 8003236:	9b03      	ldr	r3, [sp, #12]
 8003238:	69db      	ldr	r3, [r3, #28]
 800323a:	429a      	cmp	r2, r3
 800323c:	d203      	bcs.n	8003246 <chSchWakeupS+0x96>
 800323e:	4b08      	ldr	r3, [pc, #32]	; (8003260 <chSchWakeupS+0xb0>)
 8003240:	0018      	movs	r0, r3
 8003242:	f7ff f9fd 	bl	8002640 <chSysHalt>
 8003246:	9a03      	ldr	r2, [sp, #12]
 8003248:	9b01      	ldr	r3, [sp, #4]
 800324a:	0011      	movs	r1, r2
 800324c:	0018      	movs	r0, r3
 800324e:	f7fc ff9f 	bl	8000190 <_port_switch>
  }
}
 8003252:	b004      	add	sp, #16
 8003254:	bd10      	pop	{r4, pc}
 8003256:	46c0      	nop			; (mov r8, r8)
 8003258:	200004d8 	.word	0x200004d8
 800325c:	08003ac4 	.word	0x08003ac4
 8003260:	08003da8 	.word	0x08003da8
	...

08003270 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 8003270:	b510      	push	{r4, lr}

  chDbgCheckClassS();
 8003272:	f7ff faed 	bl	8002850 <chDbgCheckClassS>

  if (chSchIsRescRequiredI()) {
 8003276:	f7ff fe0b 	bl	8002e90 <chSchIsRescRequiredI>
 800327a:	1e03      	subs	r3, r0, #0
 800327c:	d001      	beq.n	8003282 <chSchRescheduleS+0x12>
    chSchDoRescheduleAhead();
 800327e:	f000 f81f 	bl	80032c0 <chSchDoRescheduleAhead>
  }
}
 8003282:	bd10      	pop	{r4, pc}
	...

08003290 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 8003290:	b082      	sub	sp, #8
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8003292:	4b08      	ldr	r3, [pc, #32]	; (80032b4 <chSchIsPreemptionRequired+0x24>)
 8003294:	681b      	ldr	r3, [r3, #0]
 8003296:	689b      	ldr	r3, [r3, #8]
 8003298:	9301      	str	r3, [sp, #4]
  tprio_t p2 = currp->prio;
 800329a:	4b06      	ldr	r3, [pc, #24]	; (80032b4 <chSchIsPreemptionRequired+0x24>)
 800329c:	699b      	ldr	r3, [r3, #24]
 800329e:	689b      	ldr	r3, [r3, #8]
 80032a0:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 80032a2:	9b01      	ldr	r3, [sp, #4]
 80032a4:	9a00      	ldr	r2, [sp, #0]
 80032a6:	429a      	cmp	r2, r3
 80032a8:	419b      	sbcs	r3, r3
 80032aa:	425b      	negs	r3, r3
 80032ac:	b2db      	uxtb	r3, r3
#endif
}
 80032ae:	0018      	movs	r0, r3
 80032b0:	b002      	add	sp, #8
 80032b2:	4770      	bx	lr
 80032b4:	200004d8 	.word	0x200004d8
	...

080032c0 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 80032c0:	b510      	push	{r4, lr}
 80032c2:	b082      	sub	sp, #8
  thread_t *otp = currp;
 80032c4:	4b1a      	ldr	r3, [pc, #104]	; (8003330 <chSchDoRescheduleAhead+0x70>)
 80032c6:	699b      	ldr	r3, [r3, #24]
 80032c8:	9301      	str	r3, [sp, #4]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 80032ca:	4b19      	ldr	r3, [pc, #100]	; (8003330 <chSchDoRescheduleAhead+0x70>)
 80032cc:	0018      	movs	r0, r3
 80032ce:	f7ff fdb7 	bl	8002e40 <queue_fifo_remove.lto_priv.219>
 80032d2:	0002      	movs	r2, r0
 80032d4:	4b16      	ldr	r3, [pc, #88]	; (8003330 <chSchDoRescheduleAhead+0x70>)
 80032d6:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 80032d8:	4b15      	ldr	r3, [pc, #84]	; (8003330 <chSchDoRescheduleAhead+0x70>)
 80032da:	699b      	ldr	r3, [r3, #24]
 80032dc:	2220      	movs	r2, #32
 80032de:	2101      	movs	r1, #1
 80032e0:	5499      	strb	r1, [r3, r2]
  if (otp->prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);
 80032e2:	9b01      	ldr	r3, [sp, #4]
 80032e4:	0018      	movs	r0, r3
 80032e6:	f7ff fe73 	bl	8002fd0 <chSchReadyAheadI>
 80032ea:	0003      	movs	r3, r0
 80032ec:	9301      	str	r3, [sp, #4]

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 80032ee:	4b10      	ldr	r3, [pc, #64]	; (8003330 <chSchDoRescheduleAhead+0x70>)
 80032f0:	699b      	ldr	r3, [r3, #24]
 80032f2:	9a01      	ldr	r2, [sp, #4]
 80032f4:	0011      	movs	r1, r2
 80032f6:	0018      	movs	r0, r3
 80032f8:	f7ff fb4a 	bl	8002990 <_trace_switch>
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80032fc:	f3ef 8309 	mrs	r3, PSP
 8003300:	001c      	movs	r4, r3
  return(result);
 8003302:	0023      	movs	r3, r4
 8003304:	9300      	str	r3, [sp, #0]
 8003306:	9b00      	ldr	r3, [sp, #0]
 8003308:	3b24      	subs	r3, #36	; 0x24
 800330a:	001a      	movs	r2, r3
 800330c:	9b01      	ldr	r3, [sp, #4]
 800330e:	69db      	ldr	r3, [r3, #28]
 8003310:	429a      	cmp	r2, r3
 8003312:	d203      	bcs.n	800331c <chSchDoRescheduleAhead+0x5c>
 8003314:	4b07      	ldr	r3, [pc, #28]	; (8003334 <chSchDoRescheduleAhead+0x74>)
 8003316:	0018      	movs	r0, r3
 8003318:	f7ff f992 	bl	8002640 <chSysHalt>
 800331c:	4b04      	ldr	r3, [pc, #16]	; (8003330 <chSchDoRescheduleAhead+0x70>)
 800331e:	699b      	ldr	r3, [r3, #24]
 8003320:	9a01      	ldr	r2, [sp, #4]
 8003322:	0011      	movs	r1, r2
 8003324:	0018      	movs	r0, r3
 8003326:	f7fc ff33 	bl	8000190 <_port_switch>
}
 800332a:	b002      	add	sp, #8
 800332c:	bd10      	pop	{r4, pc}
 800332e:	46c0      	nop			; (mov r8, r8)
 8003330:	200004d8 	.word	0x200004d8
 8003334:	08003da8 	.word	0x08003da8
	...

08003340 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8003340:	b510      	push	{r4, lr}
 8003342:	b082      	sub	sp, #8
  thread_t *otp = currp;
 8003344:	4b1a      	ldr	r3, [pc, #104]	; (80033b0 <chSchDoReschedule+0x70>)
 8003346:	699b      	ldr	r3, [r3, #24]
 8003348:	9301      	str	r3, [sp, #4]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800334a:	4b19      	ldr	r3, [pc, #100]	; (80033b0 <chSchDoReschedule+0x70>)
 800334c:	0018      	movs	r0, r3
 800334e:	f7ff fd77 	bl	8002e40 <queue_fifo_remove.lto_priv.219>
 8003352:	0002      	movs	r2, r0
 8003354:	4b16      	ldr	r3, [pc, #88]	; (80033b0 <chSchDoReschedule+0x70>)
 8003356:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 8003358:	4b15      	ldr	r3, [pc, #84]	; (80033b0 <chSchDoReschedule+0x70>)
 800335a:	699b      	ldr	r3, [r3, #24]
 800335c:	2220      	movs	r2, #32
 800335e:	2101      	movs	r1, #1
 8003360:	5499      	strb	r1, [r3, r2]
    otp = chSchReadyAheadI(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
 8003362:	9b01      	ldr	r3, [sp, #4]
 8003364:	0018      	movs	r0, r3
 8003366:	f7ff fe33 	bl	8002fd0 <chSchReadyAheadI>
 800336a:	0003      	movs	r3, r0
 800336c:	9301      	str	r3, [sp, #4]
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800336e:	4b10      	ldr	r3, [pc, #64]	; (80033b0 <chSchDoReschedule+0x70>)
 8003370:	699b      	ldr	r3, [r3, #24]
 8003372:	9a01      	ldr	r2, [sp, #4]
 8003374:	0011      	movs	r1, r2
 8003376:	0018      	movs	r0, r3
 8003378:	f7ff fb0a 	bl	8002990 <_trace_switch>
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800337c:	f3ef 8309 	mrs	r3, PSP
 8003380:	001c      	movs	r4, r3
  return(result);
 8003382:	0023      	movs	r3, r4
 8003384:	9300      	str	r3, [sp, #0]
 8003386:	9b00      	ldr	r3, [sp, #0]
 8003388:	3b24      	subs	r3, #36	; 0x24
 800338a:	001a      	movs	r2, r3
 800338c:	9b01      	ldr	r3, [sp, #4]
 800338e:	69db      	ldr	r3, [r3, #28]
 8003390:	429a      	cmp	r2, r3
 8003392:	d203      	bcs.n	800339c <chSchDoReschedule+0x5c>
 8003394:	4b07      	ldr	r3, [pc, #28]	; (80033b4 <chSchDoReschedule+0x74>)
 8003396:	0018      	movs	r0, r3
 8003398:	f7ff f952 	bl	8002640 <chSysHalt>
 800339c:	4b04      	ldr	r3, [pc, #16]	; (80033b0 <chSchDoReschedule+0x70>)
 800339e:	699b      	ldr	r3, [r3, #24]
 80033a0:	9a01      	ldr	r2, [sp, #4]
 80033a2:	0011      	movs	r1, r2
 80033a4:	0018      	movs	r0, r3
 80033a6:	f7fc fef3 	bl	8000190 <_port_switch>
}
 80033aa:	b002      	add	sp, #8
 80033ac:	bd10      	pop	{r4, pc}
 80033ae:	46c0      	nop			; (mov r8, r8)
 80033b0:	200004d8 	.word	0x200004d8
 80033b4:	08003da8 	.word	0x08003da8
	...

080033c0 <port_lock.lto_priv.240>:
  __ASM volatile ("cpsid i" : : : "memory");
 80033c0:	b672      	cpsid	i
}
 80033c2:	4770      	bx	lr
	...

080033d0 <port_unlock.lto_priv.235>:
  __ASM volatile ("cpsie i" : : : "memory");
 80033d0:	b662      	cpsie	i
}
 80033d2:	4770      	bx	lr
	...

080033e0 <list_init>:
static inline void list_init(threads_list_t *tlp) {
 80033e0:	b082      	sub	sp, #8
 80033e2:	9001      	str	r0, [sp, #4]
  tlp->next = (thread_t *)tlp;
 80033e4:	9b01      	ldr	r3, [sp, #4]
 80033e6:	9a01      	ldr	r2, [sp, #4]
 80033e8:	601a      	str	r2, [r3, #0]
}
 80033ea:	b002      	add	sp, #8
 80033ec:	4770      	bx	lr
 80033ee:	46c0      	nop			; (mov r8, r8)

080033f0 <list_notempty>:
static inline bool list_notempty(threads_list_t *tlp) {
 80033f0:	b082      	sub	sp, #8
 80033f2:	9001      	str	r0, [sp, #4]
  return (bool)(tlp->next != (thread_t *)tlp);
 80033f4:	9b01      	ldr	r3, [sp, #4]
 80033f6:	681a      	ldr	r2, [r3, #0]
 80033f8:	9b01      	ldr	r3, [sp, #4]
 80033fa:	1ad3      	subs	r3, r2, r3
 80033fc:	1e5a      	subs	r2, r3, #1
 80033fe:	4193      	sbcs	r3, r2
 8003400:	b2db      	uxtb	r3, r3
}
 8003402:	0018      	movs	r0, r3
 8003404:	b002      	add	sp, #8
 8003406:	4770      	bx	lr
	...

08003410 <queue_init.lto_priv.222>:
static inline void queue_init(threads_queue_t *tqp) {
 8003410:	b082      	sub	sp, #8
 8003412:	9001      	str	r0, [sp, #4]
  tqp->next = (thread_t *)tqp;
 8003414:	9b01      	ldr	r3, [sp, #4]
 8003416:	9a01      	ldr	r2, [sp, #4]
 8003418:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800341a:	9b01      	ldr	r3, [sp, #4]
 800341c:	9a01      	ldr	r2, [sp, #4]
 800341e:	605a      	str	r2, [r3, #4]
}
 8003420:	b002      	add	sp, #8
 8003422:	4770      	bx	lr
	...

08003430 <queue_notempty.lto_priv.186>:
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8003430:	b082      	sub	sp, #8
 8003432:	9001      	str	r0, [sp, #4]
  return (bool)(tqp->next != (const thread_t *)tqp);
 8003434:	9b01      	ldr	r3, [sp, #4]
 8003436:	681a      	ldr	r2, [r3, #0]
 8003438:	9b01      	ldr	r3, [sp, #4]
 800343a:	1ad3      	subs	r3, r2, r3
 800343c:	1e5a      	subs	r2, r3, #1
 800343e:	4193      	sbcs	r3, r2
 8003440:	b2db      	uxtb	r3, r3
}
 8003442:	0018      	movs	r0, r3
 8003444:	b002      	add	sp, #8
 8003446:	4770      	bx	lr
	...

08003450 <list_remove>:
static inline thread_t *list_remove(threads_list_t *tlp) {
 8003450:	b084      	sub	sp, #16
 8003452:	9001      	str	r0, [sp, #4]
  thread_t *tp = tlp->next;
 8003454:	9b01      	ldr	r3, [sp, #4]
 8003456:	681b      	ldr	r3, [r3, #0]
 8003458:	9303      	str	r3, [sp, #12]
  tlp->next = tp->queue.next;
 800345a:	9b03      	ldr	r3, [sp, #12]
 800345c:	681a      	ldr	r2, [r3, #0]
 800345e:	9b01      	ldr	r3, [sp, #4]
 8003460:	601a      	str	r2, [r3, #0]
  return tp;
 8003462:	9b03      	ldr	r3, [sp, #12]
}
 8003464:	0018      	movs	r0, r3
 8003466:	b004      	add	sp, #16
 8003468:	4770      	bx	lr
 800346a:	46c0      	nop			; (mov r8, r8)
 800346c:	0000      	movs	r0, r0
	...

08003470 <queue_insert.lto_priv.198>:
static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 8003470:	b082      	sub	sp, #8
 8003472:	9001      	str	r0, [sp, #4]
 8003474:	9100      	str	r1, [sp, #0]
  tp->queue.next             = (thread_t *)tqp;
 8003476:	9b01      	ldr	r3, [sp, #4]
 8003478:	9a00      	ldr	r2, [sp, #0]
 800347a:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = tqp->prev;
 800347c:	9b00      	ldr	r3, [sp, #0]
 800347e:	685a      	ldr	r2, [r3, #4]
 8003480:	9b01      	ldr	r3, [sp, #4]
 8003482:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8003484:	9b01      	ldr	r3, [sp, #4]
 8003486:	685b      	ldr	r3, [r3, #4]
 8003488:	9a01      	ldr	r2, [sp, #4]
 800348a:	601a      	str	r2, [r3, #0]
  tqp->prev                  = tp;
 800348c:	9b00      	ldr	r3, [sp, #0]
 800348e:	9a01      	ldr	r2, [sp, #4]
 8003490:	605a      	str	r2, [r3, #4]
}
 8003492:	b002      	add	sp, #8
 8003494:	4770      	bx	lr
 8003496:	46c0      	nop			; (mov r8, r8)
	...

080034a0 <queue_fifo_remove.lto_priv.220>:
static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 80034a0:	b084      	sub	sp, #16
 80034a2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
 80034a4:	9b01      	ldr	r3, [sp, #4]
 80034a6:	681b      	ldr	r3, [r3, #0]
 80034a8:	9303      	str	r3, [sp, #12]
  tqp->next             = tp->queue.next;
 80034aa:	9b03      	ldr	r3, [sp, #12]
 80034ac:	681a      	ldr	r2, [r3, #0]
 80034ae:	9b01      	ldr	r3, [sp, #4]
 80034b0:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 80034b2:	9b01      	ldr	r3, [sp, #4]
 80034b4:	681b      	ldr	r3, [r3, #0]
 80034b6:	9a01      	ldr	r2, [sp, #4]
 80034b8:	605a      	str	r2, [r3, #4]
  return tp;
 80034ba:	9b03      	ldr	r3, [sp, #12]
}
 80034bc:	0018      	movs	r0, r3
 80034be:	b004      	add	sp, #16
 80034c0:	4770      	bx	lr
 80034c2:	46c0      	nop			; (mov r8, r8)
	...

080034d0 <chSysLock.lto_priv.176>:
static inline void chSysLock(void) {
 80034d0:	b510      	push	{r4, lr}
  port_lock();
 80034d2:	f7ff ff75 	bl	80033c0 <port_lock.lto_priv.240>
  _dbg_check_lock();
 80034d6:	f7ff f903 	bl	80026e0 <_dbg_check_lock>
}
 80034da:	bd10      	pop	{r4, pc}
 80034dc:	0000      	movs	r0, r0
	...

080034e0 <chSysUnlock.lto_priv.171>:
static inline void chSysUnlock(void) {
 80034e0:	b510      	push	{r4, lr}
  _dbg_check_unlock();
 80034e2:	f7ff f915 	bl	8002710 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80034e6:	4b0a      	ldr	r3, [pc, #40]	; (8003510 <chSysUnlock.lto_priv.171+0x30>)
 80034e8:	681a      	ldr	r2, [r3, #0]
 80034ea:	4b09      	ldr	r3, [pc, #36]	; (8003510 <chSysUnlock.lto_priv.171+0x30>)
 80034ec:	429a      	cmp	r2, r3
 80034ee:	d00b      	beq.n	8003508 <chSysUnlock.lto_priv.171+0x28>
 80034f0:	4b07      	ldr	r3, [pc, #28]	; (8003510 <chSysUnlock.lto_priv.171+0x30>)
 80034f2:	699b      	ldr	r3, [r3, #24]
 80034f4:	689a      	ldr	r2, [r3, #8]
 80034f6:	4b06      	ldr	r3, [pc, #24]	; (8003510 <chSysUnlock.lto_priv.171+0x30>)
 80034f8:	681b      	ldr	r3, [r3, #0]
 80034fa:	689b      	ldr	r3, [r3, #8]
 80034fc:	429a      	cmp	r2, r3
 80034fe:	d203      	bcs.n	8003508 <chSysUnlock.lto_priv.171+0x28>
 8003500:	4b04      	ldr	r3, [pc, #16]	; (8003514 <chSysUnlock.lto_priv.171+0x34>)
 8003502:	0018      	movs	r0, r3
 8003504:	f7ff f89c 	bl	8002640 <chSysHalt>
  port_unlock();
 8003508:	f7ff ff62 	bl	80033d0 <port_unlock.lto_priv.235>
}
 800350c:	bd10      	pop	{r4, pc}
 800350e:	46c0      	nop			; (mov r8, r8)
 8003510:	200004d8 	.word	0x200004d8
 8003514:	08003aec 	.word	0x08003aec
	...

08003520 <chThdGetWorkingAreaX>:
static inline stkalign_t *chThdGetWorkingAreaX(thread_t *tp) {
 8003520:	b082      	sub	sp, #8
 8003522:	9001      	str	r0, [sp, #4]
  return tp->wabase;
 8003524:	9b01      	ldr	r3, [sp, #4]
 8003526:	69db      	ldr	r3, [r3, #28]
}
 8003528:	0018      	movs	r0, r3
 800352a:	b002      	add	sp, #8
 800352c:	4770      	bx	lr
 800352e:	46c0      	nop			; (mov r8, r8)

08003530 <chThdSleepS>:
static inline void chThdSleepS(systime_t time) {
 8003530:	b500      	push	{lr}
 8003532:	b083      	sub	sp, #12
 8003534:	9001      	str	r0, [sp, #4]
  chDbgCheck(time != TIME_IMMEDIATE);
 8003536:	9b01      	ldr	r3, [sp, #4]
 8003538:	2b00      	cmp	r3, #0
 800353a:	d103      	bne.n	8003544 <chThdSleepS+0x14>
 800353c:	4b05      	ldr	r3, [pc, #20]	; (8003554 <chThdSleepS+0x24>)
 800353e:	0018      	movs	r0, r3
 8003540:	f7ff f87e 	bl	8002640 <chSysHalt>
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8003544:	9b01      	ldr	r3, [sp, #4]
 8003546:	0019      	movs	r1, r3
 8003548:	2008      	movs	r0, #8
 800354a:	f7ff fdf9 	bl	8003140 <chSchGoSleepTimeoutS>
}
 800354e:	b003      	add	sp, #12
 8003550:	bd00      	pop	{pc}
 8003552:	46c0      	nop			; (mov r8, r8)
 8003554:	08003b34 	.word	0x08003b34
	...

08003560 <chThdDoDequeueNextI.lto_priv.201>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8003560:	b500      	push	{lr}
 8003562:	b085      	sub	sp, #20
 8003564:	9001      	str	r0, [sp, #4]
 8003566:	9100      	str	r1, [sp, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");
 8003568:	9b01      	ldr	r3, [sp, #4]
 800356a:	0018      	movs	r0, r3
 800356c:	f7ff ff60 	bl	8003430 <queue_notempty.lto_priv.186>
 8003570:	0003      	movs	r3, r0
 8003572:	001a      	movs	r2, r3
 8003574:	2301      	movs	r3, #1
 8003576:	4053      	eors	r3, r2
 8003578:	b2db      	uxtb	r3, r3
 800357a:	2b00      	cmp	r3, #0
 800357c:	d003      	beq.n	8003586 <chThdDoDequeueNextI.lto_priv.201+0x26>
 800357e:	4b0e      	ldr	r3, [pc, #56]	; (80035b8 <chThdDoDequeueNextI.lto_priv.201+0x58>)
 8003580:	0018      	movs	r0, r3
 8003582:	f7ff f85d 	bl	8002640 <chSysHalt>

  tp = queue_fifo_remove(tqp);
 8003586:	9b01      	ldr	r3, [sp, #4]
 8003588:	0018      	movs	r0, r3
 800358a:	f7ff ff89 	bl	80034a0 <queue_fifo_remove.lto_priv.220>
 800358e:	0003      	movs	r3, r0
 8003590:	9303      	str	r3, [sp, #12]

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 8003592:	9b03      	ldr	r3, [sp, #12]
 8003594:	2220      	movs	r2, #32
 8003596:	5c9b      	ldrb	r3, [r3, r2]
 8003598:	2b04      	cmp	r3, #4
 800359a:	d003      	beq.n	80035a4 <chThdDoDequeueNextI.lto_priv.201+0x44>
 800359c:	4b06      	ldr	r3, [pc, #24]	; (80035b8 <chThdDoDequeueNextI.lto_priv.201+0x58>)
 800359e:	0018      	movs	r0, r3
 80035a0:	f7ff f84e 	bl	8002640 <chSysHalt>

  tp->u.rdymsg = msg;
 80035a4:	9b03      	ldr	r3, [sp, #12]
 80035a6:	9a00      	ldr	r2, [sp, #0]
 80035a8:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 80035aa:	9b03      	ldr	r3, [sp, #12]
 80035ac:	0018      	movs	r0, r3
 80035ae:	f7ff fccf 	bl	8002f50 <chSchReadyI>
}
 80035b2:	b005      	add	sp, #20
 80035b4:	bd00      	pop	{pc}
 80035b6:	46c0      	nop			; (mov r8, r8)
 80035b8:	08003b40 	.word	0x08003b40
 80035bc:	00000000 	.word	0x00000000

080035c0 <_thread_init>:
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {
 80035c0:	b500      	push	{lr}
 80035c2:	b085      	sub	sp, #20
 80035c4:	9003      	str	r0, [sp, #12]
 80035c6:	9102      	str	r1, [sp, #8]
 80035c8:	9201      	str	r2, [sp, #4]
  tp->prio      = prio;
 80035ca:	9b03      	ldr	r3, [sp, #12]
 80035cc:	9a01      	ldr	r2, [sp, #4]
 80035ce:	609a      	str	r2, [r3, #8]
  tp->state     = CH_STATE_WTSTART;
 80035d0:	9b03      	ldr	r3, [sp, #12]
 80035d2:	2220      	movs	r2, #32
 80035d4:	2102      	movs	r1, #2
 80035d6:	5499      	strb	r1, [r3, r2]
  tp->flags     = CH_FLAG_MODE_STATIC;
 80035d8:	9b03      	ldr	r3, [sp, #12]
 80035da:	2221      	movs	r2, #33	; 0x21
 80035dc:	2100      	movs	r1, #0
 80035de:	5499      	strb	r1, [r3, r2]
  tp->realprio  = prio;
 80035e0:	9b03      	ldr	r3, [sp, #12]
 80035e2:	9a01      	ldr	r2, [sp, #4]
 80035e4:	63da      	str	r2, [r3, #60]	; 0x3c
  tp->mtxlist   = NULL;
 80035e6:	9b03      	ldr	r3, [sp, #12]
 80035e8:	2200      	movs	r2, #0
 80035ea:	639a      	str	r2, [r3, #56]	; 0x38
  tp->epending  = (eventmask_t)0;
 80035ec:	9b03      	ldr	r3, [sp, #12]
 80035ee:	2200      	movs	r2, #0
 80035f0:	635a      	str	r2, [r3, #52]	; 0x34
  tp->refs      = (trefs_t)1;
 80035f2:	9b03      	ldr	r3, [sp, #12]
 80035f4:	2222      	movs	r2, #34	; 0x22
 80035f6:	2101      	movs	r1, #1
 80035f8:	5499      	strb	r1, [r3, r2]
  tp->name      = name;
 80035fa:	9b03      	ldr	r3, [sp, #12]
 80035fc:	9a02      	ldr	r2, [sp, #8]
 80035fe:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
 8003600:	9b03      	ldr	r3, [sp, #12]
 8003602:	4a0d      	ldr	r2, [pc, #52]	; (8003638 <_thread_init+0x78>)
 8003604:	611a      	str	r2, [r3, #16]
 8003606:	4b0c      	ldr	r3, [pc, #48]	; (8003638 <_thread_init+0x78>)
 8003608:	695a      	ldr	r2, [r3, #20]
 800360a:	9b03      	ldr	r3, [sp, #12]
 800360c:	615a      	str	r2, [r3, #20]
 800360e:	9b03      	ldr	r3, [sp, #12]
 8003610:	695b      	ldr	r3, [r3, #20]
 8003612:	9a03      	ldr	r2, [sp, #12]
 8003614:	611a      	str	r2, [r3, #16]
 8003616:	4b08      	ldr	r3, [pc, #32]	; (8003638 <_thread_init+0x78>)
 8003618:	9a03      	ldr	r2, [sp, #12]
 800361a:	615a      	str	r2, [r3, #20]
  list_init(&tp->waiting);
 800361c:	9b03      	ldr	r3, [sp, #12]
 800361e:	3328      	adds	r3, #40	; 0x28
 8003620:	0018      	movs	r0, r3
 8003622:	f7ff fedd 	bl	80033e0 <list_init>
  queue_init(&tp->msgqueue);
 8003626:	9b03      	ldr	r3, [sp, #12]
 8003628:	332c      	adds	r3, #44	; 0x2c
 800362a:	0018      	movs	r0, r3
 800362c:	f7ff fef0 	bl	8003410 <queue_init.lto_priv.222>
  return tp;
 8003630:	9b03      	ldr	r3, [sp, #12]
}
 8003632:	0018      	movs	r0, r3
 8003634:	b005      	add	sp, #20
 8003636:	bd00      	pop	{pc}
 8003638:	200004d8 	.word	0x200004d8
 800363c:	00000000 	.word	0x00000000

08003640 <_thread_memfill>:
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {
 8003640:	b084      	sub	sp, #16
 8003642:	9003      	str	r0, [sp, #12]
 8003644:	9102      	str	r1, [sp, #8]
 8003646:	466b      	mov	r3, sp
 8003648:	3307      	adds	r3, #7
 800364a:	701a      	strb	r2, [r3, #0]
 800364c:	e006      	b.n	800365c <_thread_memfill+0x1c>
    *startp++ = v;
 800364e:	9b03      	ldr	r3, [sp, #12]
 8003650:	1c5a      	adds	r2, r3, #1
 8003652:	9203      	str	r2, [sp, #12]
 8003654:	466a      	mov	r2, sp
 8003656:	3207      	adds	r2, #7
 8003658:	7812      	ldrb	r2, [r2, #0]
 800365a:	701a      	strb	r2, [r3, #0]
  while (startp < endp) {
 800365c:	9a03      	ldr	r2, [sp, #12]
 800365e:	9b02      	ldr	r3, [sp, #8]
 8003660:	429a      	cmp	r2, r3
 8003662:	d3f4      	bcc.n	800364e <_thread_memfill+0xe>
}
 8003664:	b004      	add	sp, #16
 8003666:	4770      	bx	lr
	...

08003670 <chThdCreateSuspendedI>:
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 8003670:	b500      	push	{lr}
 8003672:	b085      	sub	sp, #20
 8003674:	9001      	str	r0, [sp, #4]
  chDbgCheckClassI();
 8003676:	f7ff f8d3 	bl	8002820 <chDbgCheckClassI>
  chDbgCheck(tdp != NULL);
 800367a:	9b01      	ldr	r3, [sp, #4]
 800367c:	2b00      	cmp	r3, #0
 800367e:	d103      	bne.n	8003688 <chThdCreateSuspendedI+0x18>
 8003680:	4b2a      	ldr	r3, [pc, #168]	; (800372c <chThdCreateSuspendedI+0xbc>)
 8003682:	0018      	movs	r0, r3
 8003684:	f7fe ffdc 	bl	8002640 <chSysHalt>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
 8003688:	9b01      	ldr	r3, [sp, #4]
 800368a:	685b      	ldr	r3, [r3, #4]
 800368c:	001a      	movs	r2, r3
 800368e:	2307      	movs	r3, #7
 8003690:	4013      	ands	r3, r2
 8003692:	d113      	bne.n	80036bc <chThdCreateSuspendedI+0x4c>
 8003694:	9b01      	ldr	r3, [sp, #4]
 8003696:	689b      	ldr	r3, [r3, #8]
 8003698:	001a      	movs	r2, r3
 800369a:	2307      	movs	r3, #7
 800369c:	4013      	ands	r3, r2
 800369e:	d10d      	bne.n	80036bc <chThdCreateSuspendedI+0x4c>
 80036a0:	9b01      	ldr	r3, [sp, #4]
 80036a2:	689a      	ldr	r2, [r3, #8]
 80036a4:	9b01      	ldr	r3, [sp, #4]
 80036a6:	685b      	ldr	r3, [r3, #4]
 80036a8:	429a      	cmp	r2, r3
 80036aa:	d907      	bls.n	80036bc <chThdCreateSuspendedI+0x4c>
 80036ac:	9b01      	ldr	r3, [sp, #4]
 80036ae:	689b      	ldr	r3, [r3, #8]
 80036b0:	001a      	movs	r2, r3
 80036b2:	9b01      	ldr	r3, [sp, #4]
 80036b4:	685b      	ldr	r3, [r3, #4]
 80036b6:	1ad3      	subs	r3, r2, r3
 80036b8:	2bc7      	cmp	r3, #199	; 0xc7
 80036ba:	d803      	bhi.n	80036c4 <chThdCreateSuspendedI+0x54>
 80036bc:	4b1b      	ldr	r3, [pc, #108]	; (800372c <chThdCreateSuspendedI+0xbc>)
 80036be:	0018      	movs	r0, r3
 80036c0:	f7fe ffbe 	bl	8002640 <chSysHalt>
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));
 80036c4:	9b01      	ldr	r3, [sp, #4]
 80036c6:	68db      	ldr	r3, [r3, #12]
 80036c8:	2bff      	cmp	r3, #255	; 0xff
 80036ca:	d803      	bhi.n	80036d4 <chThdCreateSuspendedI+0x64>
 80036cc:	9b01      	ldr	r3, [sp, #4]
 80036ce:	691b      	ldr	r3, [r3, #16]
 80036d0:	2b00      	cmp	r3, #0
 80036d2:	d103      	bne.n	80036dc <chThdCreateSuspendedI+0x6c>
 80036d4:	4b15      	ldr	r3, [pc, #84]	; (800372c <chThdCreateSuspendedI+0xbc>)
 80036d6:	0018      	movs	r0, r3
 80036d8:	f7fe ffb2 	bl	8002640 <chSysHalt>
  tp = (thread_t *)((uint8_t *)tdp->wend -
 80036dc:	9b01      	ldr	r3, [sp, #4]
 80036de:	689b      	ldr	r3, [r3, #8]
 80036e0:	3b48      	subs	r3, #72	; 0x48
 80036e2:	9303      	str	r3, [sp, #12]
  tp->wabase = tdp->wbase;
 80036e4:	9b01      	ldr	r3, [sp, #4]
 80036e6:	685a      	ldr	r2, [r3, #4]
 80036e8:	9b03      	ldr	r3, [sp, #12]
 80036ea:	61da      	str	r2, [r3, #28]
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 80036ec:	9b03      	ldr	r3, [sp, #12]
 80036ee:	3b24      	subs	r3, #36	; 0x24
 80036f0:	001a      	movs	r2, r3
 80036f2:	9b03      	ldr	r3, [sp, #12]
 80036f4:	60da      	str	r2, [r3, #12]
 80036f6:	9b03      	ldr	r3, [sp, #12]
 80036f8:	68db      	ldr	r3, [r3, #12]
 80036fa:	9a01      	ldr	r2, [sp, #4]
 80036fc:	6912      	ldr	r2, [r2, #16]
 80036fe:	611a      	str	r2, [r3, #16]
 8003700:	9b03      	ldr	r3, [sp, #12]
 8003702:	68db      	ldr	r3, [r3, #12]
 8003704:	9a01      	ldr	r2, [sp, #4]
 8003706:	6952      	ldr	r2, [r2, #20]
 8003708:	615a      	str	r2, [r3, #20]
 800370a:	9b03      	ldr	r3, [sp, #12]
 800370c:	68db      	ldr	r3, [r3, #12]
 800370e:	4a08      	ldr	r2, [pc, #32]	; (8003730 <chThdCreateSuspendedI+0xc0>)
 8003710:	621a      	str	r2, [r3, #32]
  return _thread_init(tp, tdp->name, tdp->prio);
 8003712:	9b01      	ldr	r3, [sp, #4]
 8003714:	6819      	ldr	r1, [r3, #0]
 8003716:	9b01      	ldr	r3, [sp, #4]
 8003718:	68da      	ldr	r2, [r3, #12]
 800371a:	9b03      	ldr	r3, [sp, #12]
 800371c:	0018      	movs	r0, r3
 800371e:	f7ff ff4f 	bl	80035c0 <_thread_init>
 8003722:	0003      	movs	r3, r0
}
 8003724:	0018      	movs	r0, r3
 8003726:	b005      	add	sp, #20
 8003728:	bd00      	pop	{pc}
 800372a:	46c0      	nop			; (mov r8, r8)
 800372c:	08003ad4 	.word	0x08003ad4
 8003730:	080001b1 	.word	0x080001b1
	...

08003740 <chThdCreate>:
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
 8003740:	b500      	push	{lr}
 8003742:	b085      	sub	sp, #20
 8003744:	9001      	str	r0, [sp, #4]
  chDbgAssert(chRegFindThreadByWorkingArea(tdp->wbase) == NULL,
 8003746:	9b01      	ldr	r3, [sp, #4]
 8003748:	685b      	ldr	r3, [r3, #4]
 800374a:	0018      	movs	r0, r3
 800374c:	f7fe fb00 	bl	8001d50 <chRegFindThreadByWorkingArea>
 8003750:	1e03      	subs	r3, r0, #0
 8003752:	d003      	beq.n	800375c <chThdCreate+0x1c>
 8003754:	4b0f      	ldr	r3, [pc, #60]	; (8003794 <chThdCreate+0x54>)
 8003756:	0018      	movs	r0, r3
 8003758:	f7fe ff72 	bl	8002640 <chSysHalt>
  _thread_memfill((uint8_t *)tdp->wbase,
 800375c:	9b01      	ldr	r3, [sp, #4]
 800375e:	6858      	ldr	r0, [r3, #4]
                  (uint8_t *)tdp->wend,
 8003760:	9b01      	ldr	r3, [sp, #4]
 8003762:	689b      	ldr	r3, [r3, #8]
  _thread_memfill((uint8_t *)tdp->wbase,
 8003764:	2255      	movs	r2, #85	; 0x55
 8003766:	0019      	movs	r1, r3
 8003768:	f7ff ff6a 	bl	8003640 <_thread_memfill>
  chSysLock();
 800376c:	f7ff feb0 	bl	80034d0 <chSysLock.lto_priv.176>
  tp = chThdCreateSuspendedI(tdp);
 8003770:	9b01      	ldr	r3, [sp, #4]
 8003772:	0018      	movs	r0, r3
 8003774:	f7ff ff7c 	bl	8003670 <chThdCreateSuspendedI>
 8003778:	0003      	movs	r3, r0
 800377a:	9303      	str	r3, [sp, #12]
  chSchWakeupS(tp, MSG_OK);
 800377c:	9b03      	ldr	r3, [sp, #12]
 800377e:	2100      	movs	r1, #0
 8003780:	0018      	movs	r0, r3
 8003782:	f7ff fd15 	bl	80031b0 <chSchWakeupS>
  chSysUnlock();
 8003786:	f7ff feab 	bl	80034e0 <chSysUnlock.lto_priv.171>
  return tp;
 800378a:	9b03      	ldr	r3, [sp, #12]
}
 800378c:	0018      	movs	r0, r3
 800378e:	b005      	add	sp, #20
 8003790:	bd00      	pop	{pc}
 8003792:	46c0      	nop			; (mov r8, r8)
 8003794:	08003af8 	.word	0x08003af8
	...

080037a0 <chThdCreateStatic>:
                            tprio_t prio, tfunc_t pf, void *arg) {
 80037a0:	b500      	push	{lr}
 80037a2:	b087      	sub	sp, #28
 80037a4:	9003      	str	r0, [sp, #12]
 80037a6:	9102      	str	r1, [sp, #8]
 80037a8:	9201      	str	r2, [sp, #4]
 80037aa:	9300      	str	r3, [sp, #0]
  chDbgCheck((wsp != NULL) &&
 80037ac:	9b03      	ldr	r3, [sp, #12]
 80037ae:	2b00      	cmp	r3, #0
 80037b0:	d010      	beq.n	80037d4 <chThdCreateStatic+0x34>
 80037b2:	9b03      	ldr	r3, [sp, #12]
 80037b4:	2207      	movs	r2, #7
 80037b6:	4013      	ands	r3, r2
 80037b8:	d10c      	bne.n	80037d4 <chThdCreateStatic+0x34>
 80037ba:	9b02      	ldr	r3, [sp, #8]
 80037bc:	2bc7      	cmp	r3, #199	; 0xc7
 80037be:	d909      	bls.n	80037d4 <chThdCreateStatic+0x34>
 80037c0:	9b02      	ldr	r3, [sp, #8]
 80037c2:	2207      	movs	r2, #7
 80037c4:	4013      	ands	r3, r2
 80037c6:	d105      	bne.n	80037d4 <chThdCreateStatic+0x34>
 80037c8:	9b01      	ldr	r3, [sp, #4]
 80037ca:	2bff      	cmp	r3, #255	; 0xff
 80037cc:	d802      	bhi.n	80037d4 <chThdCreateStatic+0x34>
 80037ce:	9b00      	ldr	r3, [sp, #0]
 80037d0:	2b00      	cmp	r3, #0
 80037d2:	d103      	bne.n	80037dc <chThdCreateStatic+0x3c>
 80037d4:	4b21      	ldr	r3, [pc, #132]	; (800385c <chThdCreateStatic+0xbc>)
 80037d6:	0018      	movs	r0, r3
 80037d8:	f7fe ff32 	bl	8002640 <chSysHalt>
  chDbgAssert(chRegFindThreadByWorkingArea(wsp) == NULL,
 80037dc:	9b03      	ldr	r3, [sp, #12]
 80037de:	0018      	movs	r0, r3
 80037e0:	f7fe fab6 	bl	8001d50 <chRegFindThreadByWorkingArea>
 80037e4:	1e03      	subs	r3, r0, #0
 80037e6:	d003      	beq.n	80037f0 <chThdCreateStatic+0x50>
 80037e8:	4b1c      	ldr	r3, [pc, #112]	; (800385c <chThdCreateStatic+0xbc>)
 80037ea:	0018      	movs	r0, r3
 80037ec:	f7fe ff28 	bl	8002640 <chSysHalt>
  _thread_memfill((uint8_t *)wsp,
 80037f0:	9a03      	ldr	r2, [sp, #12]
 80037f2:	9b02      	ldr	r3, [sp, #8]
 80037f4:	18d1      	adds	r1, r2, r3
 80037f6:	9b03      	ldr	r3, [sp, #12]
 80037f8:	2255      	movs	r2, #85	; 0x55
 80037fa:	0018      	movs	r0, r3
 80037fc:	f7ff ff20 	bl	8003640 <_thread_memfill>
  chSysLock();
 8003800:	f7ff fe66 	bl	80034d0 <chSysLock.lto_priv.176>
  tp = (thread_t *)((uint8_t *)wsp + size -
 8003804:	9b02      	ldr	r3, [sp, #8]
 8003806:	3b48      	subs	r3, #72	; 0x48
 8003808:	9a03      	ldr	r2, [sp, #12]
 800380a:	18d3      	adds	r3, r2, r3
 800380c:	9305      	str	r3, [sp, #20]
  tp->wabase = (stkalign_t *)wsp;
 800380e:	9b05      	ldr	r3, [sp, #20]
 8003810:	9a03      	ldr	r2, [sp, #12]
 8003812:	61da      	str	r2, [r3, #28]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8003814:	9b05      	ldr	r3, [sp, #20]
 8003816:	3b24      	subs	r3, #36	; 0x24
 8003818:	001a      	movs	r2, r3
 800381a:	9b05      	ldr	r3, [sp, #20]
 800381c:	60da      	str	r2, [r3, #12]
 800381e:	9b05      	ldr	r3, [sp, #20]
 8003820:	68db      	ldr	r3, [r3, #12]
 8003822:	9a00      	ldr	r2, [sp, #0]
 8003824:	611a      	str	r2, [r3, #16]
 8003826:	9b05      	ldr	r3, [sp, #20]
 8003828:	68db      	ldr	r3, [r3, #12]
 800382a:	9a08      	ldr	r2, [sp, #32]
 800382c:	615a      	str	r2, [r3, #20]
 800382e:	9b05      	ldr	r3, [sp, #20]
 8003830:	68db      	ldr	r3, [r3, #12]
 8003832:	4a0b      	ldr	r2, [pc, #44]	; (8003860 <chThdCreateStatic+0xc0>)
 8003834:	621a      	str	r2, [r3, #32]
  tp = _thread_init(tp, "noname", prio);
 8003836:	9a01      	ldr	r2, [sp, #4]
 8003838:	490a      	ldr	r1, [pc, #40]	; (8003864 <chThdCreateStatic+0xc4>)
 800383a:	9b05      	ldr	r3, [sp, #20]
 800383c:	0018      	movs	r0, r3
 800383e:	f7ff febf 	bl	80035c0 <_thread_init>
 8003842:	0003      	movs	r3, r0
 8003844:	9305      	str	r3, [sp, #20]
  chSchWakeupS(tp, MSG_OK);
 8003846:	9b05      	ldr	r3, [sp, #20]
 8003848:	2100      	movs	r1, #0
 800384a:	0018      	movs	r0, r3
 800384c:	f7ff fcb0 	bl	80031b0 <chSchWakeupS>
  chSysUnlock();
 8003850:	f7ff fe46 	bl	80034e0 <chSysUnlock.lto_priv.171>
  return tp;
 8003854:	9b05      	ldr	r3, [sp, #20]
}
 8003856:	0018      	movs	r0, r3
 8003858:	b007      	add	sp, #28
 800385a:	bd00      	pop	{pc}
 800385c:	08003b04 	.word	0x08003b04
 8003860:	080001b1 	.word	0x080001b1
 8003864:	08003dd8 	.word	0x08003dd8
	...

08003870 <chThdRelease>:
void chThdRelease(thread_t *tp) {
 8003870:	b510      	push	{r4, lr}
 8003872:	b082      	sub	sp, #8
 8003874:	9001      	str	r0, [sp, #4]
  chSysLock();
 8003876:	f7ff fe2b 	bl	80034d0 <chSysLock.lto_priv.176>
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 800387a:	9b01      	ldr	r3, [sp, #4]
 800387c:	2222      	movs	r2, #34	; 0x22
 800387e:	5c9b      	ldrb	r3, [r3, r2]
 8003880:	2b00      	cmp	r3, #0
 8003882:	d103      	bne.n	800388c <chThdRelease+0x1c>
 8003884:	4b22      	ldr	r3, [pc, #136]	; (8003910 <chThdRelease+0xa0>)
 8003886:	0018      	movs	r0, r3
 8003888:	f7fe feda 	bl	8002640 <chSysHalt>
  tp->refs--;
 800388c:	9b01      	ldr	r3, [sp, #4]
 800388e:	2222      	movs	r2, #34	; 0x22
 8003890:	5c9b      	ldrb	r3, [r3, r2]
 8003892:	3b01      	subs	r3, #1
 8003894:	b2d9      	uxtb	r1, r3
 8003896:	9b01      	ldr	r3, [sp, #4]
 8003898:	2222      	movs	r2, #34	; 0x22
 800389a:	5499      	strb	r1, [r3, r2]
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 800389c:	9b01      	ldr	r3, [sp, #4]
 800389e:	2222      	movs	r2, #34	; 0x22
 80038a0:	5c9b      	ldrb	r3, [r3, r2]
 80038a2:	2b00      	cmp	r3, #0
 80038a4:	d130      	bne.n	8003908 <chThdRelease+0x98>
 80038a6:	9b01      	ldr	r3, [sp, #4]
 80038a8:	2220      	movs	r2, #32
 80038aa:	5c9b      	ldrb	r3, [r3, r2]
 80038ac:	2b0f      	cmp	r3, #15
 80038ae:	d12b      	bne.n	8003908 <chThdRelease+0x98>
    REG_REMOVE(tp);
 80038b0:	9b01      	ldr	r3, [sp, #4]
 80038b2:	695b      	ldr	r3, [r3, #20]
 80038b4:	9a01      	ldr	r2, [sp, #4]
 80038b6:	6912      	ldr	r2, [r2, #16]
 80038b8:	611a      	str	r2, [r3, #16]
 80038ba:	9b01      	ldr	r3, [sp, #4]
 80038bc:	691b      	ldr	r3, [r3, #16]
 80038be:	9a01      	ldr	r2, [sp, #4]
 80038c0:	6952      	ldr	r2, [r2, #20]
 80038c2:	615a      	str	r2, [r3, #20]
    chSysUnlock();
 80038c4:	f7ff fe0c 	bl	80034e0 <chSysUnlock.lto_priv.171>
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 80038c8:	9b01      	ldr	r3, [sp, #4]
 80038ca:	2221      	movs	r2, #33	; 0x21
 80038cc:	5c9b      	ldrb	r3, [r3, r2]
 80038ce:	001a      	movs	r2, r3
 80038d0:	2303      	movs	r3, #3
 80038d2:	4013      	ands	r3, r2
 80038d4:	2b01      	cmp	r3, #1
 80038d6:	d002      	beq.n	80038de <chThdRelease+0x6e>
 80038d8:	2b02      	cmp	r3, #2
 80038da:	d009      	beq.n	80038f0 <chThdRelease+0x80>
 80038dc:	e016      	b.n	800390c <chThdRelease+0x9c>
      chHeapFree(chThdGetWorkingAreaX(tp));
 80038de:	9b01      	ldr	r3, [sp, #4]
 80038e0:	0018      	movs	r0, r3
 80038e2:	f7ff fe1d 	bl	8003520 <chThdGetWorkingAreaX>
 80038e6:	0003      	movs	r3, r0
 80038e8:	0018      	movs	r0, r3
 80038ea:	f7fe f8b1 	bl	8001a50 <chHeapFree>
 80038ee:	e00d      	b.n	800390c <chThdRelease+0x9c>
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 80038f0:	9b01      	ldr	r3, [sp, #4]
 80038f2:	6c1c      	ldr	r4, [r3, #64]	; 0x40
 80038f4:	9b01      	ldr	r3, [sp, #4]
 80038f6:	0018      	movs	r0, r3
 80038f8:	f7ff fe12 	bl	8003520 <chThdGetWorkingAreaX>
 80038fc:	0003      	movs	r3, r0
 80038fe:	0019      	movs	r1, r3
 8003900:	0020      	movs	r0, r4
 8003902:	f7fd fea5 	bl	8001650 <chPoolFree>
 8003906:	e001      	b.n	800390c <chThdRelease+0x9c>
  chSysUnlock();
 8003908:	f7ff fdea 	bl	80034e0 <chSysUnlock.lto_priv.171>
}
 800390c:	b002      	add	sp, #8
 800390e:	bd10      	pop	{r4, pc}
 8003910:	08003b18 	.word	0x08003b18
	...

08003920 <chThdExit>:
void chThdExit(msg_t msg) {
 8003920:	b500      	push	{lr}
 8003922:	b083      	sub	sp, #12
 8003924:	9001      	str	r0, [sp, #4]
  chSysLock();
 8003926:	f7ff fdd3 	bl	80034d0 <chSysLock.lto_priv.176>
  chThdExitS(msg);
 800392a:	9b01      	ldr	r3, [sp, #4]
 800392c:	0018      	movs	r0, r3
 800392e:	f000 f807 	bl	8003940 <chThdExitS>
}
 8003932:	b003      	add	sp, #12
 8003934:	bd00      	pop	{pc}
 8003936:	46c0      	nop			; (mov r8, r8)
	...

08003940 <chThdExitS>:
void chThdExitS(msg_t msg) {
 8003940:	b500      	push	{lr}
 8003942:	b085      	sub	sp, #20
 8003944:	9001      	str	r0, [sp, #4]
  thread_t *tp = currp;
 8003946:	4b1b      	ldr	r3, [pc, #108]	; (80039b4 <chThdExitS+0x74>)
 8003948:	699b      	ldr	r3, [r3, #24]
 800394a:	9303      	str	r3, [sp, #12]
  tp->u.exitcode = msg;
 800394c:	9b03      	ldr	r3, [sp, #12]
 800394e:	9a01      	ldr	r2, [sp, #4]
 8003950:	625a      	str	r2, [r3, #36]	; 0x24
 8003952:	e008      	b.n	8003966 <chThdExitS+0x26>
    (void) chSchReadyI(list_remove(&tp->waiting));
 8003954:	9b03      	ldr	r3, [sp, #12]
 8003956:	3328      	adds	r3, #40	; 0x28
 8003958:	0018      	movs	r0, r3
 800395a:	f7ff fd79 	bl	8003450 <list_remove>
 800395e:	0003      	movs	r3, r0
 8003960:	0018      	movs	r0, r3
 8003962:	f7ff faf5 	bl	8002f50 <chSchReadyI>
  while (list_notempty(&tp->waiting)) {
 8003966:	9b03      	ldr	r3, [sp, #12]
 8003968:	3328      	adds	r3, #40	; 0x28
 800396a:	0018      	movs	r0, r3
 800396c:	f7ff fd40 	bl	80033f0 <list_notempty>
 8003970:	1e03      	subs	r3, r0, #0
 8003972:	d1ef      	bne.n	8003954 <chThdExitS+0x14>
  if ((tp->refs == (trefs_t)0) &&
 8003974:	9b03      	ldr	r3, [sp, #12]
 8003976:	2222      	movs	r2, #34	; 0x22
 8003978:	5c9b      	ldrb	r3, [r3, r2]
 800397a:	2b00      	cmp	r3, #0
 800397c:	d110      	bne.n	80039a0 <chThdExitS+0x60>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
 800397e:	9b03      	ldr	r3, [sp, #12]
 8003980:	2221      	movs	r2, #33	; 0x21
 8003982:	5c9b      	ldrb	r3, [r3, r2]
 8003984:	001a      	movs	r2, r3
 8003986:	2303      	movs	r3, #3
 8003988:	4013      	ands	r3, r2
  if ((tp->refs == (trefs_t)0) &&
 800398a:	d109      	bne.n	80039a0 <chThdExitS+0x60>
    REG_REMOVE(tp);
 800398c:	9b03      	ldr	r3, [sp, #12]
 800398e:	695b      	ldr	r3, [r3, #20]
 8003990:	9a03      	ldr	r2, [sp, #12]
 8003992:	6912      	ldr	r2, [r2, #16]
 8003994:	611a      	str	r2, [r3, #16]
 8003996:	9b03      	ldr	r3, [sp, #12]
 8003998:	691b      	ldr	r3, [r3, #16]
 800399a:	9a03      	ldr	r2, [sp, #12]
 800399c:	6952      	ldr	r2, [r2, #20]
 800399e:	615a      	str	r2, [r3, #20]
  chSchGoSleepS(CH_STATE_FINAL);
 80039a0:	200f      	movs	r0, #15
 80039a2:	f7ff fb55 	bl	8003050 <chSchGoSleepS>
  chDbgAssert(false, "zombies apocalypse");
 80039a6:	4b04      	ldr	r3, [pc, #16]	; (80039b8 <chThdExitS+0x78>)
 80039a8:	0018      	movs	r0, r3
 80039aa:	f7fe fe49 	bl	8002640 <chSysHalt>
}
 80039ae:	b005      	add	sp, #20
 80039b0:	bd00      	pop	{pc}
 80039b2:	46c0      	nop			; (mov r8, r8)
 80039b4:	200004d8 	.word	0x200004d8
 80039b8:	08003b28 	.word	0x08003b28
 80039bc:	00000000 	.word	0x00000000

080039c0 <chThdSleep>:
void chThdSleep(systime_t time) {
 80039c0:	b500      	push	{lr}
 80039c2:	b083      	sub	sp, #12
 80039c4:	9001      	str	r0, [sp, #4]
  chSysLock();
 80039c6:	f7ff fd83 	bl	80034d0 <chSysLock.lto_priv.176>
  chThdSleepS(time);
 80039ca:	9b01      	ldr	r3, [sp, #4]
 80039cc:	0018      	movs	r0, r3
 80039ce:	f7ff fdaf 	bl	8003530 <chThdSleepS>
  chSysUnlock();
 80039d2:	f7ff fd85 	bl	80034e0 <chSysUnlock.lto_priv.171>
}
 80039d6:	b003      	add	sp, #12
 80039d8:	bd00      	pop	{pc}
 80039da:	46c0      	nop			; (mov r8, r8)
