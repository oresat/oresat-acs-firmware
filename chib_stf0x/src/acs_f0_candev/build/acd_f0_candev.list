
build/acd_f0_candev.elf:     file format elf32-littlearm


Disassembly of section .text:

080000c0 <Reset_Handler>:
 80000c0:	b672      	cpsid	i
 80000c2:	4824      	ldr	r0, [pc, #144]	; (8000154 <endfiniloop+0x6>)
 80000c4:	f380 8808 	msr	MSP, r0
 80000c8:	4823      	ldr	r0, [pc, #140]	; (8000158 <endfiniloop+0xa>)
 80000ca:	f380 8809 	msr	PSP, r0
 80000ce:	2002      	movs	r0, #2
 80000d0:	f380 8814 	msr	CONTROL, r0
 80000d4:	f3bf 8f6f 	isb	sy
 80000d8:	f003 fe0a 	bl	8003cf0 <__core_init>
 80000dc:	f000 fbe0 	bl	80008a0 <__early_init>
 80000e0:	481e      	ldr	r0, [pc, #120]	; (800015c <endfiniloop+0xe>)
 80000e2:	491f      	ldr	r1, [pc, #124]	; (8000160 <endfiniloop+0x12>)
 80000e4:	4a1b      	ldr	r2, [pc, #108]	; (8000154 <endfiniloop+0x6>)

080000e6 <msloop>:
 80000e6:	4291      	cmp	r1, r2
 80000e8:	da02      	bge.n	80000f0 <endmsloop>
 80000ea:	6008      	str	r0, [r1, #0]
 80000ec:	3104      	adds	r1, #4
 80000ee:	e7fa      	b.n	80000e6 <msloop>

080000f0 <endmsloop>:
 80000f0:	491c      	ldr	r1, [pc, #112]	; (8000164 <endfiniloop+0x16>)
 80000f2:	4a19      	ldr	r2, [pc, #100]	; (8000158 <endfiniloop+0xa>)

080000f4 <psloop>:
 80000f4:	4291      	cmp	r1, r2
 80000f6:	da02      	bge.n	80000fe <endpsloop>
 80000f8:	6008      	str	r0, [r1, #0]
 80000fa:	3104      	adds	r1, #4
 80000fc:	e7fa      	b.n	80000f4 <psloop>

080000fe <endpsloop>:
 80000fe:	491a      	ldr	r1, [pc, #104]	; (8000168 <endfiniloop+0x1a>)
 8000100:	4a1a      	ldr	r2, [pc, #104]	; (800016c <endfiniloop+0x1e>)
 8000102:	4b1b      	ldr	r3, [pc, #108]	; (8000170 <endfiniloop+0x22>)

08000104 <dloop>:
 8000104:	429a      	cmp	r2, r3
 8000106:	da04      	bge.n	8000112 <enddloop>
 8000108:	6808      	ldr	r0, [r1, #0]
 800010a:	6010      	str	r0, [r2, #0]
 800010c:	3104      	adds	r1, #4
 800010e:	3204      	adds	r2, #4
 8000110:	e7f8      	b.n	8000104 <dloop>

08000112 <enddloop>:
 8000112:	2000      	movs	r0, #0
 8000114:	4917      	ldr	r1, [pc, #92]	; (8000174 <endfiniloop+0x26>)
 8000116:	4a18      	ldr	r2, [pc, #96]	; (8000178 <endfiniloop+0x2a>)

08000118 <bloop>:
 8000118:	4291      	cmp	r1, r2
 800011a:	da02      	bge.n	8000122 <endbloop>
 800011c:	6008      	str	r0, [r1, #0]
 800011e:	3104      	adds	r1, #4
 8000120:	e7fa      	b.n	8000118 <bloop>

08000122 <endbloop>:
 8000122:	f003 fdfd 	bl	8003d20 <__init_ram_areas>
 8000126:	f003 fdeb 	bl	8003d00 <__late_init>
 800012a:	4c14      	ldr	r4, [pc, #80]	; (800017c <endfiniloop+0x2e>)
 800012c:	4d14      	ldr	r5, [pc, #80]	; (8000180 <endfiniloop+0x32>)

0800012e <initloop>:
 800012e:	42ac      	cmp	r4, r5
 8000130:	da03      	bge.n	800013a <endinitloop>
 8000132:	6821      	ldr	r1, [r4, #0]
 8000134:	4788      	blx	r1
 8000136:	3404      	adds	r4, #4
 8000138:	e7f9      	b.n	800012e <initloop>

0800013a <endinitloop>:
 800013a:	f001 f831 	bl	80011a0 <main>
 800013e:	4c11      	ldr	r4, [pc, #68]	; (8000184 <endfiniloop+0x36>)
 8000140:	4d11      	ldr	r5, [pc, #68]	; (8000188 <endfiniloop+0x3a>)

08000142 <finiloop>:
 8000142:	42ac      	cmp	r4, r5
 8000144:	da03      	bge.n	800014e <endfiniloop>
 8000146:	6821      	ldr	r1, [r4, #0]
 8000148:	4788      	blx	r1
 800014a:	3404      	adds	r4, #4
 800014c:	e7f9      	b.n	8000142 <finiloop>

0800014e <endfiniloop>:
 800014e:	490f      	ldr	r1, [pc, #60]	; (800018c <endfiniloop+0x3e>)
 8000150:	4708      	bx	r1
 8000152:	0000      	.short	0x0000
 8000154:	20000200 	.word	0x20000200
 8000158:	20000400 	.word	0x20000400
 800015c:	55555555 	.word	0x55555555
 8000160:	20000000 	.word	0x20000000
 8000164:	20000200 	.word	0x20000200
 8000168:	08004d80 	.word	0x08004d80
 800016c:	20000400 	.word	0x20000400
 8000170:	20000410 	.word	0x20000410
 8000174:	20000410 	.word	0x20000410
 8000178:	20000a50 	.word	0x20000a50
 800017c:	080000c0 	.word	0x080000c0
 8000180:	080000c0 	.word	0x080000c0
 8000184:	080000c0 	.word	0x080000c0
 8000188:	080000c0 	.word	0x080000c0
 800018c:	08003d11 	.word	0x08003d11

08000190 <_port_switch>:
 8000190:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000192:	4644      	mov	r4, r8
 8000194:	464d      	mov	r5, r9
 8000196:	4656      	mov	r6, sl
 8000198:	465f      	mov	r7, fp
 800019a:	b4f0      	push	{r4, r5, r6, r7}
 800019c:	466b      	mov	r3, sp
 800019e:	60cb      	str	r3, [r1, #12]
 80001a0:	68c3      	ldr	r3, [r0, #12]
 80001a2:	469d      	mov	sp, r3
 80001a4:	bcf0      	pop	{r4, r5, r6, r7}
 80001a6:	46a0      	mov	r8, r4
 80001a8:	46a9      	mov	r9, r5
 80001aa:	46b2      	mov	sl, r6
 80001ac:	46bb      	mov	fp, r7
 80001ae:	bdf0      	pop	{r4, r5, r6, r7, pc}

080001b0 <_port_thread_start>:
 80001b0:	b662      	cpsie	i
 80001b2:	1c28      	adds	r0, r5, #0
 80001b4:	47a0      	blx	r4
 80001b6:	2000      	movs	r0, #0
 80001b8:	f003 fc02 	bl	80039c0 <chThdExit>

080001bc <_port_switch_from_isr>:
 80001bc:	f004 faa0 	bl	8004700 <chSchDoReschedule>

080001c0 <_port_exit_from_isr>:
 80001c0:	4a01      	ldr	r2, [pc, #4]	; (80001c8 <_port_exit_from_isr+0x8>)
 80001c2:	4b02      	ldr	r3, [pc, #8]	; (80001cc <_port_exit_from_isr+0xc>)
 80001c4:	6013      	str	r3, [r2, #0]
 80001c6:	e7fe      	b.n	80001c6 <_port_exit_from_isr+0x6>
 80001c8:	e000ed04 	.word	0xe000ed04
 80001cc:	80000000 	.word	0x80000000

080001d0 <__aeabi_uidiv>:
 80001d0:	2200      	movs	r2, #0
 80001d2:	0843      	lsrs	r3, r0, #1
 80001d4:	428b      	cmp	r3, r1
 80001d6:	d374      	bcc.n	80002c2 <__aeabi_uidiv+0xf2>
 80001d8:	0903      	lsrs	r3, r0, #4
 80001da:	428b      	cmp	r3, r1
 80001dc:	d35f      	bcc.n	800029e <__aeabi_uidiv+0xce>
 80001de:	0a03      	lsrs	r3, r0, #8
 80001e0:	428b      	cmp	r3, r1
 80001e2:	d344      	bcc.n	800026e <__aeabi_uidiv+0x9e>
 80001e4:	0b03      	lsrs	r3, r0, #12
 80001e6:	428b      	cmp	r3, r1
 80001e8:	d328      	bcc.n	800023c <__aeabi_uidiv+0x6c>
 80001ea:	0c03      	lsrs	r3, r0, #16
 80001ec:	428b      	cmp	r3, r1
 80001ee:	d30d      	bcc.n	800020c <__aeabi_uidiv+0x3c>
 80001f0:	22ff      	movs	r2, #255	; 0xff
 80001f2:	0209      	lsls	r1, r1, #8
 80001f4:	ba12      	rev	r2, r2
 80001f6:	0c03      	lsrs	r3, r0, #16
 80001f8:	428b      	cmp	r3, r1
 80001fa:	d302      	bcc.n	8000202 <__aeabi_uidiv+0x32>
 80001fc:	1212      	asrs	r2, r2, #8
 80001fe:	0209      	lsls	r1, r1, #8
 8000200:	d065      	beq.n	80002ce <__aeabi_uidiv+0xfe>
 8000202:	0b03      	lsrs	r3, r0, #12
 8000204:	428b      	cmp	r3, r1
 8000206:	d319      	bcc.n	800023c <__aeabi_uidiv+0x6c>
 8000208:	e000      	b.n	800020c <__aeabi_uidiv+0x3c>
 800020a:	0a09      	lsrs	r1, r1, #8
 800020c:	0bc3      	lsrs	r3, r0, #15
 800020e:	428b      	cmp	r3, r1
 8000210:	d301      	bcc.n	8000216 <__aeabi_uidiv+0x46>
 8000212:	03cb      	lsls	r3, r1, #15
 8000214:	1ac0      	subs	r0, r0, r3
 8000216:	4152      	adcs	r2, r2
 8000218:	0b83      	lsrs	r3, r0, #14
 800021a:	428b      	cmp	r3, r1
 800021c:	d301      	bcc.n	8000222 <__aeabi_uidiv+0x52>
 800021e:	038b      	lsls	r3, r1, #14
 8000220:	1ac0      	subs	r0, r0, r3
 8000222:	4152      	adcs	r2, r2
 8000224:	0b43      	lsrs	r3, r0, #13
 8000226:	428b      	cmp	r3, r1
 8000228:	d301      	bcc.n	800022e <__aeabi_uidiv+0x5e>
 800022a:	034b      	lsls	r3, r1, #13
 800022c:	1ac0      	subs	r0, r0, r3
 800022e:	4152      	adcs	r2, r2
 8000230:	0b03      	lsrs	r3, r0, #12
 8000232:	428b      	cmp	r3, r1
 8000234:	d301      	bcc.n	800023a <__aeabi_uidiv+0x6a>
 8000236:	030b      	lsls	r3, r1, #12
 8000238:	1ac0      	subs	r0, r0, r3
 800023a:	4152      	adcs	r2, r2
 800023c:	0ac3      	lsrs	r3, r0, #11
 800023e:	428b      	cmp	r3, r1
 8000240:	d301      	bcc.n	8000246 <__aeabi_uidiv+0x76>
 8000242:	02cb      	lsls	r3, r1, #11
 8000244:	1ac0      	subs	r0, r0, r3
 8000246:	4152      	adcs	r2, r2
 8000248:	0a83      	lsrs	r3, r0, #10
 800024a:	428b      	cmp	r3, r1
 800024c:	d301      	bcc.n	8000252 <__aeabi_uidiv+0x82>
 800024e:	028b      	lsls	r3, r1, #10
 8000250:	1ac0      	subs	r0, r0, r3
 8000252:	4152      	adcs	r2, r2
 8000254:	0a43      	lsrs	r3, r0, #9
 8000256:	428b      	cmp	r3, r1
 8000258:	d301      	bcc.n	800025e <__aeabi_uidiv+0x8e>
 800025a:	024b      	lsls	r3, r1, #9
 800025c:	1ac0      	subs	r0, r0, r3
 800025e:	4152      	adcs	r2, r2
 8000260:	0a03      	lsrs	r3, r0, #8
 8000262:	428b      	cmp	r3, r1
 8000264:	d301      	bcc.n	800026a <__aeabi_uidiv+0x9a>
 8000266:	020b      	lsls	r3, r1, #8
 8000268:	1ac0      	subs	r0, r0, r3
 800026a:	4152      	adcs	r2, r2
 800026c:	d2cd      	bcs.n	800020a <__aeabi_uidiv+0x3a>
 800026e:	09c3      	lsrs	r3, r0, #7
 8000270:	428b      	cmp	r3, r1
 8000272:	d301      	bcc.n	8000278 <__aeabi_uidiv+0xa8>
 8000274:	01cb      	lsls	r3, r1, #7
 8000276:	1ac0      	subs	r0, r0, r3
 8000278:	4152      	adcs	r2, r2
 800027a:	0983      	lsrs	r3, r0, #6
 800027c:	428b      	cmp	r3, r1
 800027e:	d301      	bcc.n	8000284 <__aeabi_uidiv+0xb4>
 8000280:	018b      	lsls	r3, r1, #6
 8000282:	1ac0      	subs	r0, r0, r3
 8000284:	4152      	adcs	r2, r2
 8000286:	0943      	lsrs	r3, r0, #5
 8000288:	428b      	cmp	r3, r1
 800028a:	d301      	bcc.n	8000290 <__aeabi_uidiv+0xc0>
 800028c:	014b      	lsls	r3, r1, #5
 800028e:	1ac0      	subs	r0, r0, r3
 8000290:	4152      	adcs	r2, r2
 8000292:	0903      	lsrs	r3, r0, #4
 8000294:	428b      	cmp	r3, r1
 8000296:	d301      	bcc.n	800029c <__aeabi_uidiv+0xcc>
 8000298:	010b      	lsls	r3, r1, #4
 800029a:	1ac0      	subs	r0, r0, r3
 800029c:	4152      	adcs	r2, r2
 800029e:	08c3      	lsrs	r3, r0, #3
 80002a0:	428b      	cmp	r3, r1
 80002a2:	d301      	bcc.n	80002a8 <__aeabi_uidiv+0xd8>
 80002a4:	00cb      	lsls	r3, r1, #3
 80002a6:	1ac0      	subs	r0, r0, r3
 80002a8:	4152      	adcs	r2, r2
 80002aa:	0883      	lsrs	r3, r0, #2
 80002ac:	428b      	cmp	r3, r1
 80002ae:	d301      	bcc.n	80002b4 <__aeabi_uidiv+0xe4>
 80002b0:	008b      	lsls	r3, r1, #2
 80002b2:	1ac0      	subs	r0, r0, r3
 80002b4:	4152      	adcs	r2, r2
 80002b6:	0843      	lsrs	r3, r0, #1
 80002b8:	428b      	cmp	r3, r1
 80002ba:	d301      	bcc.n	80002c0 <__aeabi_uidiv+0xf0>
 80002bc:	004b      	lsls	r3, r1, #1
 80002be:	1ac0      	subs	r0, r0, r3
 80002c0:	4152      	adcs	r2, r2
 80002c2:	1a41      	subs	r1, r0, r1
 80002c4:	d200      	bcs.n	80002c8 <__aeabi_uidiv+0xf8>
 80002c6:	4601      	mov	r1, r0
 80002c8:	4152      	adcs	r2, r2
 80002ca:	4610      	mov	r0, r2
 80002cc:	4770      	bx	lr
 80002ce:	e7ff      	b.n	80002d0 <__aeabi_uidiv+0x100>
 80002d0:	b501      	push	{r0, lr}
 80002d2:	2000      	movs	r0, #0
 80002d4:	f000 f806 	bl	80002e4 <__aeabi_idiv0>
 80002d8:	bd02      	pop	{r1, pc}
 80002da:	46c0      	nop			; (mov r8, r8)

080002dc <__aeabi_uidivmod>:
 80002dc:	2900      	cmp	r1, #0
 80002de:	d0f7      	beq.n	80002d0 <__aeabi_uidiv+0x100>
 80002e0:	e776      	b.n	80001d0 <__aeabi_uidiv>
 80002e2:	4770      	bx	lr

080002e4 <__aeabi_idiv0>:
 80002e4:	4770      	bx	lr
 80002e6:	46c0      	nop			; (mov r8, r8)

080002e8 <strncpy>:
 80002e8:	000b      	movs	r3, r1
 80002ea:	4303      	orrs	r3, r0
 80002ec:	b570      	push	{r4, r5, r6, lr}
 80002ee:	0005      	movs	r5, r0
 80002f0:	079b      	lsls	r3, r3, #30
 80002f2:	d101      	bne.n	80002f8 <strncpy+0x10>
 80002f4:	2a03      	cmp	r2, #3
 80002f6:	d815      	bhi.n	8000324 <strncpy+0x3c>
 80002f8:	2a00      	cmp	r2, #0
 80002fa:	d012      	beq.n	8000322 <strncpy+0x3a>
 80002fc:	1c4c      	adds	r4, r1, #1
 80002fe:	7809      	ldrb	r1, [r1, #0]
 8000300:	3a01      	subs	r2, #1
 8000302:	1c6b      	adds	r3, r5, #1
 8000304:	7029      	strb	r1, [r5, #0]
 8000306:	2900      	cmp	r1, #0
 8000308:	d01b      	beq.n	8000342 <strncpy+0x5a>
 800030a:	0021      	movs	r1, r4
 800030c:	e007      	b.n	800031e <strncpy+0x36>
 800030e:	780c      	ldrb	r4, [r1, #0]
 8000310:	3301      	adds	r3, #1
 8000312:	1e5d      	subs	r5, r3, #1
 8000314:	3a01      	subs	r2, #1
 8000316:	702c      	strb	r4, [r5, #0]
 8000318:	3101      	adds	r1, #1
 800031a:	2c00      	cmp	r4, #0
 800031c:	d011      	beq.n	8000342 <strncpy+0x5a>
 800031e:	2a00      	cmp	r2, #0
 8000320:	d1f5      	bne.n	800030e <strncpy+0x26>
 8000322:	bd70      	pop	{r4, r5, r6, pc}
 8000324:	4e0b      	ldr	r6, [pc, #44]	; (8000354 <strncpy+0x6c>)
 8000326:	680c      	ldr	r4, [r1, #0]
 8000328:	4b0b      	ldr	r3, [pc, #44]	; (8000358 <strncpy+0x70>)
 800032a:	18e3      	adds	r3, r4, r3
 800032c:	43a3      	bics	r3, r4
 800032e:	4233      	tst	r3, r6
 8000330:	d1e4      	bne.n	80002fc <strncpy+0x14>
 8000332:	3504      	adds	r5, #4
 8000334:	1f2b      	subs	r3, r5, #4
 8000336:	3a04      	subs	r2, #4
 8000338:	3104      	adds	r1, #4
 800033a:	601c      	str	r4, [r3, #0]
 800033c:	2a03      	cmp	r2, #3
 800033e:	d8f2      	bhi.n	8000326 <strncpy+0x3e>
 8000340:	e7da      	b.n	80002f8 <strncpy+0x10>
 8000342:	189c      	adds	r4, r3, r2
 8000344:	2100      	movs	r1, #0
 8000346:	2a00      	cmp	r2, #0
 8000348:	d0eb      	beq.n	8000322 <strncpy+0x3a>
 800034a:	7019      	strb	r1, [r3, #0]
 800034c:	3301      	adds	r3, #1
 800034e:	42a3      	cmp	r3, r4
 8000350:	d1fb      	bne.n	800034a <strncpy+0x62>
 8000352:	e7e6      	b.n	8000322 <strncpy+0x3a>
 8000354:	80808080 	.word	0x80808080
 8000358:	fefefeff 	.word	0xfefefeff
 800035c:	00000000 	.word	0x00000000

08000360 <port_lock.lto_priv.20>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000360:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8000362:	4770      	bx	lr
	...

08000370 <port_unlock.lto_priv.18>:
  __ASM volatile ("cpsie i" : : : "memory");
 8000370:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8000372:	4770      	bx	lr
	...

08000380 <port_lock_from_isr.lto_priv.16>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8000380:	b510      	push	{r4, lr}

  port_lock();
 8000382:	f7ff ffed 	bl	8000360 <port_lock.lto_priv.20>
}
 8000386:	bd10      	pop	{r4, pc}
	...

08000390 <port_unlock_from_isr.lto_priv.14>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8000390:	b510      	push	{r4, lr}

  port_unlock();
 8000392:	f7ff ffed 	bl	8000370 <port_unlock.lto_priv.18>
}
 8000396:	bd10      	pop	{r4, pc}
	...

080003a0 <chSysLockFromISR.lto_priv.12>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 80003a0:	b510      	push	{r4, lr}

  port_lock_from_isr();
 80003a2:	f7ff ffed 	bl	8000380 <port_lock_from_isr.lto_priv.16>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 80003a6:	bd10      	pop	{r4, pc}
	...

080003b0 <chSysUnlockFromISR.lto_priv.10>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 80003b0:	b510      	push	{r4, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 80003b2:	f7ff ffed 	bl	8000390 <port_unlock_from_isr.lto_priv.14>
}
 80003b6:	bd10      	pop	{r4, pc}
	...

080003c0 <osalSysLockFromISR.lto_priv.8>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 80003c0:	b510      	push	{r4, lr}

  chSysLockFromISR();
 80003c2:	f7ff ffed 	bl	80003a0 <chSysLockFromISR.lto_priv.12>
}
 80003c6:	bd10      	pop	{r4, pc}
	...

080003d0 <osalSysUnlockFromISR.lto_priv.6>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 80003d0:	b510      	push	{r4, lr}

  chSysUnlockFromISR();
 80003d2:	f7ff ffed 	bl	80003b0 <chSysUnlockFromISR.lto_priv.10>
}
 80003d6:	bd10      	pop	{r4, pc}
	...

080003e0 <osalOsTimerHandlerI>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
 80003e0:	b510      	push	{r4, lr}

  chSysTimerHandlerI();
 80003e2:	f003 fe65 	bl	80040b0 <chSysTimerHandlerI>
}
 80003e6:	bd10      	pop	{r4, pc}
	...

080003f0 <Vector7C>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 80003f0:	b500      	push	{lr}
 80003f2:	b083      	sub	sp, #12
 80003f4:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 80003f6:	9301      	str	r3, [sp, #4]

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 80003f8:	2380      	movs	r3, #128	; 0x80
 80003fa:	05db      	lsls	r3, r3, #23
 80003fc:	691b      	ldr	r3, [r3, #16]
 80003fe:	2202      	movs	r2, #2
 8000400:	4013      	ands	r3, r2
 8000402:	d009      	beq.n	8000418 <Vector7C+0x28>
    STM32_ST_TIM->SR = 0U;
 8000404:	2380      	movs	r3, #128	; 0x80
 8000406:	05db      	lsls	r3, r3, #23
 8000408:	2200      	movs	r2, #0
 800040a:	611a      	str	r2, [r3, #16]

    osalSysLockFromISR();
 800040c:	f7ff ffd8 	bl	80003c0 <osalSysLockFromISR.lto_priv.8>
    osalOsTimerHandlerI();
 8000410:	f7ff ffe6 	bl	80003e0 <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
 8000414:	f7ff ffdc 	bl	80003d0 <osalSysUnlockFromISR.lto_priv.6>
  }

  OSAL_IRQ_EPILOGUE();
 8000418:	9b01      	ldr	r3, [sp, #4]
 800041a:	0018      	movs	r0, r3
 800041c:	f003 fa48 	bl	80038b0 <_port_irq_epilogue>
}
 8000420:	b003      	add	sp, #12
 8000422:	bd00      	pop	{pc}
	...

08000430 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 8000430:	b510      	push	{r4, lr}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8000432:	4b19      	ldr	r3, [pc, #100]	; (8000498 <st_lld_init+0x68>)
 8000434:	4a18      	ldr	r2, [pc, #96]	; (8000498 <st_lld_init+0x68>)
 8000436:	69d2      	ldr	r2, [r2, #28]
 8000438:	2101      	movs	r1, #1
 800043a:	430a      	orrs	r2, r1
 800043c:	61da      	str	r2, [r3, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 800043e:	4b17      	ldr	r3, [pc, #92]	; (800049c <st_lld_init+0x6c>)
 8000440:	4a16      	ldr	r2, [pc, #88]	; (800049c <st_lld_init+0x6c>)
 8000442:	6892      	ldr	r2, [r2, #8]
 8000444:	2101      	movs	r1, #1
 8000446:	430a      	orrs	r2, r1
 8000448:	609a      	str	r2, [r3, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 800044a:	2380      	movs	r3, #128	; 0x80
 800044c:	05db      	lsls	r3, r3, #23
 800044e:	4a14      	ldr	r2, [pc, #80]	; (80004a0 <st_lld_init+0x70>)
 8000450:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8000452:	2380      	movs	r3, #128	; 0x80
 8000454:	05db      	lsls	r3, r3, #23
 8000456:	2201      	movs	r2, #1
 8000458:	4252      	negs	r2, r2
 800045a:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 800045c:	2380      	movs	r3, #128	; 0x80
 800045e:	05db      	lsls	r3, r3, #23
 8000460:	2200      	movs	r2, #0
 8000462:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8000464:	2380      	movs	r3, #128	; 0x80
 8000466:	05db      	lsls	r3, r3, #23
 8000468:	2200      	movs	r2, #0
 800046a:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 800046c:	2380      	movs	r3, #128	; 0x80
 800046e:	05db      	lsls	r3, r3, #23
 8000470:	2200      	movs	r2, #0
 8000472:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8000474:	2380      	movs	r3, #128	; 0x80
 8000476:	05db      	lsls	r3, r3, #23
 8000478:	2200      	movs	r2, #0
 800047a:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800047c:	2380      	movs	r3, #128	; 0x80
 800047e:	05db      	lsls	r3, r3, #23
 8000480:	2201      	movs	r2, #1
 8000482:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8000484:	2380      	movs	r3, #128	; 0x80
 8000486:	05db      	lsls	r3, r3, #23
 8000488:	2201      	movs	r2, #1
 800048a:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 800048c:	2102      	movs	r1, #2
 800048e:	200f      	movs	r0, #15
 8000490:	f001 ff86 	bl	80023a0 <nvicEnableVector>
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8000494:	bd10      	pop	{r4, pc}
 8000496:	46c0      	nop			; (mov r8, r8)
 8000498:	40021000 	.word	0x40021000
 800049c:	40015800 	.word	0x40015800
 80004a0:	000012bf 	.word	0x000012bf
	...

080004b0 <port_lock.lto_priv.21>:
  __ASM volatile ("cpsid i" : : : "memory");
 80004b0:	b672      	cpsid	i
}
 80004b2:	4770      	bx	lr
	...

080004c0 <port_unlock.lto_priv.19>:
  __ASM volatile ("cpsie i" : : : "memory");
 80004c0:	b662      	cpsie	i
}
 80004c2:	4770      	bx	lr
	...

080004d0 <port_lock_from_isr.lto_priv.17>:
static inline void port_lock_from_isr(void) {
 80004d0:	b510      	push	{r4, lr}
  port_lock();
 80004d2:	f7ff ffed 	bl	80004b0 <port_lock.lto_priv.21>
}
 80004d6:	bd10      	pop	{r4, pc}
	...

080004e0 <port_unlock_from_isr.lto_priv.15>:
static inline void port_unlock_from_isr(void) {
 80004e0:	b510      	push	{r4, lr}
  port_unlock();
 80004e2:	f7ff ffed 	bl	80004c0 <port_unlock.lto_priv.19>
}
 80004e6:	bd10      	pop	{r4, pc}
	...

080004f0 <chSysLockFromISR.lto_priv.13>:
static inline void chSysLockFromISR(void) {
 80004f0:	b510      	push	{r4, lr}
  port_lock_from_isr();
 80004f2:	f7ff ffed 	bl	80004d0 <port_lock_from_isr.lto_priv.17>
}
 80004f6:	bd10      	pop	{r4, pc}
	...

08000500 <chSysUnlockFromISR.lto_priv.11>:
static inline void chSysUnlockFromISR(void) {
 8000500:	b510      	push	{r4, lr}
  port_unlock_from_isr();
 8000502:	f7ff ffed 	bl	80004e0 <port_unlock_from_isr.lto_priv.15>
}
 8000506:	bd10      	pop	{r4, pc}
	...

08000510 <osalSysLockFromISR.lto_priv.9>:
static inline void osalSysLockFromISR(void) {
 8000510:	b510      	push	{r4, lr}
  chSysLockFromISR();
 8000512:	f7ff ffed 	bl	80004f0 <chSysLockFromISR.lto_priv.13>
}
 8000516:	bd10      	pop	{r4, pc}
	...

08000520 <osalSysUnlockFromISR.lto_priv.7>:
static inline void osalSysUnlockFromISR(void) {
 8000520:	b510      	push	{r4, lr}
  chSysUnlockFromISR();
 8000522:	f7ff ffed 	bl	8000500 <chSysUnlockFromISR.lto_priv.11>
}
 8000526:	bd10      	pop	{r4, pc}
	...

08000530 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 8000530:	b500      	push	{lr}
 8000532:	b083      	sub	sp, #12
 8000534:	9001      	str	r0, [sp, #4]
 8000536:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
 8000538:	9a00      	ldr	r2, [sp, #0]
 800053a:	9b01      	ldr	r3, [sp, #4]
 800053c:	0011      	movs	r1, r2
 800053e:	0018      	movs	r0, r3
 8000540:	f003 fb7e 	bl	8003c40 <chEvtBroadcastFlagsI>
}
 8000544:	b003      	add	sp, #12
 8000546:	bd00      	pop	{pc}
	...

08000550 <usart_init>:
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
 8000550:	b500      	push	{lr}
 8000552:	b085      	sub	sp, #20
 8000554:	9001      	str	r0, [sp, #4]
 8000556:	9100      	str	r1, [sp, #0]
  USART_TypeDef *u = sdp->usart;
 8000558:	9b01      	ldr	r3, [sp, #4]
 800055a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800055c:	9303      	str	r3, [sp, #12]
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 800055e:	9b01      	ldr	r3, [sp, #4]
 8000560:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8000562:	9b00      	ldr	r3, [sp, #0]
 8000564:	681b      	ldr	r3, [r3, #0]
 8000566:	0019      	movs	r1, r3
 8000568:	0010      	movs	r0, r2
 800056a:	f7ff fe31 	bl	80001d0 <__aeabi_uidiv>
 800056e:	0003      	movs	r3, r0
 8000570:	001a      	movs	r2, r3
 8000572:	9b03      	ldr	r3, [sp, #12]
 8000574:	60da      	str	r2, [r3, #12]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8000576:	9b00      	ldr	r3, [sp, #0]
 8000578:	689b      	ldr	r3, [r3, #8]
 800057a:	2240      	movs	r2, #64	; 0x40
 800057c:	431a      	orrs	r2, r3
 800057e:	9b03      	ldr	r3, [sp, #12]
 8000580:	605a      	str	r2, [r3, #4]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8000582:	9b00      	ldr	r3, [sp, #0]
 8000584:	68db      	ldr	r3, [r3, #12]
 8000586:	2201      	movs	r2, #1
 8000588:	431a      	orrs	r2, r3
 800058a:	9b03      	ldr	r3, [sp, #12]
 800058c:	609a      	str	r2, [r3, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800058e:	9b00      	ldr	r3, [sp, #0]
 8000590:	685b      	ldr	r3, [r3, #4]
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8000592:	222e      	movs	r2, #46	; 0x2e
 8000594:	32ff      	adds	r2, #255	; 0xff
 8000596:	431a      	orrs	r2, r3
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8000598:	9b03      	ldr	r3, [sp, #12]
 800059a:	601a      	str	r2, [r3, #0]
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 800059c:	9b03      	ldr	r3, [sp, #12]
 800059e:	2201      	movs	r2, #1
 80005a0:	4252      	negs	r2, r2
 80005a2:	621a      	str	r2, [r3, #32]

  /* Deciding mask to be applied on the data register on receive, this is
     required in order to mask out the parity bit.*/
  if ((config->cr1 & USART_CR1_PCE) != 0U) {
 80005a4:	9b00      	ldr	r3, [sp, #0]
 80005a6:	685a      	ldr	r2, [r3, #4]
 80005a8:	2380      	movs	r3, #128	; 0x80
 80005aa:	00db      	lsls	r3, r3, #3
 80005ac:	4013      	ands	r3, r2
 80005ae:	d018      	beq.n	80005e2 <usart_init+0x92>
    switch (config->cr1 & (USART_CR1_M_1 | USART_CR1_M_0)) {
 80005b0:	9b00      	ldr	r3, [sp, #0]
 80005b2:	685b      	ldr	r3, [r3, #4]
 80005b4:	4a0e      	ldr	r2, [pc, #56]	; (80005f0 <usart_init+0xa0>)
 80005b6:	4013      	ands	r3, r2
 80005b8:	d004      	beq.n	80005c4 <usart_init+0x74>
 80005ba:	2280      	movs	r2, #128	; 0x80
 80005bc:	0552      	lsls	r2, r2, #21
 80005be:	4293      	cmp	r3, r2
 80005c0:	d005      	beq.n	80005ce <usart_init+0x7e>
 80005c2:	e009      	b.n	80005d8 <usart_init+0x88>
    case 0:
      sdp->rxmask = 0x7F;
 80005c4:	9b01      	ldr	r3, [sp, #4]
 80005c6:	225c      	movs	r2, #92	; 0x5c
 80005c8:	217f      	movs	r1, #127	; 0x7f
 80005ca:	5499      	strb	r1, [r3, r2]
      break;
    case USART_CR1_M_1:
      sdp->rxmask = 0x3F;
      break;
    default:
      sdp->rxmask = 0xFF;
 80005cc:	e00d      	b.n	80005ea <usart_init+0x9a>
      sdp->rxmask = 0x3F;
 80005ce:	9b01      	ldr	r3, [sp, #4]
 80005d0:	225c      	movs	r2, #92	; 0x5c
 80005d2:	213f      	movs	r1, #63	; 0x3f
 80005d4:	5499      	strb	r1, [r3, r2]
      sdp->rxmask = 0xFF;
 80005d6:	e008      	b.n	80005ea <usart_init+0x9a>
 80005d8:	9b01      	ldr	r3, [sp, #4]
 80005da:	225c      	movs	r2, #92	; 0x5c
 80005dc:	21ff      	movs	r1, #255	; 0xff
 80005de:	5499      	strb	r1, [r3, r2]
 80005e0:	e003      	b.n	80005ea <usart_init+0x9a>
    }
  }
  else {
    sdp->rxmask = 0xFF;
 80005e2:	9b01      	ldr	r3, [sp, #4]
 80005e4:	225c      	movs	r2, #92	; 0x5c
 80005e6:	21ff      	movs	r1, #255	; 0xff
 80005e8:	5499      	strb	r1, [r3, r2]
  }
}
 80005ea:	b005      	add	sp, #20
 80005ec:	bd00      	pop	{pc}
 80005ee:	46c0      	nop			; (mov r8, r8)
 80005f0:	10001000 	.word	0x10001000
	...

08000600 <set_error>:
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] isr       USART ISR register value
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
 8000600:	b500      	push	{lr}
 8000602:	b085      	sub	sp, #20
 8000604:	9001      	str	r0, [sp, #4]
 8000606:	9100      	str	r1, [sp, #0]
  eventflags_t sts = 0;
 8000608:	2300      	movs	r3, #0
 800060a:	9303      	str	r3, [sp, #12]

  if (isr & USART_ISR_ORE)
 800060c:	9b00      	ldr	r3, [sp, #0]
 800060e:	2208      	movs	r2, #8
 8000610:	4013      	ands	r3, r2
 8000612:	d003      	beq.n	800061c <set_error+0x1c>
    sts |= SD_OVERRUN_ERROR;
 8000614:	9b03      	ldr	r3, [sp, #12]
 8000616:	2280      	movs	r2, #128	; 0x80
 8000618:	4313      	orrs	r3, r2
 800061a:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_PE)
 800061c:	9b00      	ldr	r3, [sp, #0]
 800061e:	2201      	movs	r2, #1
 8000620:	4013      	ands	r3, r2
 8000622:	d003      	beq.n	800062c <set_error+0x2c>
    sts |= SD_PARITY_ERROR;
 8000624:	9b03      	ldr	r3, [sp, #12]
 8000626:	2220      	movs	r2, #32
 8000628:	4313      	orrs	r3, r2
 800062a:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_FE)
 800062c:	9b00      	ldr	r3, [sp, #0]
 800062e:	2202      	movs	r2, #2
 8000630:	4013      	ands	r3, r2
 8000632:	d003      	beq.n	800063c <set_error+0x3c>
    sts |= SD_FRAMING_ERROR;
 8000634:	9b03      	ldr	r3, [sp, #12]
 8000636:	2240      	movs	r2, #64	; 0x40
 8000638:	4313      	orrs	r3, r2
 800063a:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_NE)
 800063c:	9b00      	ldr	r3, [sp, #0]
 800063e:	2204      	movs	r2, #4
 8000640:	4013      	ands	r3, r2
 8000642:	d004      	beq.n	800064e <set_error+0x4e>
    sts |= SD_NOISE_ERROR;
 8000644:	9b03      	ldr	r3, [sp, #12]
 8000646:	2280      	movs	r2, #128	; 0x80
 8000648:	0052      	lsls	r2, r2, #1
 800064a:	4313      	orrs	r3, r2
 800064c:	9303      	str	r3, [sp, #12]
  osalSysLockFromISR();
 800064e:	f7ff ff5f 	bl	8000510 <osalSysLockFromISR.lto_priv.9>
  chnAddFlagsI(sdp, sts);
 8000652:	9b01      	ldr	r3, [sp, #4]
 8000654:	3304      	adds	r3, #4
 8000656:	9a03      	ldr	r2, [sp, #12]
 8000658:	0011      	movs	r1, r2
 800065a:	0018      	movs	r0, r3
 800065c:	f7ff ff68 	bl	8000530 <osalEventBroadcastFlagsI>
  osalSysUnlockFromISR();
 8000660:	f7ff ff5e 	bl	8000520 <osalSysUnlockFromISR.lto_priv.7>
}
 8000664:	b005      	add	sp, #20
 8000666:	bd00      	pop	{pc}
	...

08000670 <serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 8000670:	b500      	push	{lr}
 8000672:	b087      	sub	sp, #28
 8000674:	9001      	str	r0, [sp, #4]
  USART_TypeDef *u = sdp->usart;
 8000676:	9b01      	ldr	r3, [sp, #4]
 8000678:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800067a:	9305      	str	r3, [sp, #20]
  uint32_t cr1 = u->CR1;
 800067c:	9b05      	ldr	r3, [sp, #20]
 800067e:	681b      	ldr	r3, [r3, #0]
 8000680:	9304      	str	r3, [sp, #16]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 8000682:	9b05      	ldr	r3, [sp, #20]
 8000684:	69db      	ldr	r3, [r3, #28]
 8000686:	9303      	str	r3, [sp, #12]
  u->ICR = isr;
 8000688:	9b05      	ldr	r3, [sp, #20]
 800068a:	9a03      	ldr	r2, [sp, #12]
 800068c:	621a      	str	r2, [r3, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 800068e:	9b03      	ldr	r3, [sp, #12]
 8000690:	220f      	movs	r2, #15
 8000692:	4013      	ands	r3, r2
 8000694:	d005      	beq.n	80006a2 <serve_interrupt+0x32>
    set_error(sdp, isr);
 8000696:	9a03      	ldr	r2, [sp, #12]
 8000698:	9b01      	ldr	r3, [sp, #4]
 800069a:	0011      	movs	r1, r2
 800069c:	0018      	movs	r0, r3
 800069e:	f7ff ffaf 	bl	8000600 <set_error>

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 80006a2:	9a03      	ldr	r2, [sp, #12]
 80006a4:	2380      	movs	r3, #128	; 0x80
 80006a6:	005b      	lsls	r3, r3, #1
 80006a8:	4013      	ands	r3, r2
 80006aa:	d00b      	beq.n	80006c4 <serve_interrupt+0x54>
    osalSysLockFromISR();
 80006ac:	f7ff ff30 	bl	8000510 <osalSysLockFromISR.lto_priv.9>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 80006b0:	9b01      	ldr	r3, [sp, #4]
 80006b2:	1d1a      	adds	r2, r3, #4
 80006b4:	2380      	movs	r3, #128	; 0x80
 80006b6:	009b      	lsls	r3, r3, #2
 80006b8:	0019      	movs	r1, r3
 80006ba:	0010      	movs	r0, r2
 80006bc:	f7ff ff38 	bl	8000530 <osalEventBroadcastFlagsI>
    osalSysUnlockFromISR();
 80006c0:	f7ff ff2e 	bl	8000520 <osalSysUnlockFromISR.lto_priv.7>
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
 80006c4:	9b03      	ldr	r3, [sp, #12]
 80006c6:	2220      	movs	r2, #32
 80006c8:	4013      	ands	r3, r2
 80006ca:	d011      	beq.n	80006f0 <serve_interrupt+0x80>
    osalSysLockFromISR();
 80006cc:	f7ff ff20 	bl	8000510 <osalSysLockFromISR.lto_priv.9>
    sdIncomingDataI(sdp, (uint8_t)u->RDR & sdp->rxmask);
 80006d0:	9b05      	ldr	r3, [sp, #20]
 80006d2:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 80006d4:	b29b      	uxth	r3, r3
 80006d6:	b2db      	uxtb	r3, r3
 80006d8:	9a01      	ldr	r2, [sp, #4]
 80006da:	215c      	movs	r1, #92	; 0x5c
 80006dc:	5c52      	ldrb	r2, [r2, r1]
 80006de:	4013      	ands	r3, r2
 80006e0:	b2da      	uxtb	r2, r3
 80006e2:	9b01      	ldr	r3, [sp, #4]
 80006e4:	0011      	movs	r1, r2
 80006e6:	0018      	movs	r0, r3
 80006e8:	f001 fde2 	bl	80022b0 <sdIncomingDataI>
    osalSysUnlockFromISR();
 80006ec:	f7ff ff18 	bl	8000520 <osalSysUnlockFromISR.lto_priv.7>
  }

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
 80006f0:	9b04      	ldr	r3, [sp, #16]
 80006f2:	2280      	movs	r2, #128	; 0x80
 80006f4:	4013      	ands	r3, r2
 80006f6:	d023      	beq.n	8000740 <serve_interrupt+0xd0>
 80006f8:	9b03      	ldr	r3, [sp, #12]
 80006fa:	2280      	movs	r2, #128	; 0x80
 80006fc:	4013      	ands	r3, r2
 80006fe:	d01f      	beq.n	8000740 <serve_interrupt+0xd0>
    msg_t b;
    osalSysLockFromISR();
 8000700:	f7ff ff06 	bl	8000510 <osalSysLockFromISR.lto_priv.9>
    b = oqGetI(&sdp->oqueue);
 8000704:	9b01      	ldr	r3, [sp, #4]
 8000706:	3330      	adds	r3, #48	; 0x30
 8000708:	0018      	movs	r0, r3
 800070a:	f002 fdc9 	bl	80032a0 <oqGetI>
 800070e:	0003      	movs	r3, r0
 8000710:	9302      	str	r3, [sp, #8]
    if (b < MSG_OK) {
 8000712:	9b02      	ldr	r3, [sp, #8]
 8000714:	2b00      	cmp	r3, #0
 8000716:	da0d      	bge.n	8000734 <serve_interrupt+0xc4>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 8000718:	9b01      	ldr	r3, [sp, #4]
 800071a:	3304      	adds	r3, #4
 800071c:	2108      	movs	r1, #8
 800071e:	0018      	movs	r0, r3
 8000720:	f7ff ff06 	bl	8000530 <osalEventBroadcastFlagsI>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8000724:	9b04      	ldr	r3, [sp, #16]
 8000726:	22c0      	movs	r2, #192	; 0xc0
 8000728:	4393      	bics	r3, r2
 800072a:	2240      	movs	r2, #64	; 0x40
 800072c:	431a      	orrs	r2, r3
 800072e:	9b05      	ldr	r3, [sp, #20]
 8000730:	601a      	str	r2, [r3, #0]
 8000732:	e003      	b.n	800073c <serve_interrupt+0xcc>
    }
    else
      u->TDR = b;
 8000734:	9b02      	ldr	r3, [sp, #8]
 8000736:	b29a      	uxth	r2, r3
 8000738:	9b05      	ldr	r3, [sp, #20]
 800073a:	851a      	strh	r2, [r3, #40]	; 0x28
    osalSysUnlockFromISR();
 800073c:	f7ff fef0 	bl	8000520 <osalSysUnlockFromISR.lto_priv.7>
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
 8000740:	9b03      	ldr	r3, [sp, #12]
 8000742:	2240      	movs	r2, #64	; 0x40
 8000744:	4013      	ands	r3, r2
 8000746:	d022      	beq.n	800078e <serve_interrupt+0x11e>
    osalSysLockFromISR();
 8000748:	f7ff fee2 	bl	8000510 <osalSysLockFromISR.lto_priv.9>
    if (oqIsEmptyI(&sdp->oqueue))
 800074c:	9b01      	ldr	r3, [sp, #4]
 800074e:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8000750:	9b01      	ldr	r3, [sp, #4]
 8000752:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8000754:	429a      	cmp	r2, r3
 8000756:	d105      	bne.n	8000764 <serve_interrupt+0xf4>
 8000758:	9b01      	ldr	r3, [sp, #4]
 800075a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800075c:	2b00      	cmp	r3, #0
 800075e:	d001      	beq.n	8000764 <serve_interrupt+0xf4>
 8000760:	2301      	movs	r3, #1
 8000762:	e000      	b.n	8000766 <serve_interrupt+0xf6>
 8000764:	2300      	movs	r3, #0
 8000766:	1c1a      	adds	r2, r3, #0
 8000768:	2301      	movs	r3, #1
 800076a:	4013      	ands	r3, r2
 800076c:	b2db      	uxtb	r3, r3
 800076e:	2b00      	cmp	r3, #0
 8000770:	d005      	beq.n	800077e <serve_interrupt+0x10e>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 8000772:	9b01      	ldr	r3, [sp, #4]
 8000774:	3304      	adds	r3, #4
 8000776:	2110      	movs	r1, #16
 8000778:	0018      	movs	r0, r3
 800077a:	f7ff fed9 	bl	8000530 <osalEventBroadcastFlagsI>
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 800077e:	9b04      	ldr	r3, [sp, #16]
 8000780:	2240      	movs	r2, #64	; 0x40
 8000782:	4393      	bics	r3, r2
 8000784:	001a      	movs	r2, r3
 8000786:	9b05      	ldr	r3, [sp, #20]
 8000788:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 800078a:	f7ff fec9 	bl	8000520 <osalSysUnlockFromISR.lto_priv.7>
  }
}
 800078e:	b007      	add	sp, #28
 8000790:	bd00      	pop	{pc}
 8000792:	46c0      	nop			; (mov r8, r8)
	...

080007a0 <notify2>:
  USART1->CR1 |= USART_CR1_TXEIE;
}
#endif

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {
 80007a0:	b082      	sub	sp, #8
 80007a2:	9001      	str	r0, [sp, #4]

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE;
 80007a4:	4b03      	ldr	r3, [pc, #12]	; (80007b4 <notify2+0x14>)
 80007a6:	4a03      	ldr	r2, [pc, #12]	; (80007b4 <notify2+0x14>)
 80007a8:	6812      	ldr	r2, [r2, #0]
 80007aa:	2180      	movs	r1, #128	; 0x80
 80007ac:	430a      	orrs	r2, r1
 80007ae:	601a      	str	r2, [r3, #0]
}
 80007b0:	b002      	add	sp, #8
 80007b2:	4770      	bx	lr
 80007b4:	40004400 	.word	0x40004400
	...

080007c0 <VectorB0>:
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 80007c0:	b500      	push	{lr}
 80007c2:	b083      	sub	sp, #12
 80007c4:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 80007c6:	9301      	str	r3, [sp, #4]

  serve_interrupt(&SD2);
 80007c8:	4b04      	ldr	r3, [pc, #16]	; (80007dc <VectorB0+0x1c>)
 80007ca:	0018      	movs	r0, r3
 80007cc:	f7ff ff50 	bl	8000670 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 80007d0:	9b01      	ldr	r3, [sp, #4]
 80007d2:	0018      	movs	r0, r3
 80007d4:	f003 f86c 	bl	80038b0 <_port_irq_epilogue>
}
 80007d8:	b003      	add	sp, #12
 80007da:	bd00      	pop	{pc}
 80007dc:	20000610 	.word	0x20000610

080007e0 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 80007e0:	b500      	push	{lr}
 80007e2:	b083      	sub	sp, #12
  nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
#endif
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2);
 80007e4:	4b10      	ldr	r3, [pc, #64]	; (8000828 <sd_lld_init+0x48>)
 80007e6:	0018      	movs	r0, r3
 80007e8:	f001 fd32 	bl	8002250 <sdObjectInit>
  iqObjectInit(&SD2.iqueue, sd_in_buf2, sizeof sd_in_buf2, NULL, &SD2);
 80007ec:	490f      	ldr	r1, [pc, #60]	; (800082c <sd_lld_init+0x4c>)
 80007ee:	4810      	ldr	r0, [pc, #64]	; (8000830 <sd_lld_init+0x50>)
 80007f0:	4b0d      	ldr	r3, [pc, #52]	; (8000828 <sd_lld_init+0x48>)
 80007f2:	9300      	str	r3, [sp, #0]
 80007f4:	2300      	movs	r3, #0
 80007f6:	2210      	movs	r2, #16
 80007f8:	f002 fbba 	bl	8002f70 <iqObjectInit>
  oqObjectInit(&SD2.oqueue, sd_out_buf2, sizeof sd_out_buf2, notify2, &SD2);
 80007fc:	4a0d      	ldr	r2, [pc, #52]	; (8000834 <sd_lld_init+0x54>)
 80007fe:	490e      	ldr	r1, [pc, #56]	; (8000838 <sd_lld_init+0x58>)
 8000800:	480e      	ldr	r0, [pc, #56]	; (800083c <sd_lld_init+0x5c>)
 8000802:	4b09      	ldr	r3, [pc, #36]	; (8000828 <sd_lld_init+0x48>)
 8000804:	9300      	str	r3, [sp, #0]
 8000806:	0013      	movs	r3, r2
 8000808:	2210      	movs	r2, #16
 800080a:	f002 fcd9 	bl	80031c0 <oqObjectInit>
  SD2.usart = USART2;
 800080e:	4b06      	ldr	r3, [pc, #24]	; (8000828 <sd_lld_init+0x48>)
 8000810:	4a0b      	ldr	r2, [pc, #44]	; (8000840 <sd_lld_init+0x60>)
 8000812:	655a      	str	r2, [r3, #84]	; 0x54
  SD2.clock = STM32_USART2CLK;
 8000814:	4b04      	ldr	r3, [pc, #16]	; (8000828 <sd_lld_init+0x48>)
 8000816:	4a0b      	ldr	r2, [pc, #44]	; (8000844 <sd_lld_init+0x64>)
 8000818:	659a      	str	r2, [r3, #88]	; 0x58
#if defined(STM32_USART2_NUMBER)
  nvicEnableVector(STM32_USART2_NUMBER, STM32_SERIAL_USART2_PRIORITY);
 800081a:	2103      	movs	r1, #3
 800081c:	201c      	movs	r0, #28
 800081e:	f001 fdbf 	bl	80023a0 <nvicEnableVector>
    STM32_SERIAL_USE_UART7  || STM32_SERIAL_USE_UART8
#if defined(STM32_USART3_8_HANDLER)
  nvicEnableVector(STM32_USART3_8_NUMBER, STM32_SERIAL_USART3_8_PRIORITY);
#endif
#endif
}
 8000822:	b003      	add	sp, #12
 8000824:	bd00      	pop	{pc}
 8000826:	46c0      	nop			; (mov r8, r8)
 8000828:	20000610 	.word	0x20000610
 800082c:	20000670 	.word	0x20000670
 8000830:	2000061c 	.word	0x2000061c
 8000834:	080007a1 	.word	0x080007a1
 8000838:	20000680 	.word	0x20000680
 800083c:	20000640 	.word	0x20000640
 8000840:	40004400 	.word	0x40004400
 8000844:	02dc6c00 	.word	0x02dc6c00
	...

08000850 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 8000850:	b500      	push	{lr}
 8000852:	b083      	sub	sp, #12
 8000854:	9001      	str	r0, [sp, #4]
 8000856:	9100      	str	r1, [sp, #0]

  if (config == NULL)
 8000858:	9b00      	ldr	r3, [sp, #0]
 800085a:	2b00      	cmp	r3, #0
 800085c:	d101      	bne.n	8000862 <sd_lld_start+0x12>
    config = &default_config;
 800085e:	4b0c      	ldr	r3, [pc, #48]	; (8000890 <sd_lld_start+0x40>)
 8000860:	9300      	str	r3, [sp, #0]

  if (sdp->state == SD_STOP) {
 8000862:	9b01      	ldr	r3, [sp, #4]
 8000864:	7a1b      	ldrb	r3, [r3, #8]
 8000866:	2b01      	cmp	r3, #1
 8000868:	d10a      	bne.n	8000880 <sd_lld_start+0x30>
    if (&SD1 == sdp) {
      rccEnableUSART1(FALSE);
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
 800086a:	9a01      	ldr	r2, [sp, #4]
 800086c:	4b09      	ldr	r3, [pc, #36]	; (8000894 <sd_lld_start+0x44>)
 800086e:	429a      	cmp	r2, r3
 8000870:	d106      	bne.n	8000880 <sd_lld_start+0x30>
      rccEnableUSART2(FALSE);
 8000872:	4b09      	ldr	r3, [pc, #36]	; (8000898 <sd_lld_start+0x48>)
 8000874:	4a08      	ldr	r2, [pc, #32]	; (8000898 <sd_lld_start+0x48>)
 8000876:	69d2      	ldr	r2, [r2, #28]
 8000878:	2180      	movs	r1, #128	; 0x80
 800087a:	0289      	lsls	r1, r1, #10
 800087c:	430a      	orrs	r2, r1
 800087e:	61da      	str	r2, [r3, #28]
    if (&LPSD1 == sdp) {
      rccEnableLPUART1(FALSE);
    }
#endif
  }
  usart_init(sdp, config);
 8000880:	9a00      	ldr	r2, [sp, #0]
 8000882:	9b01      	ldr	r3, [sp, #4]
 8000884:	0011      	movs	r1, r2
 8000886:	0018      	movs	r0, r3
 8000888:	f7ff fe62 	bl	8000550 <usart_init>
}
 800088c:	b003      	add	sp, #12
 800088e:	bd00      	pop	{pc}
 8000890:	08004c04 	.word	0x08004c04
 8000894:	20000610 	.word	0x20000610
 8000898:	40021000 	.word	0x40021000
 800089c:	00000000 	.word	0x00000000

080008a0 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
 80008a0:	b510      	push	{r4, lr}

  stm32_clock_init();
 80008a2:	f001 fefd 	bl	80026a0 <stm32_clock_init>
}
 80008a6:	bd10      	pop	{r4, pc}
	...

080008b0 <boardInit>:
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
}
 80008b0:	4770      	bx	lr
 80008b2:	46c0      	nop			; (mov r8, r8)
	...

080008c0 <long_to_string_with_divisor>:
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
                                         long num,
                                         unsigned radix,
                                         long divisor) {
 80008c0:	b500      	push	{lr}
 80008c2:	b089      	sub	sp, #36	; 0x24
 80008c4:	9003      	str	r0, [sp, #12]
 80008c6:	9102      	str	r1, [sp, #8]
 80008c8:	9201      	str	r2, [sp, #4]
 80008ca:	9300      	str	r3, [sp, #0]
  int i;
  char *q;
  long l, ll;

  l = num;
 80008cc:	9b02      	ldr	r3, [sp, #8]
 80008ce:	9305      	str	r3, [sp, #20]
  if (divisor == 0) {
 80008d0:	9b00      	ldr	r3, [sp, #0]
 80008d2:	2b00      	cmp	r3, #0
 80008d4:	d102      	bne.n	80008dc <long_to_string_with_divisor+0x1c>
    ll = num;
 80008d6:	9b02      	ldr	r3, [sp, #8]
 80008d8:	9304      	str	r3, [sp, #16]
 80008da:	e001      	b.n	80008e0 <long_to_string_with_divisor+0x20>
  } else {
    ll = divisor;
 80008dc:	9b00      	ldr	r3, [sp, #0]
 80008de:	9304      	str	r3, [sp, #16]
  }

  q = p + MAX_FILLER;
 80008e0:	9b03      	ldr	r3, [sp, #12]
 80008e2:	330b      	adds	r3, #11
 80008e4:	9306      	str	r3, [sp, #24]
  do {
    i = (int)(l % radix);
 80008e6:	9b05      	ldr	r3, [sp, #20]
 80008e8:	9901      	ldr	r1, [sp, #4]
 80008ea:	0018      	movs	r0, r3
 80008ec:	f7ff fcf6 	bl	80002dc <__aeabi_uidivmod>
 80008f0:	000b      	movs	r3, r1
 80008f2:	9307      	str	r3, [sp, #28]
    i += '0';
 80008f4:	9b07      	ldr	r3, [sp, #28]
 80008f6:	3330      	adds	r3, #48	; 0x30
 80008f8:	9307      	str	r3, [sp, #28]
    if (i > '9')
 80008fa:	9b07      	ldr	r3, [sp, #28]
 80008fc:	2b39      	cmp	r3, #57	; 0x39
 80008fe:	dd02      	ble.n	8000906 <long_to_string_with_divisor+0x46>
      i += 'A' - '0' - 10;
 8000900:	9b07      	ldr	r3, [sp, #28]
 8000902:	3307      	adds	r3, #7
 8000904:	9307      	str	r3, [sp, #28]
    *--q = i;
 8000906:	9b06      	ldr	r3, [sp, #24]
 8000908:	3b01      	subs	r3, #1
 800090a:	9306      	str	r3, [sp, #24]
 800090c:	9b07      	ldr	r3, [sp, #28]
 800090e:	b2da      	uxtb	r2, r3
 8000910:	9b06      	ldr	r3, [sp, #24]
 8000912:	701a      	strb	r2, [r3, #0]
    l /= radix;
 8000914:	9b05      	ldr	r3, [sp, #20]
 8000916:	9901      	ldr	r1, [sp, #4]
 8000918:	0018      	movs	r0, r3
 800091a:	f7ff fc59 	bl	80001d0 <__aeabi_uidiv>
 800091e:	0003      	movs	r3, r0
 8000920:	9305      	str	r3, [sp, #20]
  } while ((ll /= radix) != 0);
 8000922:	9b04      	ldr	r3, [sp, #16]
 8000924:	9901      	ldr	r1, [sp, #4]
 8000926:	0018      	movs	r0, r3
 8000928:	f7ff fc52 	bl	80001d0 <__aeabi_uidiv>
 800092c:	0003      	movs	r3, r0
 800092e:	9304      	str	r3, [sp, #16]
 8000930:	9b04      	ldr	r3, [sp, #16]
 8000932:	2b00      	cmp	r3, #0
 8000934:	d1d7      	bne.n	80008e6 <long_to_string_with_divisor+0x26>

  i = (int)(p + MAX_FILLER - q);
 8000936:	9b03      	ldr	r3, [sp, #12]
 8000938:	330b      	adds	r3, #11
 800093a:	001a      	movs	r2, r3
 800093c:	9b06      	ldr	r3, [sp, #24]
 800093e:	1ad3      	subs	r3, r2, r3
 8000940:	9307      	str	r3, [sp, #28]
  do
    *p++ = *q++;
 8000942:	9b03      	ldr	r3, [sp, #12]
 8000944:	1c5a      	adds	r2, r3, #1
 8000946:	9203      	str	r2, [sp, #12]
 8000948:	9a06      	ldr	r2, [sp, #24]
 800094a:	1c51      	adds	r1, r2, #1
 800094c:	9106      	str	r1, [sp, #24]
 800094e:	7812      	ldrb	r2, [r2, #0]
 8000950:	701a      	strb	r2, [r3, #0]
  while (--i);
 8000952:	9b07      	ldr	r3, [sp, #28]
 8000954:	3b01      	subs	r3, #1
 8000956:	9307      	str	r3, [sp, #28]
 8000958:	9b07      	ldr	r3, [sp, #28]
 800095a:	2b00      	cmp	r3, #0
 800095c:	d1f1      	bne.n	8000942 <long_to_string_with_divisor+0x82>

  return p;
 800095e:	9b03      	ldr	r3, [sp, #12]
}
 8000960:	0018      	movs	r0, r3
 8000962:	b009      	add	sp, #36	; 0x24
 8000964:	bd00      	pop	{pc}
 8000966:	46c0      	nop			; (mov r8, r8)
	...

08000970 <ch_ltoa>:

static char *ch_ltoa(char *p, long num, unsigned radix) {
 8000970:	b500      	push	{lr}
 8000972:	b085      	sub	sp, #20
 8000974:	9003      	str	r0, [sp, #12]
 8000976:	9102      	str	r1, [sp, #8]
 8000978:	9201      	str	r2, [sp, #4]

  return long_to_string_with_divisor(p, num, radix, 0);
 800097a:	9a01      	ldr	r2, [sp, #4]
 800097c:	9902      	ldr	r1, [sp, #8]
 800097e:	9803      	ldr	r0, [sp, #12]
 8000980:	2300      	movs	r3, #0
 8000982:	f7ff ff9d 	bl	80008c0 <long_to_string_with_divisor>
 8000986:	0003      	movs	r3, r0
}
 8000988:	0018      	movs	r0, r3
 800098a:	b005      	add	sp, #20
 800098c:	bd00      	pop	{pc}
 800098e:	46c0      	nop			; (mov r8, r8)

08000990 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8000990:	b500      	push	{lr}
 8000992:	b091      	sub	sp, #68	; 0x44
 8000994:	9003      	str	r0, [sp, #12]
 8000996:	9102      	str	r1, [sp, #8]
 8000998:	9201      	str	r2, [sp, #4]
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 800099a:	2300      	movs	r3, #0
 800099c:	9309      	str	r3, [sp, #36]	; 0x24
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 800099e:	9b02      	ldr	r3, [sp, #8]
 80009a0:	1c5a      	adds	r2, r3, #1
 80009a2:	9202      	str	r2, [sp, #8]
 80009a4:	2237      	movs	r2, #55	; 0x37
 80009a6:	446a      	add	r2, sp
 80009a8:	781b      	ldrb	r3, [r3, #0]
 80009aa:	7013      	strb	r3, [r2, #0]
    if (c == 0)
 80009ac:	2337      	movs	r3, #55	; 0x37
 80009ae:	446b      	add	r3, sp
 80009b0:	781b      	ldrb	r3, [r3, #0]
 80009b2:	2b00      	cmp	r3, #0
 80009b4:	d101      	bne.n	80009ba <chvprintf+0x2a>
      return n;
 80009b6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80009b8:	e1cf      	b.n	8000d5a <chvprintf+0x3ca>
    if (c != '%') {
 80009ba:	2337      	movs	r3, #55	; 0x37
 80009bc:	446b      	add	r3, sp
 80009be:	781b      	ldrb	r3, [r3, #0]
 80009c0:	2b25      	cmp	r3, #37	; 0x25
 80009c2:	d00c      	beq.n	80009de <chvprintf+0x4e>
      streamPut(chp, (uint8_t)c);
 80009c4:	9b03      	ldr	r3, [sp, #12]
 80009c6:	681b      	ldr	r3, [r3, #0]
 80009c8:	689b      	ldr	r3, [r3, #8]
 80009ca:	2237      	movs	r2, #55	; 0x37
 80009cc:	446a      	add	r2, sp
 80009ce:	7811      	ldrb	r1, [r2, #0]
 80009d0:	9a03      	ldr	r2, [sp, #12]
 80009d2:	0010      	movs	r0, r2
 80009d4:	4798      	blx	r3
      n++;
 80009d6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80009d8:	3301      	adds	r3, #1
 80009da:	9309      	str	r3, [sp, #36]	; 0x24
 80009dc:	e7df      	b.n	800099e <chvprintf+0xe>
      continue;
    }
    p = tmpbuf;
 80009de:	ab04      	add	r3, sp, #16
 80009e0:	930f      	str	r3, [sp, #60]	; 0x3c
    s = tmpbuf;
 80009e2:	ab04      	add	r3, sp, #16
 80009e4:	930e      	str	r3, [sp, #56]	; 0x38
    left_align = FALSE;
 80009e6:	2322      	movs	r3, #34	; 0x22
 80009e8:	446b      	add	r3, sp
 80009ea:	2200      	movs	r2, #0
 80009ec:	701a      	strb	r2, [r3, #0]
    if (*fmt == '-') {
 80009ee:	9b02      	ldr	r3, [sp, #8]
 80009f0:	781b      	ldrb	r3, [r3, #0]
 80009f2:	2b2d      	cmp	r3, #45	; 0x2d
 80009f4:	d106      	bne.n	8000a04 <chvprintf+0x74>
      fmt++;
 80009f6:	9b02      	ldr	r3, [sp, #8]
 80009f8:	3301      	adds	r3, #1
 80009fa:	9302      	str	r3, [sp, #8]
      left_align = TRUE;
 80009fc:	2322      	movs	r3, #34	; 0x22
 80009fe:	446b      	add	r3, sp
 8000a00:	2201      	movs	r2, #1
 8000a02:	701a      	strb	r2, [r3, #0]
    }
    filler = ' ';
 8000a04:	2336      	movs	r3, #54	; 0x36
 8000a06:	446b      	add	r3, sp
 8000a08:	2220      	movs	r2, #32
 8000a0a:	701a      	strb	r2, [r3, #0]
    if (*fmt == '0') {
 8000a0c:	9b02      	ldr	r3, [sp, #8]
 8000a0e:	781b      	ldrb	r3, [r3, #0]
 8000a10:	2b30      	cmp	r3, #48	; 0x30
 8000a12:	d106      	bne.n	8000a22 <chvprintf+0x92>
      fmt++;
 8000a14:	9b02      	ldr	r3, [sp, #8]
 8000a16:	3301      	adds	r3, #1
 8000a18:	9302      	str	r3, [sp, #8]
      filler = '0';
 8000a1a:	2336      	movs	r3, #54	; 0x36
 8000a1c:	446b      	add	r3, sp
 8000a1e:	2230      	movs	r2, #48	; 0x30
 8000a20:	701a      	strb	r2, [r3, #0]
    }
    width = 0;
 8000a22:	2300      	movs	r3, #0
 8000a24:	930a      	str	r3, [sp, #40]	; 0x28
    while (TRUE) {
      c = *fmt++;
 8000a26:	9b02      	ldr	r3, [sp, #8]
 8000a28:	1c5a      	adds	r2, r3, #1
 8000a2a:	9202      	str	r2, [sp, #8]
 8000a2c:	2237      	movs	r2, #55	; 0x37
 8000a2e:	446a      	add	r2, sp
 8000a30:	781b      	ldrb	r3, [r3, #0]
 8000a32:	7013      	strb	r3, [r2, #0]
      if (c >= '0' && c <= '9')
 8000a34:	2337      	movs	r3, #55	; 0x37
 8000a36:	446b      	add	r3, sp
 8000a38:	781b      	ldrb	r3, [r3, #0]
 8000a3a:	2b2f      	cmp	r3, #47	; 0x2f
 8000a3c:	d90c      	bls.n	8000a58 <chvprintf+0xc8>
 8000a3e:	2337      	movs	r3, #55	; 0x37
 8000a40:	446b      	add	r3, sp
 8000a42:	781b      	ldrb	r3, [r3, #0]
 8000a44:	2b39      	cmp	r3, #57	; 0x39
 8000a46:	d807      	bhi.n	8000a58 <chvprintf+0xc8>
        c -= '0';
 8000a48:	2337      	movs	r3, #55	; 0x37
 8000a4a:	446b      	add	r3, sp
 8000a4c:	2237      	movs	r2, #55	; 0x37
 8000a4e:	446a      	add	r2, sp
 8000a50:	7812      	ldrb	r2, [r2, #0]
 8000a52:	3a30      	subs	r2, #48	; 0x30
 8000a54:	701a      	strb	r2, [r3, #0]
 8000a56:	e00b      	b.n	8000a70 <chvprintf+0xe0>
      else if (c == '*')
 8000a58:	2337      	movs	r3, #55	; 0x37
 8000a5a:	446b      	add	r3, sp
 8000a5c:	781b      	ldrb	r3, [r3, #0]
 8000a5e:	2b2a      	cmp	r3, #42	; 0x2a
 8000a60:	d112      	bne.n	8000a88 <chvprintf+0xf8>
        c = va_arg(ap, int);
 8000a62:	9b01      	ldr	r3, [sp, #4]
 8000a64:	1d1a      	adds	r2, r3, #4
 8000a66:	9201      	str	r2, [sp, #4]
 8000a68:	681a      	ldr	r2, [r3, #0]
 8000a6a:	2337      	movs	r3, #55	; 0x37
 8000a6c:	446b      	add	r3, sp
 8000a6e:	701a      	strb	r2, [r3, #0]
      else
        break;
      width = width * 10 + c;
 8000a70:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8000a72:	0013      	movs	r3, r2
 8000a74:	009b      	lsls	r3, r3, #2
 8000a76:	189b      	adds	r3, r3, r2
 8000a78:	005b      	lsls	r3, r3, #1
 8000a7a:	001a      	movs	r2, r3
 8000a7c:	2337      	movs	r3, #55	; 0x37
 8000a7e:	446b      	add	r3, sp
 8000a80:	781b      	ldrb	r3, [r3, #0]
 8000a82:	18d3      	adds	r3, r2, r3
 8000a84:	930a      	str	r3, [sp, #40]	; 0x28
 8000a86:	e7ce      	b.n	8000a26 <chvprintf+0x96>
    }
    precision = 0;
 8000a88:	2300      	movs	r3, #0
 8000a8a:	930b      	str	r3, [sp, #44]	; 0x2c
    if (c == '.') {
 8000a8c:	2337      	movs	r3, #55	; 0x37
 8000a8e:	446b      	add	r3, sp
 8000a90:	781b      	ldrb	r3, [r3, #0]
 8000a92:	2b2e      	cmp	r3, #46	; 0x2e
 8000a94:	d131      	bne.n	8000afa <chvprintf+0x16a>
      while (TRUE) {
        c = *fmt++;
 8000a96:	9b02      	ldr	r3, [sp, #8]
 8000a98:	1c5a      	adds	r2, r3, #1
 8000a9a:	9202      	str	r2, [sp, #8]
 8000a9c:	2237      	movs	r2, #55	; 0x37
 8000a9e:	446a      	add	r2, sp
 8000aa0:	781b      	ldrb	r3, [r3, #0]
 8000aa2:	7013      	strb	r3, [r2, #0]
        if (c >= '0' && c <= '9')
 8000aa4:	2337      	movs	r3, #55	; 0x37
 8000aa6:	446b      	add	r3, sp
 8000aa8:	781b      	ldrb	r3, [r3, #0]
 8000aaa:	2b2f      	cmp	r3, #47	; 0x2f
 8000aac:	d90c      	bls.n	8000ac8 <chvprintf+0x138>
 8000aae:	2337      	movs	r3, #55	; 0x37
 8000ab0:	446b      	add	r3, sp
 8000ab2:	781b      	ldrb	r3, [r3, #0]
 8000ab4:	2b39      	cmp	r3, #57	; 0x39
 8000ab6:	d807      	bhi.n	8000ac8 <chvprintf+0x138>
          c -= '0';
 8000ab8:	2337      	movs	r3, #55	; 0x37
 8000aba:	446b      	add	r3, sp
 8000abc:	2237      	movs	r2, #55	; 0x37
 8000abe:	446a      	add	r2, sp
 8000ac0:	7812      	ldrb	r2, [r2, #0]
 8000ac2:	3a30      	subs	r2, #48	; 0x30
 8000ac4:	701a      	strb	r2, [r3, #0]
 8000ac6:	e00b      	b.n	8000ae0 <chvprintf+0x150>
        else if (c == '*')
 8000ac8:	2337      	movs	r3, #55	; 0x37
 8000aca:	446b      	add	r3, sp
 8000acc:	781b      	ldrb	r3, [r3, #0]
 8000ace:	2b2a      	cmp	r3, #42	; 0x2a
 8000ad0:	d113      	bne.n	8000afa <chvprintf+0x16a>
          c = va_arg(ap, int);
 8000ad2:	9b01      	ldr	r3, [sp, #4]
 8000ad4:	1d1a      	adds	r2, r3, #4
 8000ad6:	9201      	str	r2, [sp, #4]
 8000ad8:	681a      	ldr	r2, [r3, #0]
 8000ada:	2337      	movs	r3, #55	; 0x37
 8000adc:	446b      	add	r3, sp
 8000ade:	701a      	strb	r2, [r3, #0]
        else
          break;
        precision *= 10;
 8000ae0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8000ae2:	0013      	movs	r3, r2
 8000ae4:	009b      	lsls	r3, r3, #2
 8000ae6:	189b      	adds	r3, r3, r2
 8000ae8:	005b      	lsls	r3, r3, #1
 8000aea:	930b      	str	r3, [sp, #44]	; 0x2c
        precision += c;
 8000aec:	2337      	movs	r3, #55	; 0x37
 8000aee:	446b      	add	r3, sp
 8000af0:	781b      	ldrb	r3, [r3, #0]
 8000af2:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8000af4:	18d3      	adds	r3, r2, r3
 8000af6:	930b      	str	r3, [sp, #44]	; 0x2c
 8000af8:	e7cd      	b.n	8000a96 <chvprintf+0x106>
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 8000afa:	2337      	movs	r3, #55	; 0x37
 8000afc:	446b      	add	r3, sp
 8000afe:	781b      	ldrb	r3, [r3, #0]
 8000b00:	2b6c      	cmp	r3, #108	; 0x6c
 8000b02:	d004      	beq.n	8000b0e <chvprintf+0x17e>
 8000b04:	2337      	movs	r3, #55	; 0x37
 8000b06:	446b      	add	r3, sp
 8000b08:	781b      	ldrb	r3, [r3, #0]
 8000b0a:	2b4c      	cmp	r3, #76	; 0x4c
 8000b0c:	d10f      	bne.n	8000b2e <chvprintf+0x19e>
      is_long = TRUE;
 8000b0e:	2323      	movs	r3, #35	; 0x23
 8000b10:	446b      	add	r3, sp
 8000b12:	2201      	movs	r2, #1
 8000b14:	701a      	strb	r2, [r3, #0]
      if (*fmt)
 8000b16:	9b02      	ldr	r3, [sp, #8]
 8000b18:	781b      	ldrb	r3, [r3, #0]
 8000b1a:	2b00      	cmp	r3, #0
 8000b1c:	d01c      	beq.n	8000b58 <chvprintf+0x1c8>
        c = *fmt++;
 8000b1e:	9b02      	ldr	r3, [sp, #8]
 8000b20:	1c5a      	adds	r2, r3, #1
 8000b22:	9202      	str	r2, [sp, #8]
 8000b24:	2237      	movs	r2, #55	; 0x37
 8000b26:	446a      	add	r2, sp
 8000b28:	781b      	ldrb	r3, [r3, #0]
 8000b2a:	7013      	strb	r3, [r2, #0]
 8000b2c:	e015      	b.n	8000b5a <chvprintf+0x1ca>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');
 8000b2e:	2337      	movs	r3, #55	; 0x37
 8000b30:	446b      	add	r3, sp
 8000b32:	781b      	ldrb	r3, [r3, #0]
 8000b34:	2b40      	cmp	r3, #64	; 0x40
 8000b36:	d906      	bls.n	8000b46 <chvprintf+0x1b6>
 8000b38:	2337      	movs	r3, #55	; 0x37
 8000b3a:	446b      	add	r3, sp
 8000b3c:	781b      	ldrb	r3, [r3, #0]
 8000b3e:	2b5a      	cmp	r3, #90	; 0x5a
 8000b40:	d801      	bhi.n	8000b46 <chvprintf+0x1b6>
 8000b42:	2201      	movs	r2, #1
 8000b44:	e000      	b.n	8000b48 <chvprintf+0x1b8>
 8000b46:	2200      	movs	r2, #0
 8000b48:	2323      	movs	r3, #35	; 0x23
 8000b4a:	446b      	add	r3, sp
 8000b4c:	701a      	strb	r2, [r3, #0]
 8000b4e:	781a      	ldrb	r2, [r3, #0]
 8000b50:	2101      	movs	r1, #1
 8000b52:	400a      	ands	r2, r1
 8000b54:	701a      	strb	r2, [r3, #0]
 8000b56:	e000      	b.n	8000b5a <chvprintf+0x1ca>
        c = *fmt++;
 8000b58:	46c0      	nop			; (mov r8, r8)

    /* Command decoding.*/
    switch (c) {
 8000b5a:	2337      	movs	r3, #55	; 0x37
 8000b5c:	446b      	add	r3, sp
 8000b5e:	781b      	ldrb	r3, [r3, #0]
 8000b60:	3b44      	subs	r3, #68	; 0x44
 8000b62:	2b34      	cmp	r3, #52	; 0x34
 8000b64:	d900      	bls.n	8000b68 <chvprintf+0x1d8>
 8000b66:	e083      	b.n	8000c70 <chvprintf+0x2e0>
 8000b68:	009a      	lsls	r2, r3, #2
 8000b6a:	4b7d      	ldr	r3, [pc, #500]	; (8000d60 <chvprintf+0x3d0>)
 8000b6c:	18d3      	adds	r3, r2, r3
 8000b6e:	681b      	ldr	r3, [r3, #0]
 8000b70:	469f      	mov	pc, r3
    case 'c':
      filler = ' ';
 8000b72:	2336      	movs	r3, #54	; 0x36
 8000b74:	446b      	add	r3, sp
 8000b76:	2220      	movs	r2, #32
 8000b78:	701a      	strb	r2, [r3, #0]
      *p++ = va_arg(ap, int);
 8000b7a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8000b7c:	1c53      	adds	r3, r2, #1
 8000b7e:	930f      	str	r3, [sp, #60]	; 0x3c
 8000b80:	9b01      	ldr	r3, [sp, #4]
 8000b82:	1d19      	adds	r1, r3, #4
 8000b84:	9101      	str	r1, [sp, #4]
 8000b86:	681b      	ldr	r3, [r3, #0]
 8000b88:	b2db      	uxtb	r3, r3
 8000b8a:	7013      	strb	r3, [r2, #0]
 8000b8c:	e077      	b.n	8000c7e <chvprintf+0x2ee>
      break;
    case 's':
      filler = ' ';
 8000b8e:	2336      	movs	r3, #54	; 0x36
 8000b90:	446b      	add	r3, sp
 8000b92:	2220      	movs	r2, #32
 8000b94:	701a      	strb	r2, [r3, #0]
      if ((s = va_arg(ap, char *)) == 0)
 8000b96:	9b01      	ldr	r3, [sp, #4]
 8000b98:	1d1a      	adds	r2, r3, #4
 8000b9a:	9201      	str	r2, [sp, #4]
 8000b9c:	681b      	ldr	r3, [r3, #0]
 8000b9e:	930e      	str	r3, [sp, #56]	; 0x38
 8000ba0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8000ba2:	2b00      	cmp	r3, #0
 8000ba4:	d101      	bne.n	8000baa <chvprintf+0x21a>
        s = "(null)";
 8000ba6:	4b6f      	ldr	r3, [pc, #444]	; (8000d64 <chvprintf+0x3d4>)
 8000ba8:	930e      	str	r3, [sp, #56]	; 0x38
      if (precision == 0)
 8000baa:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8000bac:	2b00      	cmp	r3, #0
 8000bae:	d101      	bne.n	8000bb4 <chvprintf+0x224>
        precision = 32767;
 8000bb0:	4b6d      	ldr	r3, [pc, #436]	; (8000d68 <chvprintf+0x3d8>)
 8000bb2:	930b      	str	r3, [sp, #44]	; 0x2c
      for (p = s; *p && (--precision >= 0); p++)
 8000bb4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8000bb6:	930f      	str	r3, [sp, #60]	; 0x3c
 8000bb8:	e002      	b.n	8000bc0 <chvprintf+0x230>
 8000bba:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8000bbc:	3301      	adds	r3, #1
 8000bbe:	930f      	str	r3, [sp, #60]	; 0x3c
 8000bc0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8000bc2:	781b      	ldrb	r3, [r3, #0]
 8000bc4:	2b00      	cmp	r3, #0
 8000bc6:	d05a      	beq.n	8000c7e <chvprintf+0x2ee>
 8000bc8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8000bca:	3b01      	subs	r3, #1
 8000bcc:	930b      	str	r3, [sp, #44]	; 0x2c
 8000bce:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8000bd0:	2b00      	cmp	r3, #0
 8000bd2:	daf2      	bge.n	8000bba <chvprintf+0x22a>
 8000bd4:	e053      	b.n	8000c7e <chvprintf+0x2ee>
      break;
    case 'D':
    case 'd':
    case 'I':
    case 'i':
      if (is_long)
 8000bd6:	2323      	movs	r3, #35	; 0x23
 8000bd8:	446b      	add	r3, sp
 8000bda:	781b      	ldrb	r3, [r3, #0]
 8000bdc:	2b00      	cmp	r3, #0
 8000bde:	d005      	beq.n	8000bec <chvprintf+0x25c>
        l = va_arg(ap, long);
 8000be0:	9b01      	ldr	r3, [sp, #4]
 8000be2:	1d1a      	adds	r2, r3, #4
 8000be4:	9201      	str	r2, [sp, #4]
 8000be6:	681b      	ldr	r3, [r3, #0]
 8000be8:	9307      	str	r3, [sp, #28]
 8000bea:	e004      	b.n	8000bf6 <chvprintf+0x266>
      else
        l = va_arg(ap, int);
 8000bec:	9b01      	ldr	r3, [sp, #4]
 8000bee:	1d1a      	adds	r2, r3, #4
 8000bf0:	9201      	str	r2, [sp, #4]
 8000bf2:	681b      	ldr	r3, [r3, #0]
 8000bf4:	9307      	str	r3, [sp, #28]
      if (l < 0) {
 8000bf6:	9b07      	ldr	r3, [sp, #28]
 8000bf8:	2b00      	cmp	r3, #0
 8000bfa:	da07      	bge.n	8000c0c <chvprintf+0x27c>
        *p++ = '-';
 8000bfc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8000bfe:	1c5a      	adds	r2, r3, #1
 8000c00:	920f      	str	r2, [sp, #60]	; 0x3c
 8000c02:	222d      	movs	r2, #45	; 0x2d
 8000c04:	701a      	strb	r2, [r3, #0]
        l = -l;
 8000c06:	9b07      	ldr	r3, [sp, #28]
 8000c08:	425b      	negs	r3, r3
 8000c0a:	9307      	str	r3, [sp, #28]
      }
      p = ch_ltoa(p, l, 10);
 8000c0c:	9907      	ldr	r1, [sp, #28]
 8000c0e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8000c10:	220a      	movs	r2, #10
 8000c12:	0018      	movs	r0, r3
 8000c14:	f7ff feac 	bl	8000970 <ch_ltoa>
 8000c18:	0003      	movs	r3, r0
 8000c1a:	930f      	str	r3, [sp, #60]	; 0x3c
 8000c1c:	e02f      	b.n	8000c7e <chvprintf+0x2ee>
      p = ftoa(p, f, precision);
      break;
#endif
    case 'X':
    case 'x':
      c = 16;
 8000c1e:	2337      	movs	r3, #55	; 0x37
 8000c20:	446b      	add	r3, sp
 8000c22:	2210      	movs	r2, #16
 8000c24:	701a      	strb	r2, [r3, #0]
 8000c26:	e008      	b.n	8000c3a <chvprintf+0x2aa>
      goto unsigned_common;
    case 'U':
    case 'u':
      c = 10;
 8000c28:	2337      	movs	r3, #55	; 0x37
 8000c2a:	446b      	add	r3, sp
 8000c2c:	220a      	movs	r2, #10
 8000c2e:	701a      	strb	r2, [r3, #0]
 8000c30:	e003      	b.n	8000c3a <chvprintf+0x2aa>
      goto unsigned_common;
    case 'O':
    case 'o':
      c = 8;
 8000c32:	2337      	movs	r3, #55	; 0x37
 8000c34:	446b      	add	r3, sp
 8000c36:	2208      	movs	r2, #8
 8000c38:	701a      	strb	r2, [r3, #0]
unsigned_common:
      if (is_long)
 8000c3a:	2323      	movs	r3, #35	; 0x23
 8000c3c:	446b      	add	r3, sp
 8000c3e:	781b      	ldrb	r3, [r3, #0]
 8000c40:	2b00      	cmp	r3, #0
 8000c42:	d005      	beq.n	8000c50 <chvprintf+0x2c0>
        l = va_arg(ap, unsigned long);
 8000c44:	9b01      	ldr	r3, [sp, #4]
 8000c46:	1d1a      	adds	r2, r3, #4
 8000c48:	9201      	str	r2, [sp, #4]
 8000c4a:	681b      	ldr	r3, [r3, #0]
 8000c4c:	9307      	str	r3, [sp, #28]
 8000c4e:	e004      	b.n	8000c5a <chvprintf+0x2ca>
      else
        l = va_arg(ap, unsigned int);
 8000c50:	9b01      	ldr	r3, [sp, #4]
 8000c52:	1d1a      	adds	r2, r3, #4
 8000c54:	9201      	str	r2, [sp, #4]
 8000c56:	681b      	ldr	r3, [r3, #0]
 8000c58:	9307      	str	r3, [sp, #28]
      p = ch_ltoa(p, l, c);
 8000c5a:	2337      	movs	r3, #55	; 0x37
 8000c5c:	446b      	add	r3, sp
 8000c5e:	781a      	ldrb	r2, [r3, #0]
 8000c60:	9907      	ldr	r1, [sp, #28]
 8000c62:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8000c64:	0018      	movs	r0, r3
 8000c66:	f7ff fe83 	bl	8000970 <ch_ltoa>
 8000c6a:	0003      	movs	r3, r0
 8000c6c:	930f      	str	r3, [sp, #60]	; 0x3c
 8000c6e:	e006      	b.n	8000c7e <chvprintf+0x2ee>
      break;
    default:
      *p++ = c;
 8000c70:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8000c72:	1c5a      	adds	r2, r3, #1
 8000c74:	920f      	str	r2, [sp, #60]	; 0x3c
 8000c76:	2237      	movs	r2, #55	; 0x37
 8000c78:	446a      	add	r2, sp
 8000c7a:	7812      	ldrb	r2, [r2, #0]
 8000c7c:	701a      	strb	r2, [r3, #0]
      break;
    }
    i = (int)(p - s);
 8000c7e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8000c80:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8000c82:	1ad3      	subs	r3, r2, r3
 8000c84:	930c      	str	r3, [sp, #48]	; 0x30
    if ((width -= i) < 0)
 8000c86:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8000c88:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8000c8a:	1ad3      	subs	r3, r2, r3
 8000c8c:	930a      	str	r3, [sp, #40]	; 0x28
 8000c8e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8000c90:	2b00      	cmp	r3, #0
 8000c92:	da01      	bge.n	8000c98 <chvprintf+0x308>
      width = 0;
 8000c94:	2300      	movs	r3, #0
 8000c96:	930a      	str	r3, [sp, #40]	; 0x28
    if (left_align == FALSE)
 8000c98:	2322      	movs	r3, #34	; 0x22
 8000c9a:	446b      	add	r3, sp
 8000c9c:	781b      	ldrb	r3, [r3, #0]
 8000c9e:	2201      	movs	r2, #1
 8000ca0:	4053      	eors	r3, r2
 8000ca2:	b2db      	uxtb	r3, r3
 8000ca4:	2b00      	cmp	r3, #0
 8000ca6:	d002      	beq.n	8000cae <chvprintf+0x31e>
      width = -width;
 8000ca8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8000caa:	425b      	negs	r3, r3
 8000cac:	930a      	str	r3, [sp, #40]	; 0x28
    if (width < 0) {
 8000cae:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8000cb0:	2b00      	cmp	r3, #0
 8000cb2:	da38      	bge.n	8000d26 <chvprintf+0x396>
      if (*s == '-' && filler == '0') {
 8000cb4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8000cb6:	781b      	ldrb	r3, [r3, #0]
 8000cb8:	2b2d      	cmp	r3, #45	; 0x2d
 8000cba:	d114      	bne.n	8000ce6 <chvprintf+0x356>
 8000cbc:	2336      	movs	r3, #54	; 0x36
 8000cbe:	446b      	add	r3, sp
 8000cc0:	781b      	ldrb	r3, [r3, #0]
 8000cc2:	2b30      	cmp	r3, #48	; 0x30
 8000cc4:	d10f      	bne.n	8000ce6 <chvprintf+0x356>
        streamPut(chp, (uint8_t)*s++);
 8000cc6:	9b03      	ldr	r3, [sp, #12]
 8000cc8:	681b      	ldr	r3, [r3, #0]
 8000cca:	689a      	ldr	r2, [r3, #8]
 8000ccc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8000cce:	1c59      	adds	r1, r3, #1
 8000cd0:	910e      	str	r1, [sp, #56]	; 0x38
 8000cd2:	7819      	ldrb	r1, [r3, #0]
 8000cd4:	9b03      	ldr	r3, [sp, #12]
 8000cd6:	0018      	movs	r0, r3
 8000cd8:	4790      	blx	r2
        n++;
 8000cda:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8000cdc:	3301      	adds	r3, #1
 8000cde:	9309      	str	r3, [sp, #36]	; 0x24
        i--;
 8000ce0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8000ce2:	3b01      	subs	r3, #1
 8000ce4:	930c      	str	r3, [sp, #48]	; 0x30
      }
      do {
        streamPut(chp, (uint8_t)filler);
 8000ce6:	9b03      	ldr	r3, [sp, #12]
 8000ce8:	681b      	ldr	r3, [r3, #0]
 8000cea:	689b      	ldr	r3, [r3, #8]
 8000cec:	2236      	movs	r2, #54	; 0x36
 8000cee:	446a      	add	r2, sp
 8000cf0:	7811      	ldrb	r1, [r2, #0]
 8000cf2:	9a03      	ldr	r2, [sp, #12]
 8000cf4:	0010      	movs	r0, r2
 8000cf6:	4798      	blx	r3
        n++;
 8000cf8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8000cfa:	3301      	adds	r3, #1
 8000cfc:	9309      	str	r3, [sp, #36]	; 0x24
      } while (++width != 0);
 8000cfe:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8000d00:	3301      	adds	r3, #1
 8000d02:	930a      	str	r3, [sp, #40]	; 0x28
 8000d04:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8000d06:	2b00      	cmp	r3, #0
 8000d08:	d1ed      	bne.n	8000ce6 <chvprintf+0x356>
 8000d0a:	e00c      	b.n	8000d26 <chvprintf+0x396>
    }
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
 8000d0c:	9b03      	ldr	r3, [sp, #12]
 8000d0e:	681b      	ldr	r3, [r3, #0]
 8000d10:	689a      	ldr	r2, [r3, #8]
 8000d12:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8000d14:	1c59      	adds	r1, r3, #1
 8000d16:	910e      	str	r1, [sp, #56]	; 0x38
 8000d18:	7819      	ldrb	r1, [r3, #0]
 8000d1a:	9b03      	ldr	r3, [sp, #12]
 8000d1c:	0018      	movs	r0, r3
 8000d1e:	4790      	blx	r2
      n++;
 8000d20:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8000d22:	3301      	adds	r3, #1
 8000d24:	9309      	str	r3, [sp, #36]	; 0x24
    while (--i >= 0) {
 8000d26:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8000d28:	3b01      	subs	r3, #1
 8000d2a:	930c      	str	r3, [sp, #48]	; 0x30
 8000d2c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8000d2e:	2b00      	cmp	r3, #0
 8000d30:	daec      	bge.n	8000d0c <chvprintf+0x37c>
 8000d32:	e00e      	b.n	8000d52 <chvprintf+0x3c2>
    }

    while (width) {
      streamPut(chp, (uint8_t)filler);
 8000d34:	9b03      	ldr	r3, [sp, #12]
 8000d36:	681b      	ldr	r3, [r3, #0]
 8000d38:	689b      	ldr	r3, [r3, #8]
 8000d3a:	2236      	movs	r2, #54	; 0x36
 8000d3c:	446a      	add	r2, sp
 8000d3e:	7811      	ldrb	r1, [r2, #0]
 8000d40:	9a03      	ldr	r2, [sp, #12]
 8000d42:	0010      	movs	r0, r2
 8000d44:	4798      	blx	r3
      n++;
 8000d46:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8000d48:	3301      	adds	r3, #1
 8000d4a:	9309      	str	r3, [sp, #36]	; 0x24
      width--;
 8000d4c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8000d4e:	3b01      	subs	r3, #1
 8000d50:	930a      	str	r3, [sp, #40]	; 0x28
    while (width) {
 8000d52:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8000d54:	2b00      	cmp	r3, #0
 8000d56:	d1ed      	bne.n	8000d34 <chvprintf+0x3a4>
 8000d58:	e621      	b.n	800099e <chvprintf+0xe>
    }
  }
}
 8000d5a:	0018      	movs	r0, r3
 8000d5c:	b011      	add	sp, #68	; 0x44
 8000d5e:	bd00      	pop	{pc}
 8000d60:	08004c84 	.word	0x08004c84
 8000d64:	080049d4 	.word	0x080049d4
 8000d68:	00007fff 	.word	0x00007fff
 8000d6c:	00000000 	.word	0x00000000

08000d70 <chprintf>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8000d70:	b40e      	push	{r1, r2, r3}
 8000d72:	b500      	push	{lr}
 8000d74:	b084      	sub	sp, #16
 8000d76:	9001      	str	r0, [sp, #4]
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8000d78:	ab06      	add	r3, sp, #24
 8000d7a:	9302      	str	r3, [sp, #8]
  formatted_bytes = chvprintf(chp, fmt, ap);
 8000d7c:	9a02      	ldr	r2, [sp, #8]
 8000d7e:	9905      	ldr	r1, [sp, #20]
 8000d80:	9b01      	ldr	r3, [sp, #4]
 8000d82:	0018      	movs	r0, r3
 8000d84:	f7ff fe04 	bl	8000990 <chvprintf>
 8000d88:	0003      	movs	r3, r0
 8000d8a:	9303      	str	r3, [sp, #12]
  va_end(ap);

  return formatted_bytes;
 8000d8c:	9b03      	ldr	r3, [sp, #12]
}
 8000d8e:	0018      	movs	r0, r3
 8000d90:	b004      	add	sp, #16
 8000d92:	bc08      	pop	{r3}
 8000d94:	b003      	add	sp, #12
 8000d96:	4718      	bx	r3
	...

08000da0 <set_util_fwversion>:
/*! \brief Firmware GIT Hash
 * GIT_COMMIT_VERSION is inserted by the build system 
 *     generated in common/marionette.mk
 */
void set_util_fwversion(VERSIONData * ver_data)
{
 8000da0:	b500      	push	{lr}
 8000da2:	b083      	sub	sp, #12
 8000da4:	9001      	str	r0, [sp, #4]
#ifndef GIT_COMMIT_VERSION
#define GIT_COMMIT_VERSION "Unknown"
#endif
    strncpy(ver_data->firmware, GIT_COMMIT_VERSION, MAX_FW_VERSION_LENGTH);
 8000da6:	9b01      	ldr	r3, [sp, #4]
 8000da8:	4903      	ldr	r1, [pc, #12]	; (8000db8 <set_util_fwversion+0x18>)
 8000daa:	2232      	movs	r2, #50	; 0x32
 8000dac:	0018      	movs	r0, r3
 8000dae:	f7ff fa9b 	bl	80002e8 <strncpy>
}
 8000db2:	b003      	add	sp, #12
 8000db4:	bd00      	pop	{pc}
 8000db6:	46c0      	nop			; (mov r8, r8)
 8000db8:	080049dc 	.word	0x080049dc
 8000dbc:	00000000 	.word	0x00000000

08000dc0 <set_util_hwversion>:
/*! \brief  HW Version
 * 4 32 bit registers: base address: 0x1FFF 7A10
 * ST Ref. STM32f40x Page 1399 section 34 'Device Electronic Signature'
 */
void set_util_hwversion(VERSIONData * ver_data)
{
 8000dc0:	b082      	sub	sp, #8
 8000dc2:	9001      	str	r0, [sp, #4]
        ver_data->hardware.id_low    = *STM32F0_UNIQUE_ID_LOW;
 8000dc4:	4b06      	ldr	r3, [pc, #24]	; (8000de0 <set_util_hwversion+0x20>)
 8000dc6:	681a      	ldr	r2, [r3, #0]
 8000dc8:	9b01      	ldr	r3, [sp, #4]
 8000dca:	63da      	str	r2, [r3, #60]	; 0x3c
        ver_data->hardware.id_center = *STM32F0_UNIQUE_ID_CENTER;
 8000dcc:	4b05      	ldr	r3, [pc, #20]	; (8000de4 <set_util_hwversion+0x24>)
 8000dce:	681a      	ldr	r2, [r3, #0]
 8000dd0:	9b01      	ldr	r3, [sp, #4]
 8000dd2:	639a      	str	r2, [r3, #56]	; 0x38
        ver_data->hardware.id_high   = *STM32F0_UNIQUE_ID_HIGH;
 8000dd4:	4b04      	ldr	r3, [pc, #16]	; (8000de8 <set_util_hwversion+0x28>)
 8000dd6:	681a      	ldr	r2, [r3, #0]
 8000dd8:	9b01      	ldr	r3, [sp, #4]
 8000dda:	635a      	str	r2, [r3, #52]	; 0x34
}
 8000ddc:	b002      	add	sp, #8
 8000dde:	4770      	bx	lr
 8000de0:	1ffff7ac 	.word	0x1ffff7ac
 8000de4:	1ffff7b0 	.word	0x1ffff7b0
 8000de8:	1ffff7b4 	.word	0x1ffff7b4
 8000dec:	00000000 	.word	0x00000000

08000df0 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8000df0:	4b01      	ldr	r3, [pc, #4]	; (8000df8 <chThdGetSelfX+0x8>)
 8000df2:	699b      	ldr	r3, [r3, #24]
}
 8000df4:	0018      	movs	r0, r3
 8000df6:	4770      	bx	lr
 8000df8:	200004e0 	.word	0x200004e0
 8000dfc:	00000000 	.word	0x00000000

08000e00 <chThdShouldTerminateX>:
 * @retval true         termination request pending.
 * @retval false        termination request not pending.
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {
 8000e00:	b510      	push	{r4, lr}

  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8000e02:	f7ff fff5 	bl	8000df0 <chThdGetSelfX>
 8000e06:	0003      	movs	r3, r0
 8000e08:	7f5b      	ldrb	r3, [r3, #29]
 8000e0a:	001a      	movs	r2, r3
 8000e0c:	2304      	movs	r3, #4
 8000e0e:	4013      	ands	r3, r2
 8000e10:	1e5a      	subs	r2, r3, #1
 8000e12:	4193      	sbcs	r3, r2
 8000e14:	b2db      	uxtb	r3, r3
}
 8000e16:	0018      	movs	r0, r3
 8000e18:	bd10      	pop	{r4, pc}
 8000e1a:	46c0      	nop			; (mov r8, r8)
 8000e1c:	0000      	movs	r0, r0
	...

08000e20 <chThdSleepS>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {
 8000e20:	b500      	push	{lr}
 8000e22:	b083      	sub	sp, #12
 8000e24:	9001      	str	r0, [sp, #4]

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8000e26:	9b01      	ldr	r3, [sp, #4]
 8000e28:	0019      	movs	r1, r3
 8000e2a:	2008      	movs	r0, #8
 8000e2c:	f003 fbe8 	bl	8004600 <chSchGoSleepTimeoutS>
}
 8000e30:	b003      	add	sp, #12
 8000e32:	bd00      	pop	{pc}
	...

08000e40 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8000e40:	b082      	sub	sp, #8
 8000e42:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 8000e44:	4b02      	ldr	r3, [pc, #8]	; (8000e50 <chRegSetThreadName+0x10>)
 8000e46:	699b      	ldr	r3, [r3, #24]
 8000e48:	9a01      	ldr	r2, [sp, #4]
 8000e4a:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 8000e4c:	b002      	add	sp, #8
 8000e4e:	4770      	bx	lr
 8000e50:	200004e0 	.word	0x200004e0
	...

08000e60 <chEvtRegisterMask>:
 *
 * @api
 */
static inline void chEvtRegisterMask(event_source_t *esp,
                                     event_listener_t *elp,
                                     eventmask_t events) {
 8000e60:	b500      	push	{lr}
 8000e62:	b085      	sub	sp, #20
 8000e64:	9003      	str	r0, [sp, #12]
 8000e66:	9102      	str	r1, [sp, #8]
 8000e68:	9201      	str	r2, [sp, #4]

  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 8000e6a:	2301      	movs	r3, #1
 8000e6c:	425b      	negs	r3, r3
 8000e6e:	9a01      	ldr	r2, [sp, #4]
 8000e70:	9902      	ldr	r1, [sp, #8]
 8000e72:	9803      	ldr	r0, [sp, #12]
 8000e74:	f002 fe9c 	bl	8003bb0 <chEvtRegisterMaskWithFlags>
}
 8000e78:	b005      	add	sp, #20
 8000e7a:	bd00      	pop	{pc}
 8000e7c:	0000      	movs	r0, r0
	...

08000e80 <chEvtRegister>:
 *
 * @api
 */
static inline void chEvtRegister(event_source_t *esp,
                                 event_listener_t *elp,
                                 eventid_t event) {
 8000e80:	b500      	push	{lr}
 8000e82:	b085      	sub	sp, #20
 8000e84:	9003      	str	r0, [sp, #12]
 8000e86:	9102      	str	r1, [sp, #8]
 8000e88:	9201      	str	r2, [sp, #4]

  chEvtRegisterMask(esp, elp, EVENT_MASK(event));
 8000e8a:	9b01      	ldr	r3, [sp, #4]
 8000e8c:	2201      	movs	r2, #1
 8000e8e:	409a      	lsls	r2, r3
 8000e90:	9902      	ldr	r1, [sp, #8]
 8000e92:	9b03      	ldr	r3, [sp, #12]
 8000e94:	0018      	movs	r0, r3
 8000e96:	f7ff ffe3 	bl	8000e60 <chEvtRegisterMask>
}
 8000e9a:	b005      	add	sp, #20
 8000e9c:	bd00      	pop	{pc}
 8000e9e:	46c0      	nop			; (mov r8, r8)

08000ea0 <can_rx>:
/*
 * Receiver thread.
 */
static THD_WORKING_AREA(can_rx_wa, 256);
static THD_FUNCTION(can_rx, p)
{
 8000ea0:	b500      	push	{lr}
 8000ea2:	b08f      	sub	sp, #60	; 0x3c
 8000ea4:	9001      	str	r0, [sp, #4]
    event_listener_t        el;
    CANRxFrame              rxmsg;

    (void)p;
    chRegSetThreadName("receiver");
 8000ea6:	4b23      	ldr	r3, [pc, #140]	; (8000f34 <can_rx+0x94>)
 8000ea8:	0018      	movs	r0, r3
 8000eaa:	f7ff ffc9 	bl	8000e40 <chRegSetThreadName>

    // Configure Status LED (Green)
    palSetLineMode(LINE_LED_GREEN, PAL_MODE_OUTPUT_PUSHPULL);
 8000eae:	4b22      	ldr	r3, [pc, #136]	; (8000f38 <can_rx+0x98>)
 8000eb0:	2201      	movs	r2, #1
 8000eb2:	2108      	movs	r1, #8
 8000eb4:	0018      	movs	r0, r3
 8000eb6:	f000 fd8b 	bl	80019d0 <_pal_lld_setgroupmode>
    palClearLine(LINE_LED_GREEN);
 8000eba:	4b1f      	ldr	r3, [pc, #124]	; (8000f38 <can_rx+0x98>)
 8000ebc:	2208      	movs	r2, #8
 8000ebe:	835a      	strh	r2, [r3, #26]

    // Register RX event
    chEvtRegister(&CAND1.rxfull_event, &el, 0);
 8000ec0:	a909      	add	r1, sp, #36	; 0x24
 8000ec2:	4b1e      	ldr	r3, [pc, #120]	; (8000f3c <can_rx+0x9c>)
 8000ec4:	2200      	movs	r2, #0
 8000ec6:	0018      	movs	r0, r3
 8000ec8:	f7ff ffda 	bl	8000e80 <chEvtRegister>
 8000ecc:	e020      	b.n	8000f10 <can_rx+0x70>

    // Start RX Loop
    while(!chThdShouldTerminateX())
    {
        if (chEvtWaitAnyTimeout(ALL_EVENTS, MS2ST(100)) == 0)
 8000ece:	23fa      	movs	r3, #250	; 0xfa
 8000ed0:	009a      	lsls	r2, r3, #2
 8000ed2:	2301      	movs	r3, #1
 8000ed4:	425b      	negs	r3, r3
 8000ed6:	0011      	movs	r1, r2
 8000ed8:	0018      	movs	r0, r3
 8000eda:	f002 fbe1 	bl	80036a0 <chEvtWaitAnyTimeout>
 8000ede:	1e03      	subs	r3, r0, #0
 8000ee0:	d015      	beq.n	8000f0e <can_rx+0x6e>
        {
            continue;
        }
        chprintf(DEBUG_CHP, "r");
 8000ee2:	4a17      	ldr	r2, [pc, #92]	; (8000f40 <can_rx+0xa0>)
 8000ee4:	4b17      	ldr	r3, [pc, #92]	; (8000f44 <can_rx+0xa4>)
 8000ee6:	0011      	movs	r1, r2
 8000ee8:	0018      	movs	r0, r3
 8000eea:	f7ff ff41 	bl	8000d70 <chprintf>
 8000eee:	e005      	b.n	8000efc <can_rx+0x5c>
        while (canReceive(&CAND1, CAN_ANY_MAILBOX, &rxmsg, TIME_IMMEDIATE) == MSG_OK)
        {
            /* Process message.*/
            palToggleLine(LINE_LED_GREEN);
 8000ef0:	4b11      	ldr	r3, [pc, #68]	; (8000f38 <can_rx+0x98>)
 8000ef2:	4a11      	ldr	r2, [pc, #68]	; (8000f38 <can_rx+0x98>)
 8000ef4:	6952      	ldr	r2, [r2, #20]
 8000ef6:	2108      	movs	r1, #8
 8000ef8:	404a      	eors	r2, r1
 8000efa:	615a      	str	r2, [r3, #20]
        while (canReceive(&CAND1, CAN_ANY_MAILBOX, &rxmsg, TIME_IMMEDIATE) == MSG_OK)
 8000efc:	aa02      	add	r2, sp, #8
 8000efe:	4812      	ldr	r0, [pc, #72]	; (8000f48 <can_rx+0xa8>)
 8000f00:	2300      	movs	r3, #0
 8000f02:	2100      	movs	r1, #0
 8000f04:	f002 fb94 	bl	8003630 <canReceiveTimeout>
 8000f08:	1e03      	subs	r3, r0, #0
 8000f0a:	d0f1      	beq.n	8000ef0 <can_rx+0x50>
 8000f0c:	e000      	b.n	8000f10 <can_rx+0x70>
            continue;
 8000f0e:	46c0      	nop			; (mov r8, r8)
    while(!chThdShouldTerminateX())
 8000f10:	f7ff ff76 	bl	8000e00 <chThdShouldTerminateX>
 8000f14:	0003      	movs	r3, r0
 8000f16:	001a      	movs	r2, r3
 8000f18:	2301      	movs	r3, #1
 8000f1a:	4053      	eors	r3, r2
 8000f1c:	b2db      	uxtb	r3, r3
 8000f1e:	2b00      	cmp	r3, #0
 8000f20:	d1d5      	bne.n	8000ece <can_rx+0x2e>
        }
    }

    //Unregister RX event before terminating thread
    chEvtUnregister(&CAND1.rxfull_event, &el);
 8000f22:	aa09      	add	r2, sp, #36	; 0x24
 8000f24:	4b05      	ldr	r3, [pc, #20]	; (8000f3c <can_rx+0x9c>)
 8000f26:	0011      	movs	r1, r2
 8000f28:	0018      	movs	r0, r3
 8000f2a:	f002 fe69 	bl	8003c00 <chEvtUnregister>
}
 8000f2e:	b00f      	add	sp, #60	; 0x3c
 8000f30:	bd00      	pop	{pc}
 8000f32:	46c0      	nop			; (mov r8, r8)
 8000f34:	080049e8 	.word	0x080049e8
 8000f38:	48000400 	.word	0x48000400
 8000f3c:	20000590 	.word	0x20000590
 8000f40:	080049f4 	.word	0x080049f4
 8000f44:	20000610 	.word	0x20000610
 8000f48:	20000578 	.word	0x20000578
 8000f4c:	00000000 	.word	0x00000000

08000f50 <CAN_ESR_break>:


//Process Error Status Register
void CAN_ESR_break(CANDriver *canp) {
 8000f50:	b500      	push	{lr}
 8000f52:	b085      	sub	sp, #20
 8000f54:	9001      	str	r0, [sp, #4]
    uint32_t esrval = canp->can->ESR;
 8000f56:	9b01      	ldr	r3, [sp, #4]
 8000f58:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000f5a:	699b      	ldr	r3, [r3, #24]
 8000f5c:	9303      	str	r3, [sp, #12]
    chprintf(DEBUG_CHP, "ESR:0x%x\r\n", esrval);
 8000f5e:	9a03      	ldr	r2, [sp, #12]
 8000f60:	4903      	ldr	r1, [pc, #12]	; (8000f70 <CAN_ESR_break+0x20>)
 8000f62:	4b04      	ldr	r3, [pc, #16]	; (8000f74 <CAN_ESR_break+0x24>)
 8000f64:	0018      	movs	r0, r3
 8000f66:	f7ff ff03 	bl	8000d70 <chprintf>
}
 8000f6a:	b005      	add	sp, #20
 8000f6c:	bd00      	pop	{pc}
 8000f6e:	46c0      	nop			; (mov r8, r8)
 8000f70:	080049f8 	.word	0x080049f8
 8000f74:	20000610 	.word	0x20000610
	...

08000f80 <CAN_TSR_break>:

//Process Transmit Status Register
void CAN_TSR_break(CANDriver *canp) {
 8000f80:	b500      	push	{lr}
 8000f82:	b085      	sub	sp, #20
 8000f84:	9001      	str	r0, [sp, #4]
    uint32_t tsrval = canp->can->TSR;
 8000f86:	9b01      	ldr	r3, [sp, #4]
 8000f88:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000f8a:	689b      	ldr	r3, [r3, #8]
 8000f8c:	9303      	str	r3, [sp, #12]
    // uint8_t tme2  = (*tsr & CAN_TSR_TME2)>>28;
    // uint8_t low0  = (*tsr & CAN_TSR_LOW0)>>29;
    // uint8_t low1  = (*tsr & CAN_TSR_LOW1)>>30;
    // uint8_t low2  = (*tsr & CAN_TSR_LOW2)>>31;

    chprintf(DEBUG_CHP, "TSR:0x%x\r\n", tsrval);
 8000f8e:	9a03      	ldr	r2, [sp, #12]
 8000f90:	4903      	ldr	r1, [pc, #12]	; (8000fa0 <CAN_TSR_break+0x20>)
 8000f92:	4b04      	ldr	r3, [pc, #16]	; (8000fa4 <CAN_TSR_break+0x24>)
 8000f94:	0018      	movs	r0, r3
 8000f96:	f7ff feeb 	bl	8000d70 <chprintf>
    // chprintf(DEBUG_CHP, "rqcp0:0x%x\ttxok0:0x%x\talst0:0x%x\tterr0:0x%x\tabrq0:0x%x\r\n", rqcp0, txok0, alst0,terr0, abrq0 );

}
 8000f9a:	b005      	add	sp, #20
 8000f9c:	bd00      	pop	{pc}
 8000f9e:	46c0      	nop			; (mov r8, r8)
 8000fa0:	08004a04 	.word	0x08004a04
 8000fa4:	20000610 	.word	0x20000610
	...

08000fb0 <can_tx>:
/*
 * Transmitter thread.
 */
static THD_WORKING_AREA(can_tx_wa, 256);
static THD_FUNCTION(can_tx, p)
{
 8000fb0:	b500      	push	{lr}
 8000fb2:	b089      	sub	sp, #36	; 0x24
 8000fb4:	9001      	str	r0, [sp, #4]
    CANTxFrame txmsg;
    msg_t msg;

    (void)p;
    chRegSetThreadName("transmitter");
 8000fb6:	4b33      	ldr	r3, [pc, #204]	; (8001084 <can_tx+0xd4>)
 8000fb8:	0018      	movs	r0, r3
 8000fba:	f7ff ff41 	bl	8000e40 <chRegSetThreadName>
    txmsg.IDE = CAN_IDE_EXT;
 8000fbe:	ab02      	add	r3, sp, #8
 8000fc0:	781a      	ldrb	r2, [r3, #0]
 8000fc2:	2120      	movs	r1, #32
 8000fc4:	430a      	orrs	r2, r1
 8000fc6:	701a      	strb	r2, [r3, #0]
    txmsg.EID = 0x31;
 8000fc8:	ab02      	add	r3, sp, #8
 8000fca:	685a      	ldr	r2, [r3, #4]
 8000fcc:	0f52      	lsrs	r2, r2, #29
 8000fce:	0752      	lsls	r2, r2, #29
 8000fd0:	2131      	movs	r1, #49	; 0x31
 8000fd2:	430a      	orrs	r2, r1
 8000fd4:	605a      	str	r2, [r3, #4]
    txmsg.RTR = CAN_RTR_DATA;
 8000fd6:	ab02      	add	r3, sp, #8
 8000fd8:	781a      	ldrb	r2, [r3, #0]
 8000fda:	2110      	movs	r1, #16
 8000fdc:	438a      	bics	r2, r1
 8000fde:	701a      	strb	r2, [r3, #0]
    txmsg.DLC = 8;
 8000fe0:	ab02      	add	r3, sp, #8
 8000fe2:	781a      	ldrb	r2, [r3, #0]
 8000fe4:	210f      	movs	r1, #15
 8000fe6:	438a      	bics	r2, r1
 8000fe8:	1c11      	adds	r1, r2, #0
 8000fea:	2208      	movs	r2, #8
 8000fec:	430a      	orrs	r2, r1
 8000fee:	701a      	strb	r2, [r3, #0]
    txmsg.data8[0] = 0x00;
 8000ff0:	ab02      	add	r3, sp, #8
 8000ff2:	2200      	movs	r2, #0
 8000ff4:	721a      	strb	r2, [r3, #8]
    txmsg.data8[1] = 0x01;
 8000ff6:	ab02      	add	r3, sp, #8
 8000ff8:	2201      	movs	r2, #1
 8000ffa:	725a      	strb	r2, [r3, #9]
    txmsg.data8[2] = 0x02;
 8000ffc:	ab02      	add	r3, sp, #8
 8000ffe:	2202      	movs	r2, #2
 8001000:	729a      	strb	r2, [r3, #10]
    txmsg.data8[3] = 0x03;
 8001002:	ab02      	add	r3, sp, #8
 8001004:	2203      	movs	r2, #3
 8001006:	72da      	strb	r2, [r3, #11]
    txmsg.data8[4] = 0x04;
 8001008:	ab02      	add	r3, sp, #8
 800100a:	2204      	movs	r2, #4
 800100c:	731a      	strb	r2, [r3, #12]
    txmsg.data8[5] = 0x05;
 800100e:	ab02      	add	r3, sp, #8
 8001010:	2205      	movs	r2, #5
 8001012:	735a      	strb	r2, [r3, #13]
    txmsg.data8[6] = 0x06;
 8001014:	ab02      	add	r3, sp, #8
 8001016:	2206      	movs	r2, #6
 8001018:	739a      	strb	r2, [r3, #14]
    txmsg.data8[7] = 0x07;
 800101a:	ab02      	add	r3, sp, #8
 800101c:	2207      	movs	r2, #7
 800101e:	73da      	strb	r2, [r3, #15]
 8001020:	e024      	b.n	800106c <can_tx+0xbc>

    // Start TX Loop
    while (!chThdShouldTerminateX())
    {
        //Process TSR and ESR
        chprintf(DEBUG_CHP, "\n\rStatus:\n\r");
 8001022:	4a19      	ldr	r2, [pc, #100]	; (8001088 <can_tx+0xd8>)
 8001024:	4b19      	ldr	r3, [pc, #100]	; (800108c <can_tx+0xdc>)
 8001026:	0011      	movs	r1, r2
 8001028:	0018      	movs	r0, r3
 800102a:	f7ff fea1 	bl	8000d70 <chprintf>
        CAN_TSR_break(&CAND1);
 800102e:	4b18      	ldr	r3, [pc, #96]	; (8001090 <can_tx+0xe0>)
 8001030:	0018      	movs	r0, r3
 8001032:	f7ff ffa5 	bl	8000f80 <CAN_TSR_break>
        chThdSleepMilliseconds(250);
 8001036:	4b17      	ldr	r3, [pc, #92]	; (8001094 <can_tx+0xe4>)
 8001038:	0018      	movs	r0, r3
 800103a:	f002 fd01 	bl	8003a40 <chThdSleep>
        CAN_ESR_break(&CAND1);
 800103e:	4b14      	ldr	r3, [pc, #80]	; (8001090 <can_tx+0xe0>)
 8001040:	0018      	movs	r0, r3
 8001042:	f7ff ff85 	bl	8000f50 <CAN_ESR_break>
        chThdSleepMilliseconds(750);
 8001046:	4b14      	ldr	r3, [pc, #80]	; (8001098 <can_tx+0xe8>)
 8001048:	0018      	movs	r0, r3
 800104a:	f002 fcf9 	bl	8003a40 <chThdSleep>

        //Transmit message
        msg = canTransmit(&CAND1, CAN_ANY_MAILBOX, &txmsg, MS2ST(100));
 800104e:	23fa      	movs	r3, #250	; 0xfa
 8001050:	009b      	lsls	r3, r3, #2
 8001052:	aa02      	add	r2, sp, #8
 8001054:	480e      	ldr	r0, [pc, #56]	; (8001090 <can_tx+0xe0>)
 8001056:	2100      	movs	r1, #0
 8001058:	f002 fab2 	bl	80035c0 <canTransmitTimeout>
 800105c:	0003      	movs	r3, r0
 800105e:	9307      	str	r3, [sp, #28]
        chprintf(DEBUG_CHP, "TX msg: %d\n\r", msg);
 8001060:	9a07      	ldr	r2, [sp, #28]
 8001062:	490e      	ldr	r1, [pc, #56]	; (800109c <can_tx+0xec>)
 8001064:	4b09      	ldr	r3, [pc, #36]	; (800108c <can_tx+0xdc>)
 8001066:	0018      	movs	r0, r3
 8001068:	f7ff fe82 	bl	8000d70 <chprintf>
    while (!chThdShouldTerminateX())
 800106c:	f7ff fec8 	bl	8000e00 <chThdShouldTerminateX>
 8001070:	0003      	movs	r3, r0
 8001072:	001a      	movs	r2, r3
 8001074:	2301      	movs	r3, #1
 8001076:	4053      	eors	r3, r2
 8001078:	b2db      	uxtb	r3, r3
 800107a:	2b00      	cmp	r3, #0
 800107c:	d1d1      	bne.n	8001022 <can_tx+0x72>
    }
}
 800107e:	b009      	add	sp, #36	; 0x24
 8001080:	bd00      	pop	{pc}
 8001082:	46c0      	nop			; (mov r8, r8)
 8001084:	08004a10 	.word	0x08004a10
 8001088:	08004a1c 	.word	0x08004a1c
 800108c:	20000610 	.word	0x20000610
 8001090:	20000578 	.word	0x20000578
 8001094:	000009c4 	.word	0x000009c4
 8001098:	00001d4c 	.word	0x00001d4c
 800109c:	08004a28 	.word	0x08004a28

080010a0 <app_init>:

static void app_init(void)
{
 80010a0:	b510      	push	{r4, lr}
 80010a2:	b082      	sub	sp, #8
    // Start up debug output, chprintf(DEBUG_CHP,...)
    sdStart(&DEBUG_SERIAL, &ser_cfg);
 80010a4:	4a1b      	ldr	r2, [pc, #108]	; (8001114 <app_init+0x74>)
 80010a6:	4b1c      	ldr	r3, [pc, #112]	; (8001118 <app_init+0x78>)
 80010a8:	0011      	movs	r1, r2
 80010aa:	0018      	movs	r0, r3
 80010ac:	f001 f8e8 	bl	8002280 <sdStart>

    set_util_fwversion(&version_info);
 80010b0:	4b1a      	ldr	r3, [pc, #104]	; (800111c <app_init+0x7c>)
 80010b2:	0018      	movs	r0, r3
 80010b4:	f7ff fe74 	bl	8000da0 <set_util_fwversion>
    set_util_hwversion(&version_info);
 80010b8:	4b18      	ldr	r3, [pc, #96]	; (800111c <app_init+0x7c>)
 80010ba:	0018      	movs	r0, r3
 80010bc:	f7ff fe80 	bl	8000dc0 <set_util_hwversion>
    chThdSleepS(S2ST(1));
 80010c0:	4b17      	ldr	r3, [pc, #92]	; (8001120 <app_init+0x80>)
 80010c2:	0018      	movs	r0, r3
 80010c4:	f7ff feac 	bl	8000e20 <chThdSleepS>

    //Print FW/HW information
    chprintf(DEBUG_CHP, "\r\nFirmware Info\r\n");
 80010c8:	4a16      	ldr	r2, [pc, #88]	; (8001124 <app_init+0x84>)
 80010ca:	4b13      	ldr	r3, [pc, #76]	; (8001118 <app_init+0x78>)
 80010cc:	0011      	movs	r1, r2
 80010ce:	0018      	movs	r0, r3
 80010d0:	f7ff fe4e 	bl	8000d70 <chprintf>
    chprintf(DEBUG_CHP, "FW HASH: %s\r\n", version_info.firmware);
 80010d4:	4a11      	ldr	r2, [pc, #68]	; (800111c <app_init+0x7c>)
 80010d6:	4914      	ldr	r1, [pc, #80]	; (8001128 <app_init+0x88>)
 80010d8:	4b0f      	ldr	r3, [pc, #60]	; (8001118 <app_init+0x78>)
 80010da:	0018      	movs	r0, r3
 80010dc:	f7ff fe48 	bl	8000d70 <chprintf>
    chprintf(DEBUG_CHP, "STF0x UNIQUE HW ID (H,C,L):\r\n0x%x\t0x%x\t0x%x\r\n"
 80010e0:	4b0e      	ldr	r3, [pc, #56]	; (800111c <app_init+0x7c>)
 80010e2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80010e4:	4b0d      	ldr	r3, [pc, #52]	; (800111c <app_init+0x7c>)
 80010e6:	6b9c      	ldr	r4, [r3, #56]	; 0x38
 80010e8:	4b0c      	ldr	r3, [pc, #48]	; (800111c <app_init+0x7c>)
 80010ea:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80010ec:	490f      	ldr	r1, [pc, #60]	; (800112c <app_init+0x8c>)
 80010ee:	480a      	ldr	r0, [pc, #40]	; (8001118 <app_init+0x78>)
 80010f0:	9300      	str	r3, [sp, #0]
 80010f2:	0023      	movs	r3, r4
 80010f4:	f7ff fe3c 	bl	8000d70 <chprintf>
            );

    /*
     * Activates CAN driver 1.
     */
    chprintf(DEBUG_CHP, "\r\nStarting CAN driver...\r\n");
 80010f8:	4a0d      	ldr	r2, [pc, #52]	; (8001130 <app_init+0x90>)
 80010fa:	4b07      	ldr	r3, [pc, #28]	; (8001118 <app_init+0x78>)
 80010fc:	0011      	movs	r1, r2
 80010fe:	0018      	movs	r0, r3
 8001100:	f7ff fe36 	bl	8000d70 <chprintf>
    canStart(&CAND1, &cancfg);
 8001104:	4a0b      	ldr	r2, [pc, #44]	; (8001134 <app_init+0x94>)
 8001106:	4b0c      	ldr	r3, [pc, #48]	; (8001138 <app_init+0x98>)
 8001108:	0011      	movs	r1, r2
 800110a:	0018      	movs	r0, r3
 800110c:	f002 fa40 	bl	8003590 <canStart>


}
 8001110:	b002      	add	sp, #8
 8001112:	bd10      	pop	{r4, pc}
 8001114:	20000400 	.word	0x20000400
 8001118:	20000610 	.word	0x20000610
 800111c:	20000690 	.word	0x20000690
 8001120:	00002710 	.word	0x00002710
 8001124:	08004a38 	.word	0x08004a38
 8001128:	08004a4c 	.word	0x08004a4c
 800112c:	08004a5c 	.word	0x08004a5c
 8001130:	08004a8c 	.word	0x08004a8c
 8001134:	08004d58 	.word	0x08004d58
 8001138:	20000578 	.word	0x20000578
 800113c:	00000000 	.word	0x00000000

08001140 <main_app>:

static void main_app(void)
{
 8001140:	b500      	push	{lr}
 8001142:	b083      	sub	sp, #12
    /*
     * Starting the transmitter and receiver threads.
     */
    chprintf(DEBUG_CHP, "\r\nStarting RX/TX threads...\r\n");
 8001144:	4a0f      	ldr	r2, [pc, #60]	; (8001184 <main_app+0x44>)
 8001146:	4b10      	ldr	r3, [pc, #64]	; (8001188 <main_app+0x48>)
 8001148:	0011      	movs	r1, r2
 800114a:	0018      	movs	r0, r3
 800114c:	f7ff fe10 	bl	8000d70 <chprintf>
    chThdCreateStatic(can_rx_wa, sizeof(can_rx_wa), NORMALPRIO + 7, can_rx, NULL);
 8001150:	4a0e      	ldr	r2, [pc, #56]	; (800118c <main_app+0x4c>)
 8001152:	23e0      	movs	r3, #224	; 0xe0
 8001154:	0059      	lsls	r1, r3, #1
 8001156:	480e      	ldr	r0, [pc, #56]	; (8001190 <main_app+0x50>)
 8001158:	2300      	movs	r3, #0
 800115a:	9300      	str	r3, [sp, #0]
 800115c:	0013      	movs	r3, r2
 800115e:	2287      	movs	r2, #135	; 0x87
 8001160:	f002 fbf6 	bl	8003950 <chThdCreateStatic>
    chThdCreateStatic(can_tx_wa, sizeof(can_tx_wa), NORMALPRIO + 7, can_tx, NULL);
 8001164:	4a0b      	ldr	r2, [pc, #44]	; (8001194 <main_app+0x54>)
 8001166:	23e0      	movs	r3, #224	; 0xe0
 8001168:	0059      	lsls	r1, r3, #1
 800116a:	480b      	ldr	r0, [pc, #44]	; (8001198 <main_app+0x58>)
 800116c:	2300      	movs	r3, #0
 800116e:	9300      	str	r3, [sp, #0]
 8001170:	0013      	movs	r3, r2
 8001172:	2287      	movs	r2, #135	; 0x87
 8001174:	f002 fbec 	bl	8003950 <chThdCreateStatic>
    /*
     * Begin main loop
     */
    while (true)
    {
        chThdSleepMilliseconds(1000);
 8001178:	4b08      	ldr	r3, [pc, #32]	; (800119c <main_app+0x5c>)
 800117a:	0018      	movs	r0, r3
 800117c:	f002 fc60 	bl	8003a40 <chThdSleep>
 8001180:	e7fa      	b.n	8001178 <main_app+0x38>
 8001182:	46c0      	nop			; (mov r8, r8)
 8001184:	08004aa8 	.word	0x08004aa8
 8001188:	20000610 	.word	0x20000610
 800118c:	08000ea1 	.word	0x08000ea1
 8001190:	200006d0 	.word	0x200006d0
 8001194:	08000fb1 	.word	0x08000fb1
 8001198:	20000890 	.word	0x20000890
 800119c:	00002710 	.word	0x00002710

080011a0 <main>:
    }
}

int main(void)
{
 80011a0:	b510      	push	{r4, lr}
     * - HAL initialization, this also initializes the configured device drivers
     *   and performs the board-specific initializations.
     * - Kernel initialization, the main() function becomes a thread and the
     *   RTOS is active.
     */
    halInit();
 80011a2:	f002 fbbd 	bl	8003920 <halInit>
    chSysInit();
 80011a6:	f002 ff5b 	bl	8004060 <chSysInit>
    app_init();
 80011aa:	f7ff ff79 	bl	80010a0 <app_init>

    main_app();
 80011ae:	f7ff ffc7 	bl	8001140 <main_app>

    return 0;
 80011b2:	2300      	movs	r3, #0
}
 80011b4:	0018      	movs	r0, r3
 80011b6:	bd10      	pop	{r4, pc}
	...

080011c0 <can_lld_tx_handler>:
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
static void can_lld_tx_handler(CANDriver *canp) {
 80011c0:	b500      	push	{lr}
 80011c2:	b085      	sub	sp, #20
 80011c4:	9001      	str	r0, [sp, #4]
  uint32_t tsr;
  eventflags_t flags;

  /* Clearing IRQ sources.*/
  tsr = canp->can->TSR;
 80011c6:	9b01      	ldr	r3, [sp, #4]
 80011c8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80011ca:	689b      	ldr	r3, [r3, #8]
 80011cc:	9302      	str	r3, [sp, #8]
  canp->can->TSR = tsr;
 80011ce:	9b01      	ldr	r3, [sp, #4]
 80011d0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80011d2:	9a02      	ldr	r2, [sp, #8]
 80011d4:	609a      	str	r2, [r3, #8]

  /* Flags to be signaled through the TX event source.*/
  flags = 0U;
 80011d6:	2300      	movs	r3, #0
 80011d8:	9303      	str	r3, [sp, #12]

  /* Checking mailbox 0.*/
  if ((tsr & CAN_TSR_RQCP0) != 0U) {
 80011da:	9b02      	ldr	r3, [sp, #8]
 80011dc:	2201      	movs	r2, #1
 80011de:	4013      	ands	r3, r2
 80011e0:	d00d      	beq.n	80011fe <can_lld_tx_handler+0x3e>
    if ((tsr & (CAN_TSR_ALST0 | CAN_TSR_TERR0)) != 0U) {
 80011e2:	9b02      	ldr	r3, [sp, #8]
 80011e4:	220c      	movs	r2, #12
 80011e6:	4013      	ands	r3, r2
 80011e8:	d005      	beq.n	80011f6 <can_lld_tx_handler+0x36>
      flags |= CAN_MAILBOX_TO_MASK(1U) << 16U;
 80011ea:	9b03      	ldr	r3, [sp, #12]
 80011ec:	2280      	movs	r2, #128	; 0x80
 80011ee:	0252      	lsls	r2, r2, #9
 80011f0:	4313      	orrs	r3, r2
 80011f2:	9303      	str	r3, [sp, #12]
 80011f4:	e003      	b.n	80011fe <can_lld_tx_handler+0x3e>
    }
    else {
      flags |= CAN_MAILBOX_TO_MASK(1U);
 80011f6:	9b03      	ldr	r3, [sp, #12]
 80011f8:	2201      	movs	r2, #1
 80011fa:	4313      	orrs	r3, r2
 80011fc:	9303      	str	r3, [sp, #12]
    }
  }

  /* Checking mailbox 1.*/
  if ((tsr & CAN_TSR_RQCP1) != 0U) {
 80011fe:	9a02      	ldr	r2, [sp, #8]
 8001200:	2380      	movs	r3, #128	; 0x80
 8001202:	005b      	lsls	r3, r3, #1
 8001204:	4013      	ands	r3, r2
 8001206:	d00e      	beq.n	8001226 <can_lld_tx_handler+0x66>
    if ((tsr & (CAN_TSR_ALST1 | CAN_TSR_TERR1)) != 0U) {
 8001208:	9a02      	ldr	r2, [sp, #8]
 800120a:	23c0      	movs	r3, #192	; 0xc0
 800120c:	011b      	lsls	r3, r3, #4
 800120e:	4013      	ands	r3, r2
 8001210:	d005      	beq.n	800121e <can_lld_tx_handler+0x5e>
      flags |= CAN_MAILBOX_TO_MASK(2U) << 16U;
 8001212:	9b03      	ldr	r3, [sp, #12]
 8001214:	2280      	movs	r2, #128	; 0x80
 8001216:	0292      	lsls	r2, r2, #10
 8001218:	4313      	orrs	r3, r2
 800121a:	9303      	str	r3, [sp, #12]
 800121c:	e003      	b.n	8001226 <can_lld_tx_handler+0x66>
    }
    else {
      flags |= CAN_MAILBOX_TO_MASK(2U);
 800121e:	9b03      	ldr	r3, [sp, #12]
 8001220:	2202      	movs	r2, #2
 8001222:	4313      	orrs	r3, r2
 8001224:	9303      	str	r3, [sp, #12]
    }
  }

  /* Checking mailbox 2.*/
  if ((tsr & CAN_TSR_RQCP2) != 0U) {
 8001226:	9a02      	ldr	r2, [sp, #8]
 8001228:	2380      	movs	r3, #128	; 0x80
 800122a:	025b      	lsls	r3, r3, #9
 800122c:	4013      	ands	r3, r2
 800122e:	d00e      	beq.n	800124e <can_lld_tx_handler+0x8e>
    if ((tsr & (CAN_TSR_ALST2 | CAN_TSR_TERR2)) != 0U) {
 8001230:	9a02      	ldr	r2, [sp, #8]
 8001232:	23c0      	movs	r3, #192	; 0xc0
 8001234:	031b      	lsls	r3, r3, #12
 8001236:	4013      	ands	r3, r2
 8001238:	d005      	beq.n	8001246 <can_lld_tx_handler+0x86>
      flags |= CAN_MAILBOX_TO_MASK(3U) << 16U;
 800123a:	9b03      	ldr	r3, [sp, #12]
 800123c:	2280      	movs	r2, #128	; 0x80
 800123e:	02d2      	lsls	r2, r2, #11
 8001240:	4313      	orrs	r3, r2
 8001242:	9303      	str	r3, [sp, #12]
 8001244:	e003      	b.n	800124e <can_lld_tx_handler+0x8e>
    }
    else {
      flags |= CAN_MAILBOX_TO_MASK(3U);
 8001246:	9b03      	ldr	r3, [sp, #12]
 8001248:	2204      	movs	r2, #4
 800124a:	4313      	orrs	r3, r2
 800124c:	9303      	str	r3, [sp, #12]
    }
  }

  /* Signaling flags and waking up threads waiting for a transmission slot.*/
  osalSysLockFromISR();
 800124e:	f001 fc8f 	bl	8002b70 <osalSysLockFromISR.lto_priv.40>
  osalThreadDequeueAllI(&canp->txqueue, MSG_OK);
 8001252:	9b01      	ldr	r3, [sp, #4]
 8001254:	3308      	adds	r3, #8
 8001256:	2100      	movs	r1, #0
 8001258:	0018      	movs	r0, r3
 800125a:	f001 fca9 	bl	8002bb0 <osalThreadDequeueAllI.lto_priv.46>
  osalEventBroadcastFlagsI(&canp->txempty_event, flags);
 800125e:	9b01      	ldr	r3, [sp, #4]
 8001260:	331c      	adds	r3, #28
 8001262:	9a03      	ldr	r2, [sp, #12]
 8001264:	0011      	movs	r1, r2
 8001266:	0018      	movs	r0, r3
 8001268:	f001 fcb2 	bl	8002bd0 <osalEventBroadcastFlagsI.lto_priv.45>
  osalSysUnlockFromISR();
 800126c:	f001 fc88 	bl	8002b80 <osalSysUnlockFromISR.lto_priv.38>
}
 8001270:	b005      	add	sp, #20
 8001272:	bd00      	pop	{pc}
	...

08001280 <can_lld_rx0_handler>:
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
static void can_lld_rx0_handler(CANDriver *canp) {
 8001280:	b500      	push	{lr}
 8001282:	b085      	sub	sp, #20
 8001284:	9001      	str	r0, [sp, #4]
  uint32_t rf0r;

  rf0r = canp->can->RF0R;
 8001286:	9b01      	ldr	r3, [sp, #4]
 8001288:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800128a:	68db      	ldr	r3, [r3, #12]
 800128c:	9303      	str	r3, [sp, #12]
  if ((rf0r & CAN_RF0R_FMP0) > 0) {
 800128e:	9b03      	ldr	r3, [sp, #12]
 8001290:	2203      	movs	r2, #3
 8001292:	4013      	ands	r3, r2
 8001294:	d017      	beq.n	80012c6 <can_lld_rx0_handler+0x46>
    /* No more receive events until the queue 0 has been emptied.*/
    canp->can->IER &= ~CAN_IER_FMPIE0;
 8001296:	9b01      	ldr	r3, [sp, #4]
 8001298:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800129a:	9a01      	ldr	r2, [sp, #4]
 800129c:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800129e:	6952      	ldr	r2, [r2, #20]
 80012a0:	2102      	movs	r1, #2
 80012a2:	438a      	bics	r2, r1
 80012a4:	615a      	str	r2, [r3, #20]
    osalSysLockFromISR();
 80012a6:	f001 fc63 	bl	8002b70 <osalSysLockFromISR.lto_priv.40>
    osalThreadDequeueAllI(&canp->rxqueue, MSG_OK);
 80012aa:	9b01      	ldr	r3, [sp, #4]
 80012ac:	3310      	adds	r3, #16
 80012ae:	2100      	movs	r1, #0
 80012b0:	0018      	movs	r0, r3
 80012b2:	f001 fc7d 	bl	8002bb0 <osalThreadDequeueAllI.lto_priv.46>
    osalEventBroadcastFlagsI(&canp->rxfull_event, CAN_MAILBOX_TO_MASK(1U));
 80012b6:	9b01      	ldr	r3, [sp, #4]
 80012b8:	3318      	adds	r3, #24
 80012ba:	2101      	movs	r1, #1
 80012bc:	0018      	movs	r0, r3
 80012be:	f001 fc87 	bl	8002bd0 <osalEventBroadcastFlagsI.lto_priv.45>
    osalSysUnlockFromISR();
 80012c2:	f001 fc5d 	bl	8002b80 <osalSysUnlockFromISR.lto_priv.38>
  }
  if ((rf0r & CAN_RF0R_FOVR0) > 0) {
 80012c6:	9b03      	ldr	r3, [sp, #12]
 80012c8:	2210      	movs	r2, #16
 80012ca:	4013      	ands	r3, r2
 80012cc:	d00d      	beq.n	80012ea <can_lld_rx0_handler+0x6a>
    /* Overflow events handling.*/
    canp->can->RF0R = CAN_RF0R_FOVR0;
 80012ce:	9b01      	ldr	r3, [sp, #4]
 80012d0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80012d2:	2210      	movs	r2, #16
 80012d4:	60da      	str	r2, [r3, #12]
    osalSysLockFromISR();
 80012d6:	f001 fc4b 	bl	8002b70 <osalSysLockFromISR.lto_priv.40>
    osalEventBroadcastFlagsI(&canp->error_event, CAN_OVERFLOW_ERROR);
 80012da:	9b01      	ldr	r3, [sp, #4]
 80012dc:	3320      	adds	r3, #32
 80012de:	2110      	movs	r1, #16
 80012e0:	0018      	movs	r0, r3
 80012e2:	f001 fc75 	bl	8002bd0 <osalEventBroadcastFlagsI.lto_priv.45>
    osalSysUnlockFromISR();
 80012e6:	f001 fc4b 	bl	8002b80 <osalSysUnlockFromISR.lto_priv.38>
  }
}
 80012ea:	b005      	add	sp, #20
 80012ec:	bd00      	pop	{pc}
 80012ee:	46c0      	nop			; (mov r8, r8)

080012f0 <can_lld_rx1_handler>:
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
static void can_lld_rx1_handler(CANDriver *canp) {
 80012f0:	b500      	push	{lr}
 80012f2:	b085      	sub	sp, #20
 80012f4:	9001      	str	r0, [sp, #4]
  uint32_t rf1r;

  rf1r = canp->can->RF1R;
 80012f6:	9b01      	ldr	r3, [sp, #4]
 80012f8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80012fa:	691b      	ldr	r3, [r3, #16]
 80012fc:	9303      	str	r3, [sp, #12]
  if ((rf1r & CAN_RF1R_FMP1) > 0) {
 80012fe:	9b03      	ldr	r3, [sp, #12]
 8001300:	2203      	movs	r2, #3
 8001302:	4013      	ands	r3, r2
 8001304:	d017      	beq.n	8001336 <can_lld_rx1_handler+0x46>
    /* No more receive events until the queue 0 has been emptied.*/
    canp->can->IER &= ~CAN_IER_FMPIE1;
 8001306:	9b01      	ldr	r3, [sp, #4]
 8001308:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800130a:	9a01      	ldr	r2, [sp, #4]
 800130c:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800130e:	6952      	ldr	r2, [r2, #20]
 8001310:	2110      	movs	r1, #16
 8001312:	438a      	bics	r2, r1
 8001314:	615a      	str	r2, [r3, #20]
    osalSysLockFromISR();
 8001316:	f001 fc2b 	bl	8002b70 <osalSysLockFromISR.lto_priv.40>
    osalThreadDequeueAllI(&canp->rxqueue, MSG_OK);
 800131a:	9b01      	ldr	r3, [sp, #4]
 800131c:	3310      	adds	r3, #16
 800131e:	2100      	movs	r1, #0
 8001320:	0018      	movs	r0, r3
 8001322:	f001 fc45 	bl	8002bb0 <osalThreadDequeueAllI.lto_priv.46>
    osalEventBroadcastFlagsI(&canp->rxfull_event, CAN_MAILBOX_TO_MASK(2U));
 8001326:	9b01      	ldr	r3, [sp, #4]
 8001328:	3318      	adds	r3, #24
 800132a:	2102      	movs	r1, #2
 800132c:	0018      	movs	r0, r3
 800132e:	f001 fc4f 	bl	8002bd0 <osalEventBroadcastFlagsI.lto_priv.45>
    osalSysUnlockFromISR();
 8001332:	f001 fc25 	bl	8002b80 <osalSysUnlockFromISR.lto_priv.38>
  }
  if ((rf1r & CAN_RF1R_FOVR1) > 0) {
 8001336:	9b03      	ldr	r3, [sp, #12]
 8001338:	2210      	movs	r2, #16
 800133a:	4013      	ands	r3, r2
 800133c:	d00d      	beq.n	800135a <can_lld_rx1_handler+0x6a>
    /* Overflow events handling.*/
    canp->can->RF1R = CAN_RF1R_FOVR1;
 800133e:	9b01      	ldr	r3, [sp, #4]
 8001340:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001342:	2210      	movs	r2, #16
 8001344:	611a      	str	r2, [r3, #16]
    osalSysLockFromISR();
 8001346:	f001 fc13 	bl	8002b70 <osalSysLockFromISR.lto_priv.40>
    osalEventBroadcastFlagsI(&canp->error_event, CAN_OVERFLOW_ERROR);
 800134a:	9b01      	ldr	r3, [sp, #4]
 800134c:	3320      	adds	r3, #32
 800134e:	2110      	movs	r1, #16
 8001350:	0018      	movs	r0, r3
 8001352:	f001 fc3d 	bl	8002bd0 <osalEventBroadcastFlagsI.lto_priv.45>
    osalSysUnlockFromISR();
 8001356:	f001 fc13 	bl	8002b80 <osalSysUnlockFromISR.lto_priv.38>
  }
}
 800135a:	b005      	add	sp, #20
 800135c:	bd00      	pop	{pc}
 800135e:	46c0      	nop			; (mov r8, r8)

08001360 <can_lld_sce_handler>:
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
static void can_lld_sce_handler(CANDriver *canp) {
 8001360:	b500      	push	{lr}
 8001362:	b087      	sub	sp, #28
 8001364:	9001      	str	r0, [sp, #4]
  uint32_t msr;

  /* Clearing IRQ sources.*/
  msr = canp->can->MSR;
 8001366:	9b01      	ldr	r3, [sp, #4]
 8001368:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800136a:	685b      	ldr	r3, [r3, #4]
 800136c:	9305      	str	r3, [sp, #20]
  canp->can->MSR = msr;
 800136e:	9b01      	ldr	r3, [sp, #4]
 8001370:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001372:	9a05      	ldr	r2, [sp, #20]
 8001374:	605a      	str	r2, [r3, #4]

  /* Wakeup event.*/
#if CAN_USE_SLEEP_MODE
  if (msr & CAN_MSR_WKUI) {
 8001376:	9b05      	ldr	r3, [sp, #20]
 8001378:	2208      	movs	r2, #8
 800137a:	4013      	ands	r3, r2
 800137c:	d014      	beq.n	80013a8 <can_lld_sce_handler+0x48>
    canp->state = CAN_READY;
 800137e:	9b01      	ldr	r3, [sp, #4]
 8001380:	2203      	movs	r2, #3
 8001382:	701a      	strb	r2, [r3, #0]
    canp->can->MCR &= ~CAN_MCR_SLEEP;
 8001384:	9b01      	ldr	r3, [sp, #4]
 8001386:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001388:	9a01      	ldr	r2, [sp, #4]
 800138a:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800138c:	6812      	ldr	r2, [r2, #0]
 800138e:	2102      	movs	r1, #2
 8001390:	438a      	bics	r2, r1
 8001392:	601a      	str	r2, [r3, #0]
    osalSysLockFromISR();
 8001394:	f001 fbec 	bl	8002b70 <osalSysLockFromISR.lto_priv.40>
    osalEventBroadcastFlagsI(&canp->wakeup_event, 0);
 8001398:	9b01      	ldr	r3, [sp, #4]
 800139a:	3328      	adds	r3, #40	; 0x28
 800139c:	2100      	movs	r1, #0
 800139e:	0018      	movs	r0, r3
 80013a0:	f001 fc16 	bl	8002bd0 <osalEventBroadcastFlagsI.lto_priv.45>
    osalSysUnlockFromISR();
 80013a4:	f001 fbec 	bl	8002b80 <osalSysUnlockFromISR.lto_priv.38>
  }
#endif /* CAN_USE_SLEEP_MODE */
  /* Error event.*/
  if (msr & CAN_MSR_ERRI) {
 80013a8:	9b05      	ldr	r3, [sp, #20]
 80013aa:	2204      	movs	r2, #4
 80013ac:	4013      	ands	r3, r2
 80013ae:	d013      	beq.n	80013d8 <can_lld_sce_handler+0x78>
    eventflags_t flags;
    uint32_t esr = canp->can->ESR;
 80013b0:	9b01      	ldr	r3, [sp, #4]
 80013b2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80013b4:	699b      	ldr	r3, [r3, #24]
 80013b6:	9304      	str	r3, [sp, #16]
#if STM32_CAN_REPORT_ALL_ERRORS
    flags = (eventflags_t)(esr & 7);
    if ((esr & CAN_ESR_LEC) > 0)
      flags |= CAN_FRAMING_ERROR;
#else
    flags = 0;
 80013b8:	2300      	movs	r3, #0
 80013ba:	9303      	str	r3, [sp, #12]
#endif

    osalSysLockFromISR();
 80013bc:	f001 fbd8 	bl	8002b70 <osalSysLockFromISR.lto_priv.40>
    /* The content of the ESR register is copied unchanged in the upper
       half word of the listener flags mask.*/
    osalEventBroadcastFlagsI(&canp->error_event,
 80013c0:	9b01      	ldr	r3, [sp, #4]
 80013c2:	3320      	adds	r3, #32
 80013c4:	0018      	movs	r0, r3
                             flags | (eventflags_t)(esr << 16U));
 80013c6:	9b04      	ldr	r3, [sp, #16]
 80013c8:	041a      	lsls	r2, r3, #16
    osalEventBroadcastFlagsI(&canp->error_event,
 80013ca:	9b03      	ldr	r3, [sp, #12]
 80013cc:	4313      	orrs	r3, r2
 80013ce:	0019      	movs	r1, r3
 80013d0:	f001 fbfe 	bl	8002bd0 <osalEventBroadcastFlagsI.lto_priv.45>
    osalSysUnlockFromISR();
 80013d4:	f001 fbd4 	bl	8002b80 <osalSysUnlockFromISR.lto_priv.38>
  }
}
 80013d8:	b007      	add	sp, #28
 80013da:	bd00      	pop	{pc}
 80013dc:	0000      	movs	r0, r0
	...

080013e0 <VectorB8>:
/**
 * @brief   CAN1 unified interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN1_UNIFIED_HANDLER) {
 80013e0:	b500      	push	{lr}
 80013e2:	b083      	sub	sp, #12
 80013e4:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 80013e6:	9301      	str	r3, [sp, #4]

  can_lld_tx_handler(&CAND1);
 80013e8:	4b0a      	ldr	r3, [pc, #40]	; (8001414 <VectorB8+0x34>)
 80013ea:	0018      	movs	r0, r3
 80013ec:	f7ff fee8 	bl	80011c0 <can_lld_tx_handler>
  can_lld_rx0_handler(&CAND1);
 80013f0:	4b08      	ldr	r3, [pc, #32]	; (8001414 <VectorB8+0x34>)
 80013f2:	0018      	movs	r0, r3
 80013f4:	f7ff ff44 	bl	8001280 <can_lld_rx0_handler>
  can_lld_rx1_handler(&CAND1);
 80013f8:	4b06      	ldr	r3, [pc, #24]	; (8001414 <VectorB8+0x34>)
 80013fa:	0018      	movs	r0, r3
 80013fc:	f7ff ff78 	bl	80012f0 <can_lld_rx1_handler>
  can_lld_sce_handler(&CAND1);
 8001400:	4b04      	ldr	r3, [pc, #16]	; (8001414 <VectorB8+0x34>)
 8001402:	0018      	movs	r0, r3
 8001404:	f7ff ffac 	bl	8001360 <can_lld_sce_handler>

  OSAL_IRQ_EPILOGUE();
 8001408:	9b01      	ldr	r3, [sp, #4]
 800140a:	0018      	movs	r0, r3
 800140c:	f002 fa50 	bl	80038b0 <_port_irq_epilogue>
}
 8001410:	b003      	add	sp, #12
 8001412:	bd00      	pop	{pc}
 8001414:	20000578 	.word	0x20000578
	...

08001420 <can_lld_init>:
/**
 * @brief   Low level CAN driver initialization.
 *
 * @notapi
 */
void can_lld_init(void) {
 8001420:	b510      	push	{r4, lr}

#if STM32_CAN_USE_CAN1
  /* Driver initialization.*/
  canObjectInit(&CAND1);
 8001422:	4b07      	ldr	r3, [pc, #28]	; (8001440 <can_lld_init+0x20>)
 8001424:	0018      	movs	r0, r3
 8001426:	f002 f883 	bl	8003530 <canObjectInit>
  CAND1.can = CAN1;
 800142a:	4b05      	ldr	r3, [pc, #20]	; (8001440 <can_lld_init+0x20>)
 800142c:	4a05      	ldr	r2, [pc, #20]	; (8001444 <can_lld_init+0x24>)
 800142e:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Filters initialization.*/
#if STM32_HAS_CAN2
  can_lld_set_filters(&CAND1, STM32_CAN_MAX_FILTERS / 2, 0, NULL);
#else
  can_lld_set_filters(&CAND1, STM32_CAN_MAX_FILTERS, 0, NULL);
 8001430:	4803      	ldr	r0, [pc, #12]	; (8001440 <can_lld_init+0x20>)
 8001432:	2300      	movs	r3, #0
 8001434:	2200      	movs	r2, #0
 8001436:	210e      	movs	r1, #14
 8001438:	f001 fbda 	bl	8002bf0 <can_lld_set_filters.lto_priv.43>
#if STM32_HAS_CAN3
#if STM32_CAN_USE_CAN3
  can_lld_set_filters(&CAND3, STM32_CAN3_MAX_FILTERS, 0, NULL);
#endif
#endif
}
 800143c:	bd10      	pop	{r4, pc}
 800143e:	46c0      	nop			; (mov r8, r8)
 8001440:	20000578 	.word	0x20000578
 8001444:	40006400 	.word	0x40006400
	...

08001450 <can_lld_start>:
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
void can_lld_start(CANDriver *canp) {
 8001450:	b500      	push	{lr}
 8001452:	b083      	sub	sp, #12
 8001454:	9001      	str	r0, [sp, #4]

  /* Clock activation.*/
#if STM32_CAN_USE_CAN1
  if (&CAND1 == canp) {
 8001456:	9a01      	ldr	r2, [sp, #4]
 8001458:	4b16      	ldr	r3, [pc, #88]	; (80014b4 <can_lld_start+0x64>)
 800145a:	429a      	cmp	r2, r3
 800145c:	d10a      	bne.n	8001474 <can_lld_start+0x24>
#if defined(STM32_CAN1_UNIFIED_NUMBER)
    nvicEnableVector(STM32_CAN1_UNIFIED_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
 800145e:	2103      	movs	r1, #3
 8001460:	201e      	movs	r0, #30
 8001462:	f000 ff9d 	bl	80023a0 <nvicEnableVector>
    nvicEnableVector(STM32_CAN1_TX_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
    nvicEnableVector(STM32_CAN1_RX0_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
    nvicEnableVector(STM32_CAN1_RX1_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
    nvicEnableVector(STM32_CAN1_SCE_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
#endif
    rccEnableCAN1(FALSE);
 8001466:	4b14      	ldr	r3, [pc, #80]	; (80014b8 <can_lld_start+0x68>)
 8001468:	4a13      	ldr	r2, [pc, #76]	; (80014b8 <can_lld_start+0x68>)
 800146a:	69d2      	ldr	r2, [r2, #28]
 800146c:	2180      	movs	r1, #128	; 0x80
 800146e:	0489      	lsls	r1, r1, #18
 8001470:	430a      	orrs	r2, r1
 8001472:	61da      	str	r2, [r3, #28]
    rccEnableCAN3(FALSE);
  }
#endif

  /* Configuring CAN. */
  canp->can->MCR = CAN_MCR_INRQ;
 8001474:	9b01      	ldr	r3, [sp, #4]
 8001476:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001478:	2201      	movs	r2, #1
 800147a:	601a      	str	r2, [r3, #0]
 800147c:	e002      	b.n	8001484 <can_lld_start+0x34>
  while ((canp->can->MSR & CAN_MSR_INAK) == 0)
    osalThreadSleepS(1);
 800147e:	2001      	movs	r0, #1
 8001480:	f001 fb86 	bl	8002b90 <osalThreadSleepS.lto_priv.44>
  while ((canp->can->MSR & CAN_MSR_INAK) == 0)
 8001484:	9b01      	ldr	r3, [sp, #4]
 8001486:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001488:	685b      	ldr	r3, [r3, #4]
 800148a:	2201      	movs	r2, #1
 800148c:	4013      	ands	r3, r2
 800148e:	d0f6      	beq.n	800147e <can_lld_start+0x2e>
  canp->can->BTR = canp->config->btr;
 8001490:	9b01      	ldr	r3, [sp, #4]
 8001492:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001494:	9a01      	ldr	r2, [sp, #4]
 8001496:	6852      	ldr	r2, [r2, #4]
 8001498:	6852      	ldr	r2, [r2, #4]
 800149a:	61da      	str	r2, [r3, #28]
  canp->can->MCR = canp->config->mcr;
 800149c:	9b01      	ldr	r3, [sp, #4]
 800149e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80014a0:	9a01      	ldr	r2, [sp, #4]
 80014a2:	6852      	ldr	r2, [r2, #4]
 80014a4:	6812      	ldr	r2, [r2, #0]
 80014a6:	601a      	str	r2, [r3, #0]
  canp->can->IER = CAN_IER_TMEIE  | CAN_IER_FMPIE0 | CAN_IER_FMPIE1 |
                   CAN_IER_WKUIE  | CAN_IER_ERRIE  | CAN_IER_LECIE  |
                   CAN_IER_BOFIE  | CAN_IER_EPVIE  | CAN_IER_EWGIE  |
                   CAN_IER_FOVIE0 | CAN_IER_FOVIE1;
#else
  canp->can->IER = CAN_IER_TMEIE  | CAN_IER_FMPIE0 | CAN_IER_FMPIE1 |
 80014a8:	9b01      	ldr	r3, [sp, #4]
 80014aa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80014ac:	4a03      	ldr	r2, [pc, #12]	; (80014bc <can_lld_start+0x6c>)
 80014ae:	615a      	str	r2, [r3, #20]
                   CAN_IER_WKUIE  | CAN_IER_ERRIE  |
                   CAN_IER_BOFIE  | CAN_IER_EPVIE  | CAN_IER_EWGIE  |
                   CAN_IER_FOVIE0 | CAN_IER_FOVIE1;
#endif
}
 80014b0:	b003      	add	sp, #12
 80014b2:	bd00      	pop	{pc}
 80014b4:	20000578 	.word	0x20000578
 80014b8:	40021000 	.word	0x40021000
 80014bc:	0001875b 	.word	0x0001875b

080014c0 <can_lld_is_tx_empty>:
 * @retval FALSE        no space in the transmit queue.
 * @retval TRUE         transmit slot available.
 *
 * @notapi
 */
bool can_lld_is_tx_empty(CANDriver *canp, canmbx_t mailbox) {
 80014c0:	b082      	sub	sp, #8
 80014c2:	9001      	str	r0, [sp, #4]
 80014c4:	9100      	str	r1, [sp, #0]

  switch (mailbox) {
 80014c6:	9b00      	ldr	r3, [sp, #0]
 80014c8:	2b01      	cmp	r3, #1
 80014ca:	d00f      	beq.n	80014ec <can_lld_is_tx_empty+0x2c>
 80014cc:	d304      	bcc.n	80014d8 <can_lld_is_tx_empty+0x18>
 80014ce:	2b02      	cmp	r3, #2
 80014d0:	d016      	beq.n	8001500 <can_lld_is_tx_empty+0x40>
 80014d2:	2b03      	cmp	r3, #3
 80014d4:	d01e      	beq.n	8001514 <can_lld_is_tx_empty+0x54>
 80014d6:	e027      	b.n	8001528 <can_lld_is_tx_empty+0x68>
  case CAN_ANY_MAILBOX:
    return (canp->can->TSR & CAN_TSR_TME) != 0;
 80014d8:	9b01      	ldr	r3, [sp, #4]
 80014da:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80014dc:	689a      	ldr	r2, [r3, #8]
 80014de:	23e0      	movs	r3, #224	; 0xe0
 80014e0:	055b      	lsls	r3, r3, #21
 80014e2:	4013      	ands	r3, r2
 80014e4:	1e5a      	subs	r2, r3, #1
 80014e6:	4193      	sbcs	r3, r2
 80014e8:	b2db      	uxtb	r3, r3
 80014ea:	e01e      	b.n	800152a <can_lld_is_tx_empty+0x6a>
  case 1:
    return (canp->can->TSR & CAN_TSR_TME0) != 0;
 80014ec:	9b01      	ldr	r3, [sp, #4]
 80014ee:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80014f0:	689a      	ldr	r2, [r3, #8]
 80014f2:	2380      	movs	r3, #128	; 0x80
 80014f4:	04db      	lsls	r3, r3, #19
 80014f6:	4013      	ands	r3, r2
 80014f8:	1e5a      	subs	r2, r3, #1
 80014fa:	4193      	sbcs	r3, r2
 80014fc:	b2db      	uxtb	r3, r3
 80014fe:	e014      	b.n	800152a <can_lld_is_tx_empty+0x6a>
  case 2:
    return (canp->can->TSR & CAN_TSR_TME1) != 0;
 8001500:	9b01      	ldr	r3, [sp, #4]
 8001502:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001504:	689a      	ldr	r2, [r3, #8]
 8001506:	2380      	movs	r3, #128	; 0x80
 8001508:	051b      	lsls	r3, r3, #20
 800150a:	4013      	ands	r3, r2
 800150c:	1e5a      	subs	r2, r3, #1
 800150e:	4193      	sbcs	r3, r2
 8001510:	b2db      	uxtb	r3, r3
 8001512:	e00a      	b.n	800152a <can_lld_is_tx_empty+0x6a>
  case 3:
    return (canp->can->TSR & CAN_TSR_TME2) != 0;
 8001514:	9b01      	ldr	r3, [sp, #4]
 8001516:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001518:	689a      	ldr	r2, [r3, #8]
 800151a:	2380      	movs	r3, #128	; 0x80
 800151c:	055b      	lsls	r3, r3, #21
 800151e:	4013      	ands	r3, r2
 8001520:	1e5a      	subs	r2, r3, #1
 8001522:	4193      	sbcs	r3, r2
 8001524:	b2db      	uxtb	r3, r3
 8001526:	e000      	b.n	800152a <can_lld_is_tx_empty+0x6a>
  default:
    return FALSE;
 8001528:	2300      	movs	r3, #0
  }
}
 800152a:	0018      	movs	r0, r3
 800152c:	b002      	add	sp, #8
 800152e:	4770      	bx	lr

08001530 <can_lld_transmit>:
 *
 * @notapi
 */
void can_lld_transmit(CANDriver *canp,
                      canmbx_t mailbox,
                      const CANTxFrame *ctfp) {
 8001530:	b086      	sub	sp, #24
 8001532:	9003      	str	r0, [sp, #12]
 8001534:	9102      	str	r1, [sp, #8]
 8001536:	9201      	str	r2, [sp, #4]
  uint32_t tir;
  CAN_TxMailBox_TypeDef *tmbp;

  /* Pointer to a free transmission mailbox.*/
  switch (mailbox) {
 8001538:	9b02      	ldr	r3, [sp, #8]
 800153a:	2b01      	cmp	r3, #1
 800153c:	d013      	beq.n	8001566 <can_lld_transmit+0x36>
 800153e:	d304      	bcc.n	800154a <can_lld_transmit+0x1a>
 8001540:	2b02      	cmp	r3, #2
 8001542:	d016      	beq.n	8001572 <can_lld_transmit+0x42>
 8001544:	2b03      	cmp	r3, #3
 8001546:	d01a      	beq.n	800157e <can_lld_transmit+0x4e>
 8001548:	e058      	b.n	80015fc <can_lld_transmit+0xcc>
  case CAN_ANY_MAILBOX:
    tmbp = &canp->can->sTxMailBox[(canp->can->TSR & CAN_TSR_CODE) >> 24];
 800154a:	9b03      	ldr	r3, [sp, #12]
 800154c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800154e:	9b03      	ldr	r3, [sp, #12]
 8001550:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001552:	6899      	ldr	r1, [r3, #8]
 8001554:	23c0      	movs	r3, #192	; 0xc0
 8001556:	049b      	lsls	r3, r3, #18
 8001558:	400b      	ands	r3, r1
 800155a:	0e1b      	lsrs	r3, r3, #24
 800155c:	3318      	adds	r3, #24
 800155e:	011b      	lsls	r3, r3, #4
 8001560:	18d3      	adds	r3, r2, r3
 8001562:	9304      	str	r3, [sp, #16]
 8001564:	e010      	b.n	8001588 <can_lld_transmit+0x58>
    break;
  case 1:
    tmbp = &canp->can->sTxMailBox[0];
 8001566:	9b03      	ldr	r3, [sp, #12]
 8001568:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800156a:	3381      	adds	r3, #129	; 0x81
 800156c:	33ff      	adds	r3, #255	; 0xff
 800156e:	9304      	str	r3, [sp, #16]
 8001570:	e00a      	b.n	8001588 <can_lld_transmit+0x58>
    break;
  case 2:
    tmbp = &canp->can->sTxMailBox[1];
 8001572:	9b03      	ldr	r3, [sp, #12]
 8001574:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001576:	3391      	adds	r3, #145	; 0x91
 8001578:	33ff      	adds	r3, #255	; 0xff
 800157a:	9304      	str	r3, [sp, #16]
 800157c:	e004      	b.n	8001588 <can_lld_transmit+0x58>
    break;
  case 3:
    tmbp = &canp->can->sTxMailBox[2];
 800157e:	9b03      	ldr	r3, [sp, #12]
 8001580:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001582:	33a1      	adds	r3, #161	; 0xa1
 8001584:	33ff      	adds	r3, #255	; 0xff
 8001586:	9304      	str	r3, [sp, #16]
  default:
    return;
  }

  /* Preparing the message.*/
  if (ctfp->IDE)
 8001588:	9b01      	ldr	r3, [sp, #4]
 800158a:	781b      	ldrb	r3, [r3, #0]
 800158c:	2220      	movs	r2, #32
 800158e:	4013      	ands	r3, r2
 8001590:	b2db      	uxtb	r3, r3
 8001592:	2b00      	cmp	r3, #0
 8001594:	d00f      	beq.n	80015b6 <can_lld_transmit+0x86>
    tir = ((uint32_t)ctfp->EID << 3) | ((uint32_t)ctfp->RTR << 1) |
 8001596:	9b01      	ldr	r3, [sp, #4]
 8001598:	685b      	ldr	r3, [r3, #4]
 800159a:	00db      	lsls	r3, r3, #3
 800159c:	08db      	lsrs	r3, r3, #3
 800159e:	00da      	lsls	r2, r3, #3
 80015a0:	9b01      	ldr	r3, [sp, #4]
 80015a2:	781b      	ldrb	r3, [r3, #0]
 80015a4:	06db      	lsls	r3, r3, #27
 80015a6:	0fdb      	lsrs	r3, r3, #31
 80015a8:	b2db      	uxtb	r3, r3
 80015aa:	005b      	lsls	r3, r3, #1
 80015ac:	4313      	orrs	r3, r2
 80015ae:	2204      	movs	r2, #4
 80015b0:	4313      	orrs	r3, r2
 80015b2:	9305      	str	r3, [sp, #20]
 80015b4:	e00d      	b.n	80015d2 <can_lld_transmit+0xa2>
          CAN_TI0R_IDE;
  else
    tir = ((uint32_t)ctfp->SID << 21) | ((uint32_t)ctfp->RTR << 1);
 80015b6:	9b01      	ldr	r3, [sp, #4]
 80015b8:	889b      	ldrh	r3, [r3, #4]
 80015ba:	055b      	lsls	r3, r3, #21
 80015bc:	0d5b      	lsrs	r3, r3, #21
 80015be:	b29b      	uxth	r3, r3
 80015c0:	055a      	lsls	r2, r3, #21
 80015c2:	9b01      	ldr	r3, [sp, #4]
 80015c4:	781b      	ldrb	r3, [r3, #0]
 80015c6:	06db      	lsls	r3, r3, #27
 80015c8:	0fdb      	lsrs	r3, r3, #31
 80015ca:	b2db      	uxtb	r3, r3
 80015cc:	005b      	lsls	r3, r3, #1
 80015ce:	4313      	orrs	r3, r2
 80015d0:	9305      	str	r3, [sp, #20]
  tmbp->TDTR = ctfp->DLC;
 80015d2:	9b01      	ldr	r3, [sp, #4]
 80015d4:	781b      	ldrb	r3, [r3, #0]
 80015d6:	071b      	lsls	r3, r3, #28
 80015d8:	0f1b      	lsrs	r3, r3, #28
 80015da:	b2db      	uxtb	r3, r3
 80015dc:	001a      	movs	r2, r3
 80015de:	9b04      	ldr	r3, [sp, #16]
 80015e0:	605a      	str	r2, [r3, #4]
  tmbp->TDLR = ctfp->data32[0];
 80015e2:	9b01      	ldr	r3, [sp, #4]
 80015e4:	689a      	ldr	r2, [r3, #8]
 80015e6:	9b04      	ldr	r3, [sp, #16]
 80015e8:	609a      	str	r2, [r3, #8]
  tmbp->TDHR = ctfp->data32[1];
 80015ea:	9b01      	ldr	r3, [sp, #4]
 80015ec:	68da      	ldr	r2, [r3, #12]
 80015ee:	9b04      	ldr	r3, [sp, #16]
 80015f0:	60da      	str	r2, [r3, #12]
  tmbp->TIR  = tir | CAN_TI0R_TXRQ;
 80015f2:	9b05      	ldr	r3, [sp, #20]
 80015f4:	2201      	movs	r2, #1
 80015f6:	431a      	orrs	r2, r3
 80015f8:	9b04      	ldr	r3, [sp, #16]
 80015fa:	601a      	str	r2, [r3, #0]
}
 80015fc:	b006      	add	sp, #24
 80015fe:	4770      	bx	lr

08001600 <can_lld_is_rx_nonempty>:
 * @retval FALSE        no space in the transmit queue.
 * @retval TRUE         transmit slot available.
 *
 * @notapi
 */
bool can_lld_is_rx_nonempty(CANDriver *canp, canmbx_t mailbox) {
 8001600:	b082      	sub	sp, #8
 8001602:	9001      	str	r0, [sp, #4]
 8001604:	9100      	str	r1, [sp, #0]

  switch (mailbox) {
 8001606:	9b00      	ldr	r3, [sp, #0]
 8001608:	2b01      	cmp	r3, #1
 800160a:	d017      	beq.n	800163c <can_lld_is_rx_nonempty+0x3c>
 800160c:	d302      	bcc.n	8001614 <can_lld_is_rx_nonempty+0x14>
 800160e:	2b02      	cmp	r3, #2
 8001610:	d01d      	beq.n	800164e <can_lld_is_rx_nonempty+0x4e>
 8001612:	e025      	b.n	8001660 <can_lld_is_rx_nonempty+0x60>
  case CAN_ANY_MAILBOX:
    return ((canp->can->RF0R & CAN_RF0R_FMP0) != 0 ||
 8001614:	9b01      	ldr	r3, [sp, #4]
 8001616:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001618:	68db      	ldr	r3, [r3, #12]
 800161a:	2203      	movs	r2, #3
 800161c:	4013      	ands	r3, r2
 800161e:	d105      	bne.n	800162c <can_lld_is_rx_nonempty+0x2c>
            (canp->can->RF1R & CAN_RF1R_FMP1) != 0);
 8001620:	9b01      	ldr	r3, [sp, #4]
 8001622:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001624:	691b      	ldr	r3, [r3, #16]
 8001626:	2203      	movs	r2, #3
 8001628:	4013      	ands	r3, r2
    return ((canp->can->RF0R & CAN_RF0R_FMP0) != 0 ||
 800162a:	d001      	beq.n	8001630 <can_lld_is_rx_nonempty+0x30>
 800162c:	2301      	movs	r3, #1
 800162e:	e000      	b.n	8001632 <can_lld_is_rx_nonempty+0x32>
 8001630:	2300      	movs	r3, #0
 8001632:	1c1a      	adds	r2, r3, #0
 8001634:	2301      	movs	r3, #1
 8001636:	4013      	ands	r3, r2
 8001638:	b2db      	uxtb	r3, r3
 800163a:	e012      	b.n	8001662 <can_lld_is_rx_nonempty+0x62>
  case 1:
    return (canp->can->RF0R & CAN_RF0R_FMP0) != 0;
 800163c:	9b01      	ldr	r3, [sp, #4]
 800163e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001640:	68db      	ldr	r3, [r3, #12]
 8001642:	2203      	movs	r2, #3
 8001644:	4013      	ands	r3, r2
 8001646:	1e5a      	subs	r2, r3, #1
 8001648:	4193      	sbcs	r3, r2
 800164a:	b2db      	uxtb	r3, r3
 800164c:	e009      	b.n	8001662 <can_lld_is_rx_nonempty+0x62>
  case 2:
    return (canp->can->RF1R & CAN_RF1R_FMP1) != 0;
 800164e:	9b01      	ldr	r3, [sp, #4]
 8001650:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001652:	691b      	ldr	r3, [r3, #16]
 8001654:	2203      	movs	r2, #3
 8001656:	4013      	ands	r3, r2
 8001658:	1e5a      	subs	r2, r3, #1
 800165a:	4193      	sbcs	r3, r2
 800165c:	b2db      	uxtb	r3, r3
 800165e:	e000      	b.n	8001662 <can_lld_is_rx_nonempty+0x62>
  default:
    return FALSE;
 8001660:	2300      	movs	r3, #0
  }
}
 8001662:	0018      	movs	r0, r3
 8001664:	b002      	add	sp, #8
 8001666:	4770      	bx	lr
	...

08001670 <can_lld_receive>:
 *
 * @notapi
 */
void can_lld_receive(CANDriver *canp,
                     canmbx_t mailbox,
                     CANRxFrame *crfp) {
 8001670:	b086      	sub	sp, #24
 8001672:	9003      	str	r0, [sp, #12]
 8001674:	9102      	str	r1, [sp, #8]
 8001676:	9201      	str	r2, [sp, #4]
  uint32_t rir, rdtr;

  if (mailbox == CAN_ANY_MAILBOX) {
 8001678:	9b02      	ldr	r3, [sp, #8]
 800167a:	2b00      	cmp	r3, #0
 800167c:	d111      	bne.n	80016a2 <can_lld_receive+0x32>
    if ((canp->can->RF0R & CAN_RF0R_FMP0) != 0)
 800167e:	9b03      	ldr	r3, [sp, #12]
 8001680:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001682:	68db      	ldr	r3, [r3, #12]
 8001684:	2203      	movs	r2, #3
 8001686:	4013      	ands	r3, r2
 8001688:	d002      	beq.n	8001690 <can_lld_receive+0x20>
      mailbox = 1;
 800168a:	2301      	movs	r3, #1
 800168c:	9302      	str	r3, [sp, #8]
 800168e:	e008      	b.n	80016a2 <can_lld_receive+0x32>
    else if ((canp->can->RF1R & CAN_RF1R_FMP1) != 0)
 8001690:	9b03      	ldr	r3, [sp, #12]
 8001692:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001694:	691b      	ldr	r3, [r3, #16]
 8001696:	2203      	movs	r2, #3
 8001698:	4013      	ands	r3, r2
 800169a:	d100      	bne.n	800169e <can_lld_receive+0x2e>
 800169c:	e0c7      	b.n	800182e <can_lld_receive+0x1be>
      mailbox = 2;
 800169e:	2302      	movs	r3, #2
 80016a0:	9302      	str	r3, [sp, #8]
    else {
      /* Should not happen, do nothing.*/
      return;
    }
  }
  switch (mailbox) {
 80016a2:	9b02      	ldr	r3, [sp, #8]
 80016a4:	2b01      	cmp	r3, #1
 80016a6:	d002      	beq.n	80016ae <can_lld_receive+0x3e>
 80016a8:	2b02      	cmp	r3, #2
 80016aa:	d02d      	beq.n	8001708 <can_lld_receive+0x98>
 80016ac:	e0bf      	b.n	800182e <can_lld_receive+0x1be>
  case 1:
    /* Fetches the message.*/
    rir  = canp->can->sFIFOMailBox[0].RIR;
 80016ae:	9b03      	ldr	r3, [sp, #12]
 80016b0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80016b2:	23d8      	movs	r3, #216	; 0xd8
 80016b4:	005b      	lsls	r3, r3, #1
 80016b6:	58d3      	ldr	r3, [r2, r3]
 80016b8:	9305      	str	r3, [sp, #20]
    rdtr = canp->can->sFIFOMailBox[0].RDTR;
 80016ba:	9b03      	ldr	r3, [sp, #12]
 80016bc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80016be:	23da      	movs	r3, #218	; 0xda
 80016c0:	005b      	lsls	r3, r3, #1
 80016c2:	58d3      	ldr	r3, [r2, r3]
 80016c4:	9304      	str	r3, [sp, #16]
    crfp->data32[0] = canp->can->sFIFOMailBox[0].RDLR;
 80016c6:	9b03      	ldr	r3, [sp, #12]
 80016c8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80016ca:	23dc      	movs	r3, #220	; 0xdc
 80016cc:	005b      	lsls	r3, r3, #1
 80016ce:	58d2      	ldr	r2, [r2, r3]
 80016d0:	9b01      	ldr	r3, [sp, #4]
 80016d2:	611a      	str	r2, [r3, #16]
    crfp->data32[1] = canp->can->sFIFOMailBox[0].RDHR;
 80016d4:	9b03      	ldr	r3, [sp, #12]
 80016d6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80016d8:	23de      	movs	r3, #222	; 0xde
 80016da:	005b      	lsls	r3, r3, #1
 80016dc:	58d2      	ldr	r2, [r2, r3]
 80016de:	9b01      	ldr	r3, [sp, #4]
 80016e0:	615a      	str	r2, [r3, #20]

    /* Releases the mailbox.*/
    canp->can->RF0R = CAN_RF0R_RFOM0;
 80016e2:	9b03      	ldr	r3, [sp, #12]
 80016e4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80016e6:	2220      	movs	r2, #32
 80016e8:	60da      	str	r2, [r3, #12]

    /* If the queue is empty re-enables the interrupt in order to generate
       events again.*/
    if ((canp->can->RF0R & CAN_RF0R_FMP0) == 0)
 80016ea:	9b03      	ldr	r3, [sp, #12]
 80016ec:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80016ee:	68db      	ldr	r3, [r3, #12]
 80016f0:	2203      	movs	r2, #3
 80016f2:	4013      	ands	r3, r2
 80016f4:	d135      	bne.n	8001762 <can_lld_receive+0xf2>
      canp->can->IER |= CAN_IER_FMPIE0;
 80016f6:	9b03      	ldr	r3, [sp, #12]
 80016f8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80016fa:	9a03      	ldr	r2, [sp, #12]
 80016fc:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80016fe:	6952      	ldr	r2, [r2, #20]
 8001700:	2102      	movs	r1, #2
 8001702:	430a      	orrs	r2, r1
 8001704:	615a      	str	r2, [r3, #20]
 8001706:	e02f      	b.n	8001768 <can_lld_receive+0xf8>
    break;
  case 2:
    /* Fetches the message.*/
    rir  = canp->can->sFIFOMailBox[1].RIR;
 8001708:	9b03      	ldr	r3, [sp, #12]
 800170a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800170c:	23e0      	movs	r3, #224	; 0xe0
 800170e:	005b      	lsls	r3, r3, #1
 8001710:	58d3      	ldr	r3, [r2, r3]
 8001712:	9305      	str	r3, [sp, #20]
    rdtr = canp->can->sFIFOMailBox[1].RDTR;
 8001714:	9b03      	ldr	r3, [sp, #12]
 8001716:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001718:	23e2      	movs	r3, #226	; 0xe2
 800171a:	005b      	lsls	r3, r3, #1
 800171c:	58d3      	ldr	r3, [r2, r3]
 800171e:	9304      	str	r3, [sp, #16]
    crfp->data32[0] = canp->can->sFIFOMailBox[1].RDLR;
 8001720:	9b03      	ldr	r3, [sp, #12]
 8001722:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001724:	23e4      	movs	r3, #228	; 0xe4
 8001726:	005b      	lsls	r3, r3, #1
 8001728:	58d2      	ldr	r2, [r2, r3]
 800172a:	9b01      	ldr	r3, [sp, #4]
 800172c:	611a      	str	r2, [r3, #16]
    crfp->data32[1] = canp->can->sFIFOMailBox[1].RDHR;
 800172e:	9b03      	ldr	r3, [sp, #12]
 8001730:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001732:	23e6      	movs	r3, #230	; 0xe6
 8001734:	005b      	lsls	r3, r3, #1
 8001736:	58d2      	ldr	r2, [r2, r3]
 8001738:	9b01      	ldr	r3, [sp, #4]
 800173a:	615a      	str	r2, [r3, #20]

    /* Releases the mailbox.*/
    canp->can->RF1R = CAN_RF1R_RFOM1;
 800173c:	9b03      	ldr	r3, [sp, #12]
 800173e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001740:	2220      	movs	r2, #32
 8001742:	611a      	str	r2, [r3, #16]

    /* If the queue is empty re-enables the interrupt in order to generate
       events again.*/
    if ((canp->can->RF1R & CAN_RF1R_FMP1) == 0)
 8001744:	9b03      	ldr	r3, [sp, #12]
 8001746:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001748:	691b      	ldr	r3, [r3, #16]
 800174a:	2203      	movs	r2, #3
 800174c:	4013      	ands	r3, r2
 800174e:	d10a      	bne.n	8001766 <can_lld_receive+0xf6>
      canp->can->IER |= CAN_IER_FMPIE1;
 8001750:	9b03      	ldr	r3, [sp, #12]
 8001752:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001754:	9a03      	ldr	r2, [sp, #12]
 8001756:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8001758:	6952      	ldr	r2, [r2, #20]
 800175a:	2110      	movs	r1, #16
 800175c:	430a      	orrs	r2, r1
 800175e:	615a      	str	r2, [r3, #20]
 8001760:	e002      	b.n	8001768 <can_lld_receive+0xf8>
      canp->can->IER |= CAN_IER_FMPIE0;
 8001762:	46c0      	nop			; (mov r8, r8)
 8001764:	e000      	b.n	8001768 <can_lld_receive+0xf8>
      canp->can->IER |= CAN_IER_FMPIE1;
 8001766:	46c0      	nop			; (mov r8, r8)
    /* Should not happen, do nothing.*/
    return;
  }

  /* Decodes the various fields in the RX frame.*/
  crfp->RTR = (rir & CAN_RI0R_RTR) >> 1;
 8001768:	9b05      	ldr	r3, [sp, #20]
 800176a:	085b      	lsrs	r3, r3, #1
 800176c:	b2db      	uxtb	r3, r3
 800176e:	1c1a      	adds	r2, r3, #0
 8001770:	2301      	movs	r3, #1
 8001772:	4013      	ands	r3, r2
 8001774:	b2da      	uxtb	r2, r3
 8001776:	9b01      	ldr	r3, [sp, #4]
 8001778:	2101      	movs	r1, #1
 800177a:	400a      	ands	r2, r1
 800177c:	0110      	lsls	r0, r2, #4
 800177e:	791a      	ldrb	r2, [r3, #4]
 8001780:	2110      	movs	r1, #16
 8001782:	438a      	bics	r2, r1
 8001784:	1c11      	adds	r1, r2, #0
 8001786:	1c02      	adds	r2, r0, #0
 8001788:	430a      	orrs	r2, r1
 800178a:	711a      	strb	r2, [r3, #4]
  crfp->IDE = (rir & CAN_RI0R_IDE) >> 2;
 800178c:	9b05      	ldr	r3, [sp, #20]
 800178e:	089b      	lsrs	r3, r3, #2
 8001790:	b2db      	uxtb	r3, r3
 8001792:	1c1a      	adds	r2, r3, #0
 8001794:	2301      	movs	r3, #1
 8001796:	4013      	ands	r3, r2
 8001798:	b2da      	uxtb	r2, r3
 800179a:	9b01      	ldr	r3, [sp, #4]
 800179c:	2101      	movs	r1, #1
 800179e:	400a      	ands	r2, r1
 80017a0:	0150      	lsls	r0, r2, #5
 80017a2:	791a      	ldrb	r2, [r3, #4]
 80017a4:	2120      	movs	r1, #32
 80017a6:	438a      	bics	r2, r1
 80017a8:	1c11      	adds	r1, r2, #0
 80017aa:	1c02      	adds	r2, r0, #0
 80017ac:	430a      	orrs	r2, r1
 80017ae:	711a      	strb	r2, [r3, #4]
  if (crfp->IDE)
 80017b0:	9b01      	ldr	r3, [sp, #4]
 80017b2:	791b      	ldrb	r3, [r3, #4]
 80017b4:	2220      	movs	r2, #32
 80017b6:	4013      	ands	r3, r2
 80017b8:	b2db      	uxtb	r3, r3
 80017ba:	2b00      	cmp	r3, #0
 80017bc:	d00c      	beq.n	80017d8 <can_lld_receive+0x168>
    crfp->EID = rir >> 3;
 80017be:	9b05      	ldr	r3, [sp, #20]
 80017c0:	08db      	lsrs	r3, r3, #3
 80017c2:	00db      	lsls	r3, r3, #3
 80017c4:	08da      	lsrs	r2, r3, #3
 80017c6:	9b01      	ldr	r3, [sp, #4]
 80017c8:	00d2      	lsls	r2, r2, #3
 80017ca:	08d2      	lsrs	r2, r2, #3
 80017cc:	6899      	ldr	r1, [r3, #8]
 80017ce:	0f49      	lsrs	r1, r1, #29
 80017d0:	0749      	lsls	r1, r1, #29
 80017d2:	430a      	orrs	r2, r1
 80017d4:	609a      	str	r2, [r3, #8]
 80017d6:	e00f      	b.n	80017f8 <can_lld_receive+0x188>
  else
    crfp->SID = rir >> 21;
 80017d8:	9b05      	ldr	r3, [sp, #20]
 80017da:	0d5b      	lsrs	r3, r3, #21
 80017dc:	b29b      	uxth	r3, r3
 80017de:	055b      	lsls	r3, r3, #21
 80017e0:	0d5b      	lsrs	r3, r3, #21
 80017e2:	b29a      	uxth	r2, r3
 80017e4:	9b01      	ldr	r3, [sp, #4]
 80017e6:	0552      	lsls	r2, r2, #21
 80017e8:	0d50      	lsrs	r0, r2, #21
 80017ea:	891a      	ldrh	r2, [r3, #8]
 80017ec:	0ad2      	lsrs	r2, r2, #11
 80017ee:	02d2      	lsls	r2, r2, #11
 80017f0:	1c11      	adds	r1, r2, #0
 80017f2:	1c02      	adds	r2, r0, #0
 80017f4:	430a      	orrs	r2, r1
 80017f6:	811a      	strh	r2, [r3, #8]
  crfp->DLC = rdtr & CAN_RDT0R_DLC;
 80017f8:	9b04      	ldr	r3, [sp, #16]
 80017fa:	b2db      	uxtb	r3, r3
 80017fc:	1c1a      	adds	r2, r3, #0
 80017fe:	230f      	movs	r3, #15
 8001800:	4013      	ands	r3, r2
 8001802:	b2da      	uxtb	r2, r3
 8001804:	9b01      	ldr	r3, [sp, #4]
 8001806:	210f      	movs	r1, #15
 8001808:	400a      	ands	r2, r1
 800180a:	0010      	movs	r0, r2
 800180c:	791a      	ldrb	r2, [r3, #4]
 800180e:	210f      	movs	r1, #15
 8001810:	438a      	bics	r2, r1
 8001812:	1c11      	adds	r1, r2, #0
 8001814:	1c02      	adds	r2, r0, #0
 8001816:	430a      	orrs	r2, r1
 8001818:	711a      	strb	r2, [r3, #4]
  crfp->FMI = (uint8_t)(rdtr >> 8);
 800181a:	9b04      	ldr	r3, [sp, #16]
 800181c:	0a1b      	lsrs	r3, r3, #8
 800181e:	b2da      	uxtb	r2, r3
 8001820:	9b01      	ldr	r3, [sp, #4]
 8001822:	701a      	strb	r2, [r3, #0]
  crfp->TIME = (uint16_t)(rdtr >> 16);
 8001824:	9b04      	ldr	r3, [sp, #16]
 8001826:	0c1b      	lsrs	r3, r3, #16
 8001828:	b29a      	uxth	r2, r3
 800182a:	9b01      	ldr	r3, [sp, #4]
 800182c:	805a      	strh	r2, [r3, #2]
}
 800182e:	b006      	add	sp, #24
 8001830:	4770      	bx	lr
 8001832:	46c0      	nop			; (mov r8, r8)
	...

08001840 <Vector64>:
/**
 * @brief   DMA1 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8001840:	b500      	push	{lr}
 8001842:	b085      	sub	sp, #20
 8001844:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 8001846:	9303      	str	r3, [sp, #12]

  dmaServeInterrupt(STM32_DMA1_STREAM1);
 8001848:	2300      	movs	r3, #0
 800184a:	9302      	str	r3, [sp, #8]
 800184c:	4b15      	ldr	r3, [pc, #84]	; (80018a4 <Vector64+0x64>)
 800184e:	681b      	ldr	r3, [r3, #0]
 8001850:	2200      	movs	r2, #0
 8001852:	40d3      	lsrs	r3, r2
 8001854:	220e      	movs	r2, #14
 8001856:	4013      	ands	r3, r2
 8001858:	9301      	str	r3, [sp, #4]
 800185a:	4b13      	ldr	r3, [pc, #76]	; (80018a8 <Vector64+0x68>)
 800185c:	681b      	ldr	r3, [r3, #0]
 800185e:	9a01      	ldr	r2, [sp, #4]
 8001860:	4013      	ands	r3, r2
 8001862:	d018      	beq.n	8001896 <Vector64+0x56>
 8001864:	4b0f      	ldr	r3, [pc, #60]	; (80018a4 <Vector64+0x64>)
 8001866:	2200      	movs	r2, #0
 8001868:	0011      	movs	r1, r2
 800186a:	9a01      	ldr	r2, [sp, #4]
 800186c:	408a      	lsls	r2, r1
 800186e:	605a      	str	r2, [r3, #4]
 8001870:	4b0e      	ldr	r3, [pc, #56]	; (80018ac <Vector64+0x6c>)
 8001872:	9a02      	ldr	r2, [sp, #8]
 8001874:	00d2      	lsls	r2, r2, #3
 8001876:	58d3      	ldr	r3, [r2, r3]
 8001878:	2b00      	cmp	r3, #0
 800187a:	d00c      	beq.n	8001896 <Vector64+0x56>
 800187c:	4b0b      	ldr	r3, [pc, #44]	; (80018ac <Vector64+0x6c>)
 800187e:	9a02      	ldr	r2, [sp, #8]
 8001880:	00d2      	lsls	r2, r2, #3
 8001882:	58d2      	ldr	r2, [r2, r3]
 8001884:	4909      	ldr	r1, [pc, #36]	; (80018ac <Vector64+0x6c>)
 8001886:	9b02      	ldr	r3, [sp, #8]
 8001888:	00db      	lsls	r3, r3, #3
 800188a:	18cb      	adds	r3, r1, r3
 800188c:	3304      	adds	r3, #4
 800188e:	681b      	ldr	r3, [r3, #0]
 8001890:	9901      	ldr	r1, [sp, #4]
 8001892:	0018      	movs	r0, r3
 8001894:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001896:	9b03      	ldr	r3, [sp, #12]
 8001898:	0018      	movs	r0, r3
 800189a:	f002 f809 	bl	80038b0 <_port_irq_epilogue>
}
 800189e:	b005      	add	sp, #20
 80018a0:	bd00      	pop	{pc}
 80018a2:	46c0      	nop			; (mov r8, r8)
 80018a4:	40020000 	.word	0x40020000
 80018a8:	40020008 	.word	0x40020008
 80018ac:	200005a8 	.word	0x200005a8

080018b0 <dmaInit>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 80018b0:	b082      	sub	sp, #8
  int i;

  dma_streams_mask = 0U;
 80018b2:	4b11      	ldr	r3, [pc, #68]	; (80018f8 <dmaInit+0x48>)
 80018b4:	2200      	movs	r2, #0
 80018b6:	601a      	str	r2, [r3, #0]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 80018b8:	2300      	movs	r3, #0
 80018ba:	9301      	str	r3, [sp, #4]
 80018bc:	e012      	b.n	80018e4 <dmaInit+0x34>
    _stm32_dma_streams[i].channel->CCR = 0U;
 80018be:	490f      	ldr	r1, [pc, #60]	; (80018fc <dmaInit+0x4c>)
 80018c0:	9a01      	ldr	r2, [sp, #4]
 80018c2:	0013      	movs	r3, r2
 80018c4:	009b      	lsls	r3, r3, #2
 80018c6:	189b      	adds	r3, r3, r2
 80018c8:	009b      	lsls	r3, r3, #2
 80018ca:	18cb      	adds	r3, r1, r3
 80018cc:	3304      	adds	r3, #4
 80018ce:	681b      	ldr	r3, [r3, #0]
 80018d0:	2200      	movs	r2, #0
 80018d2:	601a      	str	r2, [r3, #0]
    _stm32_dma_isr_redir[i].dma_func = NULL;
 80018d4:	4b0a      	ldr	r3, [pc, #40]	; (8001900 <dmaInit+0x50>)
 80018d6:	9a01      	ldr	r2, [sp, #4]
 80018d8:	00d2      	lsls	r2, r2, #3
 80018da:	2100      	movs	r1, #0
 80018dc:	50d1      	str	r1, [r2, r3]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 80018de:	9b01      	ldr	r3, [sp, #4]
 80018e0:	3301      	adds	r3, #1
 80018e2:	9301      	str	r3, [sp, #4]
 80018e4:	9b01      	ldr	r3, [sp, #4]
 80018e6:	2b04      	cmp	r3, #4
 80018e8:	dde9      	ble.n	80018be <dmaInit+0xe>
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 80018ea:	4b06      	ldr	r3, [pc, #24]	; (8001904 <dmaInit+0x54>)
 80018ec:	2201      	movs	r2, #1
 80018ee:	4252      	negs	r2, r2
 80018f0:	605a      	str	r2, [r3, #4]
#if STM32_DMA2_NUM_CHANNELS > 0
  DMA2->IFCR = 0xFFFFFFFFU;
#endif
}
 80018f2:	b002      	add	sp, #8
 80018f4:	4770      	bx	lr
 80018f6:	46c0      	nop			; (mov r8, r8)
 80018f8:	200005d0 	.word	0x200005d0
 80018fc:	08004ba0 	.word	0x08004ba0
 8001900:	200005a8 	.word	0x200005a8
 8001904:	40020000 	.word	0x40020000
	...

08001910 <ext_lld_init>:
/**
 * @brief   Low level EXT driver initialization.
 *
 * @notapi
 */
void ext_lld_init(void) {
 8001910:	b510      	push	{r4, lr}

  /* Driver initialization.*/
  extObjectInit(&EXTD1);
 8001912:	4b02      	ldr	r3, [pc, #8]	; (800191c <ext_lld_init+0xc>)
 8001914:	0018      	movs	r0, r3
 8001916:	f000 fb53 	bl	8001fc0 <extObjectInit>
}
 800191a:	bd10      	pop	{r4, pc}
 800191c:	200005d4 	.word	0x200005d4

08001920 <initgpio>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {
 8001920:	b082      	sub	sp, #8
 8001922:	9001      	str	r0, [sp, #4]
 8001924:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 8001926:	9b00      	ldr	r3, [sp, #0]
 8001928:	685a      	ldr	r2, [r3, #4]
 800192a:	9b01      	ldr	r3, [sp, #4]
 800192c:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800192e:	9b00      	ldr	r3, [sp, #0]
 8001930:	689a      	ldr	r2, [r3, #8]
 8001932:	9b01      	ldr	r3, [sp, #4]
 8001934:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8001936:	9b00      	ldr	r3, [sp, #0]
 8001938:	68da      	ldr	r2, [r3, #12]
 800193a:	9b01      	ldr	r3, [sp, #4]
 800193c:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 800193e:	9b00      	ldr	r3, [sp, #0]
 8001940:	691a      	ldr	r2, [r3, #16]
 8001942:	9b01      	ldr	r3, [sp, #4]
 8001944:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8001946:	9b00      	ldr	r3, [sp, #0]
 8001948:	695a      	ldr	r2, [r3, #20]
 800194a:	9b01      	ldr	r3, [sp, #4]
 800194c:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 800194e:	9b00      	ldr	r3, [sp, #0]
 8001950:	699a      	ldr	r2, [r3, #24]
 8001952:	9b01      	ldr	r3, [sp, #4]
 8001954:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001956:	9b00      	ldr	r3, [sp, #0]
 8001958:	681a      	ldr	r2, [r3, #0]
 800195a:	9b01      	ldr	r3, [sp, #4]
 800195c:	601a      	str	r2, [r3, #0]
}
 800195e:	b002      	add	sp, #8
 8001960:	4770      	bx	lr
 8001962:	46c0      	nop			; (mov r8, r8)
	...

08001970 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 8001970:	b500      	push	{lr}
 8001972:	b083      	sub	sp, #12
 8001974:	9001      	str	r0, [sp, #4]
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8001976:	4b12      	ldr	r3, [pc, #72]	; (80019c0 <_pal_lld_init+0x50>)
 8001978:	4a11      	ldr	r2, [pc, #68]	; (80019c0 <_pal_lld_init+0x50>)
 800197a:	6952      	ldr	r2, [r2, #20]
 800197c:	219c      	movs	r1, #156	; 0x9c
 800197e:	03c9      	lsls	r1, r1, #15
 8001980:	430a      	orrs	r2, r1
 8001982:	615a      	str	r2, [r3, #20]

  /*
   * Initial GPIO setup.
   */
#if STM32_HAS_GPIOA
  initgpio(GPIOA, &config->PAData);
 8001984:	9a01      	ldr	r2, [sp, #4]
 8001986:	2390      	movs	r3, #144	; 0x90
 8001988:	05db      	lsls	r3, r3, #23
 800198a:	0011      	movs	r1, r2
 800198c:	0018      	movs	r0, r3
 800198e:	f7ff ffc7 	bl	8001920 <initgpio>
#endif
#if STM32_HAS_GPIOB
  initgpio(GPIOB, &config->PBData);
 8001992:	9b01      	ldr	r3, [sp, #4]
 8001994:	331c      	adds	r3, #28
 8001996:	4a0b      	ldr	r2, [pc, #44]	; (80019c4 <_pal_lld_init+0x54>)
 8001998:	0019      	movs	r1, r3
 800199a:	0010      	movs	r0, r2
 800199c:	f7ff ffc0 	bl	8001920 <initgpio>
#endif
#if STM32_HAS_GPIOC
  initgpio(GPIOC, &config->PCData);
 80019a0:	9b01      	ldr	r3, [sp, #4]
 80019a2:	3338      	adds	r3, #56	; 0x38
 80019a4:	4a08      	ldr	r2, [pc, #32]	; (80019c8 <_pal_lld_init+0x58>)
 80019a6:	0019      	movs	r1, r3
 80019a8:	0010      	movs	r0, r2
 80019aa:	f7ff ffb9 	bl	8001920 <initgpio>
#endif
#if STM32_HAS_GPIOE
  initgpio(GPIOE, &config->PEData);
#endif
#if STM32_HAS_GPIOF
  initgpio(GPIOF, &config->PFData);
 80019ae:	9b01      	ldr	r3, [sp, #4]
 80019b0:	3354      	adds	r3, #84	; 0x54
 80019b2:	4a06      	ldr	r2, [pc, #24]	; (80019cc <_pal_lld_init+0x5c>)
 80019b4:	0019      	movs	r1, r3
 80019b6:	0010      	movs	r0, r2
 80019b8:	f7ff ffb2 	bl	8001920 <initgpio>
  initgpio(GPIOJ, &config->PJData);
#endif
#if STM32_HAS_GPIOK
  initgpio(GPIOK, &config->PKData);
#endif
}
 80019bc:	b003      	add	sp, #12
 80019be:	bd00      	pop	{pc}
 80019c0:	40021000 	.word	0x40021000
 80019c4:	48000400 	.word	0x48000400
 80019c8:	48000800 	.word	0x48000800
 80019cc:	48001400 	.word	0x48001400

080019d0 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 80019d0:	b08e      	sub	sp, #56	; 0x38
 80019d2:	9003      	str	r0, [sp, #12]
 80019d4:	9102      	str	r1, [sp, #8]
 80019d6:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 80019d8:	9b01      	ldr	r3, [sp, #4]
 80019da:	2203      	movs	r2, #3
 80019dc:	4013      	ands	r3, r2
 80019de:	930d      	str	r3, [sp, #52]	; 0x34
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 80019e0:	9b01      	ldr	r3, [sp, #4]
 80019e2:	089b      	lsrs	r3, r3, #2
 80019e4:	2201      	movs	r2, #1
 80019e6:	4013      	ands	r3, r2
 80019e8:	930c      	str	r3, [sp, #48]	; 0x30
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 80019ea:	9b01      	ldr	r3, [sp, #4]
 80019ec:	08db      	lsrs	r3, r3, #3
 80019ee:	2203      	movs	r2, #3
 80019f0:	4013      	ands	r3, r2
 80019f2:	930b      	str	r3, [sp, #44]	; 0x2c
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 80019f4:	9b01      	ldr	r3, [sp, #4]
 80019f6:	095b      	lsrs	r3, r3, #5
 80019f8:	2203      	movs	r2, #3
 80019fa:	4013      	ands	r3, r2
 80019fc:	930a      	str	r3, [sp, #40]	; 0x28
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 80019fe:	9b01      	ldr	r3, [sp, #4]
 8001a00:	09db      	lsrs	r3, r3, #7
 8001a02:	220f      	movs	r2, #15
 8001a04:	4013      	ands	r3, r2
 8001a06:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
 8001a08:	2300      	movs	r3, #0
 8001a0a:	9309      	str	r3, [sp, #36]	; 0x24
  while (true) {
    if ((mask & 1) != 0) {
 8001a0c:	9b02      	ldr	r3, [sp, #8]
 8001a0e:	2201      	movs	r2, #1
 8001a10:	4013      	ands	r3, r2
 8001a12:	d100      	bne.n	8001a16 <_pal_lld_setgroupmode+0x46>
 8001a14:	e079      	b.n	8001b0a <_pal_lld_setgroupmode+0x13a>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8001a16:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8001a18:	2207      	movs	r2, #7
 8001a1a:	4013      	ands	r3, r2
 8001a1c:	009b      	lsls	r3, r3, #2
 8001a1e:	9a08      	ldr	r2, [sp, #32]
 8001a20:	409a      	lsls	r2, r3
 8001a22:	0013      	movs	r3, r2
 8001a24:	9307      	str	r3, [sp, #28]
      m1 = 1 << bit;
 8001a26:	2201      	movs	r2, #1
 8001a28:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8001a2a:	409a      	lsls	r2, r3
 8001a2c:	0013      	movs	r3, r2
 8001a2e:	9306      	str	r3, [sp, #24]
      m2 = 3 << (bit * 2);
 8001a30:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8001a32:	005b      	lsls	r3, r3, #1
 8001a34:	2203      	movs	r2, #3
 8001a36:	409a      	lsls	r2, r3
 8001a38:	0013      	movs	r3, r2
 8001a3a:	9305      	str	r3, [sp, #20]
      m4 = 15 << ((bit & 7) * 4);
 8001a3c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8001a3e:	2207      	movs	r2, #7
 8001a40:	4013      	ands	r3, r2
 8001a42:	009b      	lsls	r3, r3, #2
 8001a44:	220f      	movs	r2, #15
 8001a46:	409a      	lsls	r2, r3
 8001a48:	0013      	movs	r3, r2
 8001a4a:	9304      	str	r3, [sp, #16]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8001a4c:	9b03      	ldr	r3, [sp, #12]
 8001a4e:	685b      	ldr	r3, [r3, #4]
 8001a50:	9a06      	ldr	r2, [sp, #24]
 8001a52:	43d2      	mvns	r2, r2
 8001a54:	401a      	ands	r2, r3
 8001a56:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8001a58:	431a      	orrs	r2, r3
 8001a5a:	9b03      	ldr	r3, [sp, #12]
 8001a5c:	605a      	str	r2, [r3, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8001a5e:	9b03      	ldr	r3, [sp, #12]
 8001a60:	689b      	ldr	r3, [r3, #8]
 8001a62:	9a05      	ldr	r2, [sp, #20]
 8001a64:	43d2      	mvns	r2, r2
 8001a66:	401a      	ands	r2, r3
 8001a68:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8001a6a:	431a      	orrs	r2, r3
 8001a6c:	9b03      	ldr	r3, [sp, #12]
 8001a6e:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8001a70:	9b03      	ldr	r3, [sp, #12]
 8001a72:	68db      	ldr	r3, [r3, #12]
 8001a74:	9a05      	ldr	r2, [sp, #20]
 8001a76:	43d2      	mvns	r2, r2
 8001a78:	401a      	ands	r2, r3
 8001a7a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8001a7c:	431a      	orrs	r2, r3
 8001a7e:	9b03      	ldr	r3, [sp, #12]
 8001a80:	60da      	str	r2, [r3, #12]
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 8001a82:	9b01      	ldr	r3, [sp, #4]
 8001a84:	2203      	movs	r2, #3
 8001a86:	4013      	ands	r3, r2
 8001a88:	2b02      	cmp	r3, #2
 8001a8a:	d11f      	bne.n	8001acc <_pal_lld_setgroupmode+0xfc>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 8001a8c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8001a8e:	2b07      	cmp	r3, #7
 8001a90:	d809      	bhi.n	8001aa6 <_pal_lld_setgroupmode+0xd6>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8001a92:	9b03      	ldr	r3, [sp, #12]
 8001a94:	6a1b      	ldr	r3, [r3, #32]
 8001a96:	9a04      	ldr	r2, [sp, #16]
 8001a98:	43d2      	mvns	r2, r2
 8001a9a:	401a      	ands	r2, r3
 8001a9c:	9b07      	ldr	r3, [sp, #28]
 8001a9e:	431a      	orrs	r2, r3
 8001aa0:	9b03      	ldr	r3, [sp, #12]
 8001aa2:	621a      	str	r2, [r3, #32]
 8001aa4:	e008      	b.n	8001ab8 <_pal_lld_setgroupmode+0xe8>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8001aa6:	9b03      	ldr	r3, [sp, #12]
 8001aa8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001aaa:	9a04      	ldr	r2, [sp, #16]
 8001aac:	43d2      	mvns	r2, r2
 8001aae:	401a      	ands	r2, r3
 8001ab0:	9b07      	ldr	r3, [sp, #28]
 8001ab2:	431a      	orrs	r2, r3
 8001ab4:	9b03      	ldr	r3, [sp, #12]
 8001ab6:	625a      	str	r2, [r3, #36]	; 0x24
        port->MODER   = (port->MODER & ~m2) | moder;
 8001ab8:	9b03      	ldr	r3, [sp, #12]
 8001aba:	681b      	ldr	r3, [r3, #0]
 8001abc:	9a05      	ldr	r2, [sp, #20]
 8001abe:	43d2      	mvns	r2, r2
 8001ac0:	401a      	ands	r2, r3
 8001ac2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8001ac4:	431a      	orrs	r2, r3
 8001ac6:	9b03      	ldr	r3, [sp, #12]
 8001ac8:	601a      	str	r2, [r3, #0]
 8001aca:	e01e      	b.n	8001b0a <_pal_lld_setgroupmode+0x13a>
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 8001acc:	9b03      	ldr	r3, [sp, #12]
 8001ace:	681b      	ldr	r3, [r3, #0]
 8001ad0:	9a05      	ldr	r2, [sp, #20]
 8001ad2:	43d2      	mvns	r2, r2
 8001ad4:	401a      	ands	r2, r3
 8001ad6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8001ad8:	431a      	orrs	r2, r3
 8001ada:	9b03      	ldr	r3, [sp, #12]
 8001adc:	601a      	str	r2, [r3, #0]
        if (bit < 8)
 8001ade:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8001ae0:	2b07      	cmp	r3, #7
 8001ae2:	d809      	bhi.n	8001af8 <_pal_lld_setgroupmode+0x128>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8001ae4:	9b03      	ldr	r3, [sp, #12]
 8001ae6:	6a1b      	ldr	r3, [r3, #32]
 8001ae8:	9a04      	ldr	r2, [sp, #16]
 8001aea:	43d2      	mvns	r2, r2
 8001aec:	401a      	ands	r2, r3
 8001aee:	9b07      	ldr	r3, [sp, #28]
 8001af0:	431a      	orrs	r2, r3
 8001af2:	9b03      	ldr	r3, [sp, #12]
 8001af4:	621a      	str	r2, [r3, #32]
 8001af6:	e008      	b.n	8001b0a <_pal_lld_setgroupmode+0x13a>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8001af8:	9b03      	ldr	r3, [sp, #12]
 8001afa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001afc:	9a04      	ldr	r2, [sp, #16]
 8001afe:	43d2      	mvns	r2, r2
 8001b00:	401a      	ands	r2, r3
 8001b02:	9b07      	ldr	r3, [sp, #28]
 8001b04:	431a      	orrs	r2, r3
 8001b06:	9b03      	ldr	r3, [sp, #12]
 8001b08:	625a      	str	r2, [r3, #36]	; 0x24
      }
    }
    mask >>= 1;
 8001b0a:	9b02      	ldr	r3, [sp, #8]
 8001b0c:	085b      	lsrs	r3, r3, #1
 8001b0e:	9302      	str	r3, [sp, #8]
    if (!mask)
 8001b10:	9b02      	ldr	r3, [sp, #8]
 8001b12:	2b00      	cmp	r3, #0
 8001b14:	d00f      	beq.n	8001b36 <_pal_lld_setgroupmode+0x166>
      return;
    otyper <<= 1;
 8001b16:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8001b18:	005b      	lsls	r3, r3, #1
 8001b1a:	930c      	str	r3, [sp, #48]	; 0x30
    ospeedr <<= 2;
 8001b1c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8001b1e:	009b      	lsls	r3, r3, #2
 8001b20:	930b      	str	r3, [sp, #44]	; 0x2c
    pupdr <<= 2;
 8001b22:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8001b24:	009b      	lsls	r3, r3, #2
 8001b26:	930a      	str	r3, [sp, #40]	; 0x28
    moder <<= 2;
 8001b28:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8001b2a:	009b      	lsls	r3, r3, #2
 8001b2c:	930d      	str	r3, [sp, #52]	; 0x34
    bit++;
 8001b2e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8001b30:	3301      	adds	r3, #1
 8001b32:	9309      	str	r3, [sp, #36]	; 0x24
 8001b34:	e76a      	b.n	8001a0c <_pal_lld_setgroupmode+0x3c>
  }
}
 8001b36:	b00e      	add	sp, #56	; 0x38
 8001b38:	4770      	bx	lr
 8001b3a:	46c0      	nop			; (mov r8, r8)
 8001b3c:	0000      	movs	r0, r0
	...

08001b40 <port_lock>:
  __ASM volatile ("cpsid i" : : : "memory");
 8001b40:	b672      	cpsid	i
}
 8001b42:	4770      	bx	lr
	...

08001b50 <port_unlock>:
  __ASM volatile ("cpsie i" : : : "memory");
 8001b50:	b662      	cpsie	i
}
 8001b52:	4770      	bx	lr
	...

08001b60 <port_lock_from_isr>:
static inline void port_lock_from_isr(void) {
 8001b60:	b510      	push	{r4, lr}
  port_lock();
 8001b62:	f7ff ffed 	bl	8001b40 <port_lock>
}
 8001b66:	bd10      	pop	{r4, pc}
	...

08001b70 <port_unlock_from_isr>:
static inline void port_unlock_from_isr(void) {
 8001b70:	b510      	push	{r4, lr}
  port_unlock();
 8001b72:	f7ff ffed 	bl	8001b50 <port_unlock>
}
 8001b76:	bd10      	pop	{r4, pc}
	...

08001b80 <chSysLockFromISR>:
static inline void chSysLockFromISR(void) {
 8001b80:	b510      	push	{r4, lr}
  port_lock_from_isr();
 8001b82:	f7ff ffed 	bl	8001b60 <port_lock_from_isr>
}
 8001b86:	bd10      	pop	{r4, pc}
	...

08001b90 <chSysUnlockFromISR>:
static inline void chSysUnlockFromISR(void) {
 8001b90:	b510      	push	{r4, lr}
  port_unlock_from_isr();
 8001b92:	f7ff ffed 	bl	8001b70 <port_unlock_from_isr>
}
 8001b96:	bd10      	pop	{r4, pc}
	...

08001ba0 <osalSysLockFromISR.lto_priv.41>:
static inline void osalSysLockFromISR(void) {
 8001ba0:	b510      	push	{r4, lr}
  chSysLockFromISR();
 8001ba2:	f7ff ffed 	bl	8001b80 <chSysLockFromISR>
}
 8001ba6:	bd10      	pop	{r4, pc}
	...

08001bb0 <osalSysUnlockFromISR.lto_priv.39>:
static inline void osalSysUnlockFromISR(void) {
 8001bb0:	b510      	push	{r4, lr}
  chSysUnlockFromISR();
 8001bb2:	f7ff ffed 	bl	8001b90 <chSysUnlockFromISR>
}
 8001bb6:	bd10      	pop	{r4, pc}
	...

08001bc0 <osalThreadResumeI>:
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 8001bc0:	b500      	push	{lr}
 8001bc2:	b083      	sub	sp, #12
 8001bc4:	9001      	str	r0, [sp, #4]
 8001bc6:	9100      	str	r1, [sp, #0]
  chThdResumeI(trp, msg);
 8001bc8:	9a00      	ldr	r2, [sp, #0]
 8001bca:	9b01      	ldr	r3, [sp, #4]
 8001bcc:	0011      	movs	r1, r2
 8001bce:	0018      	movs	r0, r3
 8001bd0:	f001 ff46 	bl	8003a60 <chThdResumeI>
}
 8001bd4:	b003      	add	sp, #12
 8001bd6:	bd00      	pop	{pc}
	...

08001be0 <i2c_lld_setup_rx_transfer.lto_priv.36>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_setup_rx_transfer(I2CDriver *i2cp) {
 8001be0:	b086      	sub	sp, #24
 8001be2:	9001      	str	r0, [sp, #4]
  I2C_TypeDef *dp = i2cp->i2c;
 8001be4:	9b01      	ldr	r3, [sp, #4]
 8001be6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001be8:	9303      	str	r3, [sp, #12]
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_rxbytes(i2cp);
 8001bea:	9b01      	ldr	r3, [sp, #4]
 8001bec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001bee:	685b      	ldr	r3, [r3, #4]
 8001bf0:	685b      	ldr	r3, [r3, #4]
 8001bf2:	9304      	str	r3, [sp, #16]
  if (n > 255U) {
 8001bf4:	9b04      	ldr	r3, [sp, #16]
 8001bf6:	2bff      	cmp	r3, #255	; 0xff
 8001bf8:	d905      	bls.n	8001c06 <i2c_lld_setup_rx_transfer.lto_priv.36+0x26>
    n = 255U;
 8001bfa:	23ff      	movs	r3, #255	; 0xff
 8001bfc:	9304      	str	r3, [sp, #16]
    reload = I2C_CR2_RELOAD;
 8001bfe:	2380      	movs	r3, #128	; 0x80
 8001c00:	045b      	lsls	r3, r3, #17
 8001c02:	9305      	str	r3, [sp, #20]
 8001c04:	e001      	b.n	8001c0a <i2c_lld_setup_rx_transfer.lto_priv.36+0x2a>
  }
  else {
    reload = 0U;
 8001c06:	2300      	movs	r3, #0
 8001c08:	9305      	str	r3, [sp, #20]
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8001c0a:	9b03      	ldr	r3, [sp, #12]
 8001c0c:	685b      	ldr	r3, [r3, #4]
 8001c0e:	4a09      	ldr	r2, [pc, #36]	; (8001c34 <i2c_lld_setup_rx_transfer.lto_priv.36+0x54>)
 8001c10:	401a      	ands	r2, r3
 8001c12:	9b01      	ldr	r3, [sp, #4]
 8001c14:	685b      	ldr	r3, [r3, #4]
 8001c16:	689b      	ldr	r3, [r3, #8]
 8001c18:	431a      	orrs	r2, r3
            I2C_CR2_RD_WRN | (n << 16U) | reload;
 8001c1a:	9b04      	ldr	r3, [sp, #16]
 8001c1c:	041b      	lsls	r3, r3, #16
 8001c1e:	431a      	orrs	r2, r3
 8001c20:	9b05      	ldr	r3, [sp, #20]
 8001c22:	4313      	orrs	r3, r2
 8001c24:	2280      	movs	r2, #128	; 0x80
 8001c26:	00d2      	lsls	r2, r2, #3
 8001c28:	431a      	orrs	r2, r3
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8001c2a:	9b03      	ldr	r3, [sp, #12]
 8001c2c:	605a      	str	r2, [r3, #4]
}
 8001c2e:	b006      	add	sp, #24
 8001c30:	4770      	bx	lr
 8001c32:	46c0      	nop			; (mov r8, r8)
 8001c34:	fe00ffff 	.word	0xfe00ffff
	...

08001c40 <i2c_lld_setup_tx_transfer.lto_priv.30>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_setup_tx_transfer(I2CDriver *i2cp) {
 8001c40:	b086      	sub	sp, #24
 8001c42:	9001      	str	r0, [sp, #4]
  I2C_TypeDef *dp = i2cp->i2c;
 8001c44:	9b01      	ldr	r3, [sp, #4]
 8001c46:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001c48:	9303      	str	r3, [sp, #12]
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_txbytes(i2cp);
 8001c4a:	9b01      	ldr	r3, [sp, #4]
 8001c4c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001c4e:	685b      	ldr	r3, [r3, #4]
 8001c50:	685b      	ldr	r3, [r3, #4]
 8001c52:	9304      	str	r3, [sp, #16]
  if (n > 255U) {
 8001c54:	9b04      	ldr	r3, [sp, #16]
 8001c56:	2bff      	cmp	r3, #255	; 0xff
 8001c58:	d905      	bls.n	8001c66 <i2c_lld_setup_tx_transfer.lto_priv.30+0x26>
    n = 255U;
 8001c5a:	23ff      	movs	r3, #255	; 0xff
 8001c5c:	9304      	str	r3, [sp, #16]
    reload = I2C_CR2_RELOAD;
 8001c5e:	2380      	movs	r3, #128	; 0x80
 8001c60:	045b      	lsls	r3, r3, #17
 8001c62:	9305      	str	r3, [sp, #20]
 8001c64:	e001      	b.n	8001c6a <i2c_lld_setup_tx_transfer.lto_priv.30+0x2a>
  }
  else {
    reload = 0U;
 8001c66:	2300      	movs	r3, #0
 8001c68:	9305      	str	r3, [sp, #20]
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8001c6a:	9b03      	ldr	r3, [sp, #12]
 8001c6c:	685b      	ldr	r3, [r3, #4]
 8001c6e:	4a07      	ldr	r2, [pc, #28]	; (8001c8c <i2c_lld_setup_tx_transfer.lto_priv.30+0x4c>)
 8001c70:	401a      	ands	r2, r3
 8001c72:	9b01      	ldr	r3, [sp, #4]
 8001c74:	685b      	ldr	r3, [r3, #4]
 8001c76:	689b      	ldr	r3, [r3, #8]
 8001c78:	431a      	orrs	r2, r3
            (n << 16U) | reload;
 8001c7a:	9b04      	ldr	r3, [sp, #16]
 8001c7c:	041b      	lsls	r3, r3, #16
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8001c7e:	431a      	orrs	r2, r3
            (n << 16U) | reload;
 8001c80:	9b05      	ldr	r3, [sp, #20]
 8001c82:	431a      	orrs	r2, r3
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8001c84:	9b03      	ldr	r3, [sp, #12]
 8001c86:	605a      	str	r2, [r3, #4]
}
 8001c88:	b006      	add	sp, #24
 8001c8a:	4770      	bx	lr
 8001c8c:	fe00ffff 	.word	0xfe00ffff

08001c90 <i2c_lld_serve_interrupt>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in] isr       content of the ISR register to be decoded
 *
 * @notapi
 */
static void i2c_lld_serve_interrupt(I2CDriver *i2cp, uint32_t isr) {
 8001c90:	b500      	push	{lr}
 8001c92:	b085      	sub	sp, #20
 8001c94:	9001      	str	r0, [sp, #4]
 8001c96:	9100      	str	r1, [sp, #0]
  I2C_TypeDef *dp = i2cp->i2c;
 8001c98:	9b01      	ldr	r3, [sp, #4]
 8001c9a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001c9c:	9303      	str	r3, [sp, #12]

  /* Special case of a received NACK, the transfer is aborted.*/
  if ((isr & I2C_ISR_NACKF) != 0U) {
 8001c9e:	9b00      	ldr	r3, [sp, #0]
 8001ca0:	2210      	movs	r2, #16
 8001ca2:	4013      	ands	r3, r2
 8001ca4:	d049      	beq.n	8001d3a <i2c_lld_serve_interrupt+0xaa>
#if STM32_I2C_USE_DMA == TRUE
    /* Stops the associated DMA streams.*/
    dmaStreamDisable(i2cp->dmatx);
 8001ca6:	9b01      	ldr	r3, [sp, #4]
 8001ca8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001caa:	685b      	ldr	r3, [r3, #4]
 8001cac:	9a01      	ldr	r2, [sp, #4]
 8001cae:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8001cb0:	6852      	ldr	r2, [r2, #4]
 8001cb2:	6812      	ldr	r2, [r2, #0]
 8001cb4:	210f      	movs	r1, #15
 8001cb6:	438a      	bics	r2, r1
 8001cb8:	601a      	str	r2, [r3, #0]
 8001cba:	9b01      	ldr	r3, [sp, #4]
 8001cbc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001cbe:	681b      	ldr	r3, [r3, #0]
 8001cc0:	9a01      	ldr	r2, [sp, #4]
 8001cc2:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8001cc4:	7c12      	ldrb	r2, [r2, #16]
 8001cc6:	0011      	movs	r1, r2
 8001cc8:	220e      	movs	r2, #14
 8001cca:	408a      	lsls	r2, r1
 8001ccc:	605a      	str	r2, [r3, #4]
    dmaStreamDisable(i2cp->dmarx);
 8001cce:	9b01      	ldr	r3, [sp, #4]
 8001cd0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001cd2:	685b      	ldr	r3, [r3, #4]
 8001cd4:	9a01      	ldr	r2, [sp, #4]
 8001cd6:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8001cd8:	6852      	ldr	r2, [r2, #4]
 8001cda:	6812      	ldr	r2, [r2, #0]
 8001cdc:	210f      	movs	r1, #15
 8001cde:	438a      	bics	r2, r1
 8001ce0:	601a      	str	r2, [r3, #0]
 8001ce2:	9b01      	ldr	r3, [sp, #4]
 8001ce4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001ce6:	681b      	ldr	r3, [r3, #0]
 8001ce8:	9a01      	ldr	r2, [sp, #4]
 8001cea:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8001cec:	7c12      	ldrb	r2, [r2, #16]
 8001cee:	0011      	movs	r1, r2
 8001cf0:	220e      	movs	r2, #14
 8001cf2:	408a      	lsls	r2, r1
 8001cf4:	605a      	str	r2, [r3, #4]
#endif

    /* Error flag.*/
    i2cp->errors |= I2C_ACK_FAILURE;
 8001cf6:	9b01      	ldr	r3, [sp, #4]
 8001cf8:	689b      	ldr	r3, [r3, #8]
 8001cfa:	2204      	movs	r2, #4
 8001cfc:	431a      	orrs	r2, r3
 8001cfe:	9b01      	ldr	r3, [sp, #4]
 8001d00:	609a      	str	r2, [r3, #8]

    /* Transaction finished sending the STOP.*/
    dp->CR2 |= I2C_CR2_STOP;
 8001d02:	9b03      	ldr	r3, [sp, #12]
 8001d04:	685b      	ldr	r3, [r3, #4]
 8001d06:	2280      	movs	r2, #128	; 0x80
 8001d08:	01d2      	lsls	r2, r2, #7
 8001d0a:	431a      	orrs	r2, r3
 8001d0c:	9b03      	ldr	r3, [sp, #12]
 8001d0e:	605a      	str	r2, [r3, #4]

    /* Make sure no more interrupts.*/
    dp->CR1 &= ~(I2C_CR1_TCIE | I2C_CR1_TXIE | I2C_CR1_RXIE);
 8001d10:	9b03      	ldr	r3, [sp, #12]
 8001d12:	681b      	ldr	r3, [r3, #0]
 8001d14:	2246      	movs	r2, #70	; 0x46
 8001d16:	4393      	bics	r3, r2
 8001d18:	001a      	movs	r2, r3
 8001d1a:	9b03      	ldr	r3, [sp, #12]
 8001d1c:	601a      	str	r2, [r3, #0]

    /* Errors are signaled to the upper layer.*/
    _i2c_wakeup_error_isr(i2cp);
 8001d1e:	f7ff ff3f 	bl	8001ba0 <osalSysLockFromISR.lto_priv.41>
 8001d22:	9b01      	ldr	r3, [sp, #4]
 8001d24:	331c      	adds	r3, #28
 8001d26:	001a      	movs	r2, r3
 8001d28:	2302      	movs	r3, #2
 8001d2a:	425b      	negs	r3, r3
 8001d2c:	0019      	movs	r1, r3
 8001d2e:	0010      	movs	r0, r2
 8001d30:	f7ff ff46 	bl	8001bc0 <osalThreadResumeI>
 8001d34:	f7ff ff3c 	bl	8001bb0 <osalSysUnlockFromISR.lto_priv.39>
 8001d38:	e078      	b.n	8001e2c <i2c_lld_serve_interrupt+0x19c>
    }
  }
#endif

  /* Partial transfer handling, restarting the transfer and returning.*/
  if ((isr & I2C_ISR_TCR) != 0U) {
 8001d3a:	9b00      	ldr	r3, [sp, #0]
 8001d3c:	2280      	movs	r2, #128	; 0x80
 8001d3e:	4013      	ands	r3, r2
 8001d40:	d00d      	beq.n	8001d5e <i2c_lld_serve_interrupt+0xce>
    if (i2cp->state == I2C_ACTIVE_TX) {
 8001d42:	9b01      	ldr	r3, [sp, #4]
 8001d44:	781b      	ldrb	r3, [r3, #0]
 8001d46:	2b03      	cmp	r3, #3
 8001d48:	d104      	bne.n	8001d54 <i2c_lld_serve_interrupt+0xc4>
      i2c_lld_setup_tx_transfer(i2cp);
 8001d4a:	9b01      	ldr	r3, [sp, #4]
 8001d4c:	0018      	movs	r0, r3
 8001d4e:	f7ff ff77 	bl	8001c40 <i2c_lld_setup_tx_transfer.lto_priv.30>
    }
    else {
      i2c_lld_setup_rx_transfer(i2cp);
 8001d52:	e06b      	b.n	8001e2c <i2c_lld_serve_interrupt+0x19c>
 8001d54:	9b01      	ldr	r3, [sp, #4]
 8001d56:	0018      	movs	r0, r3
 8001d58:	f7ff ff42 	bl	8001be0 <i2c_lld_setup_rx_transfer.lto_priv.36>
 8001d5c:	e066      	b.n	8001e2c <i2c_lld_serve_interrupt+0x19c>
    }
    return;
  }

  /* The following condition is true if a transfer phase has been completed.*/
  if ((isr & I2C_ISR_TC) != 0U) {
 8001d5e:	9b00      	ldr	r3, [sp, #0]
 8001d60:	2240      	movs	r2, #64	; 0x40
 8001d62:	4013      	ands	r3, r2
 8001d64:	d062      	beq.n	8001e2c <i2c_lld_serve_interrupt+0x19c>
    if (i2cp->state == I2C_ACTIVE_TX) {
 8001d66:	9b01      	ldr	r3, [sp, #4]
 8001d68:	781b      	ldrb	r3, [r3, #0]
 8001d6a:	2b03      	cmp	r3, #3
 8001d6c:	d132      	bne.n	8001dd4 <i2c_lld_serve_interrupt+0x144>
      /* End of the transmit phase.*/

#if STM32_I2C_USE_DMA == TRUE
      /* Disabling TX DMA channel.*/
      dmaStreamDisable(i2cp->dmatx);
 8001d6e:	9b01      	ldr	r3, [sp, #4]
 8001d70:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001d72:	685b      	ldr	r3, [r3, #4]
 8001d74:	9a01      	ldr	r2, [sp, #4]
 8001d76:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8001d78:	6852      	ldr	r2, [r2, #4]
 8001d7a:	6812      	ldr	r2, [r2, #0]
 8001d7c:	210f      	movs	r1, #15
 8001d7e:	438a      	bics	r2, r1
 8001d80:	601a      	str	r2, [r3, #0]
 8001d82:	9b01      	ldr	r3, [sp, #4]
 8001d84:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001d86:	681b      	ldr	r3, [r3, #0]
 8001d88:	9a01      	ldr	r2, [sp, #4]
 8001d8a:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8001d8c:	7c12      	ldrb	r2, [r2, #16]
 8001d8e:	0011      	movs	r1, r2
 8001d90:	220e      	movs	r2, #14
 8001d92:	408a      	lsls	r2, r1
 8001d94:	605a      	str	r2, [r3, #4]
#endif

      /* Starting receive phase if necessary.*/
      if (i2c_lld_get_rxbytes(i2cp) > 0U) {
 8001d96:	9b01      	ldr	r3, [sp, #4]
 8001d98:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001d9a:	685b      	ldr	r3, [r3, #4]
 8001d9c:	685b      	ldr	r3, [r3, #4]
 8001d9e:	2b00      	cmp	r3, #0
 8001da0:	d02c      	beq.n	8001dfc <i2c_lld_serve_interrupt+0x16c>
        /* Setting up the peripheral.*/
        i2c_lld_setup_rx_transfer(i2cp);
 8001da2:	9b01      	ldr	r3, [sp, #4]
 8001da4:	0018      	movs	r0, r3
 8001da6:	f7ff ff1b 	bl	8001be0 <i2c_lld_setup_rx_transfer.lto_priv.36>

#if STM32_I2C_USE_DMA == TRUE
        /* Enabling RX DMA.*/
        dmaStreamEnable(i2cp->dmarx);
 8001daa:	9b01      	ldr	r3, [sp, #4]
 8001dac:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001dae:	685b      	ldr	r3, [r3, #4]
 8001db0:	9a01      	ldr	r2, [sp, #4]
 8001db2:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8001db4:	6852      	ldr	r2, [r2, #4]
 8001db6:	6812      	ldr	r2, [r2, #0]
 8001db8:	2101      	movs	r1, #1
 8001dba:	430a      	orrs	r2, r1
 8001dbc:	601a      	str	r2, [r3, #0]
        /* RX interrupt enabled.*/
        dp->CR1 |= I2C_CR1_RXIE;
#endif

        /* Starts the read operation.*/
        dp->CR2 |= I2C_CR2_START;
 8001dbe:	9b03      	ldr	r3, [sp, #12]
 8001dc0:	685b      	ldr	r3, [r3, #4]
 8001dc2:	2280      	movs	r2, #128	; 0x80
 8001dc4:	0192      	lsls	r2, r2, #6
 8001dc6:	431a      	orrs	r2, r3
 8001dc8:	9b03      	ldr	r3, [sp, #12]
 8001dca:	605a      	str	r2, [r3, #4]

        /* State change.*/
        i2cp->state = I2C_ACTIVE_RX;
 8001dcc:	9b01      	ldr	r3, [sp, #4]
 8001dce:	2204      	movs	r2, #4
 8001dd0:	701a      	strb	r2, [r3, #0]
 8001dd2:	e02b      	b.n	8001e2c <i2c_lld_serve_interrupt+0x19c>
    }
    else {
      /* End of the receive phase.*/
#if STM32_I2C_USE_DMA == TRUE
      /* Disabling RX DMA channel.*/
      dmaStreamDisable(i2cp->dmarx);
 8001dd4:	9b01      	ldr	r3, [sp, #4]
 8001dd6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001dd8:	685b      	ldr	r3, [r3, #4]
 8001dda:	9a01      	ldr	r2, [sp, #4]
 8001ddc:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8001dde:	6852      	ldr	r2, [r2, #4]
 8001de0:	6812      	ldr	r2, [r2, #0]
 8001de2:	210f      	movs	r1, #15
 8001de4:	438a      	bics	r2, r1
 8001de6:	601a      	str	r2, [r3, #0]
 8001de8:	9b01      	ldr	r3, [sp, #4]
 8001dea:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001dec:	681b      	ldr	r3, [r3, #0]
 8001dee:	9a01      	ldr	r2, [sp, #4]
 8001df0:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8001df2:	7c12      	ldrb	r2, [r2, #16]
 8001df4:	0011      	movs	r1, r2
 8001df6:	220e      	movs	r2, #14
 8001df8:	408a      	lsls	r2, r1
 8001dfa:	605a      	str	r2, [r3, #4]
#endif
    }

    /* Transaction finished sending the STOP.*/
    dp->CR2 |= I2C_CR2_STOP;
 8001dfc:	9b03      	ldr	r3, [sp, #12]
 8001dfe:	685b      	ldr	r3, [r3, #4]
 8001e00:	2280      	movs	r2, #128	; 0x80
 8001e02:	01d2      	lsls	r2, r2, #7
 8001e04:	431a      	orrs	r2, r3
 8001e06:	9b03      	ldr	r3, [sp, #12]
 8001e08:	605a      	str	r2, [r3, #4]

    /* Make sure no more 'Transfer Complete' interrupts.*/
    dp->CR1 &= ~I2C_CR1_TCIE;
 8001e0a:	9b03      	ldr	r3, [sp, #12]
 8001e0c:	681b      	ldr	r3, [r3, #0]
 8001e0e:	2240      	movs	r2, #64	; 0x40
 8001e10:	4393      	bics	r3, r2
 8001e12:	001a      	movs	r2, r3
 8001e14:	9b03      	ldr	r3, [sp, #12]
 8001e16:	601a      	str	r2, [r3, #0]

    /* Normal transaction end.*/
    _i2c_wakeup_isr(i2cp);
 8001e18:	f7ff fec2 	bl	8001ba0 <osalSysLockFromISR.lto_priv.41>
 8001e1c:	9b01      	ldr	r3, [sp, #4]
 8001e1e:	331c      	adds	r3, #28
 8001e20:	2100      	movs	r1, #0
 8001e22:	0018      	movs	r0, r3
 8001e24:	f7ff fecc 	bl	8001bc0 <osalThreadResumeI>
 8001e28:	f7ff fec2 	bl	8001bb0 <osalSysUnlockFromISR.lto_priv.39>
  }
}
 8001e2c:	b005      	add	sp, #20
 8001e2e:	bd00      	pop	{pc}

08001e30 <i2c_lld_serve_error_interrupt>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in] isr       content of the ISR register to be decoded
 *
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint32_t isr) {
 8001e30:	b500      	push	{lr}
 8001e32:	b083      	sub	sp, #12
 8001e34:	9001      	str	r0, [sp, #4]
 8001e36:	9100      	str	r1, [sp, #0]

#if STM32_I2C_USE_DMA == TRUE
  /* Clears DMA interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8001e38:	9b01      	ldr	r3, [sp, #4]
 8001e3a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001e3c:	685b      	ldr	r3, [r3, #4]
 8001e3e:	9a01      	ldr	r2, [sp, #4]
 8001e40:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8001e42:	6852      	ldr	r2, [r2, #4]
 8001e44:	6812      	ldr	r2, [r2, #0]
 8001e46:	210f      	movs	r1, #15
 8001e48:	438a      	bics	r2, r1
 8001e4a:	601a      	str	r2, [r3, #0]
 8001e4c:	9b01      	ldr	r3, [sp, #4]
 8001e4e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001e50:	681b      	ldr	r3, [r3, #0]
 8001e52:	9a01      	ldr	r2, [sp, #4]
 8001e54:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8001e56:	7c12      	ldrb	r2, [r2, #16]
 8001e58:	0011      	movs	r1, r2
 8001e5a:	220e      	movs	r2, #14
 8001e5c:	408a      	lsls	r2, r1
 8001e5e:	605a      	str	r2, [r3, #4]
  dmaStreamDisable(i2cp->dmarx);
 8001e60:	9b01      	ldr	r3, [sp, #4]
 8001e62:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001e64:	685b      	ldr	r3, [r3, #4]
 8001e66:	9a01      	ldr	r2, [sp, #4]
 8001e68:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8001e6a:	6852      	ldr	r2, [r2, #4]
 8001e6c:	6812      	ldr	r2, [r2, #0]
 8001e6e:	210f      	movs	r1, #15
 8001e70:	438a      	bics	r2, r1
 8001e72:	601a      	str	r2, [r3, #0]
 8001e74:	9b01      	ldr	r3, [sp, #4]
 8001e76:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001e78:	681b      	ldr	r3, [r3, #0]
 8001e7a:	9a01      	ldr	r2, [sp, #4]
 8001e7c:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8001e7e:	7c12      	ldrb	r2, [r2, #16]
 8001e80:	0011      	movs	r1, r2
 8001e82:	220e      	movs	r2, #14
 8001e84:	408a      	lsls	r2, r1
 8001e86:	605a      	str	r2, [r3, #4]
#else
  /* Disabling RX and TX interrupts.*/
  i2cp->i2c->CR1 &= ~(I2C_CR1_TXIE | I2C_CR1_RXIE);
#endif

  if (isr & I2C_ISR_BERR)
 8001e88:	9a00      	ldr	r2, [sp, #0]
 8001e8a:	2380      	movs	r3, #128	; 0x80
 8001e8c:	005b      	lsls	r3, r3, #1
 8001e8e:	4013      	ands	r3, r2
 8001e90:	d005      	beq.n	8001e9e <i2c_lld_serve_error_interrupt+0x6e>
    i2cp->errors |= I2C_BUS_ERROR;
 8001e92:	9b01      	ldr	r3, [sp, #4]
 8001e94:	689b      	ldr	r3, [r3, #8]
 8001e96:	2201      	movs	r2, #1
 8001e98:	431a      	orrs	r2, r3
 8001e9a:	9b01      	ldr	r3, [sp, #4]
 8001e9c:	609a      	str	r2, [r3, #8]

  if (isr & I2C_ISR_ARLO)
 8001e9e:	9a00      	ldr	r2, [sp, #0]
 8001ea0:	2380      	movs	r3, #128	; 0x80
 8001ea2:	009b      	lsls	r3, r3, #2
 8001ea4:	4013      	ands	r3, r2
 8001ea6:	d005      	beq.n	8001eb4 <i2c_lld_serve_error_interrupt+0x84>
    i2cp->errors |= I2C_ARBITRATION_LOST;
 8001ea8:	9b01      	ldr	r3, [sp, #4]
 8001eaa:	689b      	ldr	r3, [r3, #8]
 8001eac:	2202      	movs	r2, #2
 8001eae:	431a      	orrs	r2, r3
 8001eb0:	9b01      	ldr	r3, [sp, #4]
 8001eb2:	609a      	str	r2, [r3, #8]

  if (isr & I2C_ISR_OVR)
 8001eb4:	9a00      	ldr	r2, [sp, #0]
 8001eb6:	2380      	movs	r3, #128	; 0x80
 8001eb8:	00db      	lsls	r3, r3, #3
 8001eba:	4013      	ands	r3, r2
 8001ebc:	d005      	beq.n	8001eca <i2c_lld_serve_error_interrupt+0x9a>
    i2cp->errors |= I2C_OVERRUN;
 8001ebe:	9b01      	ldr	r3, [sp, #4]
 8001ec0:	689b      	ldr	r3, [r3, #8]
 8001ec2:	2208      	movs	r2, #8
 8001ec4:	431a      	orrs	r2, r3
 8001ec6:	9b01      	ldr	r3, [sp, #4]
 8001ec8:	609a      	str	r2, [r3, #8]

  if (isr & I2C_ISR_TIMEOUT)
 8001eca:	9a00      	ldr	r2, [sp, #0]
 8001ecc:	2380      	movs	r3, #128	; 0x80
 8001ece:	015b      	lsls	r3, r3, #5
 8001ed0:	4013      	ands	r3, r2
 8001ed2:	d005      	beq.n	8001ee0 <i2c_lld_serve_error_interrupt+0xb0>
    i2cp->errors |= I2C_TIMEOUT;
 8001ed4:	9b01      	ldr	r3, [sp, #4]
 8001ed6:	689b      	ldr	r3, [r3, #8]
 8001ed8:	2220      	movs	r2, #32
 8001eda:	431a      	orrs	r2, r3
 8001edc:	9b01      	ldr	r3, [sp, #4]
 8001ede:	609a      	str	r2, [r3, #8]

  /* If some error has been identified then sends wakes the waiting thread.*/
  if (i2cp->errors != I2C_NO_ERROR)
 8001ee0:	9b01      	ldr	r3, [sp, #4]
 8001ee2:	689b      	ldr	r3, [r3, #8]
 8001ee4:	2b00      	cmp	r3, #0
 8001ee6:	d00c      	beq.n	8001f02 <i2c_lld_serve_error_interrupt+0xd2>
    _i2c_wakeup_error_isr(i2cp);
 8001ee8:	f7ff fe5a 	bl	8001ba0 <osalSysLockFromISR.lto_priv.41>
 8001eec:	9b01      	ldr	r3, [sp, #4]
 8001eee:	331c      	adds	r3, #28
 8001ef0:	001a      	movs	r2, r3
 8001ef2:	2302      	movs	r3, #2
 8001ef4:	425b      	negs	r3, r3
 8001ef6:	0019      	movs	r1, r3
 8001ef8:	0010      	movs	r0, r2
 8001efa:	f7ff fe61 	bl	8001bc0 <osalThreadResumeI>
 8001efe:	f7ff fe57 	bl	8001bb0 <osalSysUnlockFromISR.lto_priv.39>
}
 8001f02:	b003      	add	sp, #12
 8001f04:	bd00      	pop	{pc}
 8001f06:	46c0      	nop			; (mov r8, r8)
	...

08001f10 <Vector9C>:
/**
 * @brief   I2C1 event interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C1_GLOBAL_HANDLER) {
 8001f10:	b500      	push	{lr}
 8001f12:	b083      	sub	sp, #12
 8001f14:	4672      	mov	r2, lr
  uint32_t isr = I2CD1.i2c->ISR;
 8001f16:	4b12      	ldr	r3, [pc, #72]	; (8001f60 <Vector9C+0x50>)
 8001f18:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001f1a:	699b      	ldr	r3, [r3, #24]
 8001f1c:	9301      	str	r3, [sp, #4]

  OSAL_IRQ_PROLOGUE();
 8001f1e:	9200      	str	r2, [sp, #0]

  /* Clearing IRQ bits.*/
  I2CD1.i2c->ICR = isr;
 8001f20:	4b0f      	ldr	r3, [pc, #60]	; (8001f60 <Vector9C+0x50>)
 8001f22:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001f24:	9a01      	ldr	r2, [sp, #4]
 8001f26:	61da      	str	r2, [r3, #28]

  if (isr & I2C_ERROR_MASK)
 8001f28:	9a01      	ldr	r2, [sp, #4]
 8001f2a:	23fc      	movs	r3, #252	; 0xfc
 8001f2c:	019b      	lsls	r3, r3, #6
 8001f2e:	4013      	ands	r3, r2
 8001f30:	d006      	beq.n	8001f40 <Vector9C+0x30>
    i2c_lld_serve_error_interrupt(&I2CD1, isr);
 8001f32:	9a01      	ldr	r2, [sp, #4]
 8001f34:	4b0a      	ldr	r3, [pc, #40]	; (8001f60 <Vector9C+0x50>)
 8001f36:	0011      	movs	r1, r2
 8001f38:	0018      	movs	r0, r3
 8001f3a:	f7ff ff79 	bl	8001e30 <i2c_lld_serve_error_interrupt>
 8001f3e:	e009      	b.n	8001f54 <Vector9C+0x44>
  else if (isr & I2C_INT_MASK)
 8001f40:	9b01      	ldr	r3, [sp, #4]
 8001f42:	22fe      	movs	r2, #254	; 0xfe
 8001f44:	4013      	ands	r3, r2
 8001f46:	d005      	beq.n	8001f54 <Vector9C+0x44>
    i2c_lld_serve_interrupt(&I2CD1, isr);
 8001f48:	9a01      	ldr	r2, [sp, #4]
 8001f4a:	4b05      	ldr	r3, [pc, #20]	; (8001f60 <Vector9C+0x50>)
 8001f4c:	0011      	movs	r1, r2
 8001f4e:	0018      	movs	r0, r3
 8001f50:	f7ff fe9e 	bl	8001c90 <i2c_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 8001f54:	9b00      	ldr	r3, [sp, #0]
 8001f56:	0018      	movs	r0, r3
 8001f58:	f001 fcaa 	bl	80038b0 <_port_irq_epilogue>
}
 8001f5c:	b003      	add	sp, #12
 8001f5e:	bd00      	pop	{pc}
 8001f60:	200005dc 	.word	0x200005dc
	...

08001f70 <i2c_lld_init>:
/**
 * @brief   Low level I2C driver initialization.
 *
 * @notapi
 */
void i2c_lld_init(void) {
 8001f70:	b510      	push	{r4, lr}

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
 8001f72:	4b08      	ldr	r3, [pc, #32]	; (8001f94 <i2c_lld_init+0x24>)
 8001f74:	0018      	movs	r0, r3
 8001f76:	f000 f84b 	bl	8002010 <i2cObjectInit>
  I2CD1.thread = NULL;
 8001f7a:	4b06      	ldr	r3, [pc, #24]	; (8001f94 <i2c_lld_init+0x24>)
 8001f7c:	2200      	movs	r2, #0
 8001f7e:	61da      	str	r2, [r3, #28]
  I2CD1.i2c    = I2C1;
 8001f80:	4b04      	ldr	r3, [pc, #16]	; (8001f94 <i2c_lld_init+0x24>)
 8001f82:	4a05      	ldr	r2, [pc, #20]	; (8001f98 <i2c_lld_init+0x28>)
 8001f84:	631a      	str	r2, [r3, #48]	; 0x30
#if STM32_I2C_USE_DMA == TRUE
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
 8001f86:	4b03      	ldr	r3, [pc, #12]	; (8001f94 <i2c_lld_init+0x24>)
 8001f88:	4a04      	ldr	r2, [pc, #16]	; (8001f9c <i2c_lld_init+0x2c>)
 8001f8a:	629a      	str	r2, [r3, #40]	; 0x28
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
 8001f8c:	4b01      	ldr	r3, [pc, #4]	; (8001f94 <i2c_lld_init+0x24>)
 8001f8e:	4a04      	ldr	r2, [pc, #16]	; (8001fa0 <i2c_lld_init+0x30>)
 8001f90:	62da      	str	r2, [r3, #44]	; 0x2c
#if STM32_I2C_USE_DMA == TRUE
  I2CD4.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C4_RX_DMA_STREAM);
  I2CD4.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C4_TX_DMA_STREAM);
#endif
#endif /* STM32_I2C_USE_I2C4 */
}
 8001f92:	bd10      	pop	{r4, pc}
 8001f94:	200005dc 	.word	0x200005dc
 8001f98:	40005400 	.word	0x40005400
 8001f9c:	08004bc8 	.word	0x08004bc8
 8001fa0:	08004bb4 	.word	0x08004bb4
	...

08001fb0 <extInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void extInit(void) {
 8001fb0:	b510      	push	{r4, lr}

  ext_lld_init();
 8001fb2:	f7ff fcad 	bl	8001910 <ext_lld_init>
}
 8001fb6:	bd10      	pop	{r4, pc}
	...

08001fc0 <extObjectInit>:
 *
 * @param[out] extp     pointer to the @p EXTDriver object
 *
 * @init
 */
void extObjectInit(EXTDriver *extp) {
 8001fc0:	b082      	sub	sp, #8
 8001fc2:	9001      	str	r0, [sp, #4]

  extp->state  = EXT_STOP;
 8001fc4:	9b01      	ldr	r3, [sp, #4]
 8001fc6:	2201      	movs	r2, #1
 8001fc8:	701a      	strb	r2, [r3, #0]
  extp->config = NULL;
 8001fca:	9b01      	ldr	r3, [sp, #4]
 8001fcc:	2200      	movs	r2, #0
 8001fce:	605a      	str	r2, [r3, #4]
}
 8001fd0:	b002      	add	sp, #8
 8001fd2:	4770      	bx	lr
	...

08001fe0 <osalMutexObjectInit>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
 8001fe0:	b500      	push	{lr}
 8001fe2:	b083      	sub	sp, #12
 8001fe4:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 8001fe6:	9b01      	ldr	r3, [sp, #4]
 8001fe8:	0018      	movs	r0, r3
 8001fea:	f001 fdb1 	bl	8003b50 <chMtxObjectInit>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
 8001fee:	b003      	add	sp, #12
 8001ff0:	bd00      	pop	{pc}
 8001ff2:	46c0      	nop			; (mov r8, r8)
	...

08002000 <i2cInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void i2cInit(void) {
 8002000:	b510      	push	{r4, lr}

  i2c_lld_init();
 8002002:	f7ff ffb5 	bl	8001f70 <i2c_lld_init>
}
 8002006:	bd10      	pop	{r4, pc}
	...

08002010 <i2cObjectInit>:
 *
 * @param[out] i2cp     pointer to the @p I2CDriver object
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {
 8002010:	b500      	push	{lr}
 8002012:	b083      	sub	sp, #12
 8002014:	9001      	str	r0, [sp, #4]

  i2cp->state  = I2C_STOP;
 8002016:	9b01      	ldr	r3, [sp, #4]
 8002018:	2201      	movs	r2, #1
 800201a:	701a      	strb	r2, [r3, #0]
  i2cp->config = NULL;
 800201c:	9b01      	ldr	r3, [sp, #4]
 800201e:	2200      	movs	r2, #0
 8002020:	605a      	str	r2, [r3, #4]

#if I2C_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&i2cp->mutex);
 8002022:	9b01      	ldr	r3, [sp, #4]
 8002024:	330c      	adds	r3, #12
 8002026:	0018      	movs	r0, r3
 8002028:	f7ff ffda 	bl	8001fe0 <osalMutexObjectInit>
#endif

#if defined(I2C_DRIVER_EXT_INIT_HOOK)
  I2C_DRIVER_EXT_INIT_HOOK(i2cp);
#endif
}
 800202c:	b003      	add	sp, #12
 800202e:	bd00      	pop	{pc}

08002030 <port_lock.lto_priv.53>:
  __ASM volatile ("cpsid i" : : : "memory");
 8002030:	b672      	cpsid	i
}
 8002032:	4770      	bx	lr
	...

08002040 <port_unlock.lto_priv.49>:
  __ASM volatile ("cpsie i" : : : "memory");
 8002040:	b662      	cpsie	i
}
 8002042:	4770      	bx	lr
	...

08002050 <chSysLock.lto_priv.72>:
static inline void chSysLock(void) {
 8002050:	b510      	push	{r4, lr}
  port_lock();
 8002052:	f7ff ffed 	bl	8002030 <port_lock.lto_priv.53>
}
 8002056:	bd10      	pop	{r4, pc}
	...

08002060 <chSysUnlock.lto_priv.69>:
static inline void chSysUnlock(void) {
 8002060:	b510      	push	{r4, lr}
  port_unlock();
 8002062:	f7ff ffed 	bl	8002040 <port_unlock.lto_priv.49>
}
 8002066:	bd10      	pop	{r4, pc}
	...

08002070 <chEvtObjectInit>:
static inline void chEvtObjectInit(event_source_t *esp) {
 8002070:	b082      	sub	sp, #8
 8002072:	9001      	str	r0, [sp, #4]
  esp->next = (event_listener_t *)esp;
 8002074:	9b01      	ldr	r3, [sp, #4]
 8002076:	9a01      	ldr	r2, [sp, #4]
 8002078:	601a      	str	r2, [r3, #0]
}
 800207a:	b002      	add	sp, #8
 800207c:	4770      	bx	lr
 800207e:	46c0      	nop			; (mov r8, r8)

08002080 <osalSysLock.lto_priv.66>:
static inline void osalSysLock(void) {
 8002080:	b510      	push	{r4, lr}
  chSysLock();
 8002082:	f7ff ffe5 	bl	8002050 <chSysLock.lto_priv.72>
}
 8002086:	bd10      	pop	{r4, pc}
	...

08002090 <osalSysUnlock.lto_priv.62>:
static inline void osalSysUnlock(void) {
 8002090:	b510      	push	{r4, lr}
  chSysUnlock();
 8002092:	f7ff ffe5 	bl	8002060 <chSysUnlock.lto_priv.69>
}
 8002096:	bd10      	pop	{r4, pc}
	...

080020a0 <osalEventObjectInit>:
static inline void osalEventObjectInit(event_source_t *esp) {
 80020a0:	b500      	push	{lr}
 80020a2:	b083      	sub	sp, #12
 80020a4:	9001      	str	r0, [sp, #4]
  chEvtObjectInit(esp);
 80020a6:	9b01      	ldr	r3, [sp, #4]
 80020a8:	0018      	movs	r0, r3
 80020aa:	f7ff ffe1 	bl	8002070 <chEvtObjectInit>
}
 80020ae:	b003      	add	sp, #12
 80020b0:	bd00      	pop	{pc}
 80020b2:	46c0      	nop			; (mov r8, r8)
	...

080020c0 <osalEventBroadcastFlagsI.lto_priv.56>:
                                            eventflags_t flags) {
 80020c0:	b500      	push	{lr}
 80020c2:	b083      	sub	sp, #12
 80020c4:	9001      	str	r0, [sp, #4]
 80020c6:	9100      	str	r1, [sp, #0]
  chEvtBroadcastFlagsI(esp, flags);
 80020c8:	9a00      	ldr	r2, [sp, #0]
 80020ca:	9b01      	ldr	r3, [sp, #4]
 80020cc:	0011      	movs	r1, r2
 80020ce:	0018      	movs	r0, r3
 80020d0:	f001 fdb6 	bl	8003c40 <chEvtBroadcastFlagsI>
}
 80020d4:	b003      	add	sp, #12
 80020d6:	bd00      	pop	{pc}
	...

080020e0 <_write.lto_priv.22>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t _write(void *ip, const uint8_t *bp, size_t n) {
 80020e0:	b500      	push	{lr}
 80020e2:	b085      	sub	sp, #20
 80020e4:	9003      	str	r0, [sp, #12]
 80020e6:	9102      	str	r1, [sp, #8]
 80020e8:	9201      	str	r2, [sp, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 80020ea:	9b03      	ldr	r3, [sp, #12]
 80020ec:	3330      	adds	r3, #48	; 0x30
 80020ee:	0018      	movs	r0, r3
 80020f0:	2301      	movs	r3, #1
 80020f2:	425b      	negs	r3, r3
 80020f4:	9a01      	ldr	r2, [sp, #4]
 80020f6:	9902      	ldr	r1, [sp, #8]
 80020f8:	f001 f912 	bl	8003320 <oqWriteTimeout>
 80020fc:	0003      	movs	r3, r0
                        n, TIME_INFINITE);
}
 80020fe:	0018      	movs	r0, r3
 8002100:	b005      	add	sp, #20
 8002102:	bd00      	pop	{pc}
	...

08002110 <_read.lto_priv.23>:

static size_t _read(void *ip, uint8_t *bp, size_t n) {
 8002110:	b500      	push	{lr}
 8002112:	b085      	sub	sp, #20
 8002114:	9003      	str	r0, [sp, #12]
 8002116:	9102      	str	r1, [sp, #8]
 8002118:	9201      	str	r2, [sp, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 800211a:	9b03      	ldr	r3, [sp, #12]
 800211c:	330c      	adds	r3, #12
 800211e:	0018      	movs	r0, r3
 8002120:	2301      	movs	r3, #1
 8002122:	425b      	negs	r3, r3
 8002124:	9a01      	ldr	r2, [sp, #4]
 8002126:	9902      	ldr	r1, [sp, #8]
 8002128:	f000 ffd2 	bl	80030d0 <iqReadTimeout>
 800212c:	0003      	movs	r3, r0
                       n, TIME_INFINITE);
}
 800212e:	0018      	movs	r0, r3
 8002130:	b005      	add	sp, #20
 8002132:	bd00      	pop	{pc}
	...

08002140 <_put.lto_priv.4>:

static msg_t _put(void *ip, uint8_t b) {
 8002140:	b500      	push	{lr}
 8002142:	b083      	sub	sp, #12
 8002144:	9001      	str	r0, [sp, #4]
 8002146:	000a      	movs	r2, r1
 8002148:	466b      	mov	r3, sp
 800214a:	3303      	adds	r3, #3
 800214c:	701a      	strb	r2, [r3, #0]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 800214e:	9b01      	ldr	r3, [sp, #4]
 8002150:	3330      	adds	r3, #48	; 0x30
 8002152:	0018      	movs	r0, r3
 8002154:	2301      	movs	r3, #1
 8002156:	425a      	negs	r2, r3
 8002158:	466b      	mov	r3, sp
 800215a:	3303      	adds	r3, #3
 800215c:	781b      	ldrb	r3, [r3, #0]
 800215e:	0019      	movs	r1, r3
 8002160:	f001 f856 	bl	8003210 <oqPutTimeout>
 8002164:	0003      	movs	r3, r0
}
 8002166:	0018      	movs	r0, r3
 8002168:	b003      	add	sp, #12
 800216a:	bd00      	pop	{pc}
 800216c:	0000      	movs	r0, r0
	...

08002170 <_get.lto_priv.2>:

static msg_t _get(void *ip) {
 8002170:	b500      	push	{lr}
 8002172:	b083      	sub	sp, #12
 8002174:	9001      	str	r0, [sp, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8002176:	9b01      	ldr	r3, [sp, #4]
 8002178:	330c      	adds	r3, #12
 800217a:	001a      	movs	r2, r3
 800217c:	2301      	movs	r3, #1
 800217e:	425b      	negs	r3, r3
 8002180:	0019      	movs	r1, r3
 8002182:	0010      	movs	r0, r2
 8002184:	f000 ff5c 	bl	8003040 <iqGetTimeout>
 8002188:	0003      	movs	r3, r0
}
 800218a:	0018      	movs	r0, r3
 800218c:	b003      	add	sp, #12
 800218e:	bd00      	pop	{pc}

08002190 <_putt.lto_priv.24>:

static msg_t _putt(void *ip, uint8_t b, systime_t timeout) {
 8002190:	b500      	push	{lr}
 8002192:	b085      	sub	sp, #20
 8002194:	9003      	str	r0, [sp, #12]
 8002196:	9201      	str	r2, [sp, #4]
 8002198:	230b      	movs	r3, #11
 800219a:	446b      	add	r3, sp
 800219c:	1c0a      	adds	r2, r1, #0
 800219e:	701a      	strb	r2, [r3, #0]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 80021a0:	9b03      	ldr	r3, [sp, #12]
 80021a2:	3330      	adds	r3, #48	; 0x30
 80021a4:	0018      	movs	r0, r3
 80021a6:	9a01      	ldr	r2, [sp, #4]
 80021a8:	230b      	movs	r3, #11
 80021aa:	446b      	add	r3, sp
 80021ac:	781b      	ldrb	r3, [r3, #0]
 80021ae:	0019      	movs	r1, r3
 80021b0:	f001 f82e 	bl	8003210 <oqPutTimeout>
 80021b4:	0003      	movs	r3, r0
}
 80021b6:	0018      	movs	r0, r3
 80021b8:	b005      	add	sp, #20
 80021ba:	bd00      	pop	{pc}
 80021bc:	0000      	movs	r0, r0
	...

080021c0 <_gett.lto_priv.25>:

static msg_t _gett(void *ip, systime_t timeout) {
 80021c0:	b500      	push	{lr}
 80021c2:	b083      	sub	sp, #12
 80021c4:	9001      	str	r0, [sp, #4]
 80021c6:	9100      	str	r1, [sp, #0]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 80021c8:	9b01      	ldr	r3, [sp, #4]
 80021ca:	330c      	adds	r3, #12
 80021cc:	9a00      	ldr	r2, [sp, #0]
 80021ce:	0011      	movs	r1, r2
 80021d0:	0018      	movs	r0, r3
 80021d2:	f000 ff35 	bl	8003040 <iqGetTimeout>
 80021d6:	0003      	movs	r3, r0
}
 80021d8:	0018      	movs	r0, r3
 80021da:	b003      	add	sp, #12
 80021dc:	bd00      	pop	{pc}
 80021de:	46c0      	nop			; (mov r8, r8)

080021e0 <_writet.lto_priv.26>:

static size_t _writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 80021e0:	b500      	push	{lr}
 80021e2:	b085      	sub	sp, #20
 80021e4:	9003      	str	r0, [sp, #12]
 80021e6:	9102      	str	r1, [sp, #8]
 80021e8:	9201      	str	r2, [sp, #4]
 80021ea:	9300      	str	r3, [sp, #0]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 80021ec:	9b03      	ldr	r3, [sp, #12]
 80021ee:	3330      	adds	r3, #48	; 0x30
 80021f0:	0018      	movs	r0, r3
 80021f2:	9b00      	ldr	r3, [sp, #0]
 80021f4:	9a01      	ldr	r2, [sp, #4]
 80021f6:	9902      	ldr	r1, [sp, #8]
 80021f8:	f001 f892 	bl	8003320 <oqWriteTimeout>
 80021fc:	0003      	movs	r3, r0
}
 80021fe:	0018      	movs	r0, r3
 8002200:	b005      	add	sp, #20
 8002202:	bd00      	pop	{pc}
	...

08002210 <_readt.lto_priv.27>:

static size_t _readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 8002210:	b500      	push	{lr}
 8002212:	b085      	sub	sp, #20
 8002214:	9003      	str	r0, [sp, #12]
 8002216:	9102      	str	r1, [sp, #8]
 8002218:	9201      	str	r2, [sp, #4]
 800221a:	9300      	str	r3, [sp, #0]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 800221c:	9b03      	ldr	r3, [sp, #12]
 800221e:	330c      	adds	r3, #12
 8002220:	0018      	movs	r0, r3
 8002222:	9b00      	ldr	r3, [sp, #0]
 8002224:	9a01      	ldr	r2, [sp, #4]
 8002226:	9902      	ldr	r1, [sp, #8]
 8002228:	f000 ff52 	bl	80030d0 <iqReadTimeout>
 800222c:	0003      	movs	r3, r0
}
 800222e:	0018      	movs	r0, r3
 8002230:	b005      	add	sp, #20
 8002232:	bd00      	pop	{pc}
	...

08002240 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
 8002240:	b510      	push	{r4, lr}

  sd_lld_init();
 8002242:	f7fe facd 	bl	80007e0 <sd_lld_init>
}
 8002246:	bd10      	pop	{r4, pc}
	...

08002250 <sdObjectInit>:
  sdp->state = SD_STOP;
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
}
#else
void sdObjectInit(SerialDriver *sdp) {
 8002250:	b500      	push	{lr}
 8002252:	b083      	sub	sp, #12
 8002254:	9001      	str	r0, [sp, #4]

  sdp->vmt = &vmt;
 8002256:	9b01      	ldr	r3, [sp, #4]
 8002258:	4a05      	ldr	r2, [pc, #20]	; (8002270 <sdObjectInit+0x20>)
 800225a:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdp->event);
 800225c:	9b01      	ldr	r3, [sp, #4]
 800225e:	3304      	adds	r3, #4
 8002260:	0018      	movs	r0, r3
 8002262:	f7ff ff1d 	bl	80020a0 <osalEventObjectInit>
  sdp->state = SD_STOP;
 8002266:	9b01      	ldr	r3, [sp, #4]
 8002268:	2201      	movs	r2, #1
 800226a:	721a      	strb	r2, [r3, #8]
}
 800226c:	b003      	add	sp, #12
 800226e:	bd00      	pop	{pc}
 8002270:	08004b80 	.word	0x08004b80
	...

08002280 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 8002280:	b500      	push	{lr}
 8002282:	b083      	sub	sp, #12
 8002284:	9001      	str	r0, [sp, #4]
 8002286:	9100      	str	r1, [sp, #0]

  osalDbgCheck(sdp != NULL);

  osalSysLock();
 8002288:	f7ff fefa 	bl	8002080 <osalSysLock.lto_priv.66>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
 800228c:	9a00      	ldr	r2, [sp, #0]
 800228e:	9b01      	ldr	r3, [sp, #4]
 8002290:	0011      	movs	r1, r2
 8002292:	0018      	movs	r0, r3
 8002294:	f7fe fadc 	bl	8000850 <sd_lld_start>
  sdp->state = SD_READY;
 8002298:	9b01      	ldr	r3, [sp, #4]
 800229a:	2202      	movs	r2, #2
 800229c:	721a      	strb	r2, [r3, #8]
  osalSysUnlock();
 800229e:	f7ff fef7 	bl	8002090 <osalSysUnlock.lto_priv.62>
}
 80022a2:	b003      	add	sp, #12
 80022a4:	bd00      	pop	{pc}
 80022a6:	46c0      	nop			; (mov r8, r8)
	...

080022b0 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 80022b0:	b500      	push	{lr}
 80022b2:	b083      	sub	sp, #12
 80022b4:	9001      	str	r0, [sp, #4]
 80022b6:	000a      	movs	r2, r1
 80022b8:	466b      	mov	r3, sp
 80022ba:	3303      	adds	r3, #3
 80022bc:	701a      	strb	r2, [r3, #0]

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 80022be:	9b01      	ldr	r3, [sp, #4]
 80022c0:	695b      	ldr	r3, [r3, #20]
 80022c2:	2b00      	cmp	r3, #0
 80022c4:	d105      	bne.n	80022d2 <sdIncomingDataI+0x22>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 80022c6:	9b01      	ldr	r3, [sp, #4]
 80022c8:	3304      	adds	r3, #4
 80022ca:	2104      	movs	r1, #4
 80022cc:	0018      	movs	r0, r3
 80022ce:	f7ff fef7 	bl	80020c0 <osalEventBroadcastFlagsI.lto_priv.56>
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
 80022d2:	9b01      	ldr	r3, [sp, #4]
 80022d4:	330c      	adds	r3, #12
 80022d6:	001a      	movs	r2, r3
 80022d8:	466b      	mov	r3, sp
 80022da:	3303      	adds	r3, #3
 80022dc:	781b      	ldrb	r3, [r3, #0]
 80022de:	0019      	movs	r1, r3
 80022e0:	0010      	movs	r0, r2
 80022e2:	f000 fe6d 	bl	8002fc0 <iqPutI>
 80022e6:	1e03      	subs	r3, r0, #0
 80022e8:	da07      	bge.n	80022fa <sdIncomingDataI+0x4a>
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
 80022ea:	9b01      	ldr	r3, [sp, #4]
 80022ec:	1d1a      	adds	r2, r3, #4
 80022ee:	2380      	movs	r3, #128	; 0x80
 80022f0:	00db      	lsls	r3, r3, #3
 80022f2:	0019      	movs	r1, r3
 80022f4:	0010      	movs	r0, r2
 80022f6:	f7ff fee3 	bl	80020c0 <osalEventBroadcastFlagsI.lto_priv.56>
}
 80022fa:	b003      	add	sp, #12
 80022fc:	bd00      	pop	{pc}
 80022fe:	46c0      	nop			; (mov r8, r8)

08002300 <st_lld_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {
 8002300:	b082      	sub	sp, #8
 8002302:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8002304:	2380      	movs	r3, #128	; 0x80
 8002306:	05db      	lsls	r3, r3, #23
 8002308:	9a01      	ldr	r2, [sp, #4]
 800230a:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 800230c:	2380      	movs	r3, #128	; 0x80
 800230e:	05db      	lsls	r3, r3, #23
 8002310:	2200      	movs	r2, #0
 8002312:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8002314:	2380      	movs	r3, #128	; 0x80
 8002316:	05db      	lsls	r3, r3, #23
 8002318:	2202      	movs	r2, #2
 800231a:	60da      	str	r2, [r3, #12]
}
 800231c:	b002      	add	sp, #8
 800231e:	4770      	bx	lr

08002320 <st_lld_stop_alarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8002320:	2380      	movs	r3, #128	; 0x80
 8002322:	05db      	lsls	r3, r3, #23
 8002324:	2200      	movs	r2, #0
 8002326:	60da      	str	r2, [r3, #12]
}
 8002328:	4770      	bx	lr
 800232a:	46c0      	nop			; (mov r8, r8)
 800232c:	0000      	movs	r0, r0
	...

08002330 <st_lld_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {
 8002330:	b082      	sub	sp, #8
 8002332:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8002334:	2380      	movs	r3, #128	; 0x80
 8002336:	05db      	lsls	r3, r3, #23
 8002338:	9a01      	ldr	r2, [sp, #4]
 800233a:	635a      	str	r2, [r3, #52]	; 0x34
}
 800233c:	b002      	add	sp, #8
 800233e:	4770      	bx	lr

08002340 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 8002340:	b510      	push	{r4, lr}

  st_lld_init();
 8002342:	f7fe f875 	bl	8000430 <st_lld_init>
}
 8002346:	bd10      	pop	{r4, pc}
	...

08002350 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 8002350:	b500      	push	{lr}
 8002352:	b083      	sub	sp, #12
 8002354:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");

  st_lld_start_alarm(abstime);
 8002356:	9b01      	ldr	r3, [sp, #4]
 8002358:	0018      	movs	r0, r3
 800235a:	f7ff ffd1 	bl	8002300 <st_lld_start_alarm>
}
 800235e:	b003      	add	sp, #12
 8002360:	bd00      	pop	{pc}
 8002362:	46c0      	nop			; (mov r8, r8)
	...

08002370 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 8002370:	b510      	push	{r4, lr}

  st_lld_stop_alarm();
 8002372:	f7ff ffd5 	bl	8002320 <st_lld_stop_alarm>
}
 8002376:	bd10      	pop	{r4, pc}
	...

08002380 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8002380:	b500      	push	{lr}
 8002382:	b083      	sub	sp, #12
 8002384:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_set_alarm(abstime);
 8002386:	9b01      	ldr	r3, [sp, #4]
 8002388:	0018      	movs	r0, r3
 800238a:	f7ff ffd1 	bl	8002330 <st_lld_set_alarm>
}
 800238e:	b003      	add	sp, #12
 8002390:	bd00      	pop	{pc}
 8002392:	46c0      	nop			; (mov r8, r8)
	...

080023a0 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 80023a0:	b530      	push	{r4, r5, lr}
 80023a2:	b083      	sub	sp, #12
 80023a4:	9001      	str	r0, [sp, #4]
 80023a6:	9100      	str	r1, [sp, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 80023a8:	4c1b      	ldr	r4, [pc, #108]	; (8002418 <nvicEnableVector+0x78>)
 80023aa:	9b01      	ldr	r3, [sp, #4]
 80023ac:	089b      	lsrs	r3, r3, #2
 80023ae:	491a      	ldr	r1, [pc, #104]	; (8002418 <nvicEnableVector+0x78>)
 80023b0:	9a01      	ldr	r2, [sp, #4]
 80023b2:	0892      	lsrs	r2, r2, #2
 80023b4:	32c0      	adds	r2, #192	; 0xc0
 80023b6:	0092      	lsls	r2, r2, #2
 80023b8:	5852      	ldr	r2, [r2, r1]
 80023ba:	9901      	ldr	r1, [sp, #4]
 80023bc:	2003      	movs	r0, #3
 80023be:	4001      	ands	r1, r0
 80023c0:	00c9      	lsls	r1, r1, #3
 80023c2:	20ff      	movs	r0, #255	; 0xff
 80023c4:	4088      	lsls	r0, r1
 80023c6:	0001      	movs	r1, r0
 80023c8:	43c9      	mvns	r1, r1
 80023ca:	4011      	ands	r1, r2
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
 80023cc:	9a00      	ldr	r2, [sp, #0]
 80023ce:	0190      	lsls	r0, r2, #6
 80023d0:	9a01      	ldr	r2, [sp, #4]
 80023d2:	2503      	movs	r5, #3
 80023d4:	402a      	ands	r2, r5
 80023d6:	00d2      	lsls	r2, r2, #3
 80023d8:	4090      	lsls	r0, r2
 80023da:	0002      	movs	r2, r0
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 80023dc:	430a      	orrs	r2, r1
 80023de:	33c0      	adds	r3, #192	; 0xc0
 80023e0:	009b      	lsls	r3, r3, #2
 80023e2:	511a      	str	r2, [r3, r4]
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80023e4:	490c      	ldr	r1, [pc, #48]	; (8002418 <nvicEnableVector+0x78>)
 80023e6:	9b01      	ldr	r3, [sp, #4]
 80023e8:	095b      	lsrs	r3, r3, #5
 80023ea:	9a01      	ldr	r2, [sp, #4]
 80023ec:	201f      	movs	r0, #31
 80023ee:	4002      	ands	r2, r0
 80023f0:	2001      	movs	r0, #1
 80023f2:	4090      	lsls	r0, r2
 80023f4:	0002      	movs	r2, r0
 80023f6:	3360      	adds	r3, #96	; 0x60
 80023f8:	009b      	lsls	r3, r3, #2
 80023fa:	505a      	str	r2, [r3, r1]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80023fc:	4906      	ldr	r1, [pc, #24]	; (8002418 <nvicEnableVector+0x78>)
 80023fe:	9b01      	ldr	r3, [sp, #4]
 8002400:	095b      	lsrs	r3, r3, #5
 8002402:	9a01      	ldr	r2, [sp, #4]
 8002404:	201f      	movs	r0, #31
 8002406:	4002      	ands	r2, r0
 8002408:	2001      	movs	r0, #1
 800240a:	4090      	lsls	r0, r2
 800240c:	0002      	movs	r2, r0
 800240e:	009b      	lsls	r3, r3, #2
 8002410:	505a      	str	r2, [r3, r1]
}
 8002412:	b003      	add	sp, #12
 8002414:	bd30      	pop	{r4, r5, pc}
 8002416:	46c0      	nop			; (mov r8, r8)
 8002418:	e000e100 	.word	0xe000e100
 800241c:	00000000 	.word	0x00000000

08002420 <hal_lld_backup_domain_init>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8002420:	4b15      	ldr	r3, [pc, #84]	; (8002478 <hal_lld_backup_domain_init+0x58>)
 8002422:	4a15      	ldr	r2, [pc, #84]	; (8002478 <hal_lld_backup_domain_init+0x58>)
 8002424:	6812      	ldr	r2, [r2, #0]
 8002426:	2180      	movs	r1, #128	; 0x80
 8002428:	0049      	lsls	r1, r1, #1
 800242a:	430a      	orrs	r2, r1
 800242c:	601a      	str	r2, [r3, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 800242e:	4b13      	ldr	r3, [pc, #76]	; (800247c <hal_lld_backup_domain_init+0x5c>)
 8002430:	6a1a      	ldr	r2, [r3, #32]
 8002432:	23c0      	movs	r3, #192	; 0xc0
 8002434:	009b      	lsls	r3, r3, #2
 8002436:	401a      	ands	r2, r3
 8002438:	2380      	movs	r3, #128	; 0x80
 800243a:	009b      	lsls	r3, r3, #2
 800243c:	429a      	cmp	r2, r3
 800243e:	d006      	beq.n	800244e <hal_lld_backup_domain_init+0x2e>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8002440:	4b0e      	ldr	r3, [pc, #56]	; (800247c <hal_lld_backup_domain_init+0x5c>)
 8002442:	2280      	movs	r2, #128	; 0x80
 8002444:	0252      	lsls	r2, r2, #9
 8002446:	621a      	str	r2, [r3, #32]
    RCC->BDCR = 0;
 8002448:	4b0c      	ldr	r3, [pc, #48]	; (800247c <hal_lld_backup_domain_init+0x5c>)
 800244a:	2200      	movs	r2, #0
 800244c:	621a      	str	r2, [r3, #32]
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 800244e:	4b0b      	ldr	r3, [pc, #44]	; (800247c <hal_lld_backup_domain_init+0x5c>)
 8002450:	6a1a      	ldr	r2, [r3, #32]
 8002452:	2380      	movs	r3, #128	; 0x80
 8002454:	021b      	lsls	r3, r3, #8
 8002456:	4013      	ands	r3, r2
 8002458:	d10d      	bne.n	8002476 <hal_lld_backup_domain_init+0x56>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 800245a:	4b08      	ldr	r3, [pc, #32]	; (800247c <hal_lld_backup_domain_init+0x5c>)
 800245c:	4a07      	ldr	r2, [pc, #28]	; (800247c <hal_lld_backup_domain_init+0x5c>)
 800245e:	6a12      	ldr	r2, [r2, #32]
 8002460:	2180      	movs	r1, #128	; 0x80
 8002462:	0089      	lsls	r1, r1, #2
 8002464:	430a      	orrs	r2, r1
 8002466:	621a      	str	r2, [r3, #32]

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 8002468:	4b04      	ldr	r3, [pc, #16]	; (800247c <hal_lld_backup_domain_init+0x5c>)
 800246a:	4a04      	ldr	r2, [pc, #16]	; (800247c <hal_lld_backup_domain_init+0x5c>)
 800246c:	6a12      	ldr	r2, [r2, #32]
 800246e:	2180      	movs	r1, #128	; 0x80
 8002470:	0209      	lsls	r1, r1, #8
 8002472:	430a      	orrs	r2, r1
 8002474:	621a      	str	r2, [r3, #32]
  }
#endif /* STM32_RTCSEL != STM32_RTCSEL_NOCLOCK */
}
 8002476:	4770      	bx	lr
 8002478:	40007000 	.word	0x40007000
 800247c:	40021000 	.word	0x40021000

08002480 <Vector68>:
 * @note    It is declared here because this device has a non-standard
 *          DMA shared IRQ handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH23_HANDLER) {
 8002480:	b500      	push	{lr}
 8002482:	b087      	sub	sp, #28
 8002484:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 8002486:	9305      	str	r3, [sp, #20]

  /* Check on channel 2.*/
  dmaServeInterrupt(STM32_DMA1_STREAM2);
 8002488:	4b32      	ldr	r3, [pc, #200]	; (8002554 <Vector68+0xd4>)
 800248a:	2225      	movs	r2, #37	; 0x25
 800248c:	5c9b      	ldrb	r3, [r3, r2]
 800248e:	9304      	str	r3, [sp, #16]
 8002490:	4b30      	ldr	r3, [pc, #192]	; (8002554 <Vector68+0xd4>)
 8002492:	695b      	ldr	r3, [r3, #20]
 8002494:	681b      	ldr	r3, [r3, #0]
 8002496:	4a2f      	ldr	r2, [pc, #188]	; (8002554 <Vector68+0xd4>)
 8002498:	2124      	movs	r1, #36	; 0x24
 800249a:	5c52      	ldrb	r2, [r2, r1]
 800249c:	40d3      	lsrs	r3, r2
 800249e:	220e      	movs	r2, #14
 80024a0:	4013      	ands	r3, r2
 80024a2:	9303      	str	r3, [sp, #12]
 80024a4:	4b2b      	ldr	r3, [pc, #172]	; (8002554 <Vector68+0xd4>)
 80024a6:	699b      	ldr	r3, [r3, #24]
 80024a8:	681b      	ldr	r3, [r3, #0]
 80024aa:	9a03      	ldr	r2, [sp, #12]
 80024ac:	4013      	ands	r3, r2
 80024ae:	d01b      	beq.n	80024e8 <Vector68+0x68>
 80024b0:	4b28      	ldr	r3, [pc, #160]	; (8002554 <Vector68+0xd4>)
 80024b2:	695b      	ldr	r3, [r3, #20]
 80024b4:	4a27      	ldr	r2, [pc, #156]	; (8002554 <Vector68+0xd4>)
 80024b6:	2124      	movs	r1, #36	; 0x24
 80024b8:	5c52      	ldrb	r2, [r2, r1]
 80024ba:	0011      	movs	r1, r2
 80024bc:	9a03      	ldr	r2, [sp, #12]
 80024be:	408a      	lsls	r2, r1
 80024c0:	605a      	str	r2, [r3, #4]
 80024c2:	4b25      	ldr	r3, [pc, #148]	; (8002558 <Vector68+0xd8>)
 80024c4:	9a04      	ldr	r2, [sp, #16]
 80024c6:	00d2      	lsls	r2, r2, #3
 80024c8:	58d3      	ldr	r3, [r2, r3]
 80024ca:	2b00      	cmp	r3, #0
 80024cc:	d00c      	beq.n	80024e8 <Vector68+0x68>
 80024ce:	4b22      	ldr	r3, [pc, #136]	; (8002558 <Vector68+0xd8>)
 80024d0:	9a04      	ldr	r2, [sp, #16]
 80024d2:	00d2      	lsls	r2, r2, #3
 80024d4:	58d2      	ldr	r2, [r2, r3]
 80024d6:	4920      	ldr	r1, [pc, #128]	; (8002558 <Vector68+0xd8>)
 80024d8:	9b04      	ldr	r3, [sp, #16]
 80024da:	00db      	lsls	r3, r3, #3
 80024dc:	18cb      	adds	r3, r1, r3
 80024de:	3304      	adds	r3, #4
 80024e0:	681b      	ldr	r3, [r3, #0]
 80024e2:	9903      	ldr	r1, [sp, #12]
 80024e4:	0018      	movs	r0, r3
 80024e6:	4790      	blx	r2

  /* Check on channel 3.*/
  dmaServeInterrupt(STM32_DMA1_STREAM3);
 80024e8:	4b1a      	ldr	r3, [pc, #104]	; (8002554 <Vector68+0xd4>)
 80024ea:	2239      	movs	r2, #57	; 0x39
 80024ec:	5c9b      	ldrb	r3, [r3, r2]
 80024ee:	9302      	str	r3, [sp, #8]
 80024f0:	4b18      	ldr	r3, [pc, #96]	; (8002554 <Vector68+0xd4>)
 80024f2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80024f4:	681b      	ldr	r3, [r3, #0]
 80024f6:	4a17      	ldr	r2, [pc, #92]	; (8002554 <Vector68+0xd4>)
 80024f8:	2138      	movs	r1, #56	; 0x38
 80024fa:	5c52      	ldrb	r2, [r2, r1]
 80024fc:	40d3      	lsrs	r3, r2
 80024fe:	220e      	movs	r2, #14
 8002500:	4013      	ands	r3, r2
 8002502:	9301      	str	r3, [sp, #4]
 8002504:	4b13      	ldr	r3, [pc, #76]	; (8002554 <Vector68+0xd4>)
 8002506:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002508:	681b      	ldr	r3, [r3, #0]
 800250a:	9a01      	ldr	r2, [sp, #4]
 800250c:	4013      	ands	r3, r2
 800250e:	d01b      	beq.n	8002548 <Vector68+0xc8>
 8002510:	4b10      	ldr	r3, [pc, #64]	; (8002554 <Vector68+0xd4>)
 8002512:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002514:	4a0f      	ldr	r2, [pc, #60]	; (8002554 <Vector68+0xd4>)
 8002516:	2138      	movs	r1, #56	; 0x38
 8002518:	5c52      	ldrb	r2, [r2, r1]
 800251a:	0011      	movs	r1, r2
 800251c:	9a01      	ldr	r2, [sp, #4]
 800251e:	408a      	lsls	r2, r1
 8002520:	605a      	str	r2, [r3, #4]
 8002522:	4b0d      	ldr	r3, [pc, #52]	; (8002558 <Vector68+0xd8>)
 8002524:	9a02      	ldr	r2, [sp, #8]
 8002526:	00d2      	lsls	r2, r2, #3
 8002528:	58d3      	ldr	r3, [r2, r3]
 800252a:	2b00      	cmp	r3, #0
 800252c:	d00c      	beq.n	8002548 <Vector68+0xc8>
 800252e:	4b0a      	ldr	r3, [pc, #40]	; (8002558 <Vector68+0xd8>)
 8002530:	9a02      	ldr	r2, [sp, #8]
 8002532:	00d2      	lsls	r2, r2, #3
 8002534:	58d2      	ldr	r2, [r2, r3]
 8002536:	4908      	ldr	r1, [pc, #32]	; (8002558 <Vector68+0xd8>)
 8002538:	9b02      	ldr	r3, [sp, #8]
 800253a:	00db      	lsls	r3, r3, #3
 800253c:	18cb      	adds	r3, r1, r3
 800253e:	3304      	adds	r3, #4
 8002540:	681b      	ldr	r3, [r3, #0]
 8002542:	9901      	ldr	r1, [sp, #4]
 8002544:	0018      	movs	r0, r3
 8002546:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002548:	9b05      	ldr	r3, [sp, #20]
 800254a:	0018      	movs	r0, r3
 800254c:	f001 f9b0 	bl	80038b0 <_port_irq_epilogue>
}
 8002550:	b007      	add	sp, #28
 8002552:	bd00      	pop	{pc}
 8002554:	08004ba0 	.word	0x08004ba0
 8002558:	200005a8 	.word	0x200005a8
 800255c:	00000000 	.word	0x00000000

08002560 <Vector6C>:
/**
 * @brief   DMA1 streams 4, 5, 6 and 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4567_HANDLER) {
 8002560:	b500      	push	{lr}
 8002562:	b087      	sub	sp, #28
 8002564:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 8002566:	9305      	str	r3, [sp, #20]

  /* Check on channel 4.*/
  dmaServeInterrupt(STM32_DMA1_STREAM4);
 8002568:	4b32      	ldr	r3, [pc, #200]	; (8002634 <Vector6C+0xd4>)
 800256a:	224d      	movs	r2, #77	; 0x4d
 800256c:	5c9b      	ldrb	r3, [r3, r2]
 800256e:	9304      	str	r3, [sp, #16]
 8002570:	4b30      	ldr	r3, [pc, #192]	; (8002634 <Vector6C+0xd4>)
 8002572:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002574:	681b      	ldr	r3, [r3, #0]
 8002576:	4a2f      	ldr	r2, [pc, #188]	; (8002634 <Vector6C+0xd4>)
 8002578:	214c      	movs	r1, #76	; 0x4c
 800257a:	5c52      	ldrb	r2, [r2, r1]
 800257c:	40d3      	lsrs	r3, r2
 800257e:	220e      	movs	r2, #14
 8002580:	4013      	ands	r3, r2
 8002582:	9303      	str	r3, [sp, #12]
 8002584:	4b2b      	ldr	r3, [pc, #172]	; (8002634 <Vector6C+0xd4>)
 8002586:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002588:	681b      	ldr	r3, [r3, #0]
 800258a:	9a03      	ldr	r2, [sp, #12]
 800258c:	4013      	ands	r3, r2
 800258e:	d01b      	beq.n	80025c8 <Vector6C+0x68>
 8002590:	4b28      	ldr	r3, [pc, #160]	; (8002634 <Vector6C+0xd4>)
 8002592:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002594:	4a27      	ldr	r2, [pc, #156]	; (8002634 <Vector6C+0xd4>)
 8002596:	214c      	movs	r1, #76	; 0x4c
 8002598:	5c52      	ldrb	r2, [r2, r1]
 800259a:	0011      	movs	r1, r2
 800259c:	9a03      	ldr	r2, [sp, #12]
 800259e:	408a      	lsls	r2, r1
 80025a0:	605a      	str	r2, [r3, #4]
 80025a2:	4b25      	ldr	r3, [pc, #148]	; (8002638 <Vector6C+0xd8>)
 80025a4:	9a04      	ldr	r2, [sp, #16]
 80025a6:	00d2      	lsls	r2, r2, #3
 80025a8:	58d3      	ldr	r3, [r2, r3]
 80025aa:	2b00      	cmp	r3, #0
 80025ac:	d00c      	beq.n	80025c8 <Vector6C+0x68>
 80025ae:	4b22      	ldr	r3, [pc, #136]	; (8002638 <Vector6C+0xd8>)
 80025b0:	9a04      	ldr	r2, [sp, #16]
 80025b2:	00d2      	lsls	r2, r2, #3
 80025b4:	58d2      	ldr	r2, [r2, r3]
 80025b6:	4920      	ldr	r1, [pc, #128]	; (8002638 <Vector6C+0xd8>)
 80025b8:	9b04      	ldr	r3, [sp, #16]
 80025ba:	00db      	lsls	r3, r3, #3
 80025bc:	18cb      	adds	r3, r1, r3
 80025be:	3304      	adds	r3, #4
 80025c0:	681b      	ldr	r3, [r3, #0]
 80025c2:	9903      	ldr	r1, [sp, #12]
 80025c4:	0018      	movs	r0, r3
 80025c6:	4790      	blx	r2

  /* Check on channel 5.*/
  dmaServeInterrupt(STM32_DMA1_STREAM5);
 80025c8:	4b1a      	ldr	r3, [pc, #104]	; (8002634 <Vector6C+0xd4>)
 80025ca:	2261      	movs	r2, #97	; 0x61
 80025cc:	5c9b      	ldrb	r3, [r3, r2]
 80025ce:	9302      	str	r3, [sp, #8]
 80025d0:	4b18      	ldr	r3, [pc, #96]	; (8002634 <Vector6C+0xd4>)
 80025d2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80025d4:	681b      	ldr	r3, [r3, #0]
 80025d6:	4a17      	ldr	r2, [pc, #92]	; (8002634 <Vector6C+0xd4>)
 80025d8:	2160      	movs	r1, #96	; 0x60
 80025da:	5c52      	ldrb	r2, [r2, r1]
 80025dc:	40d3      	lsrs	r3, r2
 80025de:	220e      	movs	r2, #14
 80025e0:	4013      	ands	r3, r2
 80025e2:	9301      	str	r3, [sp, #4]
 80025e4:	4b13      	ldr	r3, [pc, #76]	; (8002634 <Vector6C+0xd4>)
 80025e6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80025e8:	681b      	ldr	r3, [r3, #0]
 80025ea:	9a01      	ldr	r2, [sp, #4]
 80025ec:	4013      	ands	r3, r2
 80025ee:	d01b      	beq.n	8002628 <Vector6C+0xc8>
 80025f0:	4b10      	ldr	r3, [pc, #64]	; (8002634 <Vector6C+0xd4>)
 80025f2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80025f4:	4a0f      	ldr	r2, [pc, #60]	; (8002634 <Vector6C+0xd4>)
 80025f6:	2160      	movs	r1, #96	; 0x60
 80025f8:	5c52      	ldrb	r2, [r2, r1]
 80025fa:	0011      	movs	r1, r2
 80025fc:	9a01      	ldr	r2, [sp, #4]
 80025fe:	408a      	lsls	r2, r1
 8002600:	605a      	str	r2, [r3, #4]
 8002602:	4b0d      	ldr	r3, [pc, #52]	; (8002638 <Vector6C+0xd8>)
 8002604:	9a02      	ldr	r2, [sp, #8]
 8002606:	00d2      	lsls	r2, r2, #3
 8002608:	58d3      	ldr	r3, [r2, r3]
 800260a:	2b00      	cmp	r3, #0
 800260c:	d00c      	beq.n	8002628 <Vector6C+0xc8>
 800260e:	4b0a      	ldr	r3, [pc, #40]	; (8002638 <Vector6C+0xd8>)
 8002610:	9a02      	ldr	r2, [sp, #8]
 8002612:	00d2      	lsls	r2, r2, #3
 8002614:	58d2      	ldr	r2, [r2, r3]
 8002616:	4908      	ldr	r1, [pc, #32]	; (8002638 <Vector6C+0xd8>)
 8002618:	9b02      	ldr	r3, [sp, #8]
 800261a:	00db      	lsls	r3, r3, #3
 800261c:	18cb      	adds	r3, r1, r3
 800261e:	3304      	adds	r3, #4
 8002620:	681b      	ldr	r3, [r3, #0]
 8002622:	9901      	ldr	r1, [sp, #4]
 8002624:	0018      	movs	r0, r3
 8002626:	4790      	blx	r2
#if STM32_DMA1_NUM_CHANNELS > 6
  /* Check on channel 7.*/
  dmaServeInterrupt(STM32_DMA1_STREAM7);
#endif

  OSAL_IRQ_EPILOGUE();
 8002628:	9b05      	ldr	r3, [sp, #20]
 800262a:	0018      	movs	r0, r3
 800262c:	f001 f940 	bl	80038b0 <_port_irq_epilogue>
}
 8002630:	b007      	add	sp, #28
 8002632:	bd00      	pop	{pc}
 8002634:	08004ba0 	.word	0x08004ba0
 8002638:	200005a8 	.word	0x200005a8
 800263c:	00000000 	.word	0x00000000

08002640 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 8002640:	b510      	push	{r4, lr}

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 8002642:	4b13      	ldr	r3, [pc, #76]	; (8002690 <hal_lld_init+0x50>)
 8002644:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002646:	4b12      	ldr	r3, [pc, #72]	; (8002690 <hal_lld_init+0x50>)
 8002648:	2201      	movs	r2, #1
 800264a:	4252      	negs	r2, r2
 800264c:	629a      	str	r2, [r3, #40]	; 0x28
 800264e:	4b10      	ldr	r3, [pc, #64]	; (8002690 <hal_lld_init+0x50>)
 8002650:	2200      	movs	r2, #0
 8002652:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 8002654:	4b0e      	ldr	r3, [pc, #56]	; (8002690 <hal_lld_init+0x50>)
 8002656:	691b      	ldr	r3, [r3, #16]
 8002658:	4b0d      	ldr	r3, [pc, #52]	; (8002690 <hal_lld_init+0x50>)
 800265a:	2201      	movs	r2, #1
 800265c:	4252      	negs	r2, r2
 800265e:	611a      	str	r2, [r3, #16]
 8002660:	4b0b      	ldr	r3, [pc, #44]	; (8002690 <hal_lld_init+0x50>)
 8002662:	2200      	movs	r2, #0
 8002664:	611a      	str	r2, [r3, #16]
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8002666:	4b0a      	ldr	r3, [pc, #40]	; (8002690 <hal_lld_init+0x50>)
 8002668:	4a09      	ldr	r2, [pc, #36]	; (8002690 <hal_lld_init+0x50>)
 800266a:	68d2      	ldr	r2, [r2, #12]
 800266c:	4909      	ldr	r1, [pc, #36]	; (8002694 <hal_lld_init+0x54>)
 800266e:	430a      	orrs	r2, r1
 8002670:	60da      	str	r2, [r3, #12]
 8002672:	4b07      	ldr	r3, [pc, #28]	; (8002690 <hal_lld_init+0x50>)
 8002674:	2200      	movs	r2, #0
 8002676:	60da      	str	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8002678:	4b05      	ldr	r3, [pc, #20]	; (8002690 <hal_lld_init+0x50>)
 800267a:	4a05      	ldr	r2, [pc, #20]	; (8002690 <hal_lld_init+0x50>)
 800267c:	69d2      	ldr	r2, [r2, #28]
 800267e:	2180      	movs	r1, #128	; 0x80
 8002680:	0549      	lsls	r1, r1, #21
 8002682:	430a      	orrs	r2, r1
 8002684:	61da      	str	r2, [r3, #28]

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 8002686:	f7ff fecb 	bl	8002420 <hal_lld_backup_domain_init>

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 800268a:	f7ff f911 	bl	80018b0 <dmaInit>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 800268e:	bd10      	pop	{r4, pc}
 8002690:	40021000 	.word	0x40021000
 8002694:	ffbfffff 	.word	0xffbfffff
	...

080026a0 <stm32_clock_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80026a0:	4b32      	ldr	r3, [pc, #200]	; (800276c <stm32_clock_init+0xcc>)
 80026a2:	4a32      	ldr	r2, [pc, #200]	; (800276c <stm32_clock_init+0xcc>)
 80026a4:	6812      	ldr	r2, [r2, #0]
 80026a6:	2101      	movs	r1, #1
 80026a8:	430a      	orrs	r2, r1
 80026aa:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80026ac:	4b2f      	ldr	r3, [pc, #188]	; (800276c <stm32_clock_init+0xcc>)
 80026ae:	681b      	ldr	r3, [r3, #0]
 80026b0:	2202      	movs	r2, #2
 80026b2:	4013      	ands	r3, r2
 80026b4:	d0fa      	beq.n	80026ac <stm32_clock_init+0xc>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 80026b6:	4b2d      	ldr	r3, [pc, #180]	; (800276c <stm32_clock_init+0xcc>)
 80026b8:	4a2c      	ldr	r2, [pc, #176]	; (800276c <stm32_clock_init+0xcc>)
 80026ba:	6852      	ldr	r2, [r2, #4]
 80026bc:	2103      	movs	r1, #3
 80026be:	438a      	bics	r2, r1
 80026c0:	605a      	str	r2, [r3, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 80026c2:	4b2a      	ldr	r3, [pc, #168]	; (800276c <stm32_clock_init+0xcc>)
 80026c4:	4a29      	ldr	r2, [pc, #164]	; (800276c <stm32_clock_init+0xcc>)
 80026c6:	6852      	ldr	r2, [r2, #4]
 80026c8:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 80026ca:	4b28      	ldr	r3, [pc, #160]	; (800276c <stm32_clock_init+0xcc>)
 80026cc:	685b      	ldr	r3, [r3, #4]
 80026ce:	220c      	movs	r2, #12
 80026d0:	4013      	ands	r3, r2
 80026d2:	d1fa      	bne.n	80026ca <stm32_clock_init+0x2a>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 80026d4:	4b25      	ldr	r3, [pc, #148]	; (800276c <stm32_clock_init+0xcc>)
 80026d6:	4a25      	ldr	r2, [pc, #148]	; (800276c <stm32_clock_init+0xcc>)
 80026d8:	6812      	ldr	r2, [r2, #0]
 80026da:	21f9      	movs	r1, #249	; 0xf9
 80026dc:	400a      	ands	r2, r1
 80026de:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 80026e0:	4b22      	ldr	r3, [pc, #136]	; (800276c <stm32_clock_init+0xcc>)
 80026e2:	2200      	movs	r2, #0
 80026e4:	605a      	str	r2, [r3, #4]
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_HSI14_ENABLED
  /* HSI14 activation.*/
  RCC->CR2 |= RCC_CR2_HSI14ON;
 80026e6:	4b21      	ldr	r3, [pc, #132]	; (800276c <stm32_clock_init+0xcc>)
 80026e8:	4a20      	ldr	r2, [pc, #128]	; (800276c <stm32_clock_init+0xcc>)
 80026ea:	6b52      	ldr	r2, [r2, #52]	; 0x34
 80026ec:	2101      	movs	r1, #1
 80026ee:	430a      	orrs	r2, r1
 80026f0:	635a      	str	r2, [r3, #52]	; 0x34
  while (!(RCC->CR2 & RCC_CR2_HSI14RDY))
 80026f2:	4b1e      	ldr	r3, [pc, #120]	; (800276c <stm32_clock_init+0xcc>)
 80026f4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80026f6:	2202      	movs	r2, #2
 80026f8:	4013      	ands	r3, r2
 80026fa:	d0fa      	beq.n	80026f2 <stm32_clock_init+0x52>
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 80026fc:	4b1b      	ldr	r3, [pc, #108]	; (800276c <stm32_clock_init+0xcc>)
 80026fe:	4a1b      	ldr	r2, [pc, #108]	; (800276c <stm32_clock_init+0xcc>)
 8002700:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8002702:	2101      	movs	r1, #1
 8002704:	430a      	orrs	r2, r1
 8002706:	625a      	str	r2, [r3, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8002708:	4b18      	ldr	r3, [pc, #96]	; (800276c <stm32_clock_init+0xcc>)
 800270a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800270c:	2202      	movs	r2, #2
 800270e:	4013      	ands	r3, r2
 8002710:	d0fa      	beq.n	8002708 <stm32_clock_init+0x68>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  /* CFGR2 must be configured first since CFGR value could change CFGR2 */
  RCC->CFGR2 = STM32_PREDIV;
 8002712:	4b16      	ldr	r3, [pc, #88]	; (800276c <stm32_clock_init+0xcc>)
 8002714:	2200      	movs	r2, #0
 8002716:	62da      	str	r2, [r3, #44]	; 0x2c
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 8002718:	4b14      	ldr	r3, [pc, #80]	; (800276c <stm32_clock_init+0xcc>)
 800271a:	22a0      	movs	r2, #160	; 0xa0
 800271c:	0392      	lsls	r2, r2, #14
 800271e:	605a      	str	r2, [r3, #4]
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE |
               ((STM32_PREDIV & STM32_PLLXTPRE_MASK) << STM32_PLLXTPRE_OFFSET);
#if STM32_CECSW == STM32_CECSW_OFF
  RCC->CFGR3 = STM32_USBSW  | STM32_I2C1SW | STM32_USART1SW;
#else
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
 8002720:	4b12      	ldr	r3, [pc, #72]	; (800276c <stm32_clock_init+0xcc>)
 8002722:	2200      	movs	r2, #0
 8002724:	631a      	str	r2, [r3, #48]	; 0x30
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8002726:	4b11      	ldr	r3, [pc, #68]	; (800276c <stm32_clock_init+0xcc>)
 8002728:	4a10      	ldr	r2, [pc, #64]	; (800276c <stm32_clock_init+0xcc>)
 800272a:	6812      	ldr	r2, [r2, #0]
 800272c:	2180      	movs	r1, #128	; 0x80
 800272e:	0449      	lsls	r1, r1, #17
 8002730:	430a      	orrs	r2, r1
 8002732:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8002734:	4b0d      	ldr	r3, [pc, #52]	; (800276c <stm32_clock_init+0xcc>)
 8002736:	681a      	ldr	r2, [r3, #0]
 8002738:	2380      	movs	r3, #128	; 0x80
 800273a:	049b      	lsls	r3, r3, #18
 800273c:	4013      	ands	r3, r2
 800273e:	d0f9      	beq.n	8002734 <stm32_clock_init+0x94>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8002740:	4b0b      	ldr	r3, [pc, #44]	; (8002770 <stm32_clock_init+0xd0>)
 8002742:	2211      	movs	r2, #17
 8002744:	601a      	str	r2, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8002746:	4b09      	ldr	r3, [pc, #36]	; (800276c <stm32_clock_init+0xcc>)
 8002748:	4a08      	ldr	r2, [pc, #32]	; (800276c <stm32_clock_init+0xcc>)
 800274a:	6852      	ldr	r2, [r2, #4]
 800274c:	2102      	movs	r1, #2
 800274e:	430a      	orrs	r2, r1
 8002750:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8002752:	4b06      	ldr	r3, [pc, #24]	; (800276c <stm32_clock_init+0xcc>)
 8002754:	685b      	ldr	r3, [r3, #4]
 8002756:	220c      	movs	r2, #12
 8002758:	4013      	ands	r3, r2
 800275a:	2b08      	cmp	r3, #8
 800275c:	d1f9      	bne.n	8002752 <stm32_clock_init+0xb2>
    ;                                       /* Waits selection complete.    */
#endif

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 800275e:	4b03      	ldr	r3, [pc, #12]	; (800276c <stm32_clock_init+0xcc>)
 8002760:	4a02      	ldr	r2, [pc, #8]	; (800276c <stm32_clock_init+0xcc>)
 8002762:	6992      	ldr	r2, [r2, #24]
 8002764:	2101      	movs	r1, #1
 8002766:	430a      	orrs	r2, r1
 8002768:	619a      	str	r2, [r3, #24]
#endif /* !STM32_NO_INIT */
}
 800276a:	4770      	bx	lr
 800276c:	40021000 	.word	0x40021000
 8002770:	40022000 	.word	0x40022000
	...

08002780 <Vector54>:
/**
 * @brief   EXTI[0]...EXTI[1] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector54) {
 8002780:	b500      	push	{lr}
 8002782:	b083      	sub	sp, #12
 8002784:	4673      	mov	r3, lr
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();
 8002786:	9301      	str	r3, [sp, #4]

  pr = EXTI->PR;
 8002788:	4b12      	ldr	r3, [pc, #72]	; (80027d4 <Vector54+0x54>)
 800278a:	695b      	ldr	r3, [r3, #20]
 800278c:	9300      	str	r3, [sp, #0]
  pr &= ((1U << 0) | (1U << 1));
 800278e:	9b00      	ldr	r3, [sp, #0]
 8002790:	2203      	movs	r2, #3
 8002792:	4013      	ands	r3, r2
 8002794:	9300      	str	r3, [sp, #0]
  EXTI->PR = pr;
 8002796:	4b0f      	ldr	r3, [pc, #60]	; (80027d4 <Vector54+0x54>)
 8002798:	9a00      	ldr	r2, [sp, #0]
 800279a:	615a      	str	r2, [r3, #20]
  if (pr & (1U << 0))
 800279c:	9b00      	ldr	r3, [sp, #0]
 800279e:	2201      	movs	r2, #1
 80027a0:	4013      	ands	r3, r2
 80027a2:	d006      	beq.n	80027b2 <Vector54+0x32>
    EXTD1.config->channels[0].cb(&EXTD1, 0);
 80027a4:	4b0c      	ldr	r3, [pc, #48]	; (80027d8 <Vector54+0x58>)
 80027a6:	685b      	ldr	r3, [r3, #4]
 80027a8:	685b      	ldr	r3, [r3, #4]
 80027aa:	4a0b      	ldr	r2, [pc, #44]	; (80027d8 <Vector54+0x58>)
 80027ac:	2100      	movs	r1, #0
 80027ae:	0010      	movs	r0, r2
 80027b0:	4798      	blx	r3
  if (pr & (1U << 1))
 80027b2:	9b00      	ldr	r3, [sp, #0]
 80027b4:	2202      	movs	r2, #2
 80027b6:	4013      	ands	r3, r2
 80027b8:	d006      	beq.n	80027c8 <Vector54+0x48>
    EXTD1.config->channels[1].cb(&EXTD1, 1);
 80027ba:	4b07      	ldr	r3, [pc, #28]	; (80027d8 <Vector54+0x58>)
 80027bc:	685b      	ldr	r3, [r3, #4]
 80027be:	68db      	ldr	r3, [r3, #12]
 80027c0:	4a05      	ldr	r2, [pc, #20]	; (80027d8 <Vector54+0x58>)
 80027c2:	2101      	movs	r1, #1
 80027c4:	0010      	movs	r0, r2
 80027c6:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80027c8:	9b01      	ldr	r3, [sp, #4]
 80027ca:	0018      	movs	r0, r3
 80027cc:	f001 f870 	bl	80038b0 <_port_irq_epilogue>
}
 80027d0:	b003      	add	sp, #12
 80027d2:	bd00      	pop	{pc}
 80027d4:	40010400 	.word	0x40010400
 80027d8:	200005d4 	.word	0x200005d4
 80027dc:	00000000 	.word	0x00000000

080027e0 <Vector58>:
/**
 * @brief   EXTI[2]...EXTI[3] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector58) {
 80027e0:	b500      	push	{lr}
 80027e2:	b083      	sub	sp, #12
 80027e4:	4673      	mov	r3, lr
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();
 80027e6:	9301      	str	r3, [sp, #4]

  pr = EXTI->PR;
 80027e8:	4b12      	ldr	r3, [pc, #72]	; (8002834 <Vector58+0x54>)
 80027ea:	695b      	ldr	r3, [r3, #20]
 80027ec:	9300      	str	r3, [sp, #0]
  pr &= ((1U << 2) | (1U << 3));
 80027ee:	9b00      	ldr	r3, [sp, #0]
 80027f0:	220c      	movs	r2, #12
 80027f2:	4013      	ands	r3, r2
 80027f4:	9300      	str	r3, [sp, #0]
  EXTI->PR = pr;
 80027f6:	4b0f      	ldr	r3, [pc, #60]	; (8002834 <Vector58+0x54>)
 80027f8:	9a00      	ldr	r2, [sp, #0]
 80027fa:	615a      	str	r2, [r3, #20]
  if (pr & (1U << 2))
 80027fc:	9b00      	ldr	r3, [sp, #0]
 80027fe:	2204      	movs	r2, #4
 8002800:	4013      	ands	r3, r2
 8002802:	d006      	beq.n	8002812 <Vector58+0x32>
    EXTD1.config->channels[2].cb(&EXTD1, 2);
 8002804:	4b0c      	ldr	r3, [pc, #48]	; (8002838 <Vector58+0x58>)
 8002806:	685b      	ldr	r3, [r3, #4]
 8002808:	695b      	ldr	r3, [r3, #20]
 800280a:	4a0b      	ldr	r2, [pc, #44]	; (8002838 <Vector58+0x58>)
 800280c:	2102      	movs	r1, #2
 800280e:	0010      	movs	r0, r2
 8002810:	4798      	blx	r3
  if (pr & (1U << 3))
 8002812:	9b00      	ldr	r3, [sp, #0]
 8002814:	2208      	movs	r2, #8
 8002816:	4013      	ands	r3, r2
 8002818:	d006      	beq.n	8002828 <Vector58+0x48>
    EXTD1.config->channels[3].cb(&EXTD1, 3);
 800281a:	4b07      	ldr	r3, [pc, #28]	; (8002838 <Vector58+0x58>)
 800281c:	685b      	ldr	r3, [r3, #4]
 800281e:	69db      	ldr	r3, [r3, #28]
 8002820:	4a05      	ldr	r2, [pc, #20]	; (8002838 <Vector58+0x58>)
 8002822:	2103      	movs	r1, #3
 8002824:	0010      	movs	r0, r2
 8002826:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002828:	9b01      	ldr	r3, [sp, #4]
 800282a:	0018      	movs	r0, r3
 800282c:	f001 f840 	bl	80038b0 <_port_irq_epilogue>
}
 8002830:	b003      	add	sp, #12
 8002832:	bd00      	pop	{pc}
 8002834:	40010400 	.word	0x40010400
 8002838:	200005d4 	.word	0x200005d4
 800283c:	00000000 	.word	0x00000000

08002840 <Vector5C>:
/**
 * @brief   EXTI[4]...EXTI[15] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector5C) {
 8002840:	b500      	push	{lr}
 8002842:	b083      	sub	sp, #12
 8002844:	4673      	mov	r3, lr
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();
 8002846:	9301      	str	r3, [sp, #4]

  pr = EXTI->PR;
 8002848:	4b4d      	ldr	r3, [pc, #308]	; (8002980 <Vector5C+0x140>)
 800284a:	695b      	ldr	r3, [r3, #20]
 800284c:	9300      	str	r3, [sp, #0]
  pr &= ((1U << 4)  | (1U << 5)  | (1U << 6)  | (1U << 7)  | (1U << 8)  |
 800284e:	9b00      	ldr	r3, [sp, #0]
 8002850:	4a4c      	ldr	r2, [pc, #304]	; (8002984 <Vector5C+0x144>)
 8002852:	4013      	ands	r3, r2
 8002854:	9300      	str	r3, [sp, #0]
         (1U << 9)  | (1U << 10) | (1U << 11) | (1U << 12) | (1U << 13) |
         (1U << 14) | (1U << 15));
  EXTI->PR = pr;
 8002856:	4b4a      	ldr	r3, [pc, #296]	; (8002980 <Vector5C+0x140>)
 8002858:	9a00      	ldr	r2, [sp, #0]
 800285a:	615a      	str	r2, [r3, #20]
  if (pr & (1U << 4))
 800285c:	9b00      	ldr	r3, [sp, #0]
 800285e:	2210      	movs	r2, #16
 8002860:	4013      	ands	r3, r2
 8002862:	d006      	beq.n	8002872 <Vector5C+0x32>
    EXTD1.config->channels[4].cb(&EXTD1, 4);
 8002864:	4b48      	ldr	r3, [pc, #288]	; (8002988 <Vector5C+0x148>)
 8002866:	685b      	ldr	r3, [r3, #4]
 8002868:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800286a:	4a47      	ldr	r2, [pc, #284]	; (8002988 <Vector5C+0x148>)
 800286c:	2104      	movs	r1, #4
 800286e:	0010      	movs	r0, r2
 8002870:	4798      	blx	r3
  if (pr & (1U << 5))
 8002872:	9b00      	ldr	r3, [sp, #0]
 8002874:	2220      	movs	r2, #32
 8002876:	4013      	ands	r3, r2
 8002878:	d006      	beq.n	8002888 <Vector5C+0x48>
    EXTD1.config->channels[5].cb(&EXTD1, 5);
 800287a:	4b43      	ldr	r3, [pc, #268]	; (8002988 <Vector5C+0x148>)
 800287c:	685b      	ldr	r3, [r3, #4]
 800287e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002880:	4a41      	ldr	r2, [pc, #260]	; (8002988 <Vector5C+0x148>)
 8002882:	2105      	movs	r1, #5
 8002884:	0010      	movs	r0, r2
 8002886:	4798      	blx	r3
  if (pr & (1U << 6))
 8002888:	9b00      	ldr	r3, [sp, #0]
 800288a:	2240      	movs	r2, #64	; 0x40
 800288c:	4013      	ands	r3, r2
 800288e:	d006      	beq.n	800289e <Vector5C+0x5e>
    EXTD1.config->channels[6].cb(&EXTD1, 6);
 8002890:	4b3d      	ldr	r3, [pc, #244]	; (8002988 <Vector5C+0x148>)
 8002892:	685b      	ldr	r3, [r3, #4]
 8002894:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002896:	4a3c      	ldr	r2, [pc, #240]	; (8002988 <Vector5C+0x148>)
 8002898:	2106      	movs	r1, #6
 800289a:	0010      	movs	r0, r2
 800289c:	4798      	blx	r3
  if (pr & (1U << 7))
 800289e:	9b00      	ldr	r3, [sp, #0]
 80028a0:	2280      	movs	r2, #128	; 0x80
 80028a2:	4013      	ands	r3, r2
 80028a4:	d006      	beq.n	80028b4 <Vector5C+0x74>
    EXTD1.config->channels[7].cb(&EXTD1, 7);
 80028a6:	4b38      	ldr	r3, [pc, #224]	; (8002988 <Vector5C+0x148>)
 80028a8:	685b      	ldr	r3, [r3, #4]
 80028aa:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80028ac:	4a36      	ldr	r2, [pc, #216]	; (8002988 <Vector5C+0x148>)
 80028ae:	2107      	movs	r1, #7
 80028b0:	0010      	movs	r0, r2
 80028b2:	4798      	blx	r3
  if (pr & (1U << 8))
 80028b4:	9a00      	ldr	r2, [sp, #0]
 80028b6:	2380      	movs	r3, #128	; 0x80
 80028b8:	005b      	lsls	r3, r3, #1
 80028ba:	4013      	ands	r3, r2
 80028bc:	d006      	beq.n	80028cc <Vector5C+0x8c>
    EXTD1.config->channels[8].cb(&EXTD1, 8);
 80028be:	4b32      	ldr	r3, [pc, #200]	; (8002988 <Vector5C+0x148>)
 80028c0:	685b      	ldr	r3, [r3, #4]
 80028c2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80028c4:	4a30      	ldr	r2, [pc, #192]	; (8002988 <Vector5C+0x148>)
 80028c6:	2108      	movs	r1, #8
 80028c8:	0010      	movs	r0, r2
 80028ca:	4798      	blx	r3
  if (pr & (1U << 9))
 80028cc:	9a00      	ldr	r2, [sp, #0]
 80028ce:	2380      	movs	r3, #128	; 0x80
 80028d0:	009b      	lsls	r3, r3, #2
 80028d2:	4013      	ands	r3, r2
 80028d4:	d006      	beq.n	80028e4 <Vector5C+0xa4>
    EXTD1.config->channels[9].cb(&EXTD1, 9);
 80028d6:	4b2c      	ldr	r3, [pc, #176]	; (8002988 <Vector5C+0x148>)
 80028d8:	685b      	ldr	r3, [r3, #4]
 80028da:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80028dc:	4a2a      	ldr	r2, [pc, #168]	; (8002988 <Vector5C+0x148>)
 80028de:	2109      	movs	r1, #9
 80028e0:	0010      	movs	r0, r2
 80028e2:	4798      	blx	r3
  if (pr & (1U << 10))
 80028e4:	9a00      	ldr	r2, [sp, #0]
 80028e6:	2380      	movs	r3, #128	; 0x80
 80028e8:	00db      	lsls	r3, r3, #3
 80028ea:	4013      	ands	r3, r2
 80028ec:	d006      	beq.n	80028fc <Vector5C+0xbc>
    EXTD1.config->channels[10].cb(&EXTD1, 10);
 80028ee:	4b26      	ldr	r3, [pc, #152]	; (8002988 <Vector5C+0x148>)
 80028f0:	685b      	ldr	r3, [r3, #4]
 80028f2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80028f4:	4a24      	ldr	r2, [pc, #144]	; (8002988 <Vector5C+0x148>)
 80028f6:	210a      	movs	r1, #10
 80028f8:	0010      	movs	r0, r2
 80028fa:	4798      	blx	r3
  if (pr & (1U << 11))
 80028fc:	9a00      	ldr	r2, [sp, #0]
 80028fe:	2380      	movs	r3, #128	; 0x80
 8002900:	011b      	lsls	r3, r3, #4
 8002902:	4013      	ands	r3, r2
 8002904:	d006      	beq.n	8002914 <Vector5C+0xd4>
    EXTD1.config->channels[11].cb(&EXTD1, 11);
 8002906:	4b20      	ldr	r3, [pc, #128]	; (8002988 <Vector5C+0x148>)
 8002908:	685b      	ldr	r3, [r3, #4]
 800290a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800290c:	4a1e      	ldr	r2, [pc, #120]	; (8002988 <Vector5C+0x148>)
 800290e:	210b      	movs	r1, #11
 8002910:	0010      	movs	r0, r2
 8002912:	4798      	blx	r3
  if (pr & (1U << 12))
 8002914:	9a00      	ldr	r2, [sp, #0]
 8002916:	2380      	movs	r3, #128	; 0x80
 8002918:	015b      	lsls	r3, r3, #5
 800291a:	4013      	ands	r3, r2
 800291c:	d006      	beq.n	800292c <Vector5C+0xec>
    EXTD1.config->channels[12].cb(&EXTD1, 12);
 800291e:	4b1a      	ldr	r3, [pc, #104]	; (8002988 <Vector5C+0x148>)
 8002920:	685b      	ldr	r3, [r3, #4]
 8002922:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8002924:	4a18      	ldr	r2, [pc, #96]	; (8002988 <Vector5C+0x148>)
 8002926:	210c      	movs	r1, #12
 8002928:	0010      	movs	r0, r2
 800292a:	4798      	blx	r3
  if (pr & (1U << 13))
 800292c:	9a00      	ldr	r2, [sp, #0]
 800292e:	2380      	movs	r3, #128	; 0x80
 8002930:	019b      	lsls	r3, r3, #6
 8002932:	4013      	ands	r3, r2
 8002934:	d006      	beq.n	8002944 <Vector5C+0x104>
    EXTD1.config->channels[13].cb(&EXTD1, 13);
 8002936:	4b14      	ldr	r3, [pc, #80]	; (8002988 <Vector5C+0x148>)
 8002938:	685b      	ldr	r3, [r3, #4]
 800293a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800293c:	4a12      	ldr	r2, [pc, #72]	; (8002988 <Vector5C+0x148>)
 800293e:	210d      	movs	r1, #13
 8002940:	0010      	movs	r0, r2
 8002942:	4798      	blx	r3
  if (pr & (1U << 14))
 8002944:	9a00      	ldr	r2, [sp, #0]
 8002946:	2380      	movs	r3, #128	; 0x80
 8002948:	01db      	lsls	r3, r3, #7
 800294a:	4013      	ands	r3, r2
 800294c:	d006      	beq.n	800295c <Vector5C+0x11c>
    EXTD1.config->channels[14].cb(&EXTD1, 14);
 800294e:	4b0e      	ldr	r3, [pc, #56]	; (8002988 <Vector5C+0x148>)
 8002950:	685b      	ldr	r3, [r3, #4]
 8002952:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8002954:	4a0c      	ldr	r2, [pc, #48]	; (8002988 <Vector5C+0x148>)
 8002956:	210e      	movs	r1, #14
 8002958:	0010      	movs	r0, r2
 800295a:	4798      	blx	r3
  if (pr & (1U << 15))
 800295c:	9a00      	ldr	r2, [sp, #0]
 800295e:	2380      	movs	r3, #128	; 0x80
 8002960:	021b      	lsls	r3, r3, #8
 8002962:	4013      	ands	r3, r2
 8002964:	d006      	beq.n	8002974 <Vector5C+0x134>
    EXTD1.config->channels[15].cb(&EXTD1, 15);
 8002966:	4b08      	ldr	r3, [pc, #32]	; (8002988 <Vector5C+0x148>)
 8002968:	685b      	ldr	r3, [r3, #4]
 800296a:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800296c:	4a06      	ldr	r2, [pc, #24]	; (8002988 <Vector5C+0x148>)
 800296e:	210f      	movs	r1, #15
 8002970:	0010      	movs	r0, r2
 8002972:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002974:	9b01      	ldr	r3, [sp, #4]
 8002976:	0018      	movs	r0, r3
 8002978:	f000 ff9a 	bl	80038b0 <_port_irq_epilogue>
}
 800297c:	b003      	add	sp, #12
 800297e:	bd00      	pop	{pc}
 8002980:	40010400 	.word	0x40010400
 8002984:	0000fff0 	.word	0x0000fff0
 8002988:	200005d4 	.word	0x200005d4
 800298c:	00000000 	.word	0x00000000

08002990 <Vector44>:
/**
 * @brief   EXTI[16] interrupt handler (PVD).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector44) {
 8002990:	b500      	push	{lr}
 8002992:	b083      	sub	sp, #12
 8002994:	4673      	mov	r3, lr
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();
 8002996:	9301      	str	r3, [sp, #4]

  pr = EXTI->PR;
 8002998:	4b10      	ldr	r3, [pc, #64]	; (80029dc <Vector44+0x4c>)
 800299a:	695b      	ldr	r3, [r3, #20]
 800299c:	9300      	str	r3, [sp, #0]
  pr &= EXTI->IMR & (1U << 16);
 800299e:	4b0f      	ldr	r3, [pc, #60]	; (80029dc <Vector44+0x4c>)
 80029a0:	681a      	ldr	r2, [r3, #0]
 80029a2:	2380      	movs	r3, #128	; 0x80
 80029a4:	025b      	lsls	r3, r3, #9
 80029a6:	401a      	ands	r2, r3
 80029a8:	9b00      	ldr	r3, [sp, #0]
 80029aa:	4013      	ands	r3, r2
 80029ac:	9300      	str	r3, [sp, #0]
  EXTI->PR = pr;
 80029ae:	4b0b      	ldr	r3, [pc, #44]	; (80029dc <Vector44+0x4c>)
 80029b0:	9a00      	ldr	r2, [sp, #0]
 80029b2:	615a      	str	r2, [r3, #20]
  if (pr & (1U << 16))
 80029b4:	9a00      	ldr	r2, [sp, #0]
 80029b6:	2380      	movs	r3, #128	; 0x80
 80029b8:	025b      	lsls	r3, r3, #9
 80029ba:	4013      	ands	r3, r2
 80029bc:	d007      	beq.n	80029ce <Vector44+0x3e>
    EXTD1.config->channels[16].cb(&EXTD1, 16);
 80029be:	4b08      	ldr	r3, [pc, #32]	; (80029e0 <Vector44+0x50>)
 80029c0:	685b      	ldr	r3, [r3, #4]
 80029c2:	2284      	movs	r2, #132	; 0x84
 80029c4:	589b      	ldr	r3, [r3, r2]
 80029c6:	4a06      	ldr	r2, [pc, #24]	; (80029e0 <Vector44+0x50>)
 80029c8:	2110      	movs	r1, #16
 80029ca:	0010      	movs	r0, r2
 80029cc:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80029ce:	9b01      	ldr	r3, [sp, #4]
 80029d0:	0018      	movs	r0, r3
 80029d2:	f000 ff6d 	bl	80038b0 <_port_irq_epilogue>
}
 80029d6:	b003      	add	sp, #12
 80029d8:	bd00      	pop	{pc}
 80029da:	46c0      	nop			; (mov r8, r8)
 80029dc:	40010400 	.word	0x40010400
 80029e0:	200005d4 	.word	0x200005d4
	...

080029f0 <Vector48>:
/**
 * @brief   EXTI[17],EXTI[19],EXTI[20] interrupt handler (RTC).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector48) {
 80029f0:	b500      	push	{lr}
 80029f2:	b083      	sub	sp, #12
 80029f4:	4673      	mov	r3, lr
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();
 80029f6:	9301      	str	r3, [sp, #4]

  pr = EXTI->PR;
 80029f8:	4b1d      	ldr	r3, [pc, #116]	; (8002a70 <Vector48+0x80>)
 80029fa:	695b      	ldr	r3, [r3, #20]
 80029fc:	9300      	str	r3, [sp, #0]
  pr &= EXTI->IMR & ((1U << 17) | (1U << 19) | (1U << 20));
 80029fe:	4b1c      	ldr	r3, [pc, #112]	; (8002a70 <Vector48+0x80>)
 8002a00:	681a      	ldr	r2, [r3, #0]
 8002a02:	23d0      	movs	r3, #208	; 0xd0
 8002a04:	035b      	lsls	r3, r3, #13
 8002a06:	401a      	ands	r2, r3
 8002a08:	9b00      	ldr	r3, [sp, #0]
 8002a0a:	4013      	ands	r3, r2
 8002a0c:	9300      	str	r3, [sp, #0]
  EXTI->PR = pr;
 8002a0e:	4b18      	ldr	r3, [pc, #96]	; (8002a70 <Vector48+0x80>)
 8002a10:	9a00      	ldr	r2, [sp, #0]
 8002a12:	615a      	str	r2, [r3, #20]
  if (pr & (1U << 17))
 8002a14:	9a00      	ldr	r2, [sp, #0]
 8002a16:	2380      	movs	r3, #128	; 0x80
 8002a18:	029b      	lsls	r3, r3, #10
 8002a1a:	4013      	ands	r3, r2
 8002a1c:	d007      	beq.n	8002a2e <Vector48+0x3e>
    EXTD1.config->channels[17].cb(&EXTD1, 17);
 8002a1e:	4b15      	ldr	r3, [pc, #84]	; (8002a74 <Vector48+0x84>)
 8002a20:	685b      	ldr	r3, [r3, #4]
 8002a22:	228c      	movs	r2, #140	; 0x8c
 8002a24:	589b      	ldr	r3, [r3, r2]
 8002a26:	4a13      	ldr	r2, [pc, #76]	; (8002a74 <Vector48+0x84>)
 8002a28:	2111      	movs	r1, #17
 8002a2a:	0010      	movs	r0, r2
 8002a2c:	4798      	blx	r3
  if (pr & (1U << 19))
 8002a2e:	9a00      	ldr	r2, [sp, #0]
 8002a30:	2380      	movs	r3, #128	; 0x80
 8002a32:	031b      	lsls	r3, r3, #12
 8002a34:	4013      	ands	r3, r2
 8002a36:	d007      	beq.n	8002a48 <Vector48+0x58>
    EXTD1.config->channels[19].cb(&EXTD1, 19);
 8002a38:	4b0e      	ldr	r3, [pc, #56]	; (8002a74 <Vector48+0x84>)
 8002a3a:	685b      	ldr	r3, [r3, #4]
 8002a3c:	229c      	movs	r2, #156	; 0x9c
 8002a3e:	589b      	ldr	r3, [r3, r2]
 8002a40:	4a0c      	ldr	r2, [pc, #48]	; (8002a74 <Vector48+0x84>)
 8002a42:	2113      	movs	r1, #19
 8002a44:	0010      	movs	r0, r2
 8002a46:	4798      	blx	r3
  if (pr & (1U << 20))
 8002a48:	9a00      	ldr	r2, [sp, #0]
 8002a4a:	2380      	movs	r3, #128	; 0x80
 8002a4c:	035b      	lsls	r3, r3, #13
 8002a4e:	4013      	ands	r3, r2
 8002a50:	d007      	beq.n	8002a62 <Vector48+0x72>
    EXTD1.config->channels[20].cb(&EXTD1, 20);
 8002a52:	4b08      	ldr	r3, [pc, #32]	; (8002a74 <Vector48+0x84>)
 8002a54:	685b      	ldr	r3, [r3, #4]
 8002a56:	22a4      	movs	r2, #164	; 0xa4
 8002a58:	589b      	ldr	r3, [r3, r2]
 8002a5a:	4a06      	ldr	r2, [pc, #24]	; (8002a74 <Vector48+0x84>)
 8002a5c:	2114      	movs	r1, #20
 8002a5e:	0010      	movs	r0, r2
 8002a60:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002a62:	9b01      	ldr	r3, [sp, #4]
 8002a64:	0018      	movs	r0, r3
 8002a66:	f000 ff23 	bl	80038b0 <_port_irq_epilogue>
}
 8002a6a:	b003      	add	sp, #12
 8002a6c:	bd00      	pop	{pc}
 8002a6e:	46c0      	nop			; (mov r8, r8)
 8002a70:	40010400 	.word	0x40010400
 8002a74:	200005d4 	.word	0x200005d4
	...

08002a80 <Vector70>:
 * @note    This handler is shared with the ADC so it is handled
 *          a bit differently.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector70) {
 8002a80:	b500      	push	{lr}
 8002a82:	b083      	sub	sp, #12
 8002a84:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 8002a86:	9301      	str	r3, [sp, #4]

#if HAL_USE_EXT
  {
    uint32_t pr;

    pr = EXTI->PR;
 8002a88:	4b16      	ldr	r3, [pc, #88]	; (8002ae4 <Vector70+0x64>)
 8002a8a:	695b      	ldr	r3, [r3, #20]
 8002a8c:	9300      	str	r3, [sp, #0]
    pr &= EXTI->IMR & ((1U << 21) | (1U << 22));
 8002a8e:	4b15      	ldr	r3, [pc, #84]	; (8002ae4 <Vector70+0x64>)
 8002a90:	681a      	ldr	r2, [r3, #0]
 8002a92:	23c0      	movs	r3, #192	; 0xc0
 8002a94:	03db      	lsls	r3, r3, #15
 8002a96:	401a      	ands	r2, r3
 8002a98:	9b00      	ldr	r3, [sp, #0]
 8002a9a:	4013      	ands	r3, r2
 8002a9c:	9300      	str	r3, [sp, #0]
    EXTI->PR = pr;
 8002a9e:	4b11      	ldr	r3, [pc, #68]	; (8002ae4 <Vector70+0x64>)
 8002aa0:	9a00      	ldr	r2, [sp, #0]
 8002aa2:	615a      	str	r2, [r3, #20]
    if (pr & (1U << 21))
 8002aa4:	9a00      	ldr	r2, [sp, #0]
 8002aa6:	2380      	movs	r3, #128	; 0x80
 8002aa8:	039b      	lsls	r3, r3, #14
 8002aaa:	4013      	ands	r3, r2
 8002aac:	d007      	beq.n	8002abe <Vector70+0x3e>
      EXTD1.config->channels[21].cb(&EXTD1, 21);
 8002aae:	4b0e      	ldr	r3, [pc, #56]	; (8002ae8 <Vector70+0x68>)
 8002ab0:	685b      	ldr	r3, [r3, #4]
 8002ab2:	22ac      	movs	r2, #172	; 0xac
 8002ab4:	589b      	ldr	r3, [r3, r2]
 8002ab6:	4a0c      	ldr	r2, [pc, #48]	; (8002ae8 <Vector70+0x68>)
 8002ab8:	2115      	movs	r1, #21
 8002aba:	0010      	movs	r0, r2
 8002abc:	4798      	blx	r3
    if (pr & (1U << 22))
 8002abe:	9a00      	ldr	r2, [sp, #0]
 8002ac0:	2380      	movs	r3, #128	; 0x80
 8002ac2:	03db      	lsls	r3, r3, #15
 8002ac4:	4013      	ands	r3, r2
 8002ac6:	d007      	beq.n	8002ad8 <Vector70+0x58>
      EXTD1.config->channels[21].cb(&EXTD1, 22);
 8002ac8:	4b07      	ldr	r3, [pc, #28]	; (8002ae8 <Vector70+0x68>)
 8002aca:	685b      	ldr	r3, [r3, #4]
 8002acc:	22ac      	movs	r2, #172	; 0xac
 8002ace:	589b      	ldr	r3, [r3, r2]
 8002ad0:	4a05      	ldr	r2, [pc, #20]	; (8002ae8 <Vector70+0x68>)
 8002ad2:	2116      	movs	r1, #22
 8002ad4:	0010      	movs	r0, r2
 8002ad6:	4798      	blx	r3
#endif
#if HAL_USE_ADC
  adc_lld_serve_interrupt(&ADCD1);
#endif

  OSAL_IRQ_EPILOGUE();
 8002ad8:	9b01      	ldr	r3, [sp, #4]
 8002ada:	0018      	movs	r0, r3
 8002adc:	f000 fee8 	bl	80038b0 <_port_irq_epilogue>
}
 8002ae0:	b003      	add	sp, #12
 8002ae2:	bd00      	pop	{pc}
 8002ae4:	40010400 	.word	0x40010400
 8002ae8:	200005d4 	.word	0x200005d4
 8002aec:	00000000 	.word	0x00000000

08002af0 <port_lock.lto_priv.54>:
  __ASM volatile ("cpsid i" : : : "memory");
 8002af0:	b672      	cpsid	i
}
 8002af2:	4770      	bx	lr
	...

08002b00 <port_unlock.lto_priv.50>:
  __ASM volatile ("cpsie i" : : : "memory");
 8002b00:	b662      	cpsie	i
}
 8002b02:	4770      	bx	lr
	...

08002b10 <port_lock_from_isr>:
static inline void port_lock_from_isr(void) {
 8002b10:	b510      	push	{r4, lr}
  port_lock();
 8002b12:	f7ff ffed 	bl	8002af0 <port_lock.lto_priv.54>
}
 8002b16:	bd10      	pop	{r4, pc}
	...

08002b20 <port_unlock_from_isr>:
static inline void port_unlock_from_isr(void) {
 8002b20:	b510      	push	{r4, lr}
  port_unlock();
 8002b22:	f7ff ffed 	bl	8002b00 <port_unlock.lto_priv.50>
}
 8002b26:	bd10      	pop	{r4, pc}
	...

08002b30 <chSysLockFromISR>:
static inline void chSysLockFromISR(void) {
 8002b30:	b510      	push	{r4, lr}
  port_lock_from_isr();
 8002b32:	f7ff ffed 	bl	8002b10 <port_lock_from_isr>
}
 8002b36:	bd10      	pop	{r4, pc}
	...

08002b40 <chSysUnlockFromISR>:
static inline void chSysUnlockFromISR(void) {
 8002b40:	b510      	push	{r4, lr}
  port_unlock_from_isr();
 8002b42:	f7ff ffed 	bl	8002b20 <port_unlock_from_isr>
}
 8002b46:	bd10      	pop	{r4, pc}
	...

08002b50 <chThdSleepS>:
static inline void chThdSleepS(systime_t time) {
 8002b50:	b500      	push	{lr}
 8002b52:	b083      	sub	sp, #12
 8002b54:	9001      	str	r0, [sp, #4]
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8002b56:	9b01      	ldr	r3, [sp, #4]
 8002b58:	0019      	movs	r1, r3
 8002b5a:	2008      	movs	r0, #8
 8002b5c:	f001 fd50 	bl	8004600 <chSchGoSleepTimeoutS>
}
 8002b60:	b003      	add	sp, #12
 8002b62:	bd00      	pop	{pc}
	...

08002b70 <osalSysLockFromISR.lto_priv.40>:
static inline void osalSysLockFromISR(void) {
 8002b70:	b510      	push	{r4, lr}
  chSysLockFromISR();
 8002b72:	f7ff ffdd 	bl	8002b30 <chSysLockFromISR>
}
 8002b76:	bd10      	pop	{r4, pc}
	...

08002b80 <osalSysUnlockFromISR.lto_priv.38>:
static inline void osalSysUnlockFromISR(void) {
 8002b80:	b510      	push	{r4, lr}
  chSysUnlockFromISR();
 8002b82:	f7ff ffdd 	bl	8002b40 <chSysUnlockFromISR>
}
 8002b86:	bd10      	pop	{r4, pc}
	...

08002b90 <osalThreadSleepS.lto_priv.44>:
static inline void osalThreadSleepS(systime_t time) {
 8002b90:	b500      	push	{lr}
 8002b92:	b083      	sub	sp, #12
 8002b94:	9001      	str	r0, [sp, #4]
  chThdSleepS(time);
 8002b96:	9b01      	ldr	r3, [sp, #4]
 8002b98:	0018      	movs	r0, r3
 8002b9a:	f7ff ffd9 	bl	8002b50 <chThdSleepS>
}
 8002b9e:	b003      	add	sp, #12
 8002ba0:	bd00      	pop	{pc}
 8002ba2:	46c0      	nop			; (mov r8, r8)
	...

08002bb0 <osalThreadDequeueAllI.lto_priv.46>:
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8002bb0:	b500      	push	{lr}
 8002bb2:	b083      	sub	sp, #12
 8002bb4:	9001      	str	r0, [sp, #4]
 8002bb6:	9100      	str	r1, [sp, #0]
  chThdDequeueAllI(tqp, msg);
 8002bb8:	9a00      	ldr	r2, [sp, #0]
 8002bba:	9b01      	ldr	r3, [sp, #4]
 8002bbc:	0011      	movs	r1, r2
 8002bbe:	0018      	movs	r0, r3
 8002bc0:	f000 ff9e 	bl	8003b00 <chThdDequeueAllI>
}
 8002bc4:	b003      	add	sp, #12
 8002bc6:	bd00      	pop	{pc}
	...

08002bd0 <osalEventBroadcastFlagsI.lto_priv.45>:
                                            eventflags_t flags) {
 8002bd0:	b500      	push	{lr}
 8002bd2:	b083      	sub	sp, #12
 8002bd4:	9001      	str	r0, [sp, #4]
 8002bd6:	9100      	str	r1, [sp, #0]
  chEvtBroadcastFlagsI(esp, flags);
 8002bd8:	9a00      	ldr	r2, [sp, #0]
 8002bda:	9b01      	ldr	r3, [sp, #4]
 8002bdc:	0011      	movs	r1, r2
 8002bde:	0018      	movs	r0, r3
 8002be0:	f001 f82e 	bl	8003c40 <chEvtBroadcastFlagsI>
}
 8002be4:	b003      	add	sp, #12
 8002be6:	bd00      	pop	{pc}
	...

08002bf0 <can_lld_set_filters.lto_priv.43>:
                                const CANFilter *cfp) {
 8002bf0:	b086      	sub	sp, #24
 8002bf2:	9003      	str	r0, [sp, #12]
 8002bf4:	9102      	str	r1, [sp, #8]
 8002bf6:	9201      	str	r2, [sp, #4]
 8002bf8:	9300      	str	r3, [sp, #0]
  if(canp == &CAND1) {
 8002bfa:	9a03      	ldr	r2, [sp, #12]
 8002bfc:	4b86      	ldr	r3, [pc, #536]	; (8002e18 <can_lld_set_filters.lto_priv.43+0x228>)
 8002bfe:	429a      	cmp	r2, r3
 8002c00:	d125      	bne.n	8002c4e <can_lld_set_filters.lto_priv.43+0x5e>
    rccEnableCAN1(FALSE);
 8002c02:	4b86      	ldr	r3, [pc, #536]	; (8002e1c <can_lld_set_filters.lto_priv.43+0x22c>)
 8002c04:	4a85      	ldr	r2, [pc, #532]	; (8002e1c <can_lld_set_filters.lto_priv.43+0x22c>)
 8002c06:	69d2      	ldr	r2, [r2, #28]
 8002c08:	2180      	movs	r1, #128	; 0x80
 8002c0a:	0489      	lsls	r1, r1, #18
 8002c0c:	430a      	orrs	r2, r1
 8002c0e:	61da      	str	r2, [r3, #28]
    canp->can->FMR = (canp->can->FMR & 0xFFFF0000) | CAN_FMR_FINIT;
 8002c10:	9b03      	ldr	r3, [sp, #12]
 8002c12:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002c14:	9b03      	ldr	r3, [sp, #12]
 8002c16:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8002c18:	2380      	movs	r3, #128	; 0x80
 8002c1a:	009b      	lsls	r3, r3, #2
 8002c1c:	58cb      	ldr	r3, [r1, r3]
 8002c1e:	0c1b      	lsrs	r3, r3, #16
 8002c20:	041b      	lsls	r3, r3, #16
 8002c22:	2101      	movs	r1, #1
 8002c24:	4319      	orrs	r1, r3
 8002c26:	2380      	movs	r3, #128	; 0x80
 8002c28:	009b      	lsls	r3, r3, #2
 8002c2a:	50d1      	str	r1, [r2, r3]
    canp->can->FMR = (canp->can->FMR & 0xFFFF0000) | (can2sb << 8) | CAN_FMR_FINIT;
 8002c2c:	9b03      	ldr	r3, [sp, #12]
 8002c2e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002c30:	9b03      	ldr	r3, [sp, #12]
 8002c32:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8002c34:	2380      	movs	r3, #128	; 0x80
 8002c36:	009b      	lsls	r3, r3, #2
 8002c38:	58cb      	ldr	r3, [r1, r3]
 8002c3a:	0c1b      	lsrs	r3, r3, #16
 8002c3c:	0419      	lsls	r1, r3, #16
 8002c3e:	9b02      	ldr	r3, [sp, #8]
 8002c40:	021b      	lsls	r3, r3, #8
 8002c42:	430b      	orrs	r3, r1
 8002c44:	2101      	movs	r1, #1
 8002c46:	4319      	orrs	r1, r3
 8002c48:	2380      	movs	r3, #128	; 0x80
 8002c4a:	009b      	lsls	r3, r3, #2
 8002c4c:	50d1      	str	r1, [r2, r3]
  if (num > 0) {
 8002c4e:	9b01      	ldr	r3, [sp, #4]
 8002c50:	2b00      	cmp	r3, #0
 8002c52:	d100      	bne.n	8002c56 <can_lld_set_filters.lto_priv.43+0x66>
 8002c54:	e0a3      	b.n	8002d9e <can_lld_set_filters.lto_priv.43+0x1ae>
    canp->can->FA1R = 0;
 8002c56:	9b03      	ldr	r3, [sp, #12]
 8002c58:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002c5a:	2387      	movs	r3, #135	; 0x87
 8002c5c:	009b      	lsls	r3, r3, #2
 8002c5e:	2100      	movs	r1, #0
 8002c60:	50d1      	str	r1, [r2, r3]
    canp->can->FM1R = 0;
 8002c62:	9b03      	ldr	r3, [sp, #12]
 8002c64:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002c66:	2381      	movs	r3, #129	; 0x81
 8002c68:	009b      	lsls	r3, r3, #2
 8002c6a:	2100      	movs	r1, #0
 8002c6c:	50d1      	str	r1, [r2, r3]
    canp->can->FS1R = 0;
 8002c6e:	9b03      	ldr	r3, [sp, #12]
 8002c70:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002c72:	2383      	movs	r3, #131	; 0x83
 8002c74:	009b      	lsls	r3, r3, #2
 8002c76:	2100      	movs	r1, #0
 8002c78:	50d1      	str	r1, [r2, r3]
    canp->can->FFA1R = 0;
 8002c7a:	9b03      	ldr	r3, [sp, #12]
 8002c7c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002c7e:	2385      	movs	r3, #133	; 0x85
 8002c80:	009b      	lsls	r3, r3, #2
 8002c82:	2100      	movs	r1, #0
 8002c84:	50d1      	str	r1, [r2, r3]
    if(canp == &CAND1) {
 8002c86:	9a03      	ldr	r2, [sp, #12]
 8002c88:	4b63      	ldr	r3, [pc, #396]	; (8002e18 <can_lld_set_filters.lto_priv.43+0x228>)
 8002c8a:	429a      	cmp	r2, r3
 8002c8c:	d118      	bne.n	8002cc0 <can_lld_set_filters.lto_priv.43+0xd0>
      for (i = 0; i < STM32_CAN_MAX_FILTERS; i++) {
 8002c8e:	2300      	movs	r3, #0
 8002c90:	9305      	str	r3, [sp, #20]
 8002c92:	e012      	b.n	8002cba <can_lld_set_filters.lto_priv.43+0xca>
        canp->can->sFilterRegister[i].FR1 = 0;
 8002c94:	9b03      	ldr	r3, [sp, #12]
 8002c96:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002c98:	9a05      	ldr	r2, [sp, #20]
 8002c9a:	3248      	adds	r2, #72	; 0x48
 8002c9c:	00d2      	lsls	r2, r2, #3
 8002c9e:	2100      	movs	r1, #0
 8002ca0:	50d1      	str	r1, [r2, r3]
        canp->can->sFilterRegister[i].FR2 = 0;
 8002ca2:	9b03      	ldr	r3, [sp, #12]
 8002ca4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002ca6:	9b05      	ldr	r3, [sp, #20]
 8002ca8:	3348      	adds	r3, #72	; 0x48
 8002caa:	00db      	lsls	r3, r3, #3
 8002cac:	18d3      	adds	r3, r2, r3
 8002cae:	3304      	adds	r3, #4
 8002cb0:	2200      	movs	r2, #0
 8002cb2:	601a      	str	r2, [r3, #0]
      for (i = 0; i < STM32_CAN_MAX_FILTERS; i++) {
 8002cb4:	9b05      	ldr	r3, [sp, #20]
 8002cb6:	3301      	adds	r3, #1
 8002cb8:	9305      	str	r3, [sp, #20]
 8002cba:	9b05      	ldr	r3, [sp, #20]
 8002cbc:	2b0d      	cmp	r3, #13
 8002cbe:	d9e9      	bls.n	8002c94 <can_lld_set_filters.lto_priv.43+0xa4>
    for (i = 0; i < num; i++) {
 8002cc0:	2300      	movs	r3, #0
 8002cc2:	9305      	str	r3, [sp, #20]
 8002cc4:	e066      	b.n	8002d94 <can_lld_set_filters.lto_priv.43+0x1a4>
      fmask = 1 << cfp->filter;
 8002cc6:	9b00      	ldr	r3, [sp, #0]
 8002cc8:	681b      	ldr	r3, [r3, #0]
 8002cca:	2201      	movs	r2, #1
 8002ccc:	409a      	lsls	r2, r3
 8002cce:	0013      	movs	r3, r2
 8002cd0:	9304      	str	r3, [sp, #16]
      if (cfp->mode)
 8002cd2:	9b00      	ldr	r3, [sp, #0]
 8002cd4:	791b      	ldrb	r3, [r3, #4]
 8002cd6:	2201      	movs	r2, #1
 8002cd8:	4013      	ands	r3, r2
 8002cda:	b2db      	uxtb	r3, r3
 8002cdc:	2b00      	cmp	r3, #0
 8002cde:	d00b      	beq.n	8002cf8 <can_lld_set_filters.lto_priv.43+0x108>
        canp->can->FM1R |= fmask;
 8002ce0:	9b03      	ldr	r3, [sp, #12]
 8002ce2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002ce4:	9b03      	ldr	r3, [sp, #12]
 8002ce6:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8002ce8:	2381      	movs	r3, #129	; 0x81
 8002cea:	009b      	lsls	r3, r3, #2
 8002cec:	58c9      	ldr	r1, [r1, r3]
 8002cee:	9b04      	ldr	r3, [sp, #16]
 8002cf0:	4319      	orrs	r1, r3
 8002cf2:	2381      	movs	r3, #129	; 0x81
 8002cf4:	009b      	lsls	r3, r3, #2
 8002cf6:	50d1      	str	r1, [r2, r3]
      if (cfp->scale)
 8002cf8:	9b00      	ldr	r3, [sp, #0]
 8002cfa:	791b      	ldrb	r3, [r3, #4]
 8002cfc:	2202      	movs	r2, #2
 8002cfe:	4013      	ands	r3, r2
 8002d00:	b2db      	uxtb	r3, r3
 8002d02:	2b00      	cmp	r3, #0
 8002d04:	d00b      	beq.n	8002d1e <can_lld_set_filters.lto_priv.43+0x12e>
        canp->can->FS1R |= fmask;
 8002d06:	9b03      	ldr	r3, [sp, #12]
 8002d08:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002d0a:	9b03      	ldr	r3, [sp, #12]
 8002d0c:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8002d0e:	2383      	movs	r3, #131	; 0x83
 8002d10:	009b      	lsls	r3, r3, #2
 8002d12:	58c9      	ldr	r1, [r1, r3]
 8002d14:	9b04      	ldr	r3, [sp, #16]
 8002d16:	4319      	orrs	r1, r3
 8002d18:	2383      	movs	r3, #131	; 0x83
 8002d1a:	009b      	lsls	r3, r3, #2
 8002d1c:	50d1      	str	r1, [r2, r3]
      if (cfp->assignment)
 8002d1e:	9b00      	ldr	r3, [sp, #0]
 8002d20:	791b      	ldrb	r3, [r3, #4]
 8002d22:	2204      	movs	r2, #4
 8002d24:	4013      	ands	r3, r2
 8002d26:	b2db      	uxtb	r3, r3
 8002d28:	2b00      	cmp	r3, #0
 8002d2a:	d00b      	beq.n	8002d44 <can_lld_set_filters.lto_priv.43+0x154>
        canp->can->FFA1R |= fmask;
 8002d2c:	9b03      	ldr	r3, [sp, #12]
 8002d2e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002d30:	9b03      	ldr	r3, [sp, #12]
 8002d32:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8002d34:	2385      	movs	r3, #133	; 0x85
 8002d36:	009b      	lsls	r3, r3, #2
 8002d38:	58c9      	ldr	r1, [r1, r3]
 8002d3a:	9b04      	ldr	r3, [sp, #16]
 8002d3c:	4319      	orrs	r1, r3
 8002d3e:	2385      	movs	r3, #133	; 0x85
 8002d40:	009b      	lsls	r3, r3, #2
 8002d42:	50d1      	str	r1, [r2, r3]
      canp->can->sFilterRegister[cfp->filter].FR1 = cfp->register1;
 8002d44:	9b03      	ldr	r3, [sp, #12]
 8002d46:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002d48:	9b00      	ldr	r3, [sp, #0]
 8002d4a:	6818      	ldr	r0, [r3, #0]
 8002d4c:	9b00      	ldr	r3, [sp, #0]
 8002d4e:	6899      	ldr	r1, [r3, #8]
 8002d50:	0003      	movs	r3, r0
 8002d52:	3348      	adds	r3, #72	; 0x48
 8002d54:	00db      	lsls	r3, r3, #3
 8002d56:	5099      	str	r1, [r3, r2]
      canp->can->sFilterRegister[cfp->filter].FR2 = cfp->register2;
 8002d58:	9b03      	ldr	r3, [sp, #12]
 8002d5a:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8002d5c:	9b00      	ldr	r3, [sp, #0]
 8002d5e:	6818      	ldr	r0, [r3, #0]
 8002d60:	9b00      	ldr	r3, [sp, #0]
 8002d62:	68da      	ldr	r2, [r3, #12]
 8002d64:	0003      	movs	r3, r0
 8002d66:	3348      	adds	r3, #72	; 0x48
 8002d68:	00db      	lsls	r3, r3, #3
 8002d6a:	18cb      	adds	r3, r1, r3
 8002d6c:	3304      	adds	r3, #4
 8002d6e:	601a      	str	r2, [r3, #0]
      canp->can->FA1R |= fmask;
 8002d70:	9b03      	ldr	r3, [sp, #12]
 8002d72:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002d74:	9b03      	ldr	r3, [sp, #12]
 8002d76:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8002d78:	2387      	movs	r3, #135	; 0x87
 8002d7a:	009b      	lsls	r3, r3, #2
 8002d7c:	58c9      	ldr	r1, [r1, r3]
 8002d7e:	9b04      	ldr	r3, [sp, #16]
 8002d80:	4319      	orrs	r1, r3
 8002d82:	2387      	movs	r3, #135	; 0x87
 8002d84:	009b      	lsls	r3, r3, #2
 8002d86:	50d1      	str	r1, [r2, r3]
      cfp++;
 8002d88:	9b00      	ldr	r3, [sp, #0]
 8002d8a:	3310      	adds	r3, #16
 8002d8c:	9300      	str	r3, [sp, #0]
    for (i = 0; i < num; i++) {
 8002d8e:	9b05      	ldr	r3, [sp, #20]
 8002d90:	3301      	adds	r3, #1
 8002d92:	9305      	str	r3, [sp, #20]
 8002d94:	9a05      	ldr	r2, [sp, #20]
 8002d96:	9b01      	ldr	r3, [sp, #4]
 8002d98:	429a      	cmp	r2, r3
 8002d9a:	d394      	bcc.n	8002cc6 <can_lld_set_filters.lto_priv.43+0xd6>
 8002d9c:	e023      	b.n	8002de6 <can_lld_set_filters.lto_priv.43+0x1f6>
    canp->can->sFilterRegister[0].FR1 = 0;
 8002d9e:	9b03      	ldr	r3, [sp, #12]
 8002da0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002da2:	2390      	movs	r3, #144	; 0x90
 8002da4:	009b      	lsls	r3, r3, #2
 8002da6:	2100      	movs	r1, #0
 8002da8:	50d1      	str	r1, [r2, r3]
    canp->can->sFilterRegister[0].FR2 = 0;
 8002daa:	9b03      	ldr	r3, [sp, #12]
 8002dac:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002dae:	2391      	movs	r3, #145	; 0x91
 8002db0:	009b      	lsls	r3, r3, #2
 8002db2:	2100      	movs	r1, #0
 8002db4:	50d1      	str	r1, [r2, r3]
    canp->can->FM1R = 0;
 8002db6:	9b03      	ldr	r3, [sp, #12]
 8002db8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002dba:	2381      	movs	r3, #129	; 0x81
 8002dbc:	009b      	lsls	r3, r3, #2
 8002dbe:	2100      	movs	r1, #0
 8002dc0:	50d1      	str	r1, [r2, r3]
    canp->can->FFA1R = 0;
 8002dc2:	9b03      	ldr	r3, [sp, #12]
 8002dc4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002dc6:	2385      	movs	r3, #133	; 0x85
 8002dc8:	009b      	lsls	r3, r3, #2
 8002dca:	2100      	movs	r1, #0
 8002dcc:	50d1      	str	r1, [r2, r3]
    canp->can->FS1R = 1;
 8002dce:	9b03      	ldr	r3, [sp, #12]
 8002dd0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002dd2:	2383      	movs	r3, #131	; 0x83
 8002dd4:	009b      	lsls	r3, r3, #2
 8002dd6:	2101      	movs	r1, #1
 8002dd8:	50d1      	str	r1, [r2, r3]
    canp->can->FA1R = 1;
 8002dda:	9b03      	ldr	r3, [sp, #12]
 8002ddc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002dde:	2387      	movs	r3, #135	; 0x87
 8002de0:	009b      	lsls	r3, r3, #2
 8002de2:	2101      	movs	r1, #1
 8002de4:	50d1      	str	r1, [r2, r3]
  canp->can->FMR &= ~CAN_FMR_FINIT;
 8002de6:	9b03      	ldr	r3, [sp, #12]
 8002de8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002dea:	9b03      	ldr	r3, [sp, #12]
 8002dec:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8002dee:	2380      	movs	r3, #128	; 0x80
 8002df0:	009b      	lsls	r3, r3, #2
 8002df2:	58cb      	ldr	r3, [r1, r3]
 8002df4:	2101      	movs	r1, #1
 8002df6:	438b      	bics	r3, r1
 8002df8:	0019      	movs	r1, r3
 8002dfa:	2380      	movs	r3, #128	; 0x80
 8002dfc:	009b      	lsls	r3, r3, #2
 8002dfe:	50d1      	str	r1, [r2, r3]
  if(canp == &CAND1) {
 8002e00:	9a03      	ldr	r2, [sp, #12]
 8002e02:	4b05      	ldr	r3, [pc, #20]	; (8002e18 <can_lld_set_filters.lto_priv.43+0x228>)
 8002e04:	429a      	cmp	r2, r3
 8002e06:	d105      	bne.n	8002e14 <can_lld_set_filters.lto_priv.43+0x224>
    rccDisableCAN1(FALSE);
 8002e08:	4b04      	ldr	r3, [pc, #16]	; (8002e1c <can_lld_set_filters.lto_priv.43+0x22c>)
 8002e0a:	4a04      	ldr	r2, [pc, #16]	; (8002e1c <can_lld_set_filters.lto_priv.43+0x22c>)
 8002e0c:	69d2      	ldr	r2, [r2, #28]
 8002e0e:	4904      	ldr	r1, [pc, #16]	; (8002e20 <can_lld_set_filters.lto_priv.43+0x230>)
 8002e10:	400a      	ands	r2, r1
 8002e12:	61da      	str	r2, [r3, #28]
}
 8002e14:	b006      	add	sp, #24
 8002e16:	4770      	bx	lr
 8002e18:	20000578 	.word	0x20000578
 8002e1c:	40021000 	.word	0x40021000
 8002e20:	fdffffff 	.word	0xfdffffff
	...

08002e30 <port_lock.lto_priv.89>:
  __ASM volatile ("cpsid i" : : : "memory");
 8002e30:	b672      	cpsid	i
}
 8002e32:	4770      	bx	lr
	...

08002e40 <port_unlock.lto_priv.87>:
  __ASM volatile ("cpsie i" : : : "memory");
 8002e40:	b662      	cpsie	i
}
 8002e42:	4770      	bx	lr
	...

08002e50 <st_lld_get_counter>:
  return (systime_t)STM32_ST_TIM->CNT;
 8002e50:	2380      	movs	r3, #128	; 0x80
 8002e52:	05db      	lsls	r3, r3, #23
 8002e54:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8002e56:	0018      	movs	r0, r3
 8002e58:	4770      	bx	lr
 8002e5a:	46c0      	nop			; (mov r8, r8)
 8002e5c:	0000      	movs	r0, r0
	...

08002e60 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8002e60:	b510      	push	{r4, lr}

  return stGetCounter();
 8002e62:	f7ff fff5 	bl	8002e50 <st_lld_get_counter>
 8002e66:	0003      	movs	r3, r0
}
 8002e68:	0018      	movs	r0, r3
 8002e6a:	bd10      	pop	{r4, pc}
 8002e6c:	0000      	movs	r0, r0
	...

08002e70 <queue_init.lto_priv.85>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8002e70:	b082      	sub	sp, #8
 8002e72:	9001      	str	r0, [sp, #4]

  tqp->next = (thread_t *)tqp;
 8002e74:	9b01      	ldr	r3, [sp, #4]
 8002e76:	9a01      	ldr	r2, [sp, #4]
 8002e78:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8002e7a:	9b01      	ldr	r3, [sp, #4]
 8002e7c:	9a01      	ldr	r2, [sp, #4]
 8002e7e:	605a      	str	r2, [r3, #4]
}
 8002e80:	b002      	add	sp, #8
 8002e82:	4770      	bx	lr
	...

08002e90 <chSysLock.lto_priv.83>:
static inline void chSysLock(void) {
 8002e90:	b510      	push	{r4, lr}
  port_lock();
 8002e92:	f7ff ffcd 	bl	8002e30 <port_lock.lto_priv.89>
}
 8002e96:	bd10      	pop	{r4, pc}
	...

08002ea0 <chSysUnlock.lto_priv.81>:
static inline void chSysUnlock(void) {
 8002ea0:	b510      	push	{r4, lr}
  port_unlock();
 8002ea2:	f7ff ffcd 	bl	8002e40 <port_unlock.lto_priv.87>
}
 8002ea6:	bd10      	pop	{r4, pc}
	...

08002eb0 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8002eb0:	b510      	push	{r4, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8002eb2:	f7ff ffd5 	bl	8002e60 <port_timer_get_time>
 8002eb6:	0003      	movs	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8002eb8:	0018      	movs	r0, r3
 8002eba:	bd10      	pop	{r4, pc}
 8002ebc:	0000      	movs	r0, r0
	...

08002ec0 <chThdQueueObjectInit.lto_priv.79>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 8002ec0:	b500      	push	{lr}
 8002ec2:	b083      	sub	sp, #12
 8002ec4:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
 8002ec6:	9b01      	ldr	r3, [sp, #4]
 8002ec8:	0018      	movs	r0, r3
 8002eca:	f7ff ffd1 	bl	8002e70 <queue_init.lto_priv.85>
}
 8002ece:	b003      	add	sp, #12
 8002ed0:	bd00      	pop	{pc}
 8002ed2:	46c0      	nop			; (mov r8, r8)
	...

08002ee0 <osalSysLock.lto_priv.96>:
static inline void osalSysLock(void) {
 8002ee0:	b510      	push	{r4, lr}
  chSysLock();
 8002ee2:	f7ff ffd5 	bl	8002e90 <chSysLock.lto_priv.83>
}
 8002ee6:	bd10      	pop	{r4, pc}
	...

08002ef0 <osalSysUnlock.lto_priv.94>:
static inline void osalSysUnlock(void) {
 8002ef0:	b510      	push	{r4, lr}
  chSysUnlock();
 8002ef2:	f7ff ffd5 	bl	8002ea0 <chSysUnlock.lto_priv.81>
}
 8002ef6:	bd10      	pop	{r4, pc}
	...

08002f00 <osalOsGetSystemTimeX.lto_priv.92>:
static inline systime_t osalOsGetSystemTimeX(void) {
 8002f00:	b510      	push	{r4, lr}
  return chVTGetSystemTimeX();
 8002f02:	f7ff ffd5 	bl	8002eb0 <chVTGetSystemTimeX>
 8002f06:	0003      	movs	r3, r0
}
 8002f08:	0018      	movs	r0, r3
 8002f0a:	bd10      	pop	{r4, pc}
 8002f0c:	0000      	movs	r0, r0
	...

08002f10 <osalThreadQueueObjectInit.lto_priv.77>:
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
 8002f10:	b500      	push	{lr}
 8002f12:	b083      	sub	sp, #12
 8002f14:	9001      	str	r0, [sp, #4]
  chThdQueueObjectInit(tqp);
 8002f16:	9b01      	ldr	r3, [sp, #4]
 8002f18:	0018      	movs	r0, r3
 8002f1a:	f7ff ffd1 	bl	8002ec0 <chThdQueueObjectInit.lto_priv.79>
}
 8002f1e:	b003      	add	sp, #12
 8002f20:	bd00      	pop	{pc}
 8002f22:	46c0      	nop			; (mov r8, r8)
	...

08002f30 <osalThreadEnqueueTimeoutS.lto_priv.75>:
                                              systime_t time) {
 8002f30:	b500      	push	{lr}
 8002f32:	b083      	sub	sp, #12
 8002f34:	9001      	str	r0, [sp, #4]
 8002f36:	9100      	str	r1, [sp, #0]
  return chThdEnqueueTimeoutS(tqp, time);
 8002f38:	9a00      	ldr	r2, [sp, #0]
 8002f3a:	9b01      	ldr	r3, [sp, #4]
 8002f3c:	0011      	movs	r1, r2
 8002f3e:	0018      	movs	r0, r3
 8002f40:	f000 fda6 	bl	8003a90 <chThdEnqueueTimeoutS>
 8002f44:	0003      	movs	r3, r0
}
 8002f46:	0018      	movs	r0, r3
 8002f48:	b003      	add	sp, #12
 8002f4a:	bd00      	pop	{pc}
 8002f4c:	0000      	movs	r0, r0
	...

08002f50 <osalThreadDequeueNextI>:
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8002f50:	b500      	push	{lr}
 8002f52:	b083      	sub	sp, #12
 8002f54:	9001      	str	r0, [sp, #4]
 8002f56:	9100      	str	r1, [sp, #0]
  chThdDequeueNextI(tqp, msg);
 8002f58:	9a00      	ldr	r2, [sp, #0]
 8002f5a:	9b01      	ldr	r3, [sp, #4]
 8002f5c:	0011      	movs	r1, r2
 8002f5e:	0018      	movs	r0, r3
 8002f60:	f000 fdb6 	bl	8003ad0 <chThdDequeueNextI>
}
 8002f64:	b003      	add	sp, #12
 8002f66:	bd00      	pop	{pc}
	...

08002f70 <iqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
 8002f70:	b500      	push	{lr}
 8002f72:	b085      	sub	sp, #20
 8002f74:	9003      	str	r0, [sp, #12]
 8002f76:	9102      	str	r1, [sp, #8]
 8002f78:	9201      	str	r2, [sp, #4]
 8002f7a:	9300      	str	r3, [sp, #0]

  osalThreadQueueObjectInit(&iqp->q_waiting);
 8002f7c:	9b03      	ldr	r3, [sp, #12]
 8002f7e:	0018      	movs	r0, r3
 8002f80:	f7ff ffc6 	bl	8002f10 <osalThreadQueueObjectInit.lto_priv.77>
  iqp->q_counter = 0;
 8002f84:	9b03      	ldr	r3, [sp, #12]
 8002f86:	2200      	movs	r2, #0
 8002f88:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
 8002f8a:	9b03      	ldr	r3, [sp, #12]
 8002f8c:	9a02      	ldr	r2, [sp, #8]
 8002f8e:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
 8002f90:	9b03      	ldr	r3, [sp, #12]
 8002f92:	9a02      	ldr	r2, [sp, #8]
 8002f94:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
 8002f96:	9b03      	ldr	r3, [sp, #12]
 8002f98:	9a02      	ldr	r2, [sp, #8]
 8002f9a:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
 8002f9c:	9a02      	ldr	r2, [sp, #8]
 8002f9e:	9b01      	ldr	r3, [sp, #4]
 8002fa0:	18d2      	adds	r2, r2, r3
 8002fa2:	9b03      	ldr	r3, [sp, #12]
 8002fa4:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
 8002fa6:	9b03      	ldr	r3, [sp, #12]
 8002fa8:	9a00      	ldr	r2, [sp, #0]
 8002faa:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
 8002fac:	9b03      	ldr	r3, [sp, #12]
 8002fae:	9a06      	ldr	r2, [sp, #24]
 8002fb0:	621a      	str	r2, [r3, #32]
}
 8002fb2:	b005      	add	sp, #20
 8002fb4:	bd00      	pop	{pc}
 8002fb6:	46c0      	nop			; (mov r8, r8)
	...

08002fc0 <iqPutI>:
 * @retval MSG_TIMEOUT  if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
 8002fc0:	b500      	push	{lr}
 8002fc2:	b083      	sub	sp, #12
 8002fc4:	9001      	str	r0, [sp, #4]
 8002fc6:	000a      	movs	r2, r1
 8002fc8:	466b      	mov	r3, sp
 8002fca:	3303      	adds	r3, #3
 8002fcc:	701a      	strb	r2, [r3, #0]

  osalDbgCheckClassI();

  if (iqIsFullI(iqp)) {
 8002fce:	9b01      	ldr	r3, [sp, #4]
 8002fd0:	695a      	ldr	r2, [r3, #20]
 8002fd2:	9b01      	ldr	r3, [sp, #4]
 8002fd4:	699b      	ldr	r3, [r3, #24]
 8002fd6:	429a      	cmp	r2, r3
 8002fd8:	d105      	bne.n	8002fe6 <iqPutI+0x26>
 8002fda:	9b01      	ldr	r3, [sp, #4]
 8002fdc:	689b      	ldr	r3, [r3, #8]
 8002fde:	2b00      	cmp	r3, #0
 8002fe0:	d001      	beq.n	8002fe6 <iqPutI+0x26>
 8002fe2:	2301      	movs	r3, #1
 8002fe4:	e000      	b.n	8002fe8 <iqPutI+0x28>
 8002fe6:	2300      	movs	r3, #0
 8002fe8:	1c1a      	adds	r2, r3, #0
 8002fea:	2301      	movs	r3, #1
 8002fec:	4013      	ands	r3, r2
 8002fee:	b2db      	uxtb	r3, r3
 8002ff0:	2b00      	cmp	r3, #0
 8002ff2:	d002      	beq.n	8002ffa <iqPutI+0x3a>
    return MSG_TIMEOUT;
 8002ff4:	2301      	movs	r3, #1
 8002ff6:	425b      	negs	r3, r3
 8002ff8:	e01d      	b.n	8003036 <iqPutI+0x76>
  }

  iqp->q_counter++;
 8002ffa:	9b01      	ldr	r3, [sp, #4]
 8002ffc:	689b      	ldr	r3, [r3, #8]
 8002ffe:	1c5a      	adds	r2, r3, #1
 8003000:	9b01      	ldr	r3, [sp, #4]
 8003002:	609a      	str	r2, [r3, #8]
  *iqp->q_wrptr++ = b;
 8003004:	9b01      	ldr	r3, [sp, #4]
 8003006:	695b      	ldr	r3, [r3, #20]
 8003008:	1c59      	adds	r1, r3, #1
 800300a:	9a01      	ldr	r2, [sp, #4]
 800300c:	6151      	str	r1, [r2, #20]
 800300e:	466a      	mov	r2, sp
 8003010:	3203      	adds	r2, #3
 8003012:	7812      	ldrb	r2, [r2, #0]
 8003014:	701a      	strb	r2, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 8003016:	9b01      	ldr	r3, [sp, #4]
 8003018:	695a      	ldr	r2, [r3, #20]
 800301a:	9b01      	ldr	r3, [sp, #4]
 800301c:	691b      	ldr	r3, [r3, #16]
 800301e:	429a      	cmp	r2, r3
 8003020:	d303      	bcc.n	800302a <iqPutI+0x6a>
    iqp->q_wrptr = iqp->q_buffer;
 8003022:	9b01      	ldr	r3, [sp, #4]
 8003024:	68da      	ldr	r2, [r3, #12]
 8003026:	9b01      	ldr	r3, [sp, #4]
 8003028:	615a      	str	r2, [r3, #20]
  }

  osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
 800302a:	9b01      	ldr	r3, [sp, #4]
 800302c:	2100      	movs	r1, #0
 800302e:	0018      	movs	r0, r3
 8003030:	f7ff ff8e 	bl	8002f50 <osalThreadDequeueNextI>

  return MSG_OK;
 8003034:	2300      	movs	r3, #0
}
 8003036:	0018      	movs	r0, r3
 8003038:	b003      	add	sp, #12
 800303a:	bd00      	pop	{pc}
 800303c:	0000      	movs	r0, r0
	...

08003040 <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8003040:	b500      	push	{lr}
 8003042:	b085      	sub	sp, #20
 8003044:	9001      	str	r0, [sp, #4]
 8003046:	9100      	str	r1, [sp, #0]
  uint8_t b;

  osalSysLock();
 8003048:	f7ff ff4a 	bl	8002ee0 <osalSysLock.lto_priv.96>
 800304c:	e00e      	b.n	800306c <iqGetTimeout+0x2c>

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
 800304e:	9b01      	ldr	r3, [sp, #4]
 8003050:	9a00      	ldr	r2, [sp, #0]
 8003052:	0011      	movs	r1, r2
 8003054:	0018      	movs	r0, r3
 8003056:	f7ff ff6b 	bl	8002f30 <osalThreadEnqueueTimeoutS.lto_priv.75>
 800305a:	0003      	movs	r3, r0
 800305c:	9303      	str	r3, [sp, #12]
    if (msg < MSG_OK) {
 800305e:	9b03      	ldr	r3, [sp, #12]
 8003060:	2b00      	cmp	r3, #0
 8003062:	da03      	bge.n	800306c <iqGetTimeout+0x2c>
      osalSysUnlock();
 8003064:	f7ff ff44 	bl	8002ef0 <osalSysUnlock.lto_priv.94>
      return msg;
 8003068:	9b03      	ldr	r3, [sp, #12]
 800306a:	e029      	b.n	80030c0 <iqGetTimeout+0x80>
  while (iqIsEmptyI(iqp)) {
 800306c:	9b01      	ldr	r3, [sp, #4]
 800306e:	689b      	ldr	r3, [r3, #8]
 8003070:	2b00      	cmp	r3, #0
 8003072:	d0ec      	beq.n	800304e <iqGetTimeout+0xe>
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 8003074:	9b01      	ldr	r3, [sp, #4]
 8003076:	689b      	ldr	r3, [r3, #8]
 8003078:	1e5a      	subs	r2, r3, #1
 800307a:	9b01      	ldr	r3, [sp, #4]
 800307c:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
 800307e:	9b01      	ldr	r3, [sp, #4]
 8003080:	699b      	ldr	r3, [r3, #24]
 8003082:	1c59      	adds	r1, r3, #1
 8003084:	9a01      	ldr	r2, [sp, #4]
 8003086:	6191      	str	r1, [r2, #24]
 8003088:	220b      	movs	r2, #11
 800308a:	446a      	add	r2, sp
 800308c:	781b      	ldrb	r3, [r3, #0]
 800308e:	7013      	strb	r3, [r2, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
 8003090:	9b01      	ldr	r3, [sp, #4]
 8003092:	699a      	ldr	r2, [r3, #24]
 8003094:	9b01      	ldr	r3, [sp, #4]
 8003096:	691b      	ldr	r3, [r3, #16]
 8003098:	429a      	cmp	r2, r3
 800309a:	d303      	bcc.n	80030a4 <iqGetTimeout+0x64>
    iqp->q_rdptr = iqp->q_buffer;
 800309c:	9b01      	ldr	r3, [sp, #4]
 800309e:	68da      	ldr	r2, [r3, #12]
 80030a0:	9b01      	ldr	r3, [sp, #4]
 80030a2:	619a      	str	r2, [r3, #24]
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
 80030a4:	9b01      	ldr	r3, [sp, #4]
 80030a6:	69db      	ldr	r3, [r3, #28]
 80030a8:	2b00      	cmp	r3, #0
 80030aa:	d004      	beq.n	80030b6 <iqGetTimeout+0x76>
    iqp->q_notify(iqp);
 80030ac:	9b01      	ldr	r3, [sp, #4]
 80030ae:	69db      	ldr	r3, [r3, #28]
 80030b0:	9a01      	ldr	r2, [sp, #4]
 80030b2:	0010      	movs	r0, r2
 80030b4:	4798      	blx	r3
  }

  osalSysUnlock();
 80030b6:	f7ff ff1b 	bl	8002ef0 <osalSysUnlock.lto_priv.94>

  return (msg_t)b;
 80030ba:	230b      	movs	r3, #11
 80030bc:	446b      	add	r3, sp
 80030be:	781b      	ldrb	r3, [r3, #0]
}
 80030c0:	0018      	movs	r0, r3
 80030c2:	b005      	add	sp, #20
 80030c4:	bd00      	pop	{pc}
 80030c6:	46c0      	nop			; (mov r8, r8)
	...

080030d0 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
 80030d0:	b500      	push	{lr}
 80030d2:	b08b      	sub	sp, #44	; 0x2c
 80030d4:	9003      	str	r0, [sp, #12]
 80030d6:	9102      	str	r1, [sp, #8]
 80030d8:	9201      	str	r2, [sp, #4]
 80030da:	9300      	str	r3, [sp, #0]
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
 80030dc:	9b03      	ldr	r3, [sp, #12]
 80030de:	69db      	ldr	r3, [r3, #28]
 80030e0:	9307      	str	r3, [sp, #28]
  size_t r = 0;
 80030e2:	2300      	movs	r3, #0
 80030e4:	9309      	str	r3, [sp, #36]	; 0x24

  osalDbgCheck(n > 0U);

  osalSysLock();
 80030e6:	f7ff fefb 	bl	8002ee0 <osalSysLock.lto_priv.96>

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 80030ea:	f7ff ff09 	bl	8002f00 <osalOsGetSystemTimeX.lto_priv.92>
 80030ee:	0002      	movs	r2, r0
 80030f0:	9b00      	ldr	r3, [sp, #0]
 80030f2:	18d3      	adds	r3, r2, r3
 80030f4:	9306      	str	r3, [sp, #24]
 80030f6:	e02b      	b.n	8003150 <iqReadTimeout+0x80>
    while (iqIsEmptyI(iqp)) {
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 80030f8:	9b00      	ldr	r3, [sp, #0]
 80030fa:	3301      	adds	r3, #1
 80030fc:	d002      	beq.n	8003104 <iqReadTimeout+0x34>
 80030fe:	9b00      	ldr	r3, [sp, #0]
 8003100:	2b00      	cmp	r3, #0
 8003102:	d108      	bne.n	8003116 <iqReadTimeout+0x46>
        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8003104:	9b03      	ldr	r3, [sp, #12]
 8003106:	9a00      	ldr	r2, [sp, #0]
 8003108:	0011      	movs	r1, r2
 800310a:	0018      	movs	r0, r3
 800310c:	f7ff ff10 	bl	8002f30 <osalThreadEnqueueTimeoutS.lto_priv.75>
 8003110:	0003      	movs	r3, r0
 8003112:	9308      	str	r3, [sp, #32]
 8003114:	e015      	b.n	8003142 <iqReadTimeout+0x72>
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8003116:	f7ff fef3 	bl	8002f00 <osalOsGetSystemTimeX.lto_priv.92>
 800311a:	0002      	movs	r2, r0
 800311c:	9b06      	ldr	r3, [sp, #24]
 800311e:	1a9b      	subs	r3, r3, r2
 8003120:	9305      	str	r3, [sp, #20]

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 8003122:	9a05      	ldr	r2, [sp, #20]
 8003124:	9b00      	ldr	r3, [sp, #0]
 8003126:	429a      	cmp	r2, r3
 8003128:	d903      	bls.n	8003132 <iqReadTimeout+0x62>
          osalSysUnlock();
 800312a:	f7ff fee1 	bl	8002ef0 <osalSysUnlock.lto_priv.94>
          return r;
 800312e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8003130:	e042      	b.n	80031b8 <iqReadTimeout+0xe8>
        }

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
 8003132:	9b03      	ldr	r3, [sp, #12]
 8003134:	9a05      	ldr	r2, [sp, #20]
 8003136:	0011      	movs	r1, r2
 8003138:	0018      	movs	r0, r3
 800313a:	f7ff fef9 	bl	8002f30 <osalThreadEnqueueTimeoutS.lto_priv.75>
 800313e:	0003      	movs	r3, r0
 8003140:	9308      	str	r3, [sp, #32]
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8003142:	9b08      	ldr	r3, [sp, #32]
 8003144:	2b00      	cmp	r3, #0
 8003146:	d003      	beq.n	8003150 <iqReadTimeout+0x80>
        osalSysUnlock();
 8003148:	f7ff fed2 	bl	8002ef0 <osalSysUnlock.lto_priv.94>
        return r;
 800314c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800314e:	e033      	b.n	80031b8 <iqReadTimeout+0xe8>
    while (iqIsEmptyI(iqp)) {
 8003150:	9b03      	ldr	r3, [sp, #12]
 8003152:	689b      	ldr	r3, [r3, #8]
 8003154:	2b00      	cmp	r3, #0
 8003156:	d0cf      	beq.n	80030f8 <iqReadTimeout+0x28>
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 8003158:	9b03      	ldr	r3, [sp, #12]
 800315a:	689b      	ldr	r3, [r3, #8]
 800315c:	1e5a      	subs	r2, r3, #1
 800315e:	9b03      	ldr	r3, [sp, #12]
 8003160:	609a      	str	r2, [r3, #8]
    *bp++ = *iqp->q_rdptr++;
 8003162:	9b02      	ldr	r3, [sp, #8]
 8003164:	1c5a      	adds	r2, r3, #1
 8003166:	9202      	str	r2, [sp, #8]
 8003168:	9a03      	ldr	r2, [sp, #12]
 800316a:	6992      	ldr	r2, [r2, #24]
 800316c:	1c50      	adds	r0, r2, #1
 800316e:	9903      	ldr	r1, [sp, #12]
 8003170:	6188      	str	r0, [r1, #24]
 8003172:	7812      	ldrb	r2, [r2, #0]
 8003174:	701a      	strb	r2, [r3, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
 8003176:	9b03      	ldr	r3, [sp, #12]
 8003178:	699a      	ldr	r2, [r3, #24]
 800317a:	9b03      	ldr	r3, [sp, #12]
 800317c:	691b      	ldr	r3, [r3, #16]
 800317e:	429a      	cmp	r2, r3
 8003180:	d303      	bcc.n	800318a <iqReadTimeout+0xba>
      iqp->q_rdptr = iqp->q_buffer;
 8003182:	9b03      	ldr	r3, [sp, #12]
 8003184:	68da      	ldr	r2, [r3, #12]
 8003186:	9b03      	ldr	r3, [sp, #12]
 8003188:	619a      	str	r2, [r3, #24]
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
 800318a:	9b07      	ldr	r3, [sp, #28]
 800318c:	2b00      	cmp	r3, #0
 800318e:	d003      	beq.n	8003198 <iqReadTimeout+0xc8>
      nfy(iqp);
 8003190:	9a03      	ldr	r2, [sp, #12]
 8003192:	9b07      	ldr	r3, [sp, #28]
 8003194:	0010      	movs	r0, r2
 8003196:	4798      	blx	r3
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
 8003198:	f7ff feaa 	bl	8002ef0 <osalSysUnlock.lto_priv.94>

    r++;
 800319c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800319e:	3301      	adds	r3, #1
 80031a0:	9309      	str	r3, [sp, #36]	; 0x24
    if (--n == 0U) {
 80031a2:	9b01      	ldr	r3, [sp, #4]
 80031a4:	3b01      	subs	r3, #1
 80031a6:	9301      	str	r3, [sp, #4]
 80031a8:	9b01      	ldr	r3, [sp, #4]
 80031aa:	2b00      	cmp	r3, #0
 80031ac:	d101      	bne.n	80031b2 <iqReadTimeout+0xe2>
      return r;
 80031ae:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80031b0:	e002      	b.n	80031b8 <iqReadTimeout+0xe8>
    }

    osalSysLock();
 80031b2:	f7ff fe95 	bl	8002ee0 <osalSysLock.lto_priv.96>
 80031b6:	e7cb      	b.n	8003150 <iqReadTimeout+0x80>
  }
}
 80031b8:	0018      	movs	r0, r3
 80031ba:	b00b      	add	sp, #44	; 0x2c
 80031bc:	bd00      	pop	{pc}
 80031be:	46c0      	nop			; (mov r8, r8)

080031c0 <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
 80031c0:	b500      	push	{lr}
 80031c2:	b085      	sub	sp, #20
 80031c4:	9003      	str	r0, [sp, #12]
 80031c6:	9102      	str	r1, [sp, #8]
 80031c8:	9201      	str	r2, [sp, #4]
 80031ca:	9300      	str	r3, [sp, #0]

  osalThreadQueueObjectInit(&oqp->q_waiting);
 80031cc:	9b03      	ldr	r3, [sp, #12]
 80031ce:	0018      	movs	r0, r3
 80031d0:	f7ff fe9e 	bl	8002f10 <osalThreadQueueObjectInit.lto_priv.77>
  oqp->q_counter = size;
 80031d4:	9b03      	ldr	r3, [sp, #12]
 80031d6:	9a01      	ldr	r2, [sp, #4]
 80031d8:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
 80031da:	9b03      	ldr	r3, [sp, #12]
 80031dc:	9a02      	ldr	r2, [sp, #8]
 80031de:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
 80031e0:	9b03      	ldr	r3, [sp, #12]
 80031e2:	9a02      	ldr	r2, [sp, #8]
 80031e4:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
 80031e6:	9b03      	ldr	r3, [sp, #12]
 80031e8:	9a02      	ldr	r2, [sp, #8]
 80031ea:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
 80031ec:	9a02      	ldr	r2, [sp, #8]
 80031ee:	9b01      	ldr	r3, [sp, #4]
 80031f0:	18d2      	adds	r2, r2, r3
 80031f2:	9b03      	ldr	r3, [sp, #12]
 80031f4:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
 80031f6:	9b03      	ldr	r3, [sp, #12]
 80031f8:	9a00      	ldr	r2, [sp, #0]
 80031fa:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
 80031fc:	9b03      	ldr	r3, [sp, #12]
 80031fe:	9a06      	ldr	r2, [sp, #24]
 8003200:	621a      	str	r2, [r3, #32]
}
 8003202:	b005      	add	sp, #20
 8003204:	bd00      	pop	{pc}
 8003206:	46c0      	nop			; (mov r8, r8)
	...

08003210 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8003210:	b500      	push	{lr}
 8003212:	b087      	sub	sp, #28
 8003214:	9003      	str	r0, [sp, #12]
 8003216:	9201      	str	r2, [sp, #4]
 8003218:	230b      	movs	r3, #11
 800321a:	446b      	add	r3, sp
 800321c:	1c0a      	adds	r2, r1, #0
 800321e:	701a      	strb	r2, [r3, #0]

  osalSysLock();
 8003220:	f7ff fe5e 	bl	8002ee0 <osalSysLock.lto_priv.96>
 8003224:	e00e      	b.n	8003244 <oqPutTimeout+0x34>

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8003226:	9b03      	ldr	r3, [sp, #12]
 8003228:	9a01      	ldr	r2, [sp, #4]
 800322a:	0011      	movs	r1, r2
 800322c:	0018      	movs	r0, r3
 800322e:	f7ff fe7f 	bl	8002f30 <osalThreadEnqueueTimeoutS.lto_priv.75>
 8003232:	0003      	movs	r3, r0
 8003234:	9305      	str	r3, [sp, #20]
    if (msg < MSG_OK) {
 8003236:	9b05      	ldr	r3, [sp, #20]
 8003238:	2b00      	cmp	r3, #0
 800323a:	da03      	bge.n	8003244 <oqPutTimeout+0x34>
      osalSysUnlock();
 800323c:	f7ff fe58 	bl	8002ef0 <osalSysUnlock.lto_priv.94>
      return msg;
 8003240:	9b05      	ldr	r3, [sp, #20]
 8003242:	e027      	b.n	8003294 <oqPutTimeout+0x84>
  while (oqIsFullI(oqp)) {
 8003244:	9b03      	ldr	r3, [sp, #12]
 8003246:	689b      	ldr	r3, [r3, #8]
 8003248:	2b00      	cmp	r3, #0
 800324a:	d0ec      	beq.n	8003226 <oqPutTimeout+0x16>
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 800324c:	9b03      	ldr	r3, [sp, #12]
 800324e:	689b      	ldr	r3, [r3, #8]
 8003250:	1e5a      	subs	r2, r3, #1
 8003252:	9b03      	ldr	r3, [sp, #12]
 8003254:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
 8003256:	9b03      	ldr	r3, [sp, #12]
 8003258:	695b      	ldr	r3, [r3, #20]
 800325a:	1c59      	adds	r1, r3, #1
 800325c:	9a03      	ldr	r2, [sp, #12]
 800325e:	6151      	str	r1, [r2, #20]
 8003260:	220b      	movs	r2, #11
 8003262:	446a      	add	r2, sp
 8003264:	7812      	ldrb	r2, [r2, #0]
 8003266:	701a      	strb	r2, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8003268:	9b03      	ldr	r3, [sp, #12]
 800326a:	695a      	ldr	r2, [r3, #20]
 800326c:	9b03      	ldr	r3, [sp, #12]
 800326e:	691b      	ldr	r3, [r3, #16]
 8003270:	429a      	cmp	r2, r3
 8003272:	d303      	bcc.n	800327c <oqPutTimeout+0x6c>
    oqp->q_wrptr = oqp->q_buffer;
 8003274:	9b03      	ldr	r3, [sp, #12]
 8003276:	68da      	ldr	r2, [r3, #12]
 8003278:	9b03      	ldr	r3, [sp, #12]
 800327a:	615a      	str	r2, [r3, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 800327c:	9b03      	ldr	r3, [sp, #12]
 800327e:	69db      	ldr	r3, [r3, #28]
 8003280:	2b00      	cmp	r3, #0
 8003282:	d004      	beq.n	800328e <oqPutTimeout+0x7e>
    oqp->q_notify(oqp);
 8003284:	9b03      	ldr	r3, [sp, #12]
 8003286:	69db      	ldr	r3, [r3, #28]
 8003288:	9a03      	ldr	r2, [sp, #12]
 800328a:	0010      	movs	r0, r2
 800328c:	4798      	blx	r3
  }

  osalSysUnlock();
 800328e:	f7ff fe2f 	bl	8002ef0 <osalSysUnlock.lto_priv.94>

  return MSG_OK;
 8003292:	2300      	movs	r3, #0
}
 8003294:	0018      	movs	r0, r3
 8003296:	b007      	add	sp, #28
 8003298:	bd00      	pop	{pc}
 800329a:	46c0      	nop			; (mov r8, r8)
 800329c:	0000      	movs	r0, r0
	...

080032a0 <oqGetI>:
 * @return              The byte value from the queue.
 * @retval MSG_TIMEOUT  if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
 80032a0:	b500      	push	{lr}
 80032a2:	b085      	sub	sp, #20
 80032a4:	9001      	str	r0, [sp, #4]
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp)) {
 80032a6:	9b01      	ldr	r3, [sp, #4]
 80032a8:	695a      	ldr	r2, [r3, #20]
 80032aa:	9b01      	ldr	r3, [sp, #4]
 80032ac:	699b      	ldr	r3, [r3, #24]
 80032ae:	429a      	cmp	r2, r3
 80032b0:	d105      	bne.n	80032be <oqGetI+0x1e>
 80032b2:	9b01      	ldr	r3, [sp, #4]
 80032b4:	689b      	ldr	r3, [r3, #8]
 80032b6:	2b00      	cmp	r3, #0
 80032b8:	d001      	beq.n	80032be <oqGetI+0x1e>
 80032ba:	2301      	movs	r3, #1
 80032bc:	e000      	b.n	80032c0 <oqGetI+0x20>
 80032be:	2300      	movs	r3, #0
 80032c0:	1c1a      	adds	r2, r3, #0
 80032c2:	2301      	movs	r3, #1
 80032c4:	4013      	ands	r3, r2
 80032c6:	b2db      	uxtb	r3, r3
 80032c8:	2b00      	cmp	r3, #0
 80032ca:	d002      	beq.n	80032d2 <oqGetI+0x32>
    return MSG_TIMEOUT;
 80032cc:	2301      	movs	r3, #1
 80032ce:	425b      	negs	r3, r3
 80032d0:	e01f      	b.n	8003312 <oqGetI+0x72>
  }

  oqp->q_counter++;
 80032d2:	9b01      	ldr	r3, [sp, #4]
 80032d4:	689b      	ldr	r3, [r3, #8]
 80032d6:	1c5a      	adds	r2, r3, #1
 80032d8:	9b01      	ldr	r3, [sp, #4]
 80032da:	609a      	str	r2, [r3, #8]
  b = *oqp->q_rdptr++;
 80032dc:	9b01      	ldr	r3, [sp, #4]
 80032de:	699b      	ldr	r3, [r3, #24]
 80032e0:	1c59      	adds	r1, r3, #1
 80032e2:	9a01      	ldr	r2, [sp, #4]
 80032e4:	6191      	str	r1, [r2, #24]
 80032e6:	220f      	movs	r2, #15
 80032e8:	446a      	add	r2, sp
 80032ea:	781b      	ldrb	r3, [r3, #0]
 80032ec:	7013      	strb	r3, [r2, #0]
  if (oqp->q_rdptr >= oqp->q_top) {
 80032ee:	9b01      	ldr	r3, [sp, #4]
 80032f0:	699a      	ldr	r2, [r3, #24]
 80032f2:	9b01      	ldr	r3, [sp, #4]
 80032f4:	691b      	ldr	r3, [r3, #16]
 80032f6:	429a      	cmp	r2, r3
 80032f8:	d303      	bcc.n	8003302 <oqGetI+0x62>
    oqp->q_rdptr = oqp->q_buffer;
 80032fa:	9b01      	ldr	r3, [sp, #4]
 80032fc:	68da      	ldr	r2, [r3, #12]
 80032fe:	9b01      	ldr	r3, [sp, #4]
 8003300:	619a      	str	r2, [r3, #24]
  }

  osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);
 8003302:	9b01      	ldr	r3, [sp, #4]
 8003304:	2100      	movs	r1, #0
 8003306:	0018      	movs	r0, r3
 8003308:	f7ff fe22 	bl	8002f50 <osalThreadDequeueNextI>

  return (msg_t)b;
 800330c:	230f      	movs	r3, #15
 800330e:	446b      	add	r3, sp
 8003310:	781b      	ldrb	r3, [r3, #0]
}
 8003312:	0018      	movs	r0, r3
 8003314:	b005      	add	sp, #20
 8003316:	bd00      	pop	{pc}
	...

08003320 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
 8003320:	b500      	push	{lr}
 8003322:	b08b      	sub	sp, #44	; 0x2c
 8003324:	9003      	str	r0, [sp, #12]
 8003326:	9102      	str	r1, [sp, #8]
 8003328:	9201      	str	r2, [sp, #4]
 800332a:	9300      	str	r3, [sp, #0]
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
 800332c:	9b03      	ldr	r3, [sp, #12]
 800332e:	69db      	ldr	r3, [r3, #28]
 8003330:	9307      	str	r3, [sp, #28]
  size_t w = 0;
 8003332:	2300      	movs	r3, #0
 8003334:	9309      	str	r3, [sp, #36]	; 0x24

  osalDbgCheck(n > 0U);

  osalSysLock();
 8003336:	f7ff fdd3 	bl	8002ee0 <osalSysLock.lto_priv.96>

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 800333a:	f7ff fde1 	bl	8002f00 <osalOsGetSystemTimeX.lto_priv.92>
 800333e:	0002      	movs	r2, r0
 8003340:	9b00      	ldr	r3, [sp, #0]
 8003342:	18d3      	adds	r3, r2, r3
 8003344:	9306      	str	r3, [sp, #24]
 8003346:	e02b      	b.n	80033a0 <oqWriteTimeout+0x80>
    msg_t msg;

    while (oqIsFullI(oqp)) {
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8003348:	9b00      	ldr	r3, [sp, #0]
 800334a:	3301      	adds	r3, #1
 800334c:	d002      	beq.n	8003354 <oqWriteTimeout+0x34>
 800334e:	9b00      	ldr	r3, [sp, #0]
 8003350:	2b00      	cmp	r3, #0
 8003352:	d108      	bne.n	8003366 <oqWriteTimeout+0x46>
        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8003354:	9b03      	ldr	r3, [sp, #12]
 8003356:	9a00      	ldr	r2, [sp, #0]
 8003358:	0011      	movs	r1, r2
 800335a:	0018      	movs	r0, r3
 800335c:	f7ff fde8 	bl	8002f30 <osalThreadEnqueueTimeoutS.lto_priv.75>
 8003360:	0003      	movs	r3, r0
 8003362:	9308      	str	r3, [sp, #32]
 8003364:	e015      	b.n	8003392 <oqWriteTimeout+0x72>
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8003366:	f7ff fdcb 	bl	8002f00 <osalOsGetSystemTimeX.lto_priv.92>
 800336a:	0002      	movs	r2, r0
 800336c:	9b06      	ldr	r3, [sp, #24]
 800336e:	1a9b      	subs	r3, r3, r2
 8003370:	9305      	str	r3, [sp, #20]

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 8003372:	9a05      	ldr	r2, [sp, #20]
 8003374:	9b00      	ldr	r3, [sp, #0]
 8003376:	429a      	cmp	r2, r3
 8003378:	d903      	bls.n	8003382 <oqWriteTimeout+0x62>
          osalSysUnlock();
 800337a:	f7ff fdb9 	bl	8002ef0 <osalSysUnlock.lto_priv.94>
          return w;
 800337e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8003380:	e042      	b.n	8003408 <oqWriteTimeout+0xe8>
        }

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
 8003382:	9b03      	ldr	r3, [sp, #12]
 8003384:	9a05      	ldr	r2, [sp, #20]
 8003386:	0011      	movs	r1, r2
 8003388:	0018      	movs	r0, r3
 800338a:	f7ff fdd1 	bl	8002f30 <osalThreadEnqueueTimeoutS.lto_priv.75>
 800338e:	0003      	movs	r3, r0
 8003390:	9308      	str	r3, [sp, #32]
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8003392:	9b08      	ldr	r3, [sp, #32]
 8003394:	2b00      	cmp	r3, #0
 8003396:	d003      	beq.n	80033a0 <oqWriteTimeout+0x80>
        osalSysUnlock();
 8003398:	f7ff fdaa 	bl	8002ef0 <osalSysUnlock.lto_priv.94>
        return w;
 800339c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800339e:	e033      	b.n	8003408 <oqWriteTimeout+0xe8>
    while (oqIsFullI(oqp)) {
 80033a0:	9b03      	ldr	r3, [sp, #12]
 80033a2:	689b      	ldr	r3, [r3, #8]
 80033a4:	2b00      	cmp	r3, #0
 80033a6:	d0cf      	beq.n	8003348 <oqWriteTimeout+0x28>
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 80033a8:	9b03      	ldr	r3, [sp, #12]
 80033aa:	689b      	ldr	r3, [r3, #8]
 80033ac:	1e5a      	subs	r2, r3, #1
 80033ae:	9b03      	ldr	r3, [sp, #12]
 80033b0:	609a      	str	r2, [r3, #8]
    *oqp->q_wrptr++ = *bp++;
 80033b2:	9b03      	ldr	r3, [sp, #12]
 80033b4:	695b      	ldr	r3, [r3, #20]
 80033b6:	1c59      	adds	r1, r3, #1
 80033b8:	9a03      	ldr	r2, [sp, #12]
 80033ba:	6151      	str	r1, [r2, #20]
 80033bc:	9a02      	ldr	r2, [sp, #8]
 80033be:	1c51      	adds	r1, r2, #1
 80033c0:	9102      	str	r1, [sp, #8]
 80033c2:	7812      	ldrb	r2, [r2, #0]
 80033c4:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 80033c6:	9b03      	ldr	r3, [sp, #12]
 80033c8:	695a      	ldr	r2, [r3, #20]
 80033ca:	9b03      	ldr	r3, [sp, #12]
 80033cc:	691b      	ldr	r3, [r3, #16]
 80033ce:	429a      	cmp	r2, r3
 80033d0:	d303      	bcc.n	80033da <oqWriteTimeout+0xba>
      oqp->q_wrptr = oqp->q_buffer;
 80033d2:	9b03      	ldr	r3, [sp, #12]
 80033d4:	68da      	ldr	r2, [r3, #12]
 80033d6:	9b03      	ldr	r3, [sp, #12]
 80033d8:	615a      	str	r2, [r3, #20]
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
 80033da:	9b07      	ldr	r3, [sp, #28]
 80033dc:	2b00      	cmp	r3, #0
 80033de:	d003      	beq.n	80033e8 <oqWriteTimeout+0xc8>
      nfy(oqp);
 80033e0:	9a03      	ldr	r2, [sp, #12]
 80033e2:	9b07      	ldr	r3, [sp, #28]
 80033e4:	0010      	movs	r0, r2
 80033e6:	4798      	blx	r3
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
 80033e8:	f7ff fd82 	bl	8002ef0 <osalSysUnlock.lto_priv.94>

    w++;
 80033ec:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80033ee:	3301      	adds	r3, #1
 80033f0:	9309      	str	r3, [sp, #36]	; 0x24
    if (--n == 0U) {
 80033f2:	9b01      	ldr	r3, [sp, #4]
 80033f4:	3b01      	subs	r3, #1
 80033f6:	9301      	str	r3, [sp, #4]
 80033f8:	9b01      	ldr	r3, [sp, #4]
 80033fa:	2b00      	cmp	r3, #0
 80033fc:	d101      	bne.n	8003402 <oqWriteTimeout+0xe2>
      return w;
 80033fe:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8003400:	e002      	b.n	8003408 <oqWriteTimeout+0xe8>
    }

    osalSysLock();
 8003402:	f7ff fd6d 	bl	8002ee0 <osalSysLock.lto_priv.96>
 8003406:	e7cb      	b.n	80033a0 <oqWriteTimeout+0x80>
  }
}
 8003408:	0018      	movs	r0, r3
 800340a:	b00b      	add	sp, #44	; 0x2c
 800340c:	bd00      	pop	{pc}
 800340e:	46c0      	nop			; (mov r8, r8)

08003410 <port_lock.lto_priv.90>:
  __ASM volatile ("cpsid i" : : : "memory");
 8003410:	b672      	cpsid	i
}
 8003412:	4770      	bx	lr
	...

08003420 <port_unlock.lto_priv.88>:
  __ASM volatile ("cpsie i" : : : "memory");
 8003420:	b662      	cpsie	i
}
 8003422:	4770      	bx	lr
	...

08003430 <queue_init.lto_priv.86>:
static inline void queue_init(threads_queue_t *tqp) {
 8003430:	b082      	sub	sp, #8
 8003432:	9001      	str	r0, [sp, #4]
  tqp->next = (thread_t *)tqp;
 8003434:	9b01      	ldr	r3, [sp, #4]
 8003436:	9a01      	ldr	r2, [sp, #4]
 8003438:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800343a:	9b01      	ldr	r3, [sp, #4]
 800343c:	9a01      	ldr	r2, [sp, #4]
 800343e:	605a      	str	r2, [r3, #4]
}
 8003440:	b002      	add	sp, #8
 8003442:	4770      	bx	lr
	...

08003450 <chSysLock.lto_priv.84>:
static inline void chSysLock(void) {
 8003450:	b510      	push	{r4, lr}
  port_lock();
 8003452:	f7ff ffdd 	bl	8003410 <port_lock.lto_priv.90>
}
 8003456:	bd10      	pop	{r4, pc}
	...

08003460 <chSysUnlock.lto_priv.82>:
static inline void chSysUnlock(void) {
 8003460:	b510      	push	{r4, lr}
  port_unlock();
 8003462:	f7ff ffdd 	bl	8003420 <port_unlock.lto_priv.88>
}
 8003466:	bd10      	pop	{r4, pc}
	...

08003470 <chThdQueueObjectInit.lto_priv.80>:
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 8003470:	b500      	push	{lr}
 8003472:	b083      	sub	sp, #12
 8003474:	9001      	str	r0, [sp, #4]
  queue_init(tqp);
 8003476:	9b01      	ldr	r3, [sp, #4]
 8003478:	0018      	movs	r0, r3
 800347a:	f7ff ffd9 	bl	8003430 <queue_init.lto_priv.86>
}
 800347e:	b003      	add	sp, #12
 8003480:	bd00      	pop	{pc}
 8003482:	46c0      	nop			; (mov r8, r8)
	...

08003490 <chEvtObjectInit>:
static inline void chEvtObjectInit(event_source_t *esp) {
 8003490:	b082      	sub	sp, #8
 8003492:	9001      	str	r0, [sp, #4]
  esp->next = (event_listener_t *)esp;
 8003494:	9b01      	ldr	r3, [sp, #4]
 8003496:	9a01      	ldr	r2, [sp, #4]
 8003498:	601a      	str	r2, [r3, #0]
}
 800349a:	b002      	add	sp, #8
 800349c:	4770      	bx	lr
 800349e:	46c0      	nop			; (mov r8, r8)

080034a0 <osalSysLock.lto_priv.63>:
static inline void osalSysLock(void) {
 80034a0:	b510      	push	{r4, lr}
  chSysLock();
 80034a2:	f7ff ffd5 	bl	8003450 <chSysLock.lto_priv.84>
}
 80034a6:	bd10      	pop	{r4, pc}
	...

080034b0 <osalSysUnlock.lto_priv.59>:
static inline void osalSysUnlock(void) {
 80034b0:	b510      	push	{r4, lr}
  chSysUnlock();
 80034b2:	f7ff ffd5 	bl	8003460 <chSysUnlock.lto_priv.82>
}
 80034b6:	bd10      	pop	{r4, pc}
	...

080034c0 <osalThreadQueueObjectInit.lto_priv.78>:
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
 80034c0:	b500      	push	{lr}
 80034c2:	b083      	sub	sp, #12
 80034c4:	9001      	str	r0, [sp, #4]
  chThdQueueObjectInit(tqp);
 80034c6:	9b01      	ldr	r3, [sp, #4]
 80034c8:	0018      	movs	r0, r3
 80034ca:	f7ff ffd1 	bl	8003470 <chThdQueueObjectInit.lto_priv.80>
}
 80034ce:	b003      	add	sp, #12
 80034d0:	bd00      	pop	{pc}
 80034d2:	46c0      	nop			; (mov r8, r8)
	...

080034e0 <osalThreadEnqueueTimeoutS.lto_priv.76>:
                                              systime_t time) {
 80034e0:	b500      	push	{lr}
 80034e2:	b083      	sub	sp, #12
 80034e4:	9001      	str	r0, [sp, #4]
 80034e6:	9100      	str	r1, [sp, #0]
  return chThdEnqueueTimeoutS(tqp, time);
 80034e8:	9a00      	ldr	r2, [sp, #0]
 80034ea:	9b01      	ldr	r3, [sp, #4]
 80034ec:	0011      	movs	r1, r2
 80034ee:	0018      	movs	r0, r3
 80034f0:	f000 face 	bl	8003a90 <chThdEnqueueTimeoutS>
 80034f4:	0003      	movs	r3, r0
}
 80034f6:	0018      	movs	r0, r3
 80034f8:	b003      	add	sp, #12
 80034fa:	bd00      	pop	{pc}
 80034fc:	0000      	movs	r0, r0
	...

08003500 <osalEventObjectInit>:
static inline void osalEventObjectInit(event_source_t *esp) {
 8003500:	b500      	push	{lr}
 8003502:	b083      	sub	sp, #12
 8003504:	9001      	str	r0, [sp, #4]
  chEvtObjectInit(esp);
 8003506:	9b01      	ldr	r3, [sp, #4]
 8003508:	0018      	movs	r0, r3
 800350a:	f7ff ffc1 	bl	8003490 <chEvtObjectInit>
}
 800350e:	b003      	add	sp, #12
 8003510:	bd00      	pop	{pc}
 8003512:	46c0      	nop			; (mov r8, r8)
	...

08003520 <canInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void canInit(void) {
 8003520:	b510      	push	{r4, lr}

  can_lld_init();
 8003522:	f7fd ff7d 	bl	8001420 <can_lld_init>
}
 8003526:	bd10      	pop	{r4, pc}
	...

08003530 <canObjectInit>:
 *
 * @param[out] canp     pointer to the @p CANDriver object
 *
 * @init
 */
void canObjectInit(CANDriver *canp) {
 8003530:	b500      	push	{lr}
 8003532:	b083      	sub	sp, #12
 8003534:	9001      	str	r0, [sp, #4]

  canp->state    = CAN_STOP;
 8003536:	9b01      	ldr	r3, [sp, #4]
 8003538:	2201      	movs	r2, #1
 800353a:	701a      	strb	r2, [r3, #0]
  canp->config   = NULL;
 800353c:	9b01      	ldr	r3, [sp, #4]
 800353e:	2200      	movs	r2, #0
 8003540:	605a      	str	r2, [r3, #4]
  osalThreadQueueObjectInit(&canp->txqueue);
 8003542:	9b01      	ldr	r3, [sp, #4]
 8003544:	3308      	adds	r3, #8
 8003546:	0018      	movs	r0, r3
 8003548:	f7ff ffba 	bl	80034c0 <osalThreadQueueObjectInit.lto_priv.78>
  osalThreadQueueObjectInit(&canp->rxqueue);
 800354c:	9b01      	ldr	r3, [sp, #4]
 800354e:	3310      	adds	r3, #16
 8003550:	0018      	movs	r0, r3
 8003552:	f7ff ffb5 	bl	80034c0 <osalThreadQueueObjectInit.lto_priv.78>
  osalEventObjectInit(&canp->rxfull_event);
 8003556:	9b01      	ldr	r3, [sp, #4]
 8003558:	3318      	adds	r3, #24
 800355a:	0018      	movs	r0, r3
 800355c:	f7ff ffd0 	bl	8003500 <osalEventObjectInit>
  osalEventObjectInit(&canp->txempty_event);
 8003560:	9b01      	ldr	r3, [sp, #4]
 8003562:	331c      	adds	r3, #28
 8003564:	0018      	movs	r0, r3
 8003566:	f7ff ffcb 	bl	8003500 <osalEventObjectInit>
  osalEventObjectInit(&canp->error_event);
 800356a:	9b01      	ldr	r3, [sp, #4]
 800356c:	3320      	adds	r3, #32
 800356e:	0018      	movs	r0, r3
 8003570:	f7ff ffc6 	bl	8003500 <osalEventObjectInit>
#if CAN_USE_SLEEP_MODE == TRUE
  osalEventObjectInit(&canp->sleep_event);
 8003574:	9b01      	ldr	r3, [sp, #4]
 8003576:	3324      	adds	r3, #36	; 0x24
 8003578:	0018      	movs	r0, r3
 800357a:	f7ff ffc1 	bl	8003500 <osalEventObjectInit>
  osalEventObjectInit(&canp->wakeup_event);
 800357e:	9b01      	ldr	r3, [sp, #4]
 8003580:	3328      	adds	r3, #40	; 0x28
 8003582:	0018      	movs	r0, r3
 8003584:	f7ff ffbc 	bl	8003500 <osalEventObjectInit>
#endif
}
 8003588:	b003      	add	sp, #12
 800358a:	bd00      	pop	{pc}
 800358c:	0000      	movs	r0, r0
	...

08003590 <canStart>:
 * @param[in] config    pointer to the @p CANConfig object. Depending on
 *                      the implementation the value can be @p NULL.
 *
 * @api
 */
void canStart(CANDriver *canp, const CANConfig *config) {
 8003590:	b500      	push	{lr}
 8003592:	b083      	sub	sp, #12
 8003594:	9001      	str	r0, [sp, #4]
 8003596:	9100      	str	r1, [sp, #0]

  osalDbgCheck(canp != NULL);

  osalSysLock();
 8003598:	f7ff ff82 	bl	80034a0 <osalSysLock.lto_priv.63>
  osalDbgAssert(canp->state == CAN_STOP, "invalid state");

  /* Entering initialization mode. */
  canp->state = CAN_STARTING;
 800359c:	9b01      	ldr	r3, [sp, #4]
 800359e:	2202      	movs	r2, #2
 80035a0:	701a      	strb	r2, [r3, #0]
  canp->config = config;
 80035a2:	9b01      	ldr	r3, [sp, #4]
 80035a4:	9a00      	ldr	r2, [sp, #0]
 80035a6:	605a      	str	r2, [r3, #4]

  /* Low level initialization, could be a slow process and sleeps could
     be performed inside.*/
  can_lld_start(canp);
 80035a8:	9b01      	ldr	r3, [sp, #4]
 80035aa:	0018      	movs	r0, r3
 80035ac:	f7fd ff50 	bl	8001450 <can_lld_start>

  /* The driver finally goes into the ready state.*/
  canp->state = CAN_READY;
 80035b0:	9b01      	ldr	r3, [sp, #4]
 80035b2:	2203      	movs	r2, #3
 80035b4:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 80035b6:	f7ff ff7b 	bl	80034b0 <osalSysUnlock.lto_priv.59>
}
 80035ba:	b003      	add	sp, #12
 80035bc:	bd00      	pop	{pc}
 80035be:	46c0      	nop			; (mov r8, r8)

080035c0 <canTransmitTimeout>:
 * @api
 */
msg_t canTransmitTimeout(CANDriver *canp,
                         canmbx_t mailbox,
                         const CANTxFrame *ctfp,
                         systime_t timeout) {
 80035c0:	b500      	push	{lr}
 80035c2:	b087      	sub	sp, #28
 80035c4:	9003      	str	r0, [sp, #12]
 80035c6:	9102      	str	r1, [sp, #8]
 80035c8:	9201      	str	r2, [sp, #4]
 80035ca:	9300      	str	r3, [sp, #0]

  osalDbgCheck((canp != NULL) && (ctfp != NULL) &&
               (mailbox <= (canmbx_t)CAN_TX_MAILBOXES));

  osalSysLock();
 80035cc:	f7ff ff68 	bl	80034a0 <osalSysLock.lto_priv.63>
 80035d0:	e00f      	b.n	80035f2 <canTransmitTimeout+0x32>
                "invalid state");

  /*lint -save -e9007 [13.5] Right side is supposed to be pure.*/
  while ((canp->state == CAN_SLEEP) || !can_lld_is_tx_empty(canp, mailbox)) {
  /*lint -restore*/
   msg_t msg = osalThreadEnqueueTimeoutS(&canp->txqueue, timeout);
 80035d2:	9b03      	ldr	r3, [sp, #12]
 80035d4:	3308      	adds	r3, #8
 80035d6:	9a00      	ldr	r2, [sp, #0]
 80035d8:	0011      	movs	r1, r2
 80035da:	0018      	movs	r0, r3
 80035dc:	f7ff ff80 	bl	80034e0 <osalThreadEnqueueTimeoutS.lto_priv.76>
 80035e0:	0003      	movs	r3, r0
 80035e2:	9305      	str	r3, [sp, #20]
    if (msg != MSG_OK) {
 80035e4:	9b05      	ldr	r3, [sp, #20]
 80035e6:	2b00      	cmp	r3, #0
 80035e8:	d003      	beq.n	80035f2 <canTransmitTimeout+0x32>
      osalSysUnlock();
 80035ea:	f7ff ff61 	bl	80034b0 <osalSysUnlock.lto_priv.59>
      return msg;
 80035ee:	9b05      	ldr	r3, [sp, #20]
 80035f0:	e019      	b.n	8003626 <canTransmitTimeout+0x66>
  while ((canp->state == CAN_SLEEP) || !can_lld_is_tx_empty(canp, mailbox)) {
 80035f2:	9b03      	ldr	r3, [sp, #12]
 80035f4:	781b      	ldrb	r3, [r3, #0]
 80035f6:	2b04      	cmp	r3, #4
 80035f8:	d0eb      	beq.n	80035d2 <canTransmitTimeout+0x12>
 80035fa:	9a02      	ldr	r2, [sp, #8]
 80035fc:	9b03      	ldr	r3, [sp, #12]
 80035fe:	0011      	movs	r1, r2
 8003600:	0018      	movs	r0, r3
 8003602:	f7fd ff5d 	bl	80014c0 <can_lld_is_tx_empty>
 8003606:	0003      	movs	r3, r0
 8003608:	001a      	movs	r2, r3
 800360a:	2301      	movs	r3, #1
 800360c:	4053      	eors	r3, r2
 800360e:	b2db      	uxtb	r3, r3
 8003610:	2b00      	cmp	r3, #0
 8003612:	d1de      	bne.n	80035d2 <canTransmitTimeout+0x12>
    }
  }
  can_lld_transmit(canp, mailbox, ctfp);
 8003614:	9a01      	ldr	r2, [sp, #4]
 8003616:	9902      	ldr	r1, [sp, #8]
 8003618:	9b03      	ldr	r3, [sp, #12]
 800361a:	0018      	movs	r0, r3
 800361c:	f7fd ff88 	bl	8001530 <can_lld_transmit>
  osalSysUnlock();
 8003620:	f7ff ff46 	bl	80034b0 <osalSysUnlock.lto_priv.59>
  return MSG_OK;
 8003624:	2300      	movs	r3, #0
}
 8003626:	0018      	movs	r0, r3
 8003628:	b007      	add	sp, #28
 800362a:	bd00      	pop	{pc}
 800362c:	0000      	movs	r0, r0
	...

08003630 <canReceiveTimeout>:
 * @api
 */
msg_t canReceiveTimeout(CANDriver *canp,
                        canmbx_t mailbox,
                        CANRxFrame *crfp,
                        systime_t timeout) {
 8003630:	b500      	push	{lr}
 8003632:	b087      	sub	sp, #28
 8003634:	9003      	str	r0, [sp, #12]
 8003636:	9102      	str	r1, [sp, #8]
 8003638:	9201      	str	r2, [sp, #4]
 800363a:	9300      	str	r3, [sp, #0]

  osalDbgCheck((canp != NULL) && (crfp != NULL) &&
               (mailbox <= (canmbx_t)CAN_RX_MAILBOXES));

  osalSysLock();
 800363c:	f7ff ff30 	bl	80034a0 <osalSysLock.lto_priv.63>
 8003640:	e00f      	b.n	8003662 <canReceiveTimeout+0x32>
                "invalid state");

  /*lint -save -e9007 [13.5] Right side is supposed to be pure.*/
  while ((canp->state == CAN_SLEEP) || !can_lld_is_rx_nonempty(canp, mailbox)) {
  /*lint -restore*/
    msg_t msg = osalThreadEnqueueTimeoutS(&canp->rxqueue, timeout);
 8003642:	9b03      	ldr	r3, [sp, #12]
 8003644:	3310      	adds	r3, #16
 8003646:	9a00      	ldr	r2, [sp, #0]
 8003648:	0011      	movs	r1, r2
 800364a:	0018      	movs	r0, r3
 800364c:	f7ff ff48 	bl	80034e0 <osalThreadEnqueueTimeoutS.lto_priv.76>
 8003650:	0003      	movs	r3, r0
 8003652:	9305      	str	r3, [sp, #20]
    if (msg != MSG_OK) {
 8003654:	9b05      	ldr	r3, [sp, #20]
 8003656:	2b00      	cmp	r3, #0
 8003658:	d003      	beq.n	8003662 <canReceiveTimeout+0x32>
      osalSysUnlock();
 800365a:	f7ff ff29 	bl	80034b0 <osalSysUnlock.lto_priv.59>
      return msg;
 800365e:	9b05      	ldr	r3, [sp, #20]
 8003660:	e019      	b.n	8003696 <canReceiveTimeout+0x66>
  while ((canp->state == CAN_SLEEP) || !can_lld_is_rx_nonempty(canp, mailbox)) {
 8003662:	9b03      	ldr	r3, [sp, #12]
 8003664:	781b      	ldrb	r3, [r3, #0]
 8003666:	2b04      	cmp	r3, #4
 8003668:	d0eb      	beq.n	8003642 <canReceiveTimeout+0x12>
 800366a:	9a02      	ldr	r2, [sp, #8]
 800366c:	9b03      	ldr	r3, [sp, #12]
 800366e:	0011      	movs	r1, r2
 8003670:	0018      	movs	r0, r3
 8003672:	f7fd ffc5 	bl	8001600 <can_lld_is_rx_nonempty>
 8003676:	0003      	movs	r3, r0
 8003678:	001a      	movs	r2, r3
 800367a:	2301      	movs	r3, #1
 800367c:	4053      	eors	r3, r2
 800367e:	b2db      	uxtb	r3, r3
 8003680:	2b00      	cmp	r3, #0
 8003682:	d1de      	bne.n	8003642 <canReceiveTimeout+0x12>
    }
  }
  can_lld_receive(canp, mailbox, crfp);
 8003684:	9a01      	ldr	r2, [sp, #4]
 8003686:	9902      	ldr	r1, [sp, #8]
 8003688:	9b03      	ldr	r3, [sp, #12]
 800368a:	0018      	movs	r0, r3
 800368c:	f7fd fff0 	bl	8001670 <can_lld_receive>
  osalSysUnlock();
 8003690:	f7ff ff0e 	bl	80034b0 <osalSysUnlock.lto_priv.59>
  return MSG_OK;
 8003694:	2300      	movs	r3, #0
}
 8003696:	0018      	movs	r0, r3
 8003698:	b007      	add	sp, #28
 800369a:	bd00      	pop	{pc}
 800369c:	0000      	movs	r0, r0
	...

080036a0 <chEvtWaitAnyTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
 80036a0:	b500      	push	{lr}
 80036a2:	b085      	sub	sp, #20
 80036a4:	9001      	str	r0, [sp, #4]
 80036a6:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 80036a8:	4b19      	ldr	r3, [pc, #100]	; (8003710 <chEvtWaitAnyTimeout+0x70>)
 80036aa:	699b      	ldr	r3, [r3, #24]
 80036ac:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 80036ae:	f000 fa6f 	bl	8003b90 <chSysLock.lto_priv.104>
  m = ctp->epending & events;
 80036b2:	9b02      	ldr	r3, [sp, #8]
 80036b4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80036b6:	9a01      	ldr	r2, [sp, #4]
 80036b8:	4013      	ands	r3, r2
 80036ba:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 80036bc:	9b03      	ldr	r3, [sp, #12]
 80036be:	2b00      	cmp	r3, #0
 80036c0:	d119      	bne.n	80036f6 <chEvtWaitAnyTimeout+0x56>
    if (TIME_IMMEDIATE == time) {
 80036c2:	9b00      	ldr	r3, [sp, #0]
 80036c4:	2b00      	cmp	r3, #0
 80036c6:	d103      	bne.n	80036d0 <chEvtWaitAnyTimeout+0x30>
      chSysUnlock();
 80036c8:	f000 fa6a 	bl	8003ba0 <chSysUnlock.lto_priv.99>
      return (eventmask_t)0;
 80036cc:	2300      	movs	r3, #0
 80036ce:	e01c      	b.n	800370a <chEvtWaitAnyTimeout+0x6a>
    }
    ctp->u.ewmask = events;
 80036d0:	9b02      	ldr	r3, [sp, #8]
 80036d2:	9a01      	ldr	r2, [sp, #4]
 80036d4:	621a      	str	r2, [r3, #32]
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 80036d6:	9b00      	ldr	r3, [sp, #0]
 80036d8:	0019      	movs	r1, r3
 80036da:	200a      	movs	r0, #10
 80036dc:	f000 ff90 	bl	8004600 <chSchGoSleepTimeoutS>
 80036e0:	1e03      	subs	r3, r0, #0
 80036e2:	da03      	bge.n	80036ec <chEvtWaitAnyTimeout+0x4c>
      chSysUnlock();
 80036e4:	f000 fa5c 	bl	8003ba0 <chSysUnlock.lto_priv.99>
      return (eventmask_t)0;
 80036e8:	2300      	movs	r3, #0
 80036ea:	e00e      	b.n	800370a <chEvtWaitAnyTimeout+0x6a>
    }
    m = ctp->epending & events;
 80036ec:	9b02      	ldr	r3, [sp, #8]
 80036ee:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80036f0:	9a01      	ldr	r2, [sp, #4]
 80036f2:	4013      	ands	r3, r2
 80036f4:	9303      	str	r3, [sp, #12]
  }
  ctp->epending &= ~m;
 80036f6:	9b02      	ldr	r3, [sp, #8]
 80036f8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80036fa:	9a03      	ldr	r2, [sp, #12]
 80036fc:	43d2      	mvns	r2, r2
 80036fe:	401a      	ands	r2, r3
 8003700:	9b02      	ldr	r3, [sp, #8]
 8003702:	631a      	str	r2, [r3, #48]	; 0x30
  chSysUnlock();
 8003704:	f000 fa4c 	bl	8003ba0 <chSysUnlock.lto_priv.99>

  return m;
 8003708:	9b03      	ldr	r3, [sp, #12]
}
 800370a:	0018      	movs	r0, r3
 800370c:	b005      	add	sp, #20
 800370e:	bd00      	pop	{pc}
 8003710:	200004e0 	.word	0x200004e0
	...

08003720 <port_lock.lto_priv.118>:
  __ASM volatile ("cpsid i" : : : "memory");
 8003720:	b672      	cpsid	i
}
 8003722:	4770      	bx	lr
	...

08003730 <port_unlock.lto_priv.113>:
  __ASM volatile ("cpsie i" : : : "memory");
 8003730:	b662      	cpsie	i
}
 8003732:	4770      	bx	lr
	...

08003740 <chSysLock.lto_priv.107>:
static inline void chSysLock(void) {
 8003740:	b510      	push	{r4, lr}
  port_lock();
 8003742:	f7ff ffed 	bl	8003720 <port_lock.lto_priv.118>
}
 8003746:	bd10      	pop	{r4, pc}
	...

08003750 <chSysUnlock.lto_priv.102>:
static inline void chSysUnlock(void) {
 8003750:	b510      	push	{r4, lr}
  port_unlock();
 8003752:	f7ff ffed 	bl	8003730 <port_unlock.lto_priv.113>
}
 8003756:	bd10      	pop	{r4, pc}
	...

08003760 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = __heap_base__;
 8003760:	4b03      	ldr	r3, [pc, #12]	; (8003770 <_core_init+0x10>)
 8003762:	4a04      	ldr	r2, [pc, #16]	; (8003774 <_core_init+0x14>)
 8003764:	601a      	str	r2, [r3, #0]
  endmem  = __heap_end__;
 8003766:	4b04      	ldr	r3, [pc, #16]	; (8003778 <_core_init+0x18>)
 8003768:	4a04      	ldr	r2, [pc, #16]	; (800377c <_core_init+0x1c>)
 800376a:	601a      	str	r2, [r3, #0]
  static uint8_t static_heap[CH_CFG_MEMCORE_SIZE];

  nextmem = &static_heap[0];
  endmem  = &static_heap[CH_CFG_MEMCORE_SIZE];
#endif
}
 800376c:	4770      	bx	lr
 800376e:	46c0      	nop			; (mov r8, r8)
 8003770:	2000054c 	.word	0x2000054c
 8003774:	20000a50 	.word	0x20000a50
 8003778:	20000550 	.word	0x20000550
 800377c:	20001800 	.word	0x20001800

08003780 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocAlignedI(size_t size, unsigned align) {
 8003780:	b084      	sub	sp, #16
 8003782:	9001      	str	r0, [sp, #4]
 8003784:	9100      	str	r1, [sp, #0]
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 8003786:	9a00      	ldr	r2, [sp, #0]
 8003788:	9b01      	ldr	r3, [sp, #4]
 800378a:	18d3      	adds	r3, r2, r3
 800378c:	3b01      	subs	r3, #1
 800378e:	9a00      	ldr	r2, [sp, #0]
 8003790:	4252      	negs	r2, r2
 8003792:	4013      	ands	r3, r2
 8003794:	9301      	str	r3, [sp, #4]
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 8003796:	4b0e      	ldr	r3, [pc, #56]	; (80037d0 <chCoreAllocAlignedI+0x50>)
 8003798:	681b      	ldr	r3, [r3, #0]
 800379a:	001a      	movs	r2, r3
 800379c:	9b00      	ldr	r3, [sp, #0]
 800379e:	18d3      	adds	r3, r2, r3
 80037a0:	3b01      	subs	r3, #1
 80037a2:	9a00      	ldr	r2, [sp, #0]
 80037a4:	4252      	negs	r2, r2
 80037a6:	4013      	ands	r3, r2
 80037a8:	9303      	str	r3, [sp, #12]

  if (((size_t)endmem - (size_t)p) < size) {
 80037aa:	4b0a      	ldr	r3, [pc, #40]	; (80037d4 <chCoreAllocAlignedI+0x54>)
 80037ac:	681b      	ldr	r3, [r3, #0]
 80037ae:	001a      	movs	r2, r3
 80037b0:	9b03      	ldr	r3, [sp, #12]
 80037b2:	1ad2      	subs	r2, r2, r3
 80037b4:	9b01      	ldr	r3, [sp, #4]
 80037b6:	429a      	cmp	r2, r3
 80037b8:	d201      	bcs.n	80037be <chCoreAllocAlignedI+0x3e>
    return NULL;
 80037ba:	2300      	movs	r3, #0
 80037bc:	e005      	b.n	80037ca <chCoreAllocAlignedI+0x4a>
  }
  nextmem = p + size;
 80037be:	9a03      	ldr	r2, [sp, #12]
 80037c0:	9b01      	ldr	r3, [sp, #4]
 80037c2:	18d2      	adds	r2, r2, r3
 80037c4:	4b02      	ldr	r3, [pc, #8]	; (80037d0 <chCoreAllocAlignedI+0x50>)
 80037c6:	601a      	str	r2, [r3, #0]

  return p;
 80037c8:	9b03      	ldr	r3, [sp, #12]
}
 80037ca:	0018      	movs	r0, r3
 80037cc:	b004      	add	sp, #16
 80037ce:	4770      	bx	lr
 80037d0:	2000054c 	.word	0x2000054c
 80037d4:	20000550 	.word	0x20000550
	...

080037e0 <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
 80037e0:	b500      	push	{lr}
 80037e2:	b085      	sub	sp, #20
 80037e4:	9001      	str	r0, [sp, #4]
 80037e6:	9100      	str	r1, [sp, #0]
  void *p;

  chSysLock();
 80037e8:	f7ff ffaa 	bl	8003740 <chSysLock.lto_priv.107>
  p = chCoreAllocAlignedI(size, align);
 80037ec:	9a00      	ldr	r2, [sp, #0]
 80037ee:	9b01      	ldr	r3, [sp, #4]
 80037f0:	0011      	movs	r1, r2
 80037f2:	0018      	movs	r0, r3
 80037f4:	f7ff ffc4 	bl	8003780 <chCoreAllocAlignedI>
 80037f8:	0003      	movs	r3, r0
 80037fa:	9303      	str	r3, [sp, #12]
  chSysUnlock();
 80037fc:	f7ff ffa8 	bl	8003750 <chSysUnlock.lto_priv.102>

  return p;
 8003800:	9b03      	ldr	r3, [sp, #12]
}
 8003802:	0018      	movs	r0, r3
 8003804:	b005      	add	sp, #20
 8003806:	bd00      	pop	{pc}
	...

08003810 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
 8003810:	b510      	push	{r4, lr}

  default_heap.provider = chCoreAllocAligned;
 8003812:	4b07      	ldr	r3, [pc, #28]	; (8003830 <_heap_init+0x20>)
 8003814:	4a07      	ldr	r2, [pc, #28]	; (8003834 <_heap_init+0x24>)
 8003816:	601a      	str	r2, [r3, #0]
  H_NEXT(&default_heap.header) = NULL;
 8003818:	4b05      	ldr	r3, [pc, #20]	; (8003830 <_heap_init+0x20>)
 800381a:	2200      	movs	r2, #0
 800381c:	609a      	str	r2, [r3, #8]
  H_PAGES(&default_heap.header) = 0;
 800381e:	4b04      	ldr	r3, [pc, #16]	; (8003830 <_heap_init+0x20>)
 8003820:	2200      	movs	r2, #0
 8003822:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
 8003824:	4b04      	ldr	r3, [pc, #16]	; (8003838 <_heap_init+0x28>)
 8003826:	0018      	movs	r0, r3
 8003828:	f000 f992 	bl	8003b50 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
#endif
}
 800382c:	bd10      	pop	{r4, pc}
 800382e:	46c0      	nop			; (mov r8, r8)
 8003830:	20000558 	.word	0x20000558
 8003834:	080037e1 	.word	0x080037e1
 8003838:	20000568 	.word	0x20000568
 800383c:	00000000 	.word	0x00000000

08003840 <port_lock.lto_priv.119>:
  __ASM volatile ("cpsid i" : : : "memory");
 8003840:	b672      	cpsid	i
}
 8003842:	4770      	bx	lr
	...

08003850 <port_unlock.lto_priv.114>:
  __ASM volatile ("cpsie i" : : : "memory");
 8003850:	b662      	cpsie	i
}
 8003852:	4770      	bx	lr
	...

08003860 <port_lock_from_isr>:
static inline void port_lock_from_isr(void) {
 8003860:	b510      	push	{r4, lr}
  port_lock();
 8003862:	f7ff ffed 	bl	8003840 <port_lock.lto_priv.119>
}
 8003866:	bd10      	pop	{r4, pc}
	...

08003870 <port_unlock_from_isr>:
static inline void port_unlock_from_isr(void) {
 8003870:	b510      	push	{r4, lr}
  port_unlock();
 8003872:	f7ff ffed 	bl	8003850 <port_unlock.lto_priv.114>
}
 8003876:	bd10      	pop	{r4, pc}
	...

08003880 <NMI_Handler>:
 * @brief   NMI vector.
 * @details The NMI vector is used for exception mode re-entering after a
 *          context switch.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void NMI_Handler(void) {
 8003880:	b510      	push	{r4, lr}
 8003882:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8003884:	f3ef 8309 	mrs	r3, PSP
 8003888:	001c      	movs	r4, r3
  return(result);
 800388a:	0023      	movs	r3, r4
/*lint -restore*/

  /* The port_extctx structure is pointed by the PSP register.*/
  struct port_extctx *ctxp = (struct port_extctx *)__get_PSP();
 800388c:	9301      	str	r3, [sp, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 800388e:	9b01      	ldr	r3, [sp, #4]
 8003890:	3320      	adds	r3, #32
 8003892:	9301      	str	r3, [sp, #4]

  /* Writing back the modified PSP value.*/
  __set_PSP((uint32_t)ctxp);
 8003894:	9b01      	ldr	r3, [sp, #4]
 8003896:	9300      	str	r3, [sp, #0]
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8003898:	9b00      	ldr	r3, [sp, #0]
 800389a:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 800389e:	f7ff ffe7 	bl	8003870 <port_unlock_from_isr>
}
 80038a2:	b002      	add	sp, #8
 80038a4:	bd10      	pop	{r4, pc}
 80038a6:	46c0      	nop			; (mov r8, r8)
	...

080038b0 <_port_irq_epilogue>:
/**
 * @brief   IRQ epilogue code.
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {
 80038b0:	b510      	push	{r4, lr}
 80038b2:	b084      	sub	sp, #16
 80038b4:	9001      	str	r0, [sp, #4]

  if (lr != (regarm_t)0xFFFFFFF1U) {
 80038b6:	9b01      	ldr	r3, [sp, #4]
 80038b8:	330f      	adds	r3, #15
 80038ba:	d01d      	beq.n	80038f8 <_port_irq_epilogue+0x48>
    struct port_extctx *ctxp;

    port_lock_from_isr();
 80038bc:	f7ff ffd0 	bl	8003860 <port_lock_from_isr>
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80038c0:	f3ef 8309 	mrs	r3, PSP
 80038c4:	001c      	movs	r4, r3
  return(result);
 80038c6:	0023      	movs	r3, r4

    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
 80038c8:	9303      	str	r3, [sp, #12]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 80038ca:	9b03      	ldr	r3, [sp, #12]
 80038cc:	3b20      	subs	r3, #32
 80038ce:	9303      	str	r3, [sp, #12]

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
 80038d0:	9b03      	ldr	r3, [sp, #12]
 80038d2:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 80038d4:	9b02      	ldr	r3, [sp, #8]
 80038d6:	f383 8809 	msr	PSP, r3

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 80038da:	9b03      	ldr	r3, [sp, #12]
 80038dc:	2280      	movs	r2, #128	; 0x80
 80038de:	0452      	lsls	r2, r2, #17
 80038e0:	61da      	str	r2, [r3, #28]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 80038e2:	f000 fef5 	bl	80046d0 <chSchIsPreemptionRequired>
 80038e6:	1e03      	subs	r3, r0, #0
 80038e8:	d003      	beq.n	80038f2 <_port_irq_epilogue+0x42>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80038ea:	9b03      	ldr	r3, [sp, #12]
 80038ec:	4a03      	ldr	r2, [pc, #12]	; (80038fc <_port_irq_epilogue+0x4c>)
 80038ee:	619a      	str	r2, [r3, #24]
 80038f0:	e002      	b.n	80038f8 <_port_irq_epilogue+0x48>
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 80038f2:	9b03      	ldr	r3, [sp, #12]
 80038f4:	4a02      	ldr	r2, [pc, #8]	; (8003900 <_port_irq_epilogue+0x50>)
 80038f6:	619a      	str	r2, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
  }
}
 80038f8:	b004      	add	sp, #16
 80038fa:	bd10      	pop	{r4, pc}
 80038fc:	080001bd 	.word	0x080001bd
 8003900:	080001c0 	.word	0x080001c0
	...

08003910 <osalInit>:
}
 8003910:	4770      	bx	lr
 8003912:	46c0      	nop			; (mov r8, r8)
	...

08003920 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8003920:	b510      	push	{r4, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8003922:	f7ff fff5 	bl	8003910 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 8003926:	f7fe fe8b 	bl	8002640 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 800392a:	4b08      	ldr	r3, [pc, #32]	; (800394c <halInit+0x2c>)
 800392c:	0018      	movs	r0, r3
 800392e:	f7fe f81f 	bl	8001970 <_pal_lld_init>
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
#endif
#if (HAL_USE_CAN == TRUE) || defined(__DOXYGEN__)
  canInit();
 8003932:	f7ff fdf5 	bl	8003520 <canInit>
#endif
#if (HAL_USE_DAC == TRUE) || defined(__DOXYGEN__)
  dacInit();
#endif
#if (HAL_USE_EXT == TRUE) || defined(__DOXYGEN__)
  extInit();
 8003936:	f7fe fb3b 	bl	8001fb0 <extInit>
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
#endif
#if (HAL_USE_I2C == TRUE) || defined(__DOXYGEN__)
  i2cInit();
 800393a:	f7fe fb61 	bl	8002000 <i2cInit>
#endif
#if (HAL_USE_QSPI == TRUE) || defined(__DOXYGEN__)
  qspiInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 800393e:	f7fe fc7f 	bl	8002240 <sdInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8003942:	f7fc ffb5 	bl	80008b0 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 8003946:	f7fe fcfb 	bl	8002340 <stInit>
#endif
}
 800394a:	bd10      	pop	{r4, pc}
 800394c:	08004c14 	.word	0x08004c14

08003950 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8003950:	b500      	push	{lr}
 8003952:	b087      	sub	sp, #28
 8003954:	9003      	str	r0, [sp, #12]
 8003956:	9102      	str	r1, [sp, #8]
 8003958:	9201      	str	r2, [sp, #4]
 800395a:	9300      	str	r3, [sp, #0]
  _thread_memfill((uint8_t *)wsp,
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 800395c:	f000 ff80 	bl	8004860 <chSysLock.lto_priv.141>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)wsp + size -
 8003960:	9b02      	ldr	r3, [sp, #8]
 8003962:	3b40      	subs	r3, #64	; 0x40
 8003964:	9a03      	ldr	r2, [sp, #12]
 8003966:	18d3      	adds	r3, r2, r3
 8003968:	9305      	str	r3, [sp, #20]
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 800396a:	9b05      	ldr	r3, [sp, #20]
 800396c:	3b24      	subs	r3, #36	; 0x24
 800396e:	001a      	movs	r2, r3
 8003970:	9b05      	ldr	r3, [sp, #20]
 8003972:	60da      	str	r2, [r3, #12]
 8003974:	9b05      	ldr	r3, [sp, #20]
 8003976:	68db      	ldr	r3, [r3, #12]
 8003978:	9a00      	ldr	r2, [sp, #0]
 800397a:	611a      	str	r2, [r3, #16]
 800397c:	9b05      	ldr	r3, [sp, #20]
 800397e:	68db      	ldr	r3, [r3, #12]
 8003980:	9a08      	ldr	r2, [sp, #32]
 8003982:	615a      	str	r2, [r3, #20]
 8003984:	9b05      	ldr	r3, [sp, #20]
 8003986:	68db      	ldr	r3, [r3, #12]
 8003988:	4a0a      	ldr	r2, [pc, #40]	; (80039b4 <chThdCreateStatic+0x64>)
 800398a:	621a      	str	r2, [r3, #32]

  tp = _thread_init(tp, "noname", prio);
 800398c:	9a01      	ldr	r2, [sp, #4]
 800398e:	490a      	ldr	r1, [pc, #40]	; (80039b8 <chThdCreateStatic+0x68>)
 8003990:	9b05      	ldr	r3, [sp, #20]
 8003992:	0018      	movs	r0, r3
 8003994:	f000 ff9c 	bl	80048d0 <_thread_init>
 8003998:	0003      	movs	r3, r0
 800399a:	9305      	str	r3, [sp, #20]

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 800399c:	9b05      	ldr	r3, [sp, #20]
 800399e:	2100      	movs	r1, #0
 80039a0:	0018      	movs	r0, r3
 80039a2:	f000 fe65 	bl	8004670 <chSchWakeupS>
  chSysUnlock();
 80039a6:	f000 ff63 	bl	8004870 <chSysUnlock.lto_priv.136>

  return tp;
 80039aa:	9b05      	ldr	r3, [sp, #20]
}
 80039ac:	0018      	movs	r0, r3
 80039ae:	b007      	add	sp, #28
 80039b0:	bd00      	pop	{pc}
 80039b2:	46c0      	nop			; (mov r8, r8)
 80039b4:	080001b1 	.word	0x080001b1
 80039b8:	08004ac8 	.word	0x08004ac8
 80039bc:	00000000 	.word	0x00000000

080039c0 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 80039c0:	b500      	push	{lr}
 80039c2:	b083      	sub	sp, #12
 80039c4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80039c6:	f000 ff4b 	bl	8004860 <chSysLock.lto_priv.141>
  chThdExitS(msg);
 80039ca:	9b01      	ldr	r3, [sp, #4]
 80039cc:	0018      	movs	r0, r3
 80039ce:	f000 f807 	bl	80039e0 <chThdExitS>
  /* The thread never returns here.*/
}
 80039d2:	b003      	add	sp, #12
 80039d4:	bd00      	pop	{pc}
 80039d6:	46c0      	nop			; (mov r8, r8)
	...

080039e0 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 80039e0:	b500      	push	{lr}
 80039e2:	b085      	sub	sp, #20
 80039e4:	9001      	str	r0, [sp, #4]
  thread_t *tp = currp;
 80039e6:	4b15      	ldr	r3, [pc, #84]	; (8003a3c <chThdExitS+0x5c>)
 80039e8:	699b      	ldr	r3, [r3, #24]
 80039ea:	9303      	str	r3, [sp, #12]

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 80039ec:	9b03      	ldr	r3, [sp, #12]
 80039ee:	9a01      	ldr	r2, [sp, #4]
 80039f0:	621a      	str	r2, [r3, #32]
 80039f2:	e008      	b.n	8003a06 <chThdExitS+0x26>
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
    (void) chSchReadyI(list_remove(&tp->waiting));
 80039f4:	9b03      	ldr	r3, [sp, #12]
 80039f6:	3324      	adds	r3, #36	; 0x24
 80039f8:	0018      	movs	r0, r3
 80039fa:	f000 fef1 	bl	80047e0 <list_remove.lto_priv.166>
 80039fe:	0003      	movs	r3, r0
 8003a00:	0018      	movs	r0, r3
 8003a02:	f000 fd55 	bl	80044b0 <chSchReadyI>
  while (list_notempty(&tp->waiting)) {
 8003a06:	9b03      	ldr	r3, [sp, #12]
 8003a08:	3324      	adds	r3, #36	; 0x24
 8003a0a:	0018      	movs	r0, r3
 8003a0c:	f000 feb8 	bl	8004780 <list_notempty.lto_priv.165>
 8003a10:	1e03      	subs	r3, r0, #0
 8003a12:	d1ef      	bne.n	80039f4 <chThdExitS+0x14>
  if ((tp->refs == (trefs_t)0) &&
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    REG_REMOVE(tp);
  }
#else
  if (tp->refs == (trefs_t)0) {
 8003a14:	9b03      	ldr	r3, [sp, #12]
 8003a16:	7f9b      	ldrb	r3, [r3, #30]
 8003a18:	2b00      	cmp	r3, #0
 8003a1a:	d109      	bne.n	8003a30 <chThdExitS+0x50>
    REG_REMOVE(tp);
 8003a1c:	9b03      	ldr	r3, [sp, #12]
 8003a1e:	695b      	ldr	r3, [r3, #20]
 8003a20:	9a03      	ldr	r2, [sp, #12]
 8003a22:	6912      	ldr	r2, [r2, #16]
 8003a24:	611a      	str	r2, [r3, #16]
 8003a26:	9b03      	ldr	r3, [sp, #12]
 8003a28:	691b      	ldr	r3, [r3, #16]
 8003a2a:	9a03      	ldr	r2, [sp, #12]
 8003a2c:	6952      	ldr	r2, [r2, #20]
 8003a2e:	615a      	str	r2, [r3, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 8003a30:	200f      	movs	r0, #15
 8003a32:	f000 fd8d 	bl	8004550 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 8003a36:	b005      	add	sp, #20
 8003a38:	bd00      	pop	{pc}
 8003a3a:	46c0      	nop			; (mov r8, r8)
 8003a3c:	200004e0 	.word	0x200004e0

08003a40 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8003a40:	b500      	push	{lr}
 8003a42:	b083      	sub	sp, #12
 8003a44:	9001      	str	r0, [sp, #4]

  chSysLock();
 8003a46:	f000 ff0b 	bl	8004860 <chSysLock.lto_priv.141>
  chThdSleepS(time);
 8003a4a:	9b01      	ldr	r3, [sp, #4]
 8003a4c:	0018      	movs	r0, r3
 8003a4e:	f000 ff17 	bl	8004880 <chThdSleepS.lto_priv.161>
  chSysUnlock();
 8003a52:	f000 ff0d 	bl	8004870 <chSysUnlock.lto_priv.136>
}
 8003a56:	b003      	add	sp, #12
 8003a58:	bd00      	pop	{pc}
 8003a5a:	46c0      	nop			; (mov r8, r8)
 8003a5c:	0000      	movs	r0, r0
	...

08003a60 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 8003a60:	b500      	push	{lr}
 8003a62:	b085      	sub	sp, #20
 8003a64:	9001      	str	r0, [sp, #4]
 8003a66:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 8003a68:	9b01      	ldr	r3, [sp, #4]
 8003a6a:	681b      	ldr	r3, [r3, #0]
 8003a6c:	2b00      	cmp	r3, #0
 8003a6e:	d00c      	beq.n	8003a8a <chThdResumeI+0x2a>
    thread_t *tp = *trp;
 8003a70:	9b01      	ldr	r3, [sp, #4]
 8003a72:	681b      	ldr	r3, [r3, #0]
 8003a74:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8003a76:	9b01      	ldr	r3, [sp, #4]
 8003a78:	2200      	movs	r2, #0
 8003a7a:	601a      	str	r2, [r3, #0]
    tp->u.rdymsg = msg;
 8003a7c:	9b03      	ldr	r3, [sp, #12]
 8003a7e:	9a00      	ldr	r2, [sp, #0]
 8003a80:	621a      	str	r2, [r3, #32]
    (void) chSchReadyI(tp);
 8003a82:	9b03      	ldr	r3, [sp, #12]
 8003a84:	0018      	movs	r0, r3
 8003a86:	f000 fd13 	bl	80044b0 <chSchReadyI>
  }
}
 8003a8a:	b005      	add	sp, #20
 8003a8c:	bd00      	pop	{pc}
 8003a8e:	46c0      	nop			; (mov r8, r8)

08003a90 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8003a90:	b500      	push	{lr}
 8003a92:	b083      	sub	sp, #12
 8003a94:	9001      	str	r0, [sp, #4]
 8003a96:	9100      	str	r1, [sp, #0]

  if (TIME_IMMEDIATE == timeout) {
 8003a98:	9b00      	ldr	r3, [sp, #0]
 8003a9a:	2b00      	cmp	r3, #0
 8003a9c:	d102      	bne.n	8003aa4 <chThdEnqueueTimeoutS+0x14>
    return MSG_TIMEOUT;
 8003a9e:	2301      	movs	r3, #1
 8003aa0:	425b      	negs	r3, r3
 8003aa2:	e00c      	b.n	8003abe <chThdEnqueueTimeoutS+0x2e>
  }

  queue_insert(currp, tqp);
 8003aa4:	4b07      	ldr	r3, [pc, #28]	; (8003ac4 <chThdEnqueueTimeoutS+0x34>)
 8003aa6:	699b      	ldr	r3, [r3, #24]
 8003aa8:	9a01      	ldr	r2, [sp, #4]
 8003aaa:	0011      	movs	r1, r2
 8003aac:	0018      	movs	r0, r3
 8003aae:	f000 fea7 	bl	8004800 <queue_insert.lto_priv.157>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8003ab2:	9b00      	ldr	r3, [sp, #0]
 8003ab4:	0019      	movs	r1, r3
 8003ab6:	2004      	movs	r0, #4
 8003ab8:	f000 fda2 	bl	8004600 <chSchGoSleepTimeoutS>
 8003abc:	0003      	movs	r3, r0
}
 8003abe:	0018      	movs	r0, r3
 8003ac0:	b003      	add	sp, #12
 8003ac2:	bd00      	pop	{pc}
 8003ac4:	200004e0 	.word	0x200004e0
	...

08003ad0 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8003ad0:	b500      	push	{lr}
 8003ad2:	b083      	sub	sp, #12
 8003ad4:	9001      	str	r0, [sp, #4]
 8003ad6:	9100      	str	r1, [sp, #0]

  if (queue_notempty(tqp)) {
 8003ad8:	9b01      	ldr	r3, [sp, #4]
 8003ada:	0018      	movs	r0, r3
 8003adc:	f000 fe70 	bl	80047c0 <queue_notempty.lto_priv.151>
 8003ae0:	1e03      	subs	r3, r0, #0
 8003ae2:	d005      	beq.n	8003af0 <chThdDequeueNextI+0x20>
    chThdDoDequeueNextI(tqp, msg);
 8003ae4:	9a00      	ldr	r2, [sp, #0]
 8003ae6:	9b01      	ldr	r3, [sp, #4]
 8003ae8:	0011      	movs	r1, r2
 8003aea:	0018      	movs	r0, r3
 8003aec:	f000 fed8 	bl	80048a0 <chThdDoDequeueNextI.lto_priv.159>
  }
}
 8003af0:	b003      	add	sp, #12
 8003af2:	bd00      	pop	{pc}
	...

08003b00 <chThdDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8003b00:	b500      	push	{lr}
 8003b02:	b083      	sub	sp, #12
 8003b04:	9001      	str	r0, [sp, #4]
 8003b06:	9100      	str	r1, [sp, #0]
 8003b08:	e005      	b.n	8003b16 <chThdDequeueAllI+0x16>

  while (queue_notempty(tqp)) {
    chThdDoDequeueNextI(tqp, msg);
 8003b0a:	9a00      	ldr	r2, [sp, #0]
 8003b0c:	9b01      	ldr	r3, [sp, #4]
 8003b0e:	0011      	movs	r1, r2
 8003b10:	0018      	movs	r0, r3
 8003b12:	f000 fec5 	bl	80048a0 <chThdDoDequeueNextI.lto_priv.159>
  while (queue_notempty(tqp)) {
 8003b16:	9b01      	ldr	r3, [sp, #4]
 8003b18:	0018      	movs	r0, r3
 8003b1a:	f000 fe51 	bl	80047c0 <queue_notempty.lto_priv.151>
 8003b1e:	1e03      	subs	r3, r0, #0
 8003b20:	d1f3      	bne.n	8003b0a <chThdDequeueAllI+0xa>
  }
}
 8003b22:	b003      	add	sp, #12
 8003b24:	bd00      	pop	{pc}
 8003b26:	46c0      	nop			; (mov r8, r8)
	...

08003b30 <queue_init.lto_priv.155>:
static inline void queue_init(threads_queue_t *tqp) {
 8003b30:	b082      	sub	sp, #8
 8003b32:	9001      	str	r0, [sp, #4]
  tqp->next = (thread_t *)tqp;
 8003b34:	9b01      	ldr	r3, [sp, #4]
 8003b36:	9a01      	ldr	r2, [sp, #4]
 8003b38:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8003b3a:	9b01      	ldr	r3, [sp, #4]
 8003b3c:	9a01      	ldr	r2, [sp, #4]
 8003b3e:	605a      	str	r2, [r3, #4]
}
 8003b40:	b002      	add	sp, #8
 8003b42:	4770      	bx	lr
	...

08003b50 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 8003b50:	b500      	push	{lr}
 8003b52:	b083      	sub	sp, #12
 8003b54:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
 8003b56:	9b01      	ldr	r3, [sp, #4]
 8003b58:	0018      	movs	r0, r3
 8003b5a:	f7ff ffe9 	bl	8003b30 <queue_init.lto_priv.155>
  mp->owner = NULL;
 8003b5e:	9b01      	ldr	r3, [sp, #4]
 8003b60:	2200      	movs	r2, #0
 8003b62:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
#endif
}
 8003b64:	b003      	add	sp, #12
 8003b66:	bd00      	pop	{pc}
	...

08003b70 <port_lock.lto_priv.133>:
  __ASM volatile ("cpsid i" : : : "memory");
 8003b70:	b672      	cpsid	i
}
 8003b72:	4770      	bx	lr
	...

08003b80 <port_unlock.lto_priv.128>:
  __ASM volatile ("cpsie i" : : : "memory");
 8003b80:	b662      	cpsie	i
}
 8003b82:	4770      	bx	lr
	...

08003b90 <chSysLock.lto_priv.104>:
static inline void chSysLock(void) {
 8003b90:	b510      	push	{r4, lr}
  port_lock();
 8003b92:	f7ff ffed 	bl	8003b70 <port_lock.lto_priv.133>
}
 8003b96:	bd10      	pop	{r4, pc}
	...

08003ba0 <chSysUnlock.lto_priv.99>:
static inline void chSysUnlock(void) {
 8003ba0:	b510      	push	{r4, lr}
  port_unlock();
 8003ba2:	f7ff ffed 	bl	8003b80 <port_unlock.lto_priv.128>
}
 8003ba6:	bd10      	pop	{r4, pc}
	...

08003bb0 <chEvtRegisterMaskWithFlags>:
                                eventflags_t wflags) {
 8003bb0:	b500      	push	{lr}
 8003bb2:	b085      	sub	sp, #20
 8003bb4:	9003      	str	r0, [sp, #12]
 8003bb6:	9102      	str	r1, [sp, #8]
 8003bb8:	9201      	str	r2, [sp, #4]
 8003bba:	9300      	str	r3, [sp, #0]
  chSysLock();
 8003bbc:	f7ff ffe8 	bl	8003b90 <chSysLock.lto_priv.104>
  elp->next     = esp->next;
 8003bc0:	9b03      	ldr	r3, [sp, #12]
 8003bc2:	681a      	ldr	r2, [r3, #0]
 8003bc4:	9b02      	ldr	r3, [sp, #8]
 8003bc6:	601a      	str	r2, [r3, #0]
  esp->next     = elp;
 8003bc8:	9b03      	ldr	r3, [sp, #12]
 8003bca:	9a02      	ldr	r2, [sp, #8]
 8003bcc:	601a      	str	r2, [r3, #0]
  elp->listener = currp;
 8003bce:	4b08      	ldr	r3, [pc, #32]	; (8003bf0 <chEvtRegisterMaskWithFlags+0x40>)
 8003bd0:	699a      	ldr	r2, [r3, #24]
 8003bd2:	9b02      	ldr	r3, [sp, #8]
 8003bd4:	605a      	str	r2, [r3, #4]
  elp->events   = events;
 8003bd6:	9b02      	ldr	r3, [sp, #8]
 8003bd8:	9a01      	ldr	r2, [sp, #4]
 8003bda:	609a      	str	r2, [r3, #8]
  elp->flags    = (eventflags_t)0;
 8003bdc:	9b02      	ldr	r3, [sp, #8]
 8003bde:	2200      	movs	r2, #0
 8003be0:	60da      	str	r2, [r3, #12]
  elp->wflags   = wflags;
 8003be2:	9b02      	ldr	r3, [sp, #8]
 8003be4:	9a00      	ldr	r2, [sp, #0]
 8003be6:	611a      	str	r2, [r3, #16]
  chSysUnlock();
 8003be8:	f7ff ffda 	bl	8003ba0 <chSysUnlock.lto_priv.99>
}
 8003bec:	b005      	add	sp, #20
 8003bee:	bd00      	pop	{pc}
 8003bf0:	200004e0 	.word	0x200004e0
	...

08003c00 <chEvtUnregister>:
void chEvtUnregister(event_source_t *esp, event_listener_t *elp) {
 8003c00:	b500      	push	{lr}
 8003c02:	b085      	sub	sp, #20
 8003c04:	9001      	str	r0, [sp, #4]
 8003c06:	9100      	str	r1, [sp, #0]
  p = (event_listener_t *)esp;
 8003c08:	9b01      	ldr	r3, [sp, #4]
 8003c0a:	9303      	str	r3, [sp, #12]
  chSysLock();
 8003c0c:	f7ff ffc0 	bl	8003b90 <chSysLock.lto_priv.104>
 8003c10:	e00c      	b.n	8003c2c <chEvtUnregister+0x2c>
    if (p->next == elp) {
 8003c12:	9b03      	ldr	r3, [sp, #12]
 8003c14:	681a      	ldr	r2, [r3, #0]
 8003c16:	9b00      	ldr	r3, [sp, #0]
 8003c18:	429a      	cmp	r2, r3
 8003c1a:	d104      	bne.n	8003c26 <chEvtUnregister+0x26>
      p->next = elp->next;
 8003c1c:	9b00      	ldr	r3, [sp, #0]
 8003c1e:	681a      	ldr	r2, [r3, #0]
 8003c20:	9b03      	ldr	r3, [sp, #12]
 8003c22:	601a      	str	r2, [r3, #0]
 8003c24:	e007      	b.n	8003c36 <chEvtUnregister+0x36>
    p = p->next;
 8003c26:	9b03      	ldr	r3, [sp, #12]
 8003c28:	681b      	ldr	r3, [r3, #0]
 8003c2a:	9303      	str	r3, [sp, #12]
  while (p->next != (event_listener_t *)esp) {
 8003c2c:	9b03      	ldr	r3, [sp, #12]
 8003c2e:	681a      	ldr	r2, [r3, #0]
 8003c30:	9b01      	ldr	r3, [sp, #4]
 8003c32:	429a      	cmp	r2, r3
 8003c34:	d1ed      	bne.n	8003c12 <chEvtUnregister+0x12>
  chSysUnlock();
 8003c36:	f7ff ffb3 	bl	8003ba0 <chSysUnlock.lto_priv.99>
}
 8003c3a:	b005      	add	sp, #20
 8003c3c:	bd00      	pop	{pc}
 8003c3e:	46c0      	nop			; (mov r8, r8)

08003c40 <chEvtBroadcastFlagsI>:
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8003c40:	b500      	push	{lr}
 8003c42:	b085      	sub	sp, #20
 8003c44:	9001      	str	r0, [sp, #4]
 8003c46:	9100      	str	r1, [sp, #0]
  elp = esp->next;
 8003c48:	9b01      	ldr	r3, [sp, #4]
 8003c4a:	681b      	ldr	r3, [r3, #0]
 8003c4c:	9303      	str	r3, [sp, #12]
 8003c4e:	e019      	b.n	8003c84 <chEvtBroadcastFlagsI+0x44>
    elp->flags |= flags;
 8003c50:	9b03      	ldr	r3, [sp, #12]
 8003c52:	68da      	ldr	r2, [r3, #12]
 8003c54:	9b00      	ldr	r3, [sp, #0]
 8003c56:	431a      	orrs	r2, r3
 8003c58:	9b03      	ldr	r3, [sp, #12]
 8003c5a:	60da      	str	r2, [r3, #12]
    if ((flags == (eventflags_t)0) ||
 8003c5c:	9b00      	ldr	r3, [sp, #0]
 8003c5e:	2b00      	cmp	r3, #0
 8003c60:	d005      	beq.n	8003c6e <chEvtBroadcastFlagsI+0x2e>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
 8003c62:	9b03      	ldr	r3, [sp, #12]
 8003c64:	68da      	ldr	r2, [r3, #12]
 8003c66:	9b03      	ldr	r3, [sp, #12]
 8003c68:	691b      	ldr	r3, [r3, #16]
 8003c6a:	4013      	ands	r3, r2
    if ((flags == (eventflags_t)0) ||
 8003c6c:	d007      	beq.n	8003c7e <chEvtBroadcastFlagsI+0x3e>
      chEvtSignalI(elp->listener, elp->events);
 8003c6e:	9b03      	ldr	r3, [sp, #12]
 8003c70:	685a      	ldr	r2, [r3, #4]
 8003c72:	9b03      	ldr	r3, [sp, #12]
 8003c74:	689b      	ldr	r3, [r3, #8]
 8003c76:	0019      	movs	r1, r3
 8003c78:	0010      	movs	r0, r2
 8003c7a:	f000 f809 	bl	8003c90 <chEvtSignalI>
    elp = elp->next;
 8003c7e:	9b03      	ldr	r3, [sp, #12]
 8003c80:	681b      	ldr	r3, [r3, #0]
 8003c82:	9303      	str	r3, [sp, #12]
  while (elp != (event_listener_t *)esp) {
 8003c84:	9a03      	ldr	r2, [sp, #12]
 8003c86:	9b01      	ldr	r3, [sp, #4]
 8003c88:	429a      	cmp	r2, r3
 8003c8a:	d1e1      	bne.n	8003c50 <chEvtBroadcastFlagsI+0x10>
}
 8003c8c:	b005      	add	sp, #20
 8003c8e:	bd00      	pop	{pc}

08003c90 <chEvtSignalI>:
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 8003c90:	b500      	push	{lr}
 8003c92:	b083      	sub	sp, #12
 8003c94:	9001      	str	r0, [sp, #4]
 8003c96:	9100      	str	r1, [sp, #0]
  tp->epending |= events;
 8003c98:	9b01      	ldr	r3, [sp, #4]
 8003c9a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8003c9c:	9b00      	ldr	r3, [sp, #0]
 8003c9e:	431a      	orrs	r2, r3
 8003ca0:	9b01      	ldr	r3, [sp, #4]
 8003ca2:	631a      	str	r2, [r3, #48]	; 0x30
  if (((tp->state == CH_STATE_WTOREVT) &&
 8003ca4:	9b01      	ldr	r3, [sp, #4]
 8003ca6:	7f1b      	ldrb	r3, [r3, #28]
 8003ca8:	2b0a      	cmp	r3, #10
 8003caa:	d105      	bne.n	8003cb8 <chEvtSignalI+0x28>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8003cac:	9b01      	ldr	r3, [sp, #4]
 8003cae:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8003cb0:	9b01      	ldr	r3, [sp, #4]
 8003cb2:	6a1b      	ldr	r3, [r3, #32]
 8003cb4:	4013      	ands	r3, r2
  if (((tp->state == CH_STATE_WTOREVT) &&
 8003cb6:	d10c      	bne.n	8003cd2 <chEvtSignalI+0x42>
      ((tp->state == CH_STATE_WTANDEVT) &&
 8003cb8:	9b01      	ldr	r3, [sp, #4]
 8003cba:	7f1b      	ldrb	r3, [r3, #28]
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8003cbc:	2b0b      	cmp	r3, #11
 8003cbe:	d10f      	bne.n	8003ce0 <chEvtSignalI+0x50>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 8003cc0:	9b01      	ldr	r3, [sp, #4]
 8003cc2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8003cc4:	9b01      	ldr	r3, [sp, #4]
 8003cc6:	6a1b      	ldr	r3, [r3, #32]
 8003cc8:	401a      	ands	r2, r3
 8003cca:	9b01      	ldr	r3, [sp, #4]
 8003ccc:	6a1b      	ldr	r3, [r3, #32]
      ((tp->state == CH_STATE_WTANDEVT) &&
 8003cce:	429a      	cmp	r2, r3
 8003cd0:	d106      	bne.n	8003ce0 <chEvtSignalI+0x50>
    tp->u.rdymsg = MSG_OK;
 8003cd2:	9b01      	ldr	r3, [sp, #4]
 8003cd4:	2200      	movs	r2, #0
 8003cd6:	621a      	str	r2, [r3, #32]
    (void) chSchReadyI(tp);
 8003cd8:	9b01      	ldr	r3, [sp, #4]
 8003cda:	0018      	movs	r0, r3
 8003cdc:	f000 fbe8 	bl	80044b0 <chSchReadyI>
}
 8003ce0:	b003      	add	sp, #12
 8003ce2:	bd00      	pop	{pc}
	...

08003cf0 <__core_init>:

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8003cf0:	4770      	bx	lr
 8003cf2:	46c0      	nop			; (mov r8, r8)
	...

08003d00 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8003d00:	4770      	bx	lr
 8003d02:	46c0      	nop			; (mov r8, r8)
	...

08003d10 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8003d10:	e7fe      	b.n	8003d10 <__default_exit>
 8003d12:	46c0      	nop			; (mov r8, r8)
	...

08003d20 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8003d20:	b084      	sub	sp, #16
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8003d22:	4b16      	ldr	r3, [pc, #88]	; (8003d7c <__init_ram_areas+0x5c>)
 8003d24:	9303      	str	r3, [sp, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 8003d26:	9b03      	ldr	r3, [sp, #12]
 8003d28:	681b      	ldr	r3, [r3, #0]
 8003d2a:	9302      	str	r3, [sp, #8]
    uint32_t *p = rap->init_area;
 8003d2c:	9b03      	ldr	r3, [sp, #12]
 8003d2e:	685b      	ldr	r3, [r3, #4]
 8003d30:	9301      	str	r3, [sp, #4]
 8003d32:	e009      	b.n	8003d48 <__init_ram_areas+0x28>

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
      *p = *tp;
 8003d34:	9b02      	ldr	r3, [sp, #8]
 8003d36:	681a      	ldr	r2, [r3, #0]
 8003d38:	9b01      	ldr	r3, [sp, #4]
 8003d3a:	601a      	str	r2, [r3, #0]
      p++;
 8003d3c:	9b01      	ldr	r3, [sp, #4]
 8003d3e:	3304      	adds	r3, #4
 8003d40:	9301      	str	r3, [sp, #4]
      tp++;
 8003d42:	9b02      	ldr	r3, [sp, #8]
 8003d44:	3304      	adds	r3, #4
 8003d46:	9302      	str	r3, [sp, #8]
    while (p < rap->clear_area) {
 8003d48:	9b03      	ldr	r3, [sp, #12]
 8003d4a:	689a      	ldr	r2, [r3, #8]
 8003d4c:	9b01      	ldr	r3, [sp, #4]
 8003d4e:	429a      	cmp	r2, r3
 8003d50:	d8f0      	bhi.n	8003d34 <__init_ram_areas+0x14>
 8003d52:	e005      	b.n	8003d60 <__init_ram_areas+0x40>
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8003d54:	9b01      	ldr	r3, [sp, #4]
 8003d56:	2200      	movs	r2, #0
 8003d58:	601a      	str	r2, [r3, #0]
      p++;
 8003d5a:	9b01      	ldr	r3, [sp, #4]
 8003d5c:	3304      	adds	r3, #4
 8003d5e:	9301      	str	r3, [sp, #4]
    while (p < rap->no_init_area) {
 8003d60:	9b03      	ldr	r3, [sp, #12]
 8003d62:	68da      	ldr	r2, [r3, #12]
 8003d64:	9b01      	ldr	r3, [sp, #4]
 8003d66:	429a      	cmp	r2, r3
 8003d68:	d8f4      	bhi.n	8003d54 <__init_ram_areas+0x34>
    }
    rap++;
 8003d6a:	9b03      	ldr	r3, [sp, #12]
 8003d6c:	3310      	adds	r3, #16
 8003d6e:	9303      	str	r3, [sp, #12]
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8003d70:	9a03      	ldr	r2, [sp, #12]
 8003d72:	4b03      	ldr	r3, [pc, #12]	; (8003d80 <__init_ram_areas+0x60>)
 8003d74:	429a      	cmp	r2, r3
 8003d76:	d3d6      	bcc.n	8003d26 <__init_ram_areas+0x6>
#endif
}
 8003d78:	b004      	add	sp, #16
 8003d7a:	4770      	bx	lr
 8003d7c:	08004ad0 	.word	0x08004ad0
 8003d80:	08004b50 	.word	0x08004b50
	...

08003d90 <BusFault_Handler>:
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
__attribute__((weak))
void _unhandled_exception(void) {
 8003d90:	e7fe      	b.n	8003d90 <BusFault_Handler>
 8003d92:	46c0      	nop			; (mov r8, r8)
	...

08003da0 <NVIC_SetPriority>:
  \note    The priority cannot be set for every core interrupt.
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8003da0:	b530      	push	{r4, r5, lr}
 8003da2:	b083      	sub	sp, #12
 8003da4:	0002      	movs	r2, r0
 8003da6:	9100      	str	r1, [sp, #0]
 8003da8:	466b      	mov	r3, sp
 8003daa:	3307      	adds	r3, #7
 8003dac:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) < 0)
 8003dae:	466b      	mov	r3, sp
 8003db0:	3307      	adds	r3, #7
 8003db2:	781b      	ldrb	r3, [r3, #0]
 8003db4:	2b7f      	cmp	r3, #127	; 0x7f
 8003db6:	d936      	bls.n	8003e26 <NVIC_SetPriority+0x86>
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8003db8:	4c32      	ldr	r4, [pc, #200]	; (8003e84 <NVIC_SetPriority+0xe4>)
 8003dba:	466b      	mov	r3, sp
 8003dbc:	3307      	adds	r3, #7
 8003dbe:	781b      	ldrb	r3, [r3, #0]
 8003dc0:	001a      	movs	r2, r3
 8003dc2:	230f      	movs	r3, #15
 8003dc4:	4013      	ands	r3, r2
 8003dc6:	3b08      	subs	r3, #8
 8003dc8:	0899      	lsrs	r1, r3, #2
 8003dca:	4a2e      	ldr	r2, [pc, #184]	; (8003e84 <NVIC_SetPriority+0xe4>)
 8003dcc:	466b      	mov	r3, sp
 8003dce:	3307      	adds	r3, #7
 8003dd0:	781b      	ldrb	r3, [r3, #0]
 8003dd2:	0018      	movs	r0, r3
 8003dd4:	230f      	movs	r3, #15
 8003dd6:	4003      	ands	r3, r0
 8003dd8:	3b08      	subs	r3, #8
 8003dda:	089b      	lsrs	r3, r3, #2
 8003ddc:	3306      	adds	r3, #6
 8003dde:	009b      	lsls	r3, r3, #2
 8003de0:	18d3      	adds	r3, r2, r3
 8003de2:	3304      	adds	r3, #4
 8003de4:	681b      	ldr	r3, [r3, #0]
 8003de6:	466a      	mov	r2, sp
 8003de8:	3207      	adds	r2, #7
 8003dea:	7812      	ldrb	r2, [r2, #0]
 8003dec:	0010      	movs	r0, r2
 8003dee:	2203      	movs	r2, #3
 8003df0:	4002      	ands	r2, r0
 8003df2:	00d2      	lsls	r2, r2, #3
 8003df4:	20ff      	movs	r0, #255	; 0xff
 8003df6:	4090      	lsls	r0, r2
 8003df8:	0002      	movs	r2, r0
 8003dfa:	43d2      	mvns	r2, r2
 8003dfc:	401a      	ands	r2, r3
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 8003dfe:	9b00      	ldr	r3, [sp, #0]
 8003e00:	019b      	lsls	r3, r3, #6
 8003e02:	20ff      	movs	r0, #255	; 0xff
 8003e04:	4018      	ands	r0, r3
 8003e06:	466b      	mov	r3, sp
 8003e08:	3307      	adds	r3, #7
 8003e0a:	781b      	ldrb	r3, [r3, #0]
 8003e0c:	001d      	movs	r5, r3
 8003e0e:	2303      	movs	r3, #3
 8003e10:	402b      	ands	r3, r5
 8003e12:	00db      	lsls	r3, r3, #3
 8003e14:	4098      	lsls	r0, r3
 8003e16:	0003      	movs	r3, r0
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8003e18:	431a      	orrs	r2, r3
 8003e1a:	1d8b      	adds	r3, r1, #6
 8003e1c:	009b      	lsls	r3, r3, #2
 8003e1e:	18e3      	adds	r3, r4, r3
 8003e20:	3304      	adds	r3, #4
 8003e22:	601a      	str	r2, [r3, #0]
 8003e24:	e02b      	b.n	8003e7e <NVIC_SetPriority+0xde>
  }
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8003e26:	4c18      	ldr	r4, [pc, #96]	; (8003e88 <NVIC_SetPriority+0xe8>)
 8003e28:	466b      	mov	r3, sp
 8003e2a:	3307      	adds	r3, #7
 8003e2c:	781b      	ldrb	r3, [r3, #0]
 8003e2e:	b25b      	sxtb	r3, r3
 8003e30:	089b      	lsrs	r3, r3, #2
 8003e32:	4915      	ldr	r1, [pc, #84]	; (8003e88 <NVIC_SetPriority+0xe8>)
 8003e34:	466a      	mov	r2, sp
 8003e36:	3207      	adds	r2, #7
 8003e38:	7812      	ldrb	r2, [r2, #0]
 8003e3a:	b252      	sxtb	r2, r2
 8003e3c:	0892      	lsrs	r2, r2, #2
 8003e3e:	32c0      	adds	r2, #192	; 0xc0
 8003e40:	0092      	lsls	r2, r2, #2
 8003e42:	5852      	ldr	r2, [r2, r1]
 8003e44:	4669      	mov	r1, sp
 8003e46:	3107      	adds	r1, #7
 8003e48:	7809      	ldrb	r1, [r1, #0]
 8003e4a:	0008      	movs	r0, r1
 8003e4c:	2103      	movs	r1, #3
 8003e4e:	4001      	ands	r1, r0
 8003e50:	00c9      	lsls	r1, r1, #3
 8003e52:	20ff      	movs	r0, #255	; 0xff
 8003e54:	4088      	lsls	r0, r1
 8003e56:	0001      	movs	r1, r0
 8003e58:	43c9      	mvns	r1, r1
 8003e5a:	4011      	ands	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 8003e5c:	9a00      	ldr	r2, [sp, #0]
 8003e5e:	0192      	lsls	r2, r2, #6
 8003e60:	20ff      	movs	r0, #255	; 0xff
 8003e62:	4010      	ands	r0, r2
 8003e64:	466a      	mov	r2, sp
 8003e66:	3207      	adds	r2, #7
 8003e68:	7812      	ldrb	r2, [r2, #0]
 8003e6a:	0015      	movs	r5, r2
 8003e6c:	2203      	movs	r2, #3
 8003e6e:	402a      	ands	r2, r5
 8003e70:	00d2      	lsls	r2, r2, #3
 8003e72:	4090      	lsls	r0, r2
 8003e74:	0002      	movs	r2, r0
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8003e76:	430a      	orrs	r2, r1
 8003e78:	33c0      	adds	r3, #192	; 0xc0
 8003e7a:	009b      	lsls	r3, r3, #2
 8003e7c:	511a      	str	r2, [r3, r4]
  }
}
 8003e7e:	b003      	add	sp, #12
 8003e80:	bd30      	pop	{r4, r5, pc}
 8003e82:	46c0      	nop			; (mov r8, r8)
 8003e84:	e000ed00 	.word	0xe000ed00
 8003e88:	e000e100 	.word	0xe000e100
 8003e8c:	00000000 	.word	0x00000000

08003e90 <port_init>:
static inline void port_init(void) {
 8003e90:	b510      	push	{r4, lr}
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 8003e92:	2302      	movs	r3, #2
 8003e94:	425b      	negs	r3, r3
 8003e96:	2100      	movs	r1, #0
 8003e98:	0018      	movs	r0, r3
 8003e9a:	f7ff ff81 	bl	8003da0 <NVIC_SetPriority>
}
 8003e9e:	bd10      	pop	{r4, pc}

08003ea0 <port_lock.lto_priv.180>:
  __ASM volatile ("cpsid i" : : : "memory");
 8003ea0:	b672      	cpsid	i
}
 8003ea2:	4770      	bx	lr
	...

08003eb0 <port_unlock.lto_priv.177>:
  __ASM volatile ("cpsie i" : : : "memory");
 8003eb0:	b662      	cpsie	i
}
 8003eb2:	4770      	bx	lr
	...

08003ec0 <port_lock_from_isr.lto_priv.189>:
static inline void port_lock_from_isr(void) {
 8003ec0:	b510      	push	{r4, lr}
  port_lock();
 8003ec2:	f7ff ffed 	bl	8003ea0 <port_lock.lto_priv.180>
}
 8003ec6:	bd10      	pop	{r4, pc}
	...

08003ed0 <port_unlock_from_isr.lto_priv.187>:
static inline void port_unlock_from_isr(void) {
 8003ed0:	b510      	push	{r4, lr}
  port_unlock();
 8003ed2:	f7ff ffed 	bl	8003eb0 <port_unlock.lto_priv.177>
}
 8003ed6:	bd10      	pop	{r4, pc}
	...

08003ee0 <port_enable>:
 8003ee0:	b662      	cpsie	i
 * @brief   Enables all the interrupt sources.
 */
static inline void port_enable(void) {

  __enable_irq();
}
 8003ee2:	4770      	bx	lr
	...

08003ef0 <port_wait_for_interrupt>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 8003ef0:	4770      	bx	lr
 8003ef2:	46c0      	nop			; (mov r8, r8)
	...

08003f00 <st_lld_get_counter.lto_priv.174>:
  return (systime_t)STM32_ST_TIM->CNT;
 8003f00:	2380      	movs	r3, #128	; 0x80
 8003f02:	05db      	lsls	r3, r3, #23
 8003f04:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8003f06:	0018      	movs	r0, r3
 8003f08:	4770      	bx	lr
 8003f0a:	46c0      	nop			; (mov r8, r8)
 8003f0c:	0000      	movs	r0, r0
	...

08003f10 <port_timer_stop_alarm.lto_priv.195>:
static inline void port_timer_stop_alarm(void) {
 8003f10:	b510      	push	{r4, lr}
  stStopAlarm();
 8003f12:	f7fe fa2d 	bl	8002370 <stStopAlarm>
}
 8003f16:	bd10      	pop	{r4, pc}
	...

08003f20 <port_timer_set_alarm.lto_priv.193>:
static inline void port_timer_set_alarm(systime_t time) {
 8003f20:	b500      	push	{lr}
 8003f22:	b083      	sub	sp, #12
 8003f24:	9001      	str	r0, [sp, #4]
  stSetAlarm(time);
 8003f26:	9b01      	ldr	r3, [sp, #4]
 8003f28:	0018      	movs	r0, r3
 8003f2a:	f7fe fa29 	bl	8002380 <stSetAlarm>
}
 8003f2e:	b003      	add	sp, #12
 8003f30:	bd00      	pop	{pc}
 8003f32:	46c0      	nop			; (mov r8, r8)
	...

08003f40 <port_timer_get_time.lto_priv.171>:
static inline systime_t port_timer_get_time(void) {
 8003f40:	b510      	push	{r4, lr}
  return stGetCounter();
 8003f42:	f7ff ffdd 	bl	8003f00 <st_lld_get_counter.lto_priv.174>
 8003f46:	0003      	movs	r3, r0
}
 8003f48:	0018      	movs	r0, r3
 8003f4a:	bd10      	pop	{r4, pc}
 8003f4c:	0000      	movs	r0, r0
	...

08003f50 <chSysEnable>:
static inline void chSysEnable(void) {
 8003f50:	b510      	push	{r4, lr}
  port_enable();
 8003f52:	f7ff ffc5 	bl	8003ee0 <port_enable>
}
 8003f56:	bd10      	pop	{r4, pc}
	...

08003f60 <chSysLockFromISR.lto_priv.185>:
static inline void chSysLockFromISR(void) {
 8003f60:	b510      	push	{r4, lr}
  port_lock_from_isr();
 8003f62:	f7ff ffad 	bl	8003ec0 <port_lock_from_isr.lto_priv.189>
}
 8003f66:	bd10      	pop	{r4, pc}
	...

08003f70 <chSysUnlockFromISR.lto_priv.183>:
static inline void chSysUnlockFromISR(void) {
 8003f70:	b510      	push	{r4, lr}
  port_unlock_from_isr();
 8003f72:	f7ff ffad 	bl	8003ed0 <port_unlock_from_isr.lto_priv.187>
}
 8003f76:	bd10      	pop	{r4, pc}
	...

08003f80 <chVTGetSystemTimeX.lto_priv.191>:
static inline systime_t chVTGetSystemTimeX(void) {
 8003f80:	b510      	push	{r4, lr}
  return port_timer_get_time();
 8003f82:	f7ff ffdd 	bl	8003f40 <port_timer_get_time.lto_priv.171>
 8003f86:	0003      	movs	r3, r0
}
 8003f88:	0018      	movs	r0, r3
 8003f8a:	bd10      	pop	{r4, pc}
 8003f8c:	0000      	movs	r0, r0
	...

08003f90 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
 8003f90:	b500      	push	{lr}
 8003f92:	b085      	sub	sp, #20
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.next;
 8003f94:	4b2a      	ldr	r3, [pc, #168]	; (8004040 <chVTDoTickI+0xb0>)
 8003f96:	69db      	ldr	r3, [r3, #28]
 8003f98:	9303      	str	r3, [sp, #12]
  now = chVTGetSystemTimeX();
 8003f9a:	f7ff fff1 	bl	8003f80 <chVTGetSystemTimeX.lto_priv.191>
 8003f9e:	0003      	movs	r3, r0
 8003fa0:	9302      	str	r3, [sp, #8]
 8003fa2:	e02b      	b.n	8003ffc <chVTDoTickI+0x6c>
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;
 8003fa4:	4b26      	ldr	r3, [pc, #152]	; (8004040 <chVTDoTickI+0xb0>)
 8003fa6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8003fa8:	9b03      	ldr	r3, [sp, #12]
 8003faa:	689b      	ldr	r3, [r3, #8]
 8003fac:	18d2      	adds	r2, r2, r3
 8003fae:	4b24      	ldr	r3, [pc, #144]	; (8004040 <chVTDoTickI+0xb0>)
 8003fb0:	629a      	str	r2, [r3, #40]	; 0x28

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8003fb2:	9b03      	ldr	r3, [sp, #12]
 8003fb4:	681b      	ldr	r3, [r3, #0]
 8003fb6:	4a23      	ldr	r2, [pc, #140]	; (8004044 <chVTDoTickI+0xb4>)
 8003fb8:	605a      	str	r2, [r3, #4]
    ch.vtlist.next = vtp->next;
 8003fba:	9b03      	ldr	r3, [sp, #12]
 8003fbc:	681a      	ldr	r2, [r3, #0]
 8003fbe:	4b20      	ldr	r3, [pc, #128]	; (8004040 <chVTDoTickI+0xb0>)
 8003fc0:	61da      	str	r2, [r3, #28]
    fn = vtp->func;
 8003fc2:	9b03      	ldr	r3, [sp, #12]
 8003fc4:	68db      	ldr	r3, [r3, #12]
 8003fc6:	9300      	str	r3, [sp, #0]
    vtp->func = NULL;
 8003fc8:	9b03      	ldr	r3, [sp, #12]
 8003fca:	2200      	movs	r2, #0
 8003fcc:	60da      	str	r2, [r3, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8003fce:	4b1c      	ldr	r3, [pc, #112]	; (8004040 <chVTDoTickI+0xb0>)
 8003fd0:	69da      	ldr	r2, [r3, #28]
 8003fd2:	4b1c      	ldr	r3, [pc, #112]	; (8004044 <chVTDoTickI+0xb4>)
 8003fd4:	429a      	cmp	r2, r3
 8003fd6:	d101      	bne.n	8003fdc <chVTDoTickI+0x4c>
      port_timer_stop_alarm();
 8003fd8:	f7ff ff9a 	bl	8003f10 <port_timer_stop_alarm.lto_priv.195>
    }

    /* Leaving the system critical zone in order to execute the callback
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();
 8003fdc:	f7ff ffc8 	bl	8003f70 <chSysUnlockFromISR.lto_priv.183>

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->par);
 8003fe0:	9b03      	ldr	r3, [sp, #12]
 8003fe2:	691a      	ldr	r2, [r3, #16]
 8003fe4:	9b00      	ldr	r3, [sp, #0]
 8003fe6:	0010      	movs	r0, r2
 8003fe8:	4798      	blx	r3

    /* Re-entering the critical zone in order to continue the exploration
       of the list.*/
    chSysLockFromISR();
 8003fea:	f7ff ffb9 	bl	8003f60 <chSysLockFromISR.lto_priv.185>

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.next;
 8003fee:	4b14      	ldr	r3, [pc, #80]	; (8004040 <chVTDoTickI+0xb0>)
 8003ff0:	69db      	ldr	r3, [r3, #28]
 8003ff2:	9303      	str	r3, [sp, #12]
    now = chVTGetSystemTimeX();
 8003ff4:	f7ff ffc4 	bl	8003f80 <chVTGetSystemTimeX.lto_priv.191>
 8003ff8:	0003      	movs	r3, r0
 8003ffa:	9302      	str	r3, [sp, #8]
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8003ffc:	9b03      	ldr	r3, [sp, #12]
 8003ffe:	689a      	ldr	r2, [r3, #8]
 8004000:	4b0f      	ldr	r3, [pc, #60]	; (8004040 <chVTDoTickI+0xb0>)
 8004002:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004004:	9902      	ldr	r1, [sp, #8]
 8004006:	1acb      	subs	r3, r1, r3
 8004008:	429a      	cmp	r2, r3
 800400a:	d9cb      	bls.n	8003fa4 <chVTDoTickI+0x14>
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 800400c:	4b0c      	ldr	r3, [pc, #48]	; (8004040 <chVTDoTickI+0xb0>)
 800400e:	69da      	ldr	r2, [r3, #28]
 8004010:	4b0c      	ldr	r3, [pc, #48]	; (8004044 <chVTDoTickI+0xb4>)
 8004012:	429a      	cmp	r2, r3
 8004014:	d012      	beq.n	800403c <chVTDoTickI+0xac>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.lasttime + vtp->delta - now;
 8004016:	4b0a      	ldr	r3, [pc, #40]	; (8004040 <chVTDoTickI+0xb0>)
 8004018:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800401a:	9b03      	ldr	r3, [sp, #12]
 800401c:	689b      	ldr	r3, [r3, #8]
 800401e:	18d2      	adds	r2, r2, r3
 8004020:	9b02      	ldr	r3, [sp, #8]
 8004022:	1ad3      	subs	r3, r2, r3
 8004024:	9301      	str	r3, [sp, #4]
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8004026:	9b01      	ldr	r3, [sp, #4]
 8004028:	2b01      	cmp	r3, #1
 800402a:	d801      	bhi.n	8004030 <chVTDoTickI+0xa0>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800402c:	2302      	movs	r3, #2
 800402e:	9301      	str	r3, [sp, #4]
  }
  port_timer_set_alarm(now + delta);
 8004030:	9a02      	ldr	r2, [sp, #8]
 8004032:	9b01      	ldr	r3, [sp, #4]
 8004034:	18d3      	adds	r3, r2, r3
 8004036:	0018      	movs	r0, r3
 8004038:	f7ff ff72 	bl	8003f20 <port_timer_set_alarm.lto_priv.193>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.lasttime) <=
              (now + delta - ch.vtlist.lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800403c:	b005      	add	sp, #20
 800403e:	bd00      	pop	{pc}
 8004040:	200004e0 	.word	0x200004e0
 8004044:	200004fc 	.word	0x200004fc
	...

08004050 <_idle_thread.lto_priv.28>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8004050:	b500      	push	{lr}
 8004052:	b083      	sub	sp, #12
 8004054:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 8004056:	f7ff ff4b 	bl	8003ef0 <port_wait_for_interrupt>
 800405a:	e7fc      	b.n	8004056 <_idle_thread.lto_priv.28+0x6>
 800405c:	0000      	movs	r0, r0
	...

08004060 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 8004060:	b510      	push	{r4, lr}

  _scheduler_init();
 8004062:	f000 fa0d 	bl	8004480 <_scheduler_init>
  _vt_init();
 8004066:	f000 f86b 	bl	8004140 <_vt_init>
#endif
#if CH_CFG_USE_TM == TRUE
  _tm_init();
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 800406a:	f7ff fb79 	bl	8003760 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 800406e:	f7ff fbcf 	bl	8003810 <_heap_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 8004072:	490b      	ldr	r1, [pc, #44]	; (80040a0 <chSysInit+0x40>)
 8004074:	4b0b      	ldr	r3, [pc, #44]	; (80040a4 <chSysInit+0x44>)
 8004076:	2280      	movs	r2, #128	; 0x80
 8004078:	0018      	movs	r0, r3
 800407a:	f000 fc29 	bl	80048d0 <_thread_init>
 800407e:	0002      	movs	r2, r0
 8004080:	4b09      	ldr	r3, [pc, #36]	; (80040a8 <chSysInit+0x48>)
 8004082:	619a      	str	r2, [r3, #24]
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 8004084:	4b08      	ldr	r3, [pc, #32]	; (80040a8 <chSysInit+0x48>)
 8004086:	699b      	ldr	r3, [r3, #24]
 8004088:	2201      	movs	r2, #1
 800408a:	771a      	strb	r2, [r3, #28]

  /* Port layer initialization last because it depend on some of the
     initializations performed before.*/
  port_init();
 800408c:	f7ff ff00 	bl	8003e90 <port_init>
  /* Starting measurement for this thread.*/
  chTMStartMeasurementX(&currp->stats);
#endif

  /* It is alive now.*/
  chSysEnable();
 8004090:	f7ff ff5e 	bl	8003f50 <chSysEnable>
    };

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreate(&idle_descriptor);
 8004094:	4b05      	ldr	r3, [pc, #20]	; (80040ac <chSysInit+0x4c>)
 8004096:	0018      	movs	r0, r3
 8004098:	f000 fc82 	bl	80049a0 <chThdCreate>
  }
#endif
}
 800409c:	bd10      	pop	{r4, pc}
 800409e:	46c0      	nop			; (mov r8, r8)
 80040a0:	08004b68 	.word	0x08004b68
 80040a4:	20000510 	.word	0x20000510
 80040a8:	200004e0 	.word	0x200004e0
 80040ac:	08004b50 	.word	0x08004b50

080040b0 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 80040b0:	b510      	push	{r4, lr}
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->time++;
#endif
  chVTDoTickI();
 80040b2:	f7ff ff6d 	bl	8003f90 <chVTDoTickI>
  CH_CFG_SYSTEM_TICK_HOOK();
}
 80040b6:	bd10      	pop	{r4, pc}
	...

080040c0 <st_lld_get_counter.lto_priv.175>:
  return (systime_t)STM32_ST_TIM->CNT;
 80040c0:	2380      	movs	r3, #128	; 0x80
 80040c2:	05db      	lsls	r3, r3, #23
 80040c4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 80040c6:	0018      	movs	r0, r3
 80040c8:	4770      	bx	lr
 80040ca:	46c0      	nop			; (mov r8, r8)
 80040cc:	0000      	movs	r0, r0
	...

080040d0 <port_timer_start_alarm>:
static inline void port_timer_start_alarm(systime_t time) {
 80040d0:	b500      	push	{lr}
 80040d2:	b083      	sub	sp, #12
 80040d4:	9001      	str	r0, [sp, #4]
  stStartAlarm(time);
 80040d6:	9b01      	ldr	r3, [sp, #4]
 80040d8:	0018      	movs	r0, r3
 80040da:	f7fe f939 	bl	8002350 <stStartAlarm>
}
 80040de:	b003      	add	sp, #12
 80040e0:	bd00      	pop	{pc}
 80040e2:	46c0      	nop			; (mov r8, r8)
	...

080040f0 <port_timer_stop_alarm.lto_priv.196>:
static inline void port_timer_stop_alarm(void) {
 80040f0:	b510      	push	{r4, lr}
  stStopAlarm();
 80040f2:	f7fe f93d 	bl	8002370 <stStopAlarm>
}
 80040f6:	bd10      	pop	{r4, pc}
	...

08004100 <port_timer_set_alarm.lto_priv.194>:
static inline void port_timer_set_alarm(systime_t time) {
 8004100:	b500      	push	{lr}
 8004102:	b083      	sub	sp, #12
 8004104:	9001      	str	r0, [sp, #4]
  stSetAlarm(time);
 8004106:	9b01      	ldr	r3, [sp, #4]
 8004108:	0018      	movs	r0, r3
 800410a:	f7fe f939 	bl	8002380 <stSetAlarm>
}
 800410e:	b003      	add	sp, #12
 8004110:	bd00      	pop	{pc}
 8004112:	46c0      	nop			; (mov r8, r8)
	...

08004120 <port_timer_get_time.lto_priv.172>:
static inline systime_t port_timer_get_time(void) {
 8004120:	b510      	push	{r4, lr}
  return stGetCounter();
 8004122:	f7ff ffcd 	bl	80040c0 <st_lld_get_counter.lto_priv.175>
 8004126:	0003      	movs	r3, r0
}
 8004128:	0018      	movs	r0, r3
 800412a:	bd10      	pop	{r4, pc}
 800412c:	0000      	movs	r0, r0
	...

08004130 <chVTGetSystemTimeX.lto_priv.192>:
static inline systime_t chVTGetSystemTimeX(void) {
 8004130:	b510      	push	{r4, lr}
  return port_timer_get_time();
 8004132:	f7ff fff5 	bl	8004120 <port_timer_get_time.lto_priv.172>
 8004136:	0003      	movs	r3, r0
}
 8004138:	0018      	movs	r0, r3
 800413a:	bd10      	pop	{r4, pc}
 800413c:	0000      	movs	r0, r0
	...

08004140 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8004140:	4b06      	ldr	r3, [pc, #24]	; (800415c <_vt_init+0x1c>)
 8004142:	4a07      	ldr	r2, [pc, #28]	; (8004160 <_vt_init+0x20>)
 8004144:	61da      	str	r2, [r3, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8004146:	4b05      	ldr	r3, [pc, #20]	; (800415c <_vt_init+0x1c>)
 8004148:	4a05      	ldr	r2, [pc, #20]	; (8004160 <_vt_init+0x20>)
 800414a:	621a      	str	r2, [r3, #32]
  ch.vtlist.delta = (systime_t)-1;
 800414c:	4b03      	ldr	r3, [pc, #12]	; (800415c <_vt_init+0x1c>)
 800414e:	2201      	movs	r2, #1
 8004150:	4252      	negs	r2, r2
 8004152:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 8004154:	4b01      	ldr	r3, [pc, #4]	; (800415c <_vt_init+0x1c>)
 8004156:	2200      	movs	r2, #0
 8004158:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800415a:	4770      	bx	lr
 800415c:	200004e0 	.word	0x200004e0
 8004160:	200004fc 	.word	0x200004fc
	...

08004170 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8004170:	b500      	push	{lr}
 8004172:	b089      	sub	sp, #36	; 0x24
 8004174:	9003      	str	r0, [sp, #12]
 8004176:	9102      	str	r1, [sp, #8]
 8004178:	9201      	str	r2, [sp, #4]
 800417a:	9300      	str	r3, [sp, #0]
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
 800417c:	9b03      	ldr	r3, [sp, #12]
 800417e:	9a00      	ldr	r2, [sp, #0]
 8004180:	611a      	str	r2, [r3, #16]
  vtp->func = vtfunc;
 8004182:	9b03      	ldr	r3, [sp, #12]
 8004184:	9a01      	ldr	r2, [sp, #4]
 8004186:	60da      	str	r2, [r3, #12]

#if CH_CFG_ST_TIMEDELTA > 0
  {
    systime_t now = chVTGetSystemTimeX();
 8004188:	f7ff ffd2 	bl	8004130 <chVTGetSystemTimeX.lto_priv.192>
 800418c:	0003      	movs	r3, r0
 800418e:	9305      	str	r3, [sp, #20]

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8004190:	9b02      	ldr	r3, [sp, #8]
 8004192:	2b01      	cmp	r3, #1
 8004194:	d801      	bhi.n	800419a <chVTDoSetI+0x2a>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 8004196:	2302      	movs	r3, #2
 8004198:	9302      	str	r3, [sp, #8]
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800419a:	4b38      	ldr	r3, [pc, #224]	; (800427c <chVTDoSetI+0x10c>)
 800419c:	69da      	ldr	r2, [r3, #28]
 800419e:	4b38      	ldr	r3, [pc, #224]	; (8004280 <chVTDoSetI+0x110>)
 80041a0:	429a      	cmp	r2, r3
 80041a2:	d119      	bne.n	80041d8 <chVTDoSetI+0x68>

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
 80041a4:	4b35      	ldr	r3, [pc, #212]	; (800427c <chVTDoSetI+0x10c>)
 80041a6:	9a05      	ldr	r2, [sp, #20]
 80041a8:	629a      	str	r2, [r3, #40]	; 0x28
      ch.vtlist.next = vtp;
 80041aa:	4b34      	ldr	r3, [pc, #208]	; (800427c <chVTDoSetI+0x10c>)
 80041ac:	9a03      	ldr	r2, [sp, #12]
 80041ae:	61da      	str	r2, [r3, #28]
      ch.vtlist.prev = vtp;
 80041b0:	4b32      	ldr	r3, [pc, #200]	; (800427c <chVTDoSetI+0x10c>)
 80041b2:	9a03      	ldr	r2, [sp, #12]
 80041b4:	621a      	str	r2, [r3, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 80041b6:	9b03      	ldr	r3, [sp, #12]
 80041b8:	4a31      	ldr	r2, [pc, #196]	; (8004280 <chVTDoSetI+0x110>)
 80041ba:	601a      	str	r2, [r3, #0]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 80041bc:	9b03      	ldr	r3, [sp, #12]
 80041be:	4a30      	ldr	r2, [pc, #192]	; (8004280 <chVTDoSetI+0x110>)
 80041c0:	605a      	str	r2, [r3, #4]
      vtp->delta = delay;
 80041c2:	9b03      	ldr	r3, [sp, #12]
 80041c4:	9a02      	ldr	r2, [sp, #8]
 80041c6:	609a      	str	r2, [r3, #8]

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.lasttime + delay);
 80041c8:	4b2c      	ldr	r3, [pc, #176]	; (800427c <chVTDoSetI+0x10c>)
 80041ca:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80041cc:	9b02      	ldr	r3, [sp, #8]
 80041ce:	18d3      	adds	r3, r2, r3
 80041d0:	0018      	movs	r0, r3
 80041d2:	f7ff ff7d 	bl	80040d0 <port_timer_start_alarm>
 80041d6:	e04f      	b.n	8004278 <chVTDoSetI+0x108>

      return;
    }

    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;
 80041d8:	4b28      	ldr	r3, [pc, #160]	; (800427c <chVTDoSetI+0x10c>)
 80041da:	69db      	ldr	r3, [r3, #28]
 80041dc:	9307      	str	r3, [sp, #28]

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = now - ch.vtlist.lasttime + delay;
 80041de:	4b27      	ldr	r3, [pc, #156]	; (800427c <chVTDoSetI+0x10c>)
 80041e0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80041e2:	9a05      	ldr	r2, [sp, #20]
 80041e4:	1ad2      	subs	r2, r2, r3
 80041e6:	9b02      	ldr	r3, [sp, #8]
 80041e8:	18d3      	adds	r3, r2, r3
 80041ea:	9306      	str	r3, [sp, #24]

    if (delta < now - ch.vtlist.lasttime) {
 80041ec:	4b23      	ldr	r3, [pc, #140]	; (800427c <chVTDoSetI+0x10c>)
 80041ee:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80041f0:	9a05      	ldr	r2, [sp, #20]
 80041f2:	1ad2      	subs	r2, r2, r3
 80041f4:	9b06      	ldr	r3, [sp, #24]
 80041f6:	429a      	cmp	r2, r3
 80041f8:	d908      	bls.n	800420c <chVTDoSetI+0x9c>
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 80041fa:	9b07      	ldr	r3, [sp, #28]
 80041fc:	689b      	ldr	r3, [r3, #8]
 80041fe:	9a06      	ldr	r2, [sp, #24]
 8004200:	1ad3      	subs	r3, r2, r3
 8004202:	9306      	str	r3, [sp, #24]
      p = p->next;
 8004204:	9b07      	ldr	r3, [sp, #28]
 8004206:	681b      	ldr	r3, [r3, #0]
 8004208:	9307      	str	r3, [sp, #28]
 800420a:	e014      	b.n	8004236 <chVTDoSetI+0xc6>
    }
    else if (delta < p->delta) {
 800420c:	9b07      	ldr	r3, [sp, #28]
 800420e:	689a      	ldr	r2, [r3, #8]
 8004210:	9b06      	ldr	r3, [sp, #24]
 8004212:	429a      	cmp	r2, r3
 8004214:	d90f      	bls.n	8004236 <chVTDoSetI+0xc6>
     /* A small delay that will become the first element in the delta list
        and next deadline.*/
      port_timer_set_alarm(ch.vtlist.lasttime + delta);
 8004216:	4b19      	ldr	r3, [pc, #100]	; (800427c <chVTDoSetI+0x10c>)
 8004218:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800421a:	9b06      	ldr	r3, [sp, #24]
 800421c:	18d3      	adds	r3, r2, r3
 800421e:	0018      	movs	r0, r3
 8004220:	f7ff ff6e 	bl	8004100 <port_timer_set_alarm.lto_priv.194>
 8004224:	e007      	b.n	8004236 <chVTDoSetI+0xc6>
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    delta -= p->delta;
 8004226:	9b07      	ldr	r3, [sp, #28]
 8004228:	689b      	ldr	r3, [r3, #8]
 800422a:	9a06      	ldr	r2, [sp, #24]
 800422c:	1ad3      	subs	r3, r2, r3
 800422e:	9306      	str	r3, [sp, #24]
    p = p->next;
 8004230:	9b07      	ldr	r3, [sp, #28]
 8004232:	681b      	ldr	r3, [r3, #0]
 8004234:	9307      	str	r3, [sp, #28]
  while (p->delta < delta) {
 8004236:	9b07      	ldr	r3, [sp, #28]
 8004238:	689a      	ldr	r2, [r3, #8]
 800423a:	9b06      	ldr	r3, [sp, #24]
 800423c:	429a      	cmp	r2, r3
 800423e:	d3f2      	bcc.n	8004226 <chVTDoSetI+0xb6>
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
 8004240:	9b03      	ldr	r3, [sp, #12]
 8004242:	9a07      	ldr	r2, [sp, #28]
 8004244:	601a      	str	r2, [r3, #0]
  vtp->prev = vtp->next->prev;
 8004246:	9b03      	ldr	r3, [sp, #12]
 8004248:	681b      	ldr	r3, [r3, #0]
 800424a:	685a      	ldr	r2, [r3, #4]
 800424c:	9b03      	ldr	r3, [sp, #12]
 800424e:	605a      	str	r2, [r3, #4]
  vtp->prev->next = vtp;
 8004250:	9b03      	ldr	r3, [sp, #12]
 8004252:	685b      	ldr	r3, [r3, #4]
 8004254:	9a03      	ldr	r2, [sp, #12]
 8004256:	601a      	str	r2, [r3, #0]
  p->prev = vtp;
 8004258:	9b07      	ldr	r3, [sp, #28]
 800425a:	9a03      	ldr	r2, [sp, #12]
 800425c:	605a      	str	r2, [r3, #4]
  vtp->delta = delta
 800425e:	9b03      	ldr	r3, [sp, #12]
 8004260:	9a06      	ldr	r2, [sp, #24]
 8004262:	609a      	str	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 8004264:	9b07      	ldr	r3, [sp, #28]
 8004266:	689a      	ldr	r2, [r3, #8]
 8004268:	9b06      	ldr	r3, [sp, #24]
 800426a:	1ad2      	subs	r2, r2, r3
 800426c:	9b07      	ldr	r3, [sp, #28]
 800426e:	609a      	str	r2, [r3, #8]
  ch.vtlist.delta = (systime_t)-1;
 8004270:	4b02      	ldr	r3, [pc, #8]	; (800427c <chVTDoSetI+0x10c>)
 8004272:	2201      	movs	r2, #1
 8004274:	4252      	negs	r2, r2
 8004276:	625a      	str	r2, [r3, #36]	; 0x24
}
 8004278:	b009      	add	sp, #36	; 0x24
 800427a:	bd00      	pop	{pc}
 800427c:	200004e0 	.word	0x200004e0
 8004280:	200004fc 	.word	0x200004fc
	...

08004290 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8004290:	b500      	push	{lr}
 8004292:	b085      	sub	sp, #20
 8004294:	9001      	str	r0, [sp, #4]
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8004296:	4b31      	ldr	r3, [pc, #196]	; (800435c <chVTDoResetI+0xcc>)
 8004298:	69da      	ldr	r2, [r3, #28]
 800429a:	9b01      	ldr	r3, [sp, #4]
 800429c:	429a      	cmp	r2, r3
 800429e:	d01b      	beq.n	80042d8 <chVTDoResetI+0x48>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 80042a0:	9b01      	ldr	r3, [sp, #4]
 80042a2:	685b      	ldr	r3, [r3, #4]
 80042a4:	9a01      	ldr	r2, [sp, #4]
 80042a6:	6812      	ldr	r2, [r2, #0]
 80042a8:	601a      	str	r2, [r3, #0]
    vtp->next->prev = vtp->prev;
 80042aa:	9b01      	ldr	r3, [sp, #4]
 80042ac:	681b      	ldr	r3, [r3, #0]
 80042ae:	9a01      	ldr	r2, [sp, #4]
 80042b0:	6852      	ldr	r2, [r2, #4]
 80042b2:	605a      	str	r2, [r3, #4]
    vtp->func = NULL;
 80042b4:	9b01      	ldr	r3, [sp, #4]
 80042b6:	2200      	movs	r2, #0
 80042b8:	60da      	str	r2, [r3, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 80042ba:	9b01      	ldr	r3, [sp, #4]
 80042bc:	681a      	ldr	r2, [r3, #0]
 80042be:	4b28      	ldr	r3, [pc, #160]	; (8004360 <chVTDoResetI+0xd0>)
 80042c0:	429a      	cmp	r2, r3
 80042c2:	d047      	beq.n	8004354 <chVTDoResetI+0xc4>
      vtp->next->delta += vtp->delta;
 80042c4:	9b01      	ldr	r3, [sp, #4]
 80042c6:	681b      	ldr	r3, [r3, #0]
 80042c8:	9a01      	ldr	r2, [sp, #4]
 80042ca:	6812      	ldr	r2, [r2, #0]
 80042cc:	6891      	ldr	r1, [r2, #8]
 80042ce:	9a01      	ldr	r2, [sp, #4]
 80042d0:	6892      	ldr	r2, [r2, #8]
 80042d2:	188a      	adds	r2, r1, r2
 80042d4:	609a      	str	r2, [r3, #8]
 80042d6:	e03e      	b.n	8004356 <chVTDoResetI+0xc6>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 80042d8:	9b01      	ldr	r3, [sp, #4]
 80042da:	681a      	ldr	r2, [r3, #0]
 80042dc:	4b1f      	ldr	r3, [pc, #124]	; (800435c <chVTDoResetI+0xcc>)
 80042de:	61da      	str	r2, [r3, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 80042e0:	4b1e      	ldr	r3, [pc, #120]	; (800435c <chVTDoResetI+0xcc>)
 80042e2:	69db      	ldr	r3, [r3, #28]
 80042e4:	4a1e      	ldr	r2, [pc, #120]	; (8004360 <chVTDoResetI+0xd0>)
 80042e6:	605a      	str	r2, [r3, #4]
  vtp->func = NULL;
 80042e8:	9b01      	ldr	r3, [sp, #4]
 80042ea:	2200      	movs	r2, #0
 80042ec:	60da      	str	r2, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80042ee:	4b1b      	ldr	r3, [pc, #108]	; (800435c <chVTDoResetI+0xcc>)
 80042f0:	69da      	ldr	r2, [r3, #28]
 80042f2:	4b1b      	ldr	r3, [pc, #108]	; (8004360 <chVTDoResetI+0xd0>)
 80042f4:	429a      	cmp	r2, r3
 80042f6:	d102      	bne.n	80042fe <chVTDoResetI+0x6e>
    port_timer_stop_alarm();
 80042f8:	f7ff fefa 	bl	80040f0 <port_timer_stop_alarm.lto_priv.196>
 80042fc:	e02b      	b.n	8004356 <chVTDoResetI+0xc6>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 80042fe:	4b17      	ldr	r3, [pc, #92]	; (800435c <chVTDoResetI+0xcc>)
 8004300:	69db      	ldr	r3, [r3, #28]
 8004302:	4a16      	ldr	r2, [pc, #88]	; (800435c <chVTDoResetI+0xcc>)
 8004304:	69d2      	ldr	r2, [r2, #28]
 8004306:	6891      	ldr	r1, [r2, #8]
 8004308:	9a01      	ldr	r2, [sp, #4]
 800430a:	6892      	ldr	r2, [r2, #8]
 800430c:	188a      	adds	r2, r1, r2
 800430e:	609a      	str	r2, [r3, #8]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 8004310:	f7ff ff0e 	bl	8004130 <chVTGetSystemTimeX.lto_priv.192>
 8004314:	0002      	movs	r2, r0
 8004316:	4b11      	ldr	r3, [pc, #68]	; (800435c <chVTDoResetI+0xcc>)
 8004318:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800431a:	1ad3      	subs	r3, r2, r3
 800431c:	9302      	str	r3, [sp, #8]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 800431e:	4b0f      	ldr	r3, [pc, #60]	; (800435c <chVTDoResetI+0xcc>)
 8004320:	69db      	ldr	r3, [r3, #28]
 8004322:	689a      	ldr	r2, [r3, #8]
 8004324:	9b02      	ldr	r3, [sp, #8]
 8004326:	429a      	cmp	r2, r3
 8004328:	d915      	bls.n	8004356 <chVTDoResetI+0xc6>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 800432a:	4b0c      	ldr	r3, [pc, #48]	; (800435c <chVTDoResetI+0xcc>)
 800432c:	69db      	ldr	r3, [r3, #28]
 800432e:	689a      	ldr	r2, [r3, #8]
 8004330:	9b02      	ldr	r3, [sp, #8]
 8004332:	1ad3      	subs	r3, r2, r3
 8004334:	9303      	str	r3, [sp, #12]

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8004336:	9b03      	ldr	r3, [sp, #12]
 8004338:	2b01      	cmp	r3, #1
 800433a:	d801      	bhi.n	8004340 <chVTDoResetI+0xb0>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800433c:	2302      	movs	r3, #2
 800433e:	9303      	str	r3, [sp, #12]
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
 8004340:	4b06      	ldr	r3, [pc, #24]	; (800435c <chVTDoResetI+0xcc>)
 8004342:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8004344:	9b02      	ldr	r3, [sp, #8]
 8004346:	18d2      	adds	r2, r2, r3
 8004348:	9b03      	ldr	r3, [sp, #12]
 800434a:	18d3      	adds	r3, r2, r3
 800434c:	0018      	movs	r0, r3
 800434e:	f7ff fed7 	bl	8004100 <port_timer_set_alarm.lto_priv.194>
 8004352:	e000      	b.n	8004356 <chVTDoResetI+0xc6>
      vtp->next->delta += vtp->delta;
 8004354:	46c0      	nop			; (mov r8, r8)
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8004356:	b005      	add	sp, #20
 8004358:	bd00      	pop	{pc}
 800435a:	46c0      	nop			; (mov r8, r8)
 800435c:	200004e0 	.word	0x200004e0
 8004360:	200004fc 	.word	0x200004fc
	...

08004370 <port_lock.lto_priv.181>:
  __ASM volatile ("cpsid i" : : : "memory");
 8004370:	b672      	cpsid	i
}
 8004372:	4770      	bx	lr
	...

08004380 <port_unlock.lto_priv.178>:
  __ASM volatile ("cpsie i" : : : "memory");
 8004380:	b662      	cpsie	i
}
 8004382:	4770      	bx	lr
	...

08004390 <port_lock_from_isr.lto_priv.190>:
static inline void port_lock_from_isr(void) {
 8004390:	b510      	push	{r4, lr}
  port_lock();
 8004392:	f7ff ffed 	bl	8004370 <port_lock.lto_priv.181>
}
 8004396:	bd10      	pop	{r4, pc}
	...

080043a0 <port_unlock_from_isr.lto_priv.188>:
static inline void port_unlock_from_isr(void) {
 80043a0:	b510      	push	{r4, lr}
  port_unlock();
 80043a2:	f7ff ffed 	bl	8004380 <port_unlock.lto_priv.178>
}
 80043a6:	bd10      	pop	{r4, pc}
	...

080043b0 <queue_init.lto_priv.169>:
static inline void queue_init(threads_queue_t *tqp) {
 80043b0:	b082      	sub	sp, #8
 80043b2:	9001      	str	r0, [sp, #4]
  tqp->next = (thread_t *)tqp;
 80043b4:	9b01      	ldr	r3, [sp, #4]
 80043b6:	9a01      	ldr	r2, [sp, #4]
 80043b8:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80043ba:	9b01      	ldr	r3, [sp, #4]
 80043bc:	9a01      	ldr	r2, [sp, #4]
 80043be:	605a      	str	r2, [r3, #4]
}
 80043c0:	b002      	add	sp, #8
 80043c2:	4770      	bx	lr
	...

080043d0 <queue_fifo_remove.lto_priv.167>:
  tp->queue.prev             = tqp->prev;
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 80043d0:	b084      	sub	sp, #16
 80043d2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
 80043d4:	9b01      	ldr	r3, [sp, #4]
 80043d6:	681b      	ldr	r3, [r3, #0]
 80043d8:	9303      	str	r3, [sp, #12]

  tqp->next             = tp->queue.next;
 80043da:	9b03      	ldr	r3, [sp, #12]
 80043dc:	681a      	ldr	r2, [r3, #0]
 80043de:	9b01      	ldr	r3, [sp, #4]
 80043e0:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 80043e2:	9b01      	ldr	r3, [sp, #4]
 80043e4:	681b      	ldr	r3, [r3, #0]
 80043e6:	9a01      	ldr	r2, [sp, #4]
 80043e8:	605a      	str	r2, [r3, #4]

  return tp;
 80043ea:	9b03      	ldr	r3, [sp, #12]
}
 80043ec:	0018      	movs	r0, r3
 80043ee:	b004      	add	sp, #16
 80043f0:	4770      	bx	lr
 80043f2:	46c0      	nop			; (mov r8, r8)
	...

08004400 <queue_dequeue>:
  tqp->prev->queue.next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
 8004400:	b082      	sub	sp, #8
 8004402:	9001      	str	r0, [sp, #4]

  tp->queue.prev->queue.next = tp->queue.next;
 8004404:	9b01      	ldr	r3, [sp, #4]
 8004406:	685b      	ldr	r3, [r3, #4]
 8004408:	9a01      	ldr	r2, [sp, #4]
 800440a:	6812      	ldr	r2, [r2, #0]
 800440c:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800440e:	9b01      	ldr	r3, [sp, #4]
 8004410:	681b      	ldr	r3, [r3, #0]
 8004412:	9a01      	ldr	r2, [sp, #4]
 8004414:	6852      	ldr	r2, [r2, #4]
 8004416:	605a      	str	r2, [r3, #4]

  return tp;
 8004418:	9b01      	ldr	r3, [sp, #4]
}
 800441a:	0018      	movs	r0, r3
 800441c:	b002      	add	sp, #8
 800441e:	4770      	bx	lr

08004420 <chSysLockFromISR.lto_priv.186>:
static inline void chSysLockFromISR(void) {
 8004420:	b510      	push	{r4, lr}
  port_lock_from_isr();
 8004422:	f7ff ffb5 	bl	8004390 <port_lock_from_isr.lto_priv.190>
}
 8004426:	bd10      	pop	{r4, pc}
	...

08004430 <chSysUnlockFromISR.lto_priv.184>:
static inline void chSysUnlockFromISR(void) {
 8004430:	b510      	push	{r4, lr}
  port_unlock_from_isr();
 8004432:	f7ff ffb5 	bl	80043a0 <port_unlock_from_isr.lto_priv.188>
}
 8004436:	bd10      	pop	{r4, pc}
	...

08004440 <chVTIsArmedI>:
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 8004440:	b082      	sub	sp, #8
 8004442:	9001      	str	r0, [sp, #4]
  return (bool)(vtp->func != NULL);
 8004444:	9b01      	ldr	r3, [sp, #4]
 8004446:	68db      	ldr	r3, [r3, #12]
 8004448:	1e5a      	subs	r2, r3, #1
 800444a:	4193      	sbcs	r3, r2
 800444c:	b2db      	uxtb	r3, r3
}
 800444e:	0018      	movs	r0, r3
 8004450:	b002      	add	sp, #8
 8004452:	4770      	bx	lr
	...

08004460 <chSemFastSignalI>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 8004460:	b082      	sub	sp, #8
 8004462:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  sp->cnt++;
 8004464:	9b01      	ldr	r3, [sp, #4]
 8004466:	689b      	ldr	r3, [r3, #8]
 8004468:	1c5a      	adds	r2, r3, #1
 800446a:	9b01      	ldr	r3, [sp, #4]
 800446c:	609a      	str	r2, [r3, #8]
}
 800446e:	b002      	add	sp, #8
 8004470:	4770      	bx	lr
 8004472:	46c0      	nop			; (mov r8, r8)
	...

08004480 <_scheduler_init>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
 8004480:	b510      	push	{r4, lr}

  queue_init(&ch.rlist.queue);
 8004482:	4b07      	ldr	r3, [pc, #28]	; (80044a0 <_scheduler_init+0x20>)
 8004484:	0018      	movs	r0, r3
 8004486:	f7ff ff93 	bl	80043b0 <queue_init.lto_priv.169>
  ch.rlist.prio = NOPRIO;
 800448a:	4b05      	ldr	r3, [pc, #20]	; (80044a0 <_scheduler_init+0x20>)
 800448c:	2200      	movs	r2, #0
 800448e:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.newer = (thread_t *)&ch.rlist;
 8004490:	4b03      	ldr	r3, [pc, #12]	; (80044a0 <_scheduler_init+0x20>)
 8004492:	4a03      	ldr	r2, [pc, #12]	; (80044a0 <_scheduler_init+0x20>)
 8004494:	611a      	str	r2, [r3, #16]
  ch.rlist.older = (thread_t *)&ch.rlist;
 8004496:	4b02      	ldr	r3, [pc, #8]	; (80044a0 <_scheduler_init+0x20>)
 8004498:	4a01      	ldr	r2, [pc, #4]	; (80044a0 <_scheduler_init+0x20>)
 800449a:	615a      	str	r2, [r3, #20]
#endif
}
 800449c:	bd10      	pop	{r4, pc}
 800449e:	46c0      	nop			; (mov r8, r8)
 80044a0:	200004e0 	.word	0x200004e0
	...

080044b0 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 80044b0:	b084      	sub	sp, #16
 80044b2:	9001      	str	r0, [sp, #4]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80044b4:	9b01      	ldr	r3, [sp, #4]
 80044b6:	2200      	movs	r2, #0
 80044b8:	771a      	strb	r2, [r3, #28]
  cp = (thread_t *)&ch.rlist.queue;
 80044ba:	4b0e      	ldr	r3, [pc, #56]	; (80044f4 <chSchReadyI+0x44>)
 80044bc:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->queue.next;
 80044be:	9b03      	ldr	r3, [sp, #12]
 80044c0:	681b      	ldr	r3, [r3, #0]
 80044c2:	9303      	str	r3, [sp, #12]
  } while (cp->prio >= tp->prio);
 80044c4:	9b03      	ldr	r3, [sp, #12]
 80044c6:	689a      	ldr	r2, [r3, #8]
 80044c8:	9b01      	ldr	r3, [sp, #4]
 80044ca:	689b      	ldr	r3, [r3, #8]
 80044cc:	429a      	cmp	r2, r3
 80044ce:	d2f6      	bcs.n	80044be <chSchReadyI+0xe>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 80044d0:	9b01      	ldr	r3, [sp, #4]
 80044d2:	9a03      	ldr	r2, [sp, #12]
 80044d4:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 80044d6:	9b03      	ldr	r3, [sp, #12]
 80044d8:	685a      	ldr	r2, [r3, #4]
 80044da:	9b01      	ldr	r3, [sp, #4]
 80044dc:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 80044de:	9b01      	ldr	r3, [sp, #4]
 80044e0:	685b      	ldr	r3, [r3, #4]
 80044e2:	9a01      	ldr	r2, [sp, #4]
 80044e4:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 80044e6:	9b03      	ldr	r3, [sp, #12]
 80044e8:	9a01      	ldr	r2, [sp, #4]
 80044ea:	605a      	str	r2, [r3, #4]

  return tp;
 80044ec:	9b01      	ldr	r3, [sp, #4]
}
 80044ee:	0018      	movs	r0, r3
 80044f0:	b004      	add	sp, #16
 80044f2:	4770      	bx	lr
 80044f4:	200004e0 	.word	0x200004e0
	...

08004500 <chSchReadyAheadI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyAheadI(thread_t *tp) {
 8004500:	b084      	sub	sp, #16
 8004502:	9001      	str	r0, [sp, #4]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8004504:	9b01      	ldr	r3, [sp, #4]
 8004506:	2200      	movs	r2, #0
 8004508:	771a      	strb	r2, [r3, #28]
  cp = (thread_t *)&ch.rlist.queue;
 800450a:	4b0e      	ldr	r3, [pc, #56]	; (8004544 <chSchReadyAheadI+0x44>)
 800450c:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->queue.next;
 800450e:	9b03      	ldr	r3, [sp, #12]
 8004510:	681b      	ldr	r3, [r3, #0]
 8004512:	9303      	str	r3, [sp, #12]
  } while (cp->prio > tp->prio);
 8004514:	9b03      	ldr	r3, [sp, #12]
 8004516:	689a      	ldr	r2, [r3, #8]
 8004518:	9b01      	ldr	r3, [sp, #4]
 800451a:	689b      	ldr	r3, [r3, #8]
 800451c:	429a      	cmp	r2, r3
 800451e:	d8f6      	bhi.n	800450e <chSchReadyAheadI+0xe>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8004520:	9b01      	ldr	r3, [sp, #4]
 8004522:	9a03      	ldr	r2, [sp, #12]
 8004524:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 8004526:	9b03      	ldr	r3, [sp, #12]
 8004528:	685a      	ldr	r2, [r3, #4]
 800452a:	9b01      	ldr	r3, [sp, #4]
 800452c:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 800452e:	9b01      	ldr	r3, [sp, #4]
 8004530:	685b      	ldr	r3, [r3, #4]
 8004532:	9a01      	ldr	r2, [sp, #4]
 8004534:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 8004536:	9b03      	ldr	r3, [sp, #12]
 8004538:	9a01      	ldr	r2, [sp, #4]
 800453a:	605a      	str	r2, [r3, #4]

  return tp;
 800453c:	9b01      	ldr	r3, [sp, #4]
}
 800453e:	0018      	movs	r0, r3
 8004540:	b004      	add	sp, #16
 8004542:	4770      	bx	lr
 8004544:	200004e0 	.word	0x200004e0
	...

08004550 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8004550:	b500      	push	{lr}
 8004552:	b085      	sub	sp, #20
 8004554:	0002      	movs	r2, r0
 8004556:	466b      	mov	r3, sp
 8004558:	3307      	adds	r3, #7
 800455a:	701a      	strb	r2, [r3, #0]
  thread_t *otp = currp;
 800455c:	4b0d      	ldr	r3, [pc, #52]	; (8004594 <chSchGoSleepS+0x44>)
 800455e:	699b      	ldr	r3, [r3, #24]
 8004560:	9303      	str	r3, [sp, #12]

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 8004562:	9b03      	ldr	r3, [sp, #12]
 8004564:	466a      	mov	r2, sp
 8004566:	3207      	adds	r2, #7
 8004568:	7812      	ldrb	r2, [r2, #0]
 800456a:	771a      	strb	r2, [r3, #28]
     time quantum when it will wakeup.*/
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800456c:	4b09      	ldr	r3, [pc, #36]	; (8004594 <chSchGoSleepS+0x44>)
 800456e:	0018      	movs	r0, r3
 8004570:	f7ff ff2e 	bl	80043d0 <queue_fifo_remove.lto_priv.167>
 8004574:	0002      	movs	r2, r0
 8004576:	4b07      	ldr	r3, [pc, #28]	; (8004594 <chSchGoSleepS+0x44>)
 8004578:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 800457a:	4b06      	ldr	r3, [pc, #24]	; (8004594 <chSchGoSleepS+0x44>)
 800457c:	699b      	ldr	r3, [r3, #24]
 800457e:	2201      	movs	r2, #1
 8004580:	771a      	strb	r2, [r3, #28]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8004582:	4b04      	ldr	r3, [pc, #16]	; (8004594 <chSchGoSleepS+0x44>)
 8004584:	699b      	ldr	r3, [r3, #24]
 8004586:	9a03      	ldr	r2, [sp, #12]
 8004588:	0011      	movs	r1, r2
 800458a:	0018      	movs	r0, r3
 800458c:	f7fb fe00 	bl	8000190 <_port_switch>
}
 8004590:	b005      	add	sp, #20
 8004592:	bd00      	pop	{pc}
 8004594:	200004e0 	.word	0x200004e0
	...

080045a0 <wakeup>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 80045a0:	b500      	push	{lr}
 80045a2:	b085      	sub	sp, #20
 80045a4:	9001      	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
 80045a6:	9b01      	ldr	r3, [sp, #4]
 80045a8:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
 80045aa:	f7ff ff39 	bl	8004420 <chSysLockFromISR.lto_priv.186>
  switch (tp->state) {
 80045ae:	9b03      	ldr	r3, [sp, #12]
 80045b0:	7f1b      	ldrb	r3, [r3, #28]
 80045b2:	2b07      	cmp	r3, #7
 80045b4:	d815      	bhi.n	80045e2 <wakeup+0x42>
 80045b6:	009a      	lsls	r2, r3, #2
 80045b8:	4b10      	ldr	r3, [pc, #64]	; (80045fc <wakeup+0x5c>)
 80045ba:	18d3      	adds	r3, r2, r3
 80045bc:	681b      	ldr	r3, [r3, #0]
 80045be:	469f      	mov	pc, r3
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 80045c0:	f7ff ff36 	bl	8004430 <chSysUnlockFromISR.lto_priv.184>
 80045c4:	e017      	b.n	80045f6 <wakeup+0x56>
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 80045c6:	9b03      	ldr	r3, [sp, #12]
 80045c8:	6a1b      	ldr	r3, [r3, #32]
 80045ca:	2200      	movs	r2, #0
 80045cc:	601a      	str	r2, [r3, #0]
 80045ce:	e008      	b.n	80045e2 <wakeup+0x42>
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 80045d0:	9b03      	ldr	r3, [sp, #12]
 80045d2:	6a1b      	ldr	r3, [r3, #32]
 80045d4:	0018      	movs	r0, r3
 80045d6:	f7ff ff43 	bl	8004460 <chSemFastSignalI>
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
 80045da:	9b03      	ldr	r3, [sp, #12]
 80045dc:	0018      	movs	r0, r3
 80045de:	f7ff ff0f 	bl	8004400 <queue_dequeue>
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 80045e2:	9b03      	ldr	r3, [sp, #12]
 80045e4:	2201      	movs	r2, #1
 80045e6:	4252      	negs	r2, r2
 80045e8:	621a      	str	r2, [r3, #32]
  (void) chSchReadyI(tp);
 80045ea:	9b03      	ldr	r3, [sp, #12]
 80045ec:	0018      	movs	r0, r3
 80045ee:	f7ff ff5f 	bl	80044b0 <chSchReadyI>
  chSysUnlockFromISR();
 80045f2:	f7ff ff1d 	bl	8004430 <chSysUnlockFromISR.lto_priv.184>
}
 80045f6:	b005      	add	sp, #20
 80045f8:	bd00      	pop	{pc}
 80045fa:	46c0      	nop			; (mov r8, r8)
 80045fc:	08004d60 	.word	0x08004d60

08004600 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8004600:	b500      	push	{lr}
 8004602:	b089      	sub	sp, #36	; 0x24
 8004604:	0002      	movs	r2, r0
 8004606:	9100      	str	r1, [sp, #0]
 8004608:	466b      	mov	r3, sp
 800460a:	3307      	adds	r3, #7
 800460c:	701a      	strb	r2, [r3, #0]

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 800460e:	9b00      	ldr	r3, [sp, #0]
 8004610:	3301      	adds	r3, #1
 8004612:	d017      	beq.n	8004644 <chSchGoSleepTimeoutS+0x44>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8004614:	4b11      	ldr	r3, [pc, #68]	; (800465c <chSchGoSleepTimeoutS+0x5c>)
 8004616:	699b      	ldr	r3, [r3, #24]
 8004618:	4a11      	ldr	r2, [pc, #68]	; (8004660 <chSchGoSleepTimeoutS+0x60>)
 800461a:	9900      	ldr	r1, [sp, #0]
 800461c:	a803      	add	r0, sp, #12
 800461e:	f7ff fda7 	bl	8004170 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8004622:	466b      	mov	r3, sp
 8004624:	3307      	adds	r3, #7
 8004626:	781b      	ldrb	r3, [r3, #0]
 8004628:	0018      	movs	r0, r3
 800462a:	f7ff ff91 	bl	8004550 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 800462e:	ab03      	add	r3, sp, #12
 8004630:	0018      	movs	r0, r3
 8004632:	f7ff ff05 	bl	8004440 <chVTIsArmedI>
 8004636:	1e03      	subs	r3, r0, #0
 8004638:	d00a      	beq.n	8004650 <chSchGoSleepTimeoutS+0x50>
      chVTDoResetI(&vt);
 800463a:	ab03      	add	r3, sp, #12
 800463c:	0018      	movs	r0, r3
 800463e:	f7ff fe27 	bl	8004290 <chVTDoResetI>
 8004642:	e005      	b.n	8004650 <chSchGoSleepTimeoutS+0x50>
    }
  }
  else {
    chSchGoSleepS(newstate);
 8004644:	466b      	mov	r3, sp
 8004646:	3307      	adds	r3, #7
 8004648:	781b      	ldrb	r3, [r3, #0]
 800464a:	0018      	movs	r0, r3
 800464c:	f7ff ff80 	bl	8004550 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
 8004650:	4b02      	ldr	r3, [pc, #8]	; (800465c <chSchGoSleepTimeoutS+0x5c>)
 8004652:	699b      	ldr	r3, [r3, #24]
 8004654:	6a1b      	ldr	r3, [r3, #32]
}
 8004656:	0018      	movs	r0, r3
 8004658:	b009      	add	sp, #36	; 0x24
 800465a:	bd00      	pop	{pc}
 800465c:	200004e0 	.word	0x200004e0
 8004660:	080045a1 	.word	0x080045a1
	...

08004670 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8004670:	b500      	push	{lr}
 8004672:	b085      	sub	sp, #20
 8004674:	9001      	str	r0, [sp, #4]
 8004676:	9100      	str	r1, [sp, #0]
  thread_t *otp = currp;
 8004678:	4b12      	ldr	r3, [pc, #72]	; (80046c4 <chSchWakeupS+0x54>)
 800467a:	699b      	ldr	r3, [r3, #24]
 800467c:	9303      	str	r3, [sp, #12]
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 800467e:	9b01      	ldr	r3, [sp, #4]
 8004680:	9a00      	ldr	r2, [sp, #0]
 8004682:	621a      	str	r2, [r3, #32]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 8004684:	9b01      	ldr	r3, [sp, #4]
 8004686:	689a      	ldr	r2, [r3, #8]
 8004688:	9b03      	ldr	r3, [sp, #12]
 800468a:	689b      	ldr	r3, [r3, #8]
 800468c:	429a      	cmp	r2, r3
 800468e:	d804      	bhi.n	800469a <chSchWakeupS+0x2a>
    (void) chSchReadyI(ntp);
 8004690:	9b01      	ldr	r3, [sp, #4]
 8004692:	0018      	movs	r0, r3
 8004694:	f7ff ff0c 	bl	80044b0 <chSchReadyI>
 8004698:	e011      	b.n	80046be <chSchWakeupS+0x4e>
  }
  else {
    otp = chSchReadyI(otp);
 800469a:	9b03      	ldr	r3, [sp, #12]
 800469c:	0018      	movs	r0, r3
 800469e:	f7ff ff07 	bl	80044b0 <chSchReadyI>
 80046a2:	0003      	movs	r3, r0
 80046a4:	9303      	str	r3, [sp, #12]
    if (otp->prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
 80046a6:	4b07      	ldr	r3, [pc, #28]	; (80046c4 <chSchWakeupS+0x54>)
 80046a8:	9a01      	ldr	r2, [sp, #4]
 80046aa:	619a      	str	r2, [r3, #24]
    ntp->state = CH_STATE_CURRENT;
 80046ac:	9b01      	ldr	r3, [sp, #4]
 80046ae:	2201      	movs	r2, #1
 80046b0:	771a      	strb	r2, [r3, #28]

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 80046b2:	9a03      	ldr	r2, [sp, #12]
 80046b4:	9b01      	ldr	r3, [sp, #4]
 80046b6:	0011      	movs	r1, r2
 80046b8:	0018      	movs	r0, r3
 80046ba:	f7fb fd69 	bl	8000190 <_port_switch>
  }
}
 80046be:	b005      	add	sp, #20
 80046c0:	bd00      	pop	{pc}
 80046c2:	46c0      	nop			; (mov r8, r8)
 80046c4:	200004e0 	.word	0x200004e0
	...

080046d0 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 80046d0:	b082      	sub	sp, #8
  tprio_t p1 = firstprio(&ch.rlist.queue);
 80046d2:	4b08      	ldr	r3, [pc, #32]	; (80046f4 <chSchIsPreemptionRequired+0x24>)
 80046d4:	681b      	ldr	r3, [r3, #0]
 80046d6:	689b      	ldr	r3, [r3, #8]
 80046d8:	9301      	str	r3, [sp, #4]
  tprio_t p2 = currp->prio;
 80046da:	4b06      	ldr	r3, [pc, #24]	; (80046f4 <chSchIsPreemptionRequired+0x24>)
 80046dc:	699b      	ldr	r3, [r3, #24]
 80046de:	689b      	ldr	r3, [r3, #8]
 80046e0:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 80046e2:	9b01      	ldr	r3, [sp, #4]
 80046e4:	9a00      	ldr	r2, [sp, #0]
 80046e6:	429a      	cmp	r2, r3
 80046e8:	419b      	sbcs	r3, r3
 80046ea:	425b      	negs	r3, r3
 80046ec:	b2db      	uxtb	r3, r3
#endif
}
 80046ee:	0018      	movs	r0, r3
 80046f0:	b002      	add	sp, #8
 80046f2:	4770      	bx	lr
 80046f4:	200004e0 	.word	0x200004e0
	...

08004700 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8004700:	b500      	push	{lr}
 8004702:	b083      	sub	sp, #12
  thread_t *otp = currp;
 8004704:	4b0e      	ldr	r3, [pc, #56]	; (8004740 <chSchDoReschedule+0x40>)
 8004706:	699b      	ldr	r3, [r3, #24]
 8004708:	9301      	str	r3, [sp, #4]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800470a:	4b0d      	ldr	r3, [pc, #52]	; (8004740 <chSchDoReschedule+0x40>)
 800470c:	0018      	movs	r0, r3
 800470e:	f7ff fe5f 	bl	80043d0 <queue_fifo_remove.lto_priv.167>
 8004712:	0002      	movs	r2, r0
 8004714:	4b0a      	ldr	r3, [pc, #40]	; (8004740 <chSchDoReschedule+0x40>)
 8004716:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 8004718:	4b09      	ldr	r3, [pc, #36]	; (8004740 <chSchDoReschedule+0x40>)
 800471a:	699b      	ldr	r3, [r3, #24]
 800471c:	2201      	movs	r2, #1
 800471e:	771a      	strb	r2, [r3, #28]
    otp = chSchReadyAheadI(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
 8004720:	9b01      	ldr	r3, [sp, #4]
 8004722:	0018      	movs	r0, r3
 8004724:	f7ff feec 	bl	8004500 <chSchReadyAheadI>
 8004728:	0003      	movs	r3, r0
 800472a:	9301      	str	r3, [sp, #4]
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800472c:	4b04      	ldr	r3, [pc, #16]	; (8004740 <chSchDoReschedule+0x40>)
 800472e:	699b      	ldr	r3, [r3, #24]
 8004730:	9a01      	ldr	r2, [sp, #4]
 8004732:	0011      	movs	r1, r2
 8004734:	0018      	movs	r0, r3
 8004736:	f7fb fd2b 	bl	8000190 <_port_switch>
}
 800473a:	b003      	add	sp, #12
 800473c:	bd00      	pop	{pc}
 800473e:	46c0      	nop			; (mov r8, r8)
 8004740:	200004e0 	.word	0x200004e0
	...

08004750 <port_lock.lto_priv.182>:
  __ASM volatile ("cpsid i" : : : "memory");
 8004750:	b672      	cpsid	i
}
 8004752:	4770      	bx	lr
	...

08004760 <port_unlock.lto_priv.179>:
  __ASM volatile ("cpsie i" : : : "memory");
 8004760:	b662      	cpsie	i
}
 8004762:	4770      	bx	lr
	...

08004770 <list_init>:
static inline void list_init(threads_list_t *tlp) {
 8004770:	b082      	sub	sp, #8
 8004772:	9001      	str	r0, [sp, #4]
  tlp->next = (thread_t *)tlp;
 8004774:	9b01      	ldr	r3, [sp, #4]
 8004776:	9a01      	ldr	r2, [sp, #4]
 8004778:	601a      	str	r2, [r3, #0]
}
 800477a:	b002      	add	sp, #8
 800477c:	4770      	bx	lr
 800477e:	46c0      	nop			; (mov r8, r8)

08004780 <list_notempty.lto_priv.165>:
static inline bool list_notempty(threads_list_t *tlp) {
 8004780:	b082      	sub	sp, #8
 8004782:	9001      	str	r0, [sp, #4]
  return (bool)(tlp->next != (thread_t *)tlp);
 8004784:	9b01      	ldr	r3, [sp, #4]
 8004786:	681a      	ldr	r2, [r3, #0]
 8004788:	9b01      	ldr	r3, [sp, #4]
 800478a:	1ad3      	subs	r3, r2, r3
 800478c:	1e5a      	subs	r2, r3, #1
 800478e:	4193      	sbcs	r3, r2
 8004790:	b2db      	uxtb	r3, r3
}
 8004792:	0018      	movs	r0, r3
 8004794:	b002      	add	sp, #8
 8004796:	4770      	bx	lr
	...

080047a0 <queue_init.lto_priv.170>:
static inline void queue_init(threads_queue_t *tqp) {
 80047a0:	b082      	sub	sp, #8
 80047a2:	9001      	str	r0, [sp, #4]
  tqp->next = (thread_t *)tqp;
 80047a4:	9b01      	ldr	r3, [sp, #4]
 80047a6:	9a01      	ldr	r2, [sp, #4]
 80047a8:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80047aa:	9b01      	ldr	r3, [sp, #4]
 80047ac:	9a01      	ldr	r2, [sp, #4]
 80047ae:	605a      	str	r2, [r3, #4]
}
 80047b0:	b002      	add	sp, #8
 80047b2:	4770      	bx	lr
	...

080047c0 <queue_notempty.lto_priv.151>:
static inline bool queue_notempty(const threads_queue_t *tqp) {
 80047c0:	b082      	sub	sp, #8
 80047c2:	9001      	str	r0, [sp, #4]
  return (bool)(tqp->next != (const thread_t *)tqp);
 80047c4:	9b01      	ldr	r3, [sp, #4]
 80047c6:	681a      	ldr	r2, [r3, #0]
 80047c8:	9b01      	ldr	r3, [sp, #4]
 80047ca:	1ad3      	subs	r3, r2, r3
 80047cc:	1e5a      	subs	r2, r3, #1
 80047ce:	4193      	sbcs	r3, r2
 80047d0:	b2db      	uxtb	r3, r3
}
 80047d2:	0018      	movs	r0, r3
 80047d4:	b002      	add	sp, #8
 80047d6:	4770      	bx	lr
	...

080047e0 <list_remove.lto_priv.166>:
static inline thread_t *list_remove(threads_list_t *tlp) {
 80047e0:	b084      	sub	sp, #16
 80047e2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tlp->next;
 80047e4:	9b01      	ldr	r3, [sp, #4]
 80047e6:	681b      	ldr	r3, [r3, #0]
 80047e8:	9303      	str	r3, [sp, #12]
  tlp->next = tp->queue.next;
 80047ea:	9b03      	ldr	r3, [sp, #12]
 80047ec:	681a      	ldr	r2, [r3, #0]
 80047ee:	9b01      	ldr	r3, [sp, #4]
 80047f0:	601a      	str	r2, [r3, #0]
  return tp;
 80047f2:	9b03      	ldr	r3, [sp, #12]
}
 80047f4:	0018      	movs	r0, r3
 80047f6:	b004      	add	sp, #16
 80047f8:	4770      	bx	lr
 80047fa:	46c0      	nop			; (mov r8, r8)
 80047fc:	0000      	movs	r0, r0
	...

08004800 <queue_insert.lto_priv.157>:
static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 8004800:	b082      	sub	sp, #8
 8004802:	9001      	str	r0, [sp, #4]
 8004804:	9100      	str	r1, [sp, #0]
  tp->queue.next             = (thread_t *)tqp;
 8004806:	9b01      	ldr	r3, [sp, #4]
 8004808:	9a00      	ldr	r2, [sp, #0]
 800480a:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = tqp->prev;
 800480c:	9b00      	ldr	r3, [sp, #0]
 800480e:	685a      	ldr	r2, [r3, #4]
 8004810:	9b01      	ldr	r3, [sp, #4]
 8004812:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8004814:	9b01      	ldr	r3, [sp, #4]
 8004816:	685b      	ldr	r3, [r3, #4]
 8004818:	9a01      	ldr	r2, [sp, #4]
 800481a:	601a      	str	r2, [r3, #0]
  tqp->prev                  = tp;
 800481c:	9b00      	ldr	r3, [sp, #0]
 800481e:	9a01      	ldr	r2, [sp, #4]
 8004820:	605a      	str	r2, [r3, #4]
}
 8004822:	b002      	add	sp, #8
 8004824:	4770      	bx	lr
 8004826:	46c0      	nop			; (mov r8, r8)
	...

08004830 <queue_fifo_remove.lto_priv.168>:
static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8004830:	b084      	sub	sp, #16
 8004832:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
 8004834:	9b01      	ldr	r3, [sp, #4]
 8004836:	681b      	ldr	r3, [r3, #0]
 8004838:	9303      	str	r3, [sp, #12]
  tqp->next             = tp->queue.next;
 800483a:	9b03      	ldr	r3, [sp, #12]
 800483c:	681a      	ldr	r2, [r3, #0]
 800483e:	9b01      	ldr	r3, [sp, #4]
 8004840:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8004842:	9b01      	ldr	r3, [sp, #4]
 8004844:	681b      	ldr	r3, [r3, #0]
 8004846:	9a01      	ldr	r2, [sp, #4]
 8004848:	605a      	str	r2, [r3, #4]
  return tp;
 800484a:	9b03      	ldr	r3, [sp, #12]
}
 800484c:	0018      	movs	r0, r3
 800484e:	b004      	add	sp, #16
 8004850:	4770      	bx	lr
 8004852:	46c0      	nop			; (mov r8, r8)
	...

08004860 <chSysLock.lto_priv.141>:
static inline void chSysLock(void) {
 8004860:	b510      	push	{r4, lr}
  port_lock();
 8004862:	f7ff ff75 	bl	8004750 <port_lock.lto_priv.182>
}
 8004866:	bd10      	pop	{r4, pc}
	...

08004870 <chSysUnlock.lto_priv.136>:
static inline void chSysUnlock(void) {
 8004870:	b510      	push	{r4, lr}
  port_unlock();
 8004872:	f7ff ff75 	bl	8004760 <port_unlock.lto_priv.179>
}
 8004876:	bd10      	pop	{r4, pc}
	...

08004880 <chThdSleepS.lto_priv.161>:
static inline void chThdSleepS(systime_t time) {
 8004880:	b500      	push	{lr}
 8004882:	b083      	sub	sp, #12
 8004884:	9001      	str	r0, [sp, #4]
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8004886:	9b01      	ldr	r3, [sp, #4]
 8004888:	0019      	movs	r1, r3
 800488a:	2008      	movs	r0, #8
 800488c:	f7ff feb8 	bl	8004600 <chSchGoSleepTimeoutS>
}
 8004890:	b003      	add	sp, #12
 8004892:	bd00      	pop	{pc}
	...

080048a0 <chThdDoDequeueNextI.lto_priv.159>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 80048a0:	b500      	push	{lr}
 80048a2:	b085      	sub	sp, #20
 80048a4:	9001      	str	r0, [sp, #4]
 80048a6:	9100      	str	r1, [sp, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);
 80048a8:	9b01      	ldr	r3, [sp, #4]
 80048aa:	0018      	movs	r0, r3
 80048ac:	f7ff ffc0 	bl	8004830 <queue_fifo_remove.lto_priv.168>
 80048b0:	0003      	movs	r3, r0
 80048b2:	9303      	str	r3, [sp, #12]

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 80048b4:	9b03      	ldr	r3, [sp, #12]
 80048b6:	9a00      	ldr	r2, [sp, #0]
 80048b8:	621a      	str	r2, [r3, #32]
  (void) chSchReadyI(tp);
 80048ba:	9b03      	ldr	r3, [sp, #12]
 80048bc:	0018      	movs	r0, r3
 80048be:	f7ff fdf7 	bl	80044b0 <chSchReadyI>
}
 80048c2:	b005      	add	sp, #20
 80048c4:	bd00      	pop	{pc}
 80048c6:	46c0      	nop			; (mov r8, r8)
	...

080048d0 <_thread_init>:
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {
 80048d0:	b500      	push	{lr}
 80048d2:	b085      	sub	sp, #20
 80048d4:	9003      	str	r0, [sp, #12]
 80048d6:	9102      	str	r1, [sp, #8]
 80048d8:	9201      	str	r2, [sp, #4]
  tp->prio      = prio;
 80048da:	9b03      	ldr	r3, [sp, #12]
 80048dc:	9a01      	ldr	r2, [sp, #4]
 80048de:	609a      	str	r2, [r3, #8]
  tp->state     = CH_STATE_WTSTART;
 80048e0:	9b03      	ldr	r3, [sp, #12]
 80048e2:	2202      	movs	r2, #2
 80048e4:	771a      	strb	r2, [r3, #28]
  tp->flags     = CH_FLAG_MODE_STATIC;
 80048e6:	9b03      	ldr	r3, [sp, #12]
 80048e8:	2200      	movs	r2, #0
 80048ea:	775a      	strb	r2, [r3, #29]
  tp->realprio  = prio;
 80048ec:	9b03      	ldr	r3, [sp, #12]
 80048ee:	9a01      	ldr	r2, [sp, #4]
 80048f0:	639a      	str	r2, [r3, #56]	; 0x38
  tp->mtxlist   = NULL;
 80048f2:	9b03      	ldr	r3, [sp, #12]
 80048f4:	2200      	movs	r2, #0
 80048f6:	635a      	str	r2, [r3, #52]	; 0x34
  tp->epending  = (eventmask_t)0;
 80048f8:	9b03      	ldr	r3, [sp, #12]
 80048fa:	2200      	movs	r2, #0
 80048fc:	631a      	str	r2, [r3, #48]	; 0x30
  tp->refs      = (trefs_t)1;
 80048fe:	9b03      	ldr	r3, [sp, #12]
 8004900:	2201      	movs	r2, #1
 8004902:	779a      	strb	r2, [r3, #30]
  tp->name      = name;
 8004904:	9b03      	ldr	r3, [sp, #12]
 8004906:	9a02      	ldr	r2, [sp, #8]
 8004908:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
 800490a:	9b03      	ldr	r3, [sp, #12]
 800490c:	4a0d      	ldr	r2, [pc, #52]	; (8004944 <_thread_init+0x74>)
 800490e:	611a      	str	r2, [r3, #16]
 8004910:	4b0c      	ldr	r3, [pc, #48]	; (8004944 <_thread_init+0x74>)
 8004912:	695a      	ldr	r2, [r3, #20]
 8004914:	9b03      	ldr	r3, [sp, #12]
 8004916:	615a      	str	r2, [r3, #20]
 8004918:	9b03      	ldr	r3, [sp, #12]
 800491a:	695b      	ldr	r3, [r3, #20]
 800491c:	9a03      	ldr	r2, [sp, #12]
 800491e:	611a      	str	r2, [r3, #16]
 8004920:	4b08      	ldr	r3, [pc, #32]	; (8004944 <_thread_init+0x74>)
 8004922:	9a03      	ldr	r2, [sp, #12]
 8004924:	615a      	str	r2, [r3, #20]
  list_init(&tp->waiting);
 8004926:	9b03      	ldr	r3, [sp, #12]
 8004928:	3324      	adds	r3, #36	; 0x24
 800492a:	0018      	movs	r0, r3
 800492c:	f7ff ff20 	bl	8004770 <list_init>
  queue_init(&tp->msgqueue);
 8004930:	9b03      	ldr	r3, [sp, #12]
 8004932:	3328      	adds	r3, #40	; 0x28
 8004934:	0018      	movs	r0, r3
 8004936:	f7ff ff33 	bl	80047a0 <queue_init.lto_priv.170>
  return tp;
 800493a:	9b03      	ldr	r3, [sp, #12]
}
 800493c:	0018      	movs	r0, r3
 800493e:	b005      	add	sp, #20
 8004940:	bd00      	pop	{pc}
 8004942:	46c0      	nop			; (mov r8, r8)
 8004944:	200004e0 	.word	0x200004e0
	...

08004950 <chThdCreateSuspendedI>:
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 8004950:	b500      	push	{lr}
 8004952:	b085      	sub	sp, #20
 8004954:	9001      	str	r0, [sp, #4]
  tp = (thread_t *)((uint8_t *)tdp->wend -
 8004956:	9b01      	ldr	r3, [sp, #4]
 8004958:	689b      	ldr	r3, [r3, #8]
 800495a:	3b40      	subs	r3, #64	; 0x40
 800495c:	9303      	str	r3, [sp, #12]
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800495e:	9b03      	ldr	r3, [sp, #12]
 8004960:	3b24      	subs	r3, #36	; 0x24
 8004962:	001a      	movs	r2, r3
 8004964:	9b03      	ldr	r3, [sp, #12]
 8004966:	60da      	str	r2, [r3, #12]
 8004968:	9b03      	ldr	r3, [sp, #12]
 800496a:	68db      	ldr	r3, [r3, #12]
 800496c:	9a01      	ldr	r2, [sp, #4]
 800496e:	6912      	ldr	r2, [r2, #16]
 8004970:	611a      	str	r2, [r3, #16]
 8004972:	9b03      	ldr	r3, [sp, #12]
 8004974:	68db      	ldr	r3, [r3, #12]
 8004976:	9a01      	ldr	r2, [sp, #4]
 8004978:	6952      	ldr	r2, [r2, #20]
 800497a:	615a      	str	r2, [r3, #20]
 800497c:	9b03      	ldr	r3, [sp, #12]
 800497e:	68db      	ldr	r3, [r3, #12]
 8004980:	4a06      	ldr	r2, [pc, #24]	; (800499c <chThdCreateSuspendedI+0x4c>)
 8004982:	621a      	str	r2, [r3, #32]
  return _thread_init(tp, tdp->name, tdp->prio);
 8004984:	9b01      	ldr	r3, [sp, #4]
 8004986:	6819      	ldr	r1, [r3, #0]
 8004988:	9b01      	ldr	r3, [sp, #4]
 800498a:	68da      	ldr	r2, [r3, #12]
 800498c:	9b03      	ldr	r3, [sp, #12]
 800498e:	0018      	movs	r0, r3
 8004990:	f7ff ff9e 	bl	80048d0 <_thread_init>
 8004994:	0003      	movs	r3, r0
}
 8004996:	0018      	movs	r0, r3
 8004998:	b005      	add	sp, #20
 800499a:	bd00      	pop	{pc}
 800499c:	080001b1 	.word	0x080001b1

080049a0 <chThdCreate>:
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
 80049a0:	b500      	push	{lr}
 80049a2:	b085      	sub	sp, #20
 80049a4:	9001      	str	r0, [sp, #4]
  chSysLock();
 80049a6:	f7ff ff5b 	bl	8004860 <chSysLock.lto_priv.141>
  tp = chThdCreateSuspendedI(tdp);
 80049aa:	9b01      	ldr	r3, [sp, #4]
 80049ac:	0018      	movs	r0, r3
 80049ae:	f7ff ffcf 	bl	8004950 <chThdCreateSuspendedI>
 80049b2:	0003      	movs	r3, r0
 80049b4:	9303      	str	r3, [sp, #12]
  chSchWakeupS(tp, MSG_OK);
 80049b6:	9b03      	ldr	r3, [sp, #12]
 80049b8:	2100      	movs	r1, #0
 80049ba:	0018      	movs	r0, r3
 80049bc:	f7ff fe58 	bl	8004670 <chSchWakeupS>
  chSysUnlock();
 80049c0:	f7ff ff56 	bl	8004870 <chSysUnlock.lto_priv.136>
  return tp;
 80049c4:	9b03      	ldr	r3, [sp, #12]
}
 80049c6:	0018      	movs	r0, r3
 80049c8:	b005      	add	sp, #20
 80049ca:	bd00      	pop	{pc}
